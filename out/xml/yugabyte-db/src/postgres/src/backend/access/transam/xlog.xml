<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/access/transam/xlog.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * xlog.c
 *		PostgreSQL write-ahead log manager
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * src/backend/access/transam/xlog.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/clog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/commit_ts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/multixact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/rewriteheap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/subtrans.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/timeline.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tuptoaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/twophase.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xloginsert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogreader.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catversion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_control.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_database.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port/atomics.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/bgwriter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/walwriter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/startup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/basebackup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/logical.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/slot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/origin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/snapbuild.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walreceiver.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walsender.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/large_object.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/latch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pmsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/reinit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/spin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/backend_random.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_lsn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relmapper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_trace.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>extern</specifier> <name>uint32</name></type> <name>bootstrap_data_checksum_version</name></decl>;</decl_stmt>

<comment type="block">/* File path names (all relative to $PGDATA) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVERY_COMMAND_FILE</name></cpp:macro>	<cpp:value>"recovery.conf"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVERY_COMMAND_DONE</name></cpp:macro>	<cpp:value>"recovery.done"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROMOTE_SIGNAL_FILE</name></cpp:macro>		<cpp:value>"promote"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FALLBACK_PROMOTE_SIGNAL_FILE</name></cpp:macro> <cpp:value>"fallback_promote"</cpp:value></cpp:define>


<comment type="block">/* User-settable parameters */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>max_wal_size_mb</name> <init>= <expr><literal type="number">1024</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* 1 GB */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>min_wal_size_mb</name> <init>= <expr><literal type="number">80</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* 80 MB */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>wal_keep_segments</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>XLOGbuffers</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>XLogArchiveTimeout</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>XLogArchiveMode</name> <init>= <expr><name>ARCHIVE_MODE_OFF</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>XLogArchiveCommand</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>EnableHotStandby</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>fullPageWrites</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>wal_log_hints</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>wal_compression</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>wal_consistency_checking_string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>wal_consistency_checking</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>log_checkpoints</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>sync_method</name> <init>= <expr><name>DEFAULT_SYNC_METHOD</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>wal_level</name> <init>= <expr><name>WAL_LEVEL_MINIMAL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>CommitDelay</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* precommit delay in microseconds */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>CommitSiblings</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* # concurrent xacts needed to sleep */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>wal_retrieve_retry_interval</name> <init>= <expr><literal type="number">5000</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WAL_DEBUG</name></cpp:ifdef>
<decl_stmt><decl><type><name>bool</name></type>		<name>XLOG_DEBUG</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>int</name></type>			<name>wal_segment_size</name> <init>= <expr><name>DEFAULT_XLOG_SEG_SIZE</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Number of WAL insertion locks to use. A higher value allows more insertions
 * to happen concurrently, but adds some CPU overhead to flushing the WAL,
 * which needs to iterate all the locks.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_XLOGINSERT_LOCKS</name></cpp:macro>  <cpp:value>8</cpp:value></cpp:define>

<comment type="block">/*
 * Max distance from last checkpoint, before triggering a new xlog-based
 * checkpoint.
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>CheckPointSegments</name></decl>;</decl_stmt>

<comment type="block">/* Estimated distance between checkpoints, in bytes */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>double</name></type> <name>CheckPointDistanceEstimate</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>double</name></type> <name>PrevCheckPointDistance</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * GUC support
 */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>sync_method_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"fsync"</literal></expr>, <expr><name>SYNC_METHOD_FSYNC</name></expr>, <expr><name>false</name></expr>}</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_FSYNC_WRITETHROUGH</name></cpp:ifdef>
	<expr><block>{<expr><literal type="string">"fsync_writethrough"</literal></expr>, <expr><name>SYNC_METHOD_FSYNC_WRITETHROUGH</name></expr>, <expr><name>false</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_FDATASYNC</name></cpp:ifdef>
	<expr><block>{<expr><literal type="string">"fdatasync"</literal></expr>, <expr><name>SYNC_METHOD_FDATASYNC</name></expr>, <expr><name>false</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>OPEN_SYNC_FLAG</name></cpp:ifdef>
	<expr><block>{<expr><literal type="string">"open_sync"</literal></expr>, <expr><name>SYNC_METHOD_OPEN</name></expr>, <expr><name>false</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>OPEN_DATASYNC_FLAG</name></cpp:ifdef>
	<expr><block>{<expr><literal type="string">"open_datasync"</literal></expr>, <expr><name>SYNC_METHOD_OPEN_DSYNC</name></expr>, <expr><name>false</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * Although only "on", "off", and "always" are documented,
 * we accept all the likely variants of "on" and "off".
 */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>archive_mode_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"always"</literal></expr>, <expr><name>ARCHIVE_MODE_ALWAYS</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"on"</literal></expr>, <expr><name>ARCHIVE_MODE_ON</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"off"</literal></expr>, <expr><name>ARCHIVE_MODE_OFF</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"true"</literal></expr>, <expr><name>ARCHIVE_MODE_ON</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"false"</literal></expr>, <expr><name>ARCHIVE_MODE_OFF</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"yes"</literal></expr>, <expr><name>ARCHIVE_MODE_ON</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"no"</literal></expr>, <expr><name>ARCHIVE_MODE_OFF</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"1"</literal></expr>, <expr><name>ARCHIVE_MODE_ON</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"0"</literal></expr>, <expr><name>ARCHIVE_MODE_OFF</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Statistics for current checkpoint are collected in this global struct.
 * Because only the checkpointer or a stand-alone backend can perform
 * checkpoints, this will be unused in normal backends.
 */</comment>
<decl_stmt><decl><type><name>CheckpointStatsData</name></type> <name>CheckpointStats</name></decl>;</decl_stmt>

<comment type="block">/*
 * ThisTimeLineID will be same in all backends --- it identifies current
 * WAL timeline for the database system.
 */</comment>
<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>ThisTimeLineID</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Are we doing recovery from XLOG?
 *
 * This is only ever true in the startup process; it should be read as meaning
 * "this process is replaying WAL records", rather than "the system is in
 * recovery mode".  It should be examined primarily by functions that need
 * to act differently when called from a WAL redo function (e.g., to skip WAL
 * logging).  To check whether the system is in recovery regardless of which
 * process you're running in, use RecoveryInProgress() but only after shared
 * memory startup and lock initialization.
 */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>InRecovery</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Are we in Hot Standby mode? Only valid in startup process, see xlog.h */</comment>
<decl_stmt><decl><type><name>HotStandbyState</name></type> <name>standbyState</name> <init>= <expr><name>STANDBY_DISABLED</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>LastRec</name></decl>;</decl_stmt>

<comment type="block">/* Local copy of WalRcv-&gt;receivedUpto */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>receivedUpto</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>TimeLineID</name></type> <name>receiveTLI</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * During recovery, lastFullPageWrites keeps track of full_page_writes that
 * the replayed WAL records indicate. It's initialized with full_page_writes
 * that the recovery starting checkpoint record indicates, and then updated
 * each time XLOG_FPW_CHANGE record is replayed.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>lastFullPageWrites</name></decl>;</decl_stmt>

<comment type="block">/*
 * Local copy of SharedRecoveryInProgress variable. True actually means "not
 * known, need to check the shared state".
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>LocalRecoveryInProgress</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Local copy of SharedHotStandbyActive variable. False actually means "not
 * known, need to check the shared state".
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>LocalHotStandbyActive</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Local state for XLogInsertAllowed():
 *		1: unconditionally allowed to insert XLOG
 *		0: unconditionally not allowed to insert XLOG
 *		-1: must check RecoveryInProgress(); disallow until it is false
 * Most processes start with -1 and transition to 1 after seeing that recovery
 * is not in progress.  But we can also force the value for special cases.
 * The coding in XLogInsertAllowed() depends on the first two of these states
 * being numerically the same as bool true and false.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>LocalXLogInsertAllowed</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * When ArchiveRecoveryRequested is set, archive recovery was requested,
 * ie. recovery.conf file was present. When InArchiveRecovery is set, we are
 * currently recovering using offline XLOG archives. These variables are only
 * valid in the startup process.
 *
 * When ArchiveRecoveryRequested is true, but InArchiveRecovery is false, we're
 * currently performing crash recovery using only XLOG files in pg_wal, but
 * will switch to using offline XLOG archives as soon as we reach the end of
 * WAL in pg_wal.
*/</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>ArchiveRecoveryRequested</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>InArchiveRecovery</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Was the last xlog file restored from archive, or local? */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>restoredFromArchive</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Buffers dedicated to consistency checks of size BLCKSZ */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>replay_image_masked</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>master_image_masked</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* options taken from recovery.conf for archive recovery */</comment>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>recoveryRestoreCommand</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>recoveryEndCommand</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>archiveCleanupCommand</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>RecoveryTargetType</name></type> <name>recoveryTarget</name> <init>= <expr><name>RECOVERY_TARGET_UNSET</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>recoveryTargetInclusive</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>RecoveryTargetAction</name></type> <name>recoveryTargetAction</name> <init>= <expr><name>RECOVERY_TARGET_ACTION_PAUSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>TransactionId</name></type> <name>recoveryTargetXid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>recoveryTargetTime</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>recoveryTargetName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>recoveryTargetLSN</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>recovery_min_apply_delay</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>recoveryDelayUntilTime</name></decl>;</decl_stmt>

<comment type="block">/* options taken from recovery.conf for XLOG streaming */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>StandbyModeRequested</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>PrimaryConnInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>PrimarySlotName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>TriggerFile</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* are we currently in standby mode? */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>StandbyMode</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* whether request for fast promotion has been made yet */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>fast_promote</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * if recoveryStopsBefore/After returns true, it saves information of the stop
 * point here
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>TransactionId</name></type> <name>recoveryStopXid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>recoveryStopTime</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>recoveryStopLSN</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>recoveryStopName</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>recoveryStopAfter</name></decl>;</decl_stmt>

<comment type="block">/*
 * During normal operation, the only timeline we care about is ThisTimeLineID.
 * During recovery, however, things are more complicated.  To simplify life
 * for rmgr code, we keep ThisTimeLineID set to the "current" timeline as we
 * scan through the WAL history (that is, it is the line that was active when
 * the currently-scanned WAL record was generated).  We also need these
 * timeline values:
 *
 * recoveryTargetTLI: the desired timeline that we want to end in.
 *
 * recoveryTargetIsLatest: was the requested target timeline 'latest'?
 *
 * expectedTLEs: a list of TimeLineHistoryEntries for recoveryTargetTLI and the timelines of
 * its known parents, newest first (so recoveryTargetTLI is always the
 * first list member).  Only these TLIs are expected to be seen in the WAL
 * segments we read, and indeed only these TLIs will be considered as
 * candidate WAL files to open at all.
 *
 * curFileTLI: the TLI appearing in the name of the current input WAL file.
 * (This is not necessarily the same as ThisTimeLineID, because we could
 * be scanning data that was copied from an ancestor timeline when the current
 * file was created.)  During a sequential scan we do not allow this value
 * to decrease.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>TimeLineID</name></type> <name>recoveryTargetTLI</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>recoveryTargetIsLatest</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>expectedTLEs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>TimeLineID</name></type> <name>curFileTLI</name></decl>;</decl_stmt>

<comment type="block">/*
 * ProcLastRecPtr points to the start of the last XLOG record inserted by the
 * current backend.  It is updated for all inserts.  XactLastRecEnd points to
 * end+1 of the last record, and is reset when we end a top-level transaction,
 * or start a new one; so it can be used to tell if the current transaction has
 * created any XLOG records.
 *
 * While in parallel mode, this may not be fully up to date.  When committing,
 * a transaction can assume this covers all xlog records written either by the
 * user backend or by any parallel worker which was present at any point during
 * the transaction.  But when aborting, or when still in parallel mode, other
 * parallel backends may have written WAL records at later LSNs than the value
 * stored here.  The parallel leader advances its own copy, when necessary,
 * in WaitForParallelWorkersToFinish.
 */</comment>
<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>ProcLastRecPtr</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>XactLastRecEnd</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>XactLastCommitEnd</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * RedoRecPtr is this backend's local copy of the REDO record pointer
 * (which is almost but not quite the same as a pointer to the most recent
 * CHECKPOINT record).  We update this from the shared-memory copy,
 * XLogCtl-&gt;Insert.RedoRecPtr, whenever we can safely do so (ie, when we
 * hold an insertion lock).  See XLogInsertRecord for details.  We are also
 * allowed to update from XLogCtl-&gt;RedoRecPtr if we hold the info_lck;
 * see GetRedoRecPtr.  A freshly spawned backend obtains the value during
 * InitXLOGAccess.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>RedoRecPtr</name></decl>;</decl_stmt>

<comment type="block">/*
 * doPageWrites is this backend's local copy of (forcePageWrites ||
 * fullPageWrites).  It is used together with RedoRecPtr to decide whether
 * a full-page image of a page need to be taken.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>doPageWrites</name></decl>;</decl_stmt>

<comment type="block">/* Has the recovery code requested a walreceiver wakeup? */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>doRequestWalReceiverReply</name></decl>;</decl_stmt>

<comment type="block">/*
 * RedoStartLSN points to the checkpoint's REDO location which is specified
 * in a backup label file, backup history file or control file. In standby
 * mode, XLOG streaming usually starts from the position where an invalid
 * record was found. But if we fail to read even the initial checkpoint
 * record, we use the REDO location instead of the checkpoint location as
 * the start position of XLOG streaming. Otherwise we would have to jump
 * backwards to the REDO location after reading the checkpoint record,
 * because the REDO record can precede the checkpoint record.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>RedoStartLSN</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*----------
 * Shared-memory data structures for XLOG control
 *
 * LogwrtRqst indicates a byte position that we need to write and/or fsync
 * the log up to (all records before that point must be written or fsynced).
 * LogwrtResult indicates the byte positions we have already written/fsynced.
 * These structs are identical but are declared separately to indicate their
 * slightly different functions.
 *
 * To read XLogCtl-&gt;LogwrtResult, you must hold either info_lck or
 * WALWriteLock.  To update it, you need to hold both locks.  The point of
 * this arrangement is that the value can be examined by code that already
 * holds WALWriteLock without needing to grab info_lck as well.  In addition
 * to the shared variable, each backend has a private copy of LogwrtResult,
 * which is updated when convenient.
 *
 * The request bookkeeping is simpler: there is a shared XLogCtl-&gt;LogwrtRqst
 * (protected by info_lck), but we don't need to cache any copies of it.
 *
 * info_lck is only held long enough to read/update the protected variables,
 * so it's a plain spinlock.  The other locks are held longer (potentially
 * over I/O operations), so we use LWLocks for them.  These locks are:
 *
 * WALBufMappingLock: must be held to replace a page in the WAL buffer cache.
 * It is only held while initializing and changing the mapping.  If the
 * contents of the buffer being replaced haven't been written yet, the mapping
 * lock is released while the write is done, and reacquired afterwards.
 *
 * WALWriteLock: must be held to write WAL buffers to disk (XLogWrite or
 * XLogFlush).
 *
 * ControlFileLock: must be held to read/update control file or create
 * new log file.
 *
 * CheckpointLock: must be held to do a checkpoint or restartpoint (ensures
 * only one checkpointer at a time; currently, with all checkpoints done by
 * the checkpointer, this is just pro forma).
 *
 *----------
 */</comment>

<typedef>typedef <type><struct>struct <name>XLogwrtRqst</name>
<block>{
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>Write</name></decl>;</decl_stmt>			<comment type="block">/* last byte + 1 to write out */</comment>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>Flush</name></decl>;</decl_stmt>			<comment type="block">/* last byte + 1 to flush */</comment>
}</block></struct></type> <name>XLogwrtRqst</name>;</typedef>

<typedef>typedef <type><struct>struct <name>XLogwrtResult</name>
<block>{
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>Write</name></decl>;</decl_stmt>			<comment type="block">/* last byte + 1 written out */</comment>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>Flush</name></decl>;</decl_stmt>			<comment type="block">/* last byte + 1 flushed */</comment>
}</block></struct></type> <name>XLogwrtResult</name>;</typedef>

<comment type="block">/*
 * Inserting to WAL is protected by a small fixed number of WAL insertion
 * locks. To insert to the WAL, you must hold one of the locks - it doesn't
 * matter which one. To lock out other concurrent insertions, you must hold
 * of them. Each WAL insertion lock consists of a lightweight lock, plus an
 * indicator of how far the insertion has progressed (insertingAt).
 *
 * The insertingAt values are read when a process wants to flush WAL from
 * the in-memory buffers to disk, to check that all the insertions to the
 * region the process is about to write out have finished. You could simply
 * wait for all currently in-progress insertions to finish, but the
 * insertingAt indicator allows you to ignore insertions to later in the WAL,
 * so that you only wait for the insertions that are modifying the buffers
 * you're about to write out.
 *
 * This isn't just an optimization. If all the WAL buffers are dirty, an
 * inserter that's holding a WAL insert lock might need to evict an old WAL
 * buffer, which requires flushing the WAL. If it's possible for an inserter
 * to block on another inserter unnecessarily, deadlock can arise when two
 * inserters holding a WAL insert lock wait for each other to finish their
 * insertion.
 *
 * Small WAL records that don't cross a page boundary never update the value,
 * the WAL record is just copied to the page and the lock is released. But
 * to avoid the deadlock-scenario explained above, the indicator is always
 * updated before sleeping while holding an insertion lock.
 *
 * lastImportantAt contains the LSN of the last important WAL record inserted
 * using a given lock. This value is used to detect if there has been
 * important WAL activity since the last time some action, like a checkpoint,
 * was performed - allowing to not repeat the action if not. The LSN is
 * updated for all insertions, unless the XLOG_MARK_UNIMPORTANT flag was
 * set. lastImportantAt is never cleared, only overwritten by the LSN of newer
 * records.  Tracking the WAL activity directly in WALInsertLock has the
 * advantage of not needing any additional locks to update the value.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>LWLock</name></type>		<name>lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>insertingAt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lastImportantAt</name></decl>;</decl_stmt>
}</block></struct></type> <name>WALInsertLock</name>;</typedef>

<comment type="block">/*
 * All the WAL insertion locks are allocated as an array in shared memory. We
 * force the array stride to be a power of 2, which saves a few cycles in
 * indexing, but more importantly also ensures that individual slots don't
 * cross cache line boundaries. (Of course, we have to also ensure that the
 * array start address is suitably aligned.)
 */</comment>
<typedef>typedef <type><union>union <name>WALInsertLockPadded</name>
<block>{
	<decl_stmt><decl><type><name>WALInsertLock</name></type> <name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>pad</name><index>[<expr><name>PG_CACHE_LINE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
}</block></union></type> <name>WALInsertLockPadded</name>;</typedef>

<comment type="block">/*
 * State of an exclusive backup, necessary to control concurrent activities
 * across sessions when working on exclusive backups.
 *
 * EXCLUSIVE_BACKUP_NONE means that there is no exclusive backup actually
 * running, to be more precise pg_start_backup() is not being executed for
 * an exclusive backup and there is no exclusive backup in progress.
 * EXCLUSIVE_BACKUP_STARTING means that pg_start_backup() is starting an
 * exclusive backup.
 * EXCLUSIVE_BACKUP_IN_PROGRESS means that pg_start_backup() has finished
 * running and an exclusive backup is in progress. pg_stop_backup() is
 * needed to finish it.
 * EXCLUSIVE_BACKUP_STOPPING means that pg_stop_backup() is stopping an
 * exclusive backup.
 */</comment>
<typedef>typedef <type><enum>enum <name>ExclusiveBackupState</name>
<block>{
	<decl><name>EXCLUSIVE_BACKUP_NONE</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
	<decl><name>EXCLUSIVE_BACKUP_STARTING</name></decl>,
	<decl><name>EXCLUSIVE_BACKUP_IN_PROGRESS</name></decl>,
	<decl><name>EXCLUSIVE_BACKUP_STOPPING</name></decl>
}</block></enum></type> <name>ExclusiveBackupState</name>;</typedef>

<comment type="block">/*
 * Session status of running backup, used for sanity checks in SQL-callable
 * functions to start and stop backups.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>SessionBackupState</name></type> <name>sessionBackupState</name> <init>= <expr><name>SESSION_BACKUP_NONE</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Shared state data for WAL insertion.
 */</comment>
<typedef>typedef <type><struct>struct <name>XLogCtlInsert</name>
<block>{
	<decl_stmt><decl><type><name>slock_t</name></type>		<name>insertpos_lck</name></decl>;</decl_stmt>	<comment type="block">/* protects CurrBytePos and PrevBytePos */</comment>

	<comment type="block">/*
	 * CurrBytePos is the end of reserved WAL. The next record will be
	 * inserted at that position. PrevBytePos is the start position of the
	 * previously inserted (or rather, reserved) record - it is copied to the
	 * prev-link of the next record. These are stored as "usable byte
	 * positions" rather than XLogRecPtrs (see XLogBytePosToRecPtr()).
	 */</comment>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>CurrBytePos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>PrevBytePos</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Make sure the above heavily-contended spinlock and byte positions are
	 * on their own cache line. In particular, the RedoRecPtr and full page
	 * write variables below should be on a different cache line. They are
	 * read on every WAL insertion, but updated rarely, and we don't want
	 * those reads to steal the cache line containing Curr/PrevBytePos.
	 */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>pad</name><index>[<expr><name>PG_CACHE_LINE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * fullPageWrites is the master copy used by all backends to determine
	 * whether to write full-page to WAL, instead of using process-local one.
	 * This is required because, when full_page_writes is changed by SIGHUP,
	 * we must WAL-log it before it actually affects WAL-logging by backends.
	 * Checkpointer sets at startup or after SIGHUP.
	 *
	 * To read these fields, you must hold an insertion lock. To modify them,
	 * you must hold ALL the locks.
	 */</comment>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>RedoRecPtr</name></decl>;</decl_stmt>		<comment type="block">/* current redo point for insertions */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>forcePageWrites</name></decl>;</decl_stmt>	<comment type="block">/* forcing full-page writes for PITR? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>fullPageWrites</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * exclusiveBackupState indicates the state of an exclusive backup (see
	 * comments of ExclusiveBackupState for more details). nonExclusiveBackups
	 * is a counter indicating the number of streaming base backups currently
	 * in progress. forcePageWrites is set to true when either of these is
	 * non-zero. lastBackupStart is the latest checkpoint redo location used
	 * as a starting point for an online backup.
	 */</comment>
	<decl_stmt><decl><type><name>ExclusiveBackupState</name></type> <name>exclusiveBackupState</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nonExclusiveBackups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lastBackupStart</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * WAL insertion locks.
	 */</comment>
	<decl_stmt><decl><type><name>WALInsertLockPadded</name> <modifier>*</modifier></type><name>WALInsertLocks</name></decl>;</decl_stmt>
}</block></struct></type> <name>XLogCtlInsert</name>;</typedef>

<comment type="block">/*
 * Total shared-memory state for XLOG.
 */</comment>
<typedef>typedef <type><struct>struct <name>XLogCtlData</name>
<block>{
	<decl_stmt><decl><type><name>XLogCtlInsert</name></type> <name>Insert</name></decl>;</decl_stmt>

	<comment type="block">/* Protected by info_lck: */</comment>
	<decl_stmt><decl><type><name>XLogwrtRqst</name></type> <name>LogwrtRqst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>RedoRecPtr</name></decl>;</decl_stmt>		<comment type="block">/* a recent copy of Insert-&gt;RedoRecPtr */</comment>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>ckptXidEpoch</name></decl>;</decl_stmt>	<comment type="block">/* nextXID &amp; epoch of latest checkpoint */</comment>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>ckptXid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>asyncXactLSN</name></decl>;</decl_stmt>	<comment type="block">/* LSN of newest async commit/abort */</comment>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>replicationSlotMinLSN</name></decl>;</decl_stmt>	<comment type="block">/* oldest LSN needed by any slot */</comment>

	<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>lastRemovedSegNo</name></decl>;</decl_stmt>	<comment type="block">/* latest removed/recycled XLOG segment */</comment>

	<comment type="block">/* Fake LSN counter, for unlogged relations. Protected by ulsn_lck. */</comment>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>unloggedLSN</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>slock_t</name></type>		<name>ulsn_lck</name></decl>;</decl_stmt>

	<comment type="block">/* Time and LSN of last xlog segment switch. Protected by WALWriteLock. */</comment>
	<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>lastSegSwitchTime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lastSegSwitchLSN</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Protected by info_lck and WALWriteLock (you must hold either lock to
	 * read it, but both to update)
	 */</comment>
	<decl_stmt><decl><type><name>XLogwrtResult</name></type> <name>LogwrtResult</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Latest initialized page in the cache (last byte position + 1).
	 *
	 * To change the identity of a buffer (and InitializedUpTo), you need to
	 * hold WALBufMappingLock.  To change the identity of a buffer that's
	 * still dirty, the old page needs to be written out first, and for that
	 * you need WALWriteLock, and you need to ensure that there are no
	 * in-progress insertions to the page by calling
	 * WaitXLogInsertionsToFinish().
	 */</comment>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>InitializedUpTo</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * These values do not change after startup, although the pointed-to pages
	 * and xlblocks values certainly do.  xlblock values are protected by
	 * WALBufMappingLock.
	 */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pages</name></decl>;</decl_stmt>			<comment type="block">/* buffers for unwritten XLOG pages */</comment>
	<decl_stmt><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>xlblocks</name></decl>;</decl_stmt>		<comment type="block">/* 1st byte ptr-s + XLOG_BLCKSZ */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>XLogCacheBlck</name></decl>;</decl_stmt>	<comment type="block">/* highest allocated xlog buffer index */</comment>

	<comment type="block">/*
	 * Shared copy of ThisTimeLineID. Does not change after end-of-recovery.
	 * If we created a new timeline when the system was started up,
	 * PrevTimeLineID is the old timeline's ID that we forked off from.
	 * Otherwise it's equal to ThisTimeLineID.
	 */</comment>
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>ThisTimeLineID</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>PrevTimeLineID</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * archiveCleanupCommand is read from recovery.conf but needs to be in
	 * shared memory so that the checkpointer process can access it.
	 */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>archiveCleanupCommand</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * SharedRecoveryInProgress indicates if we're still in crash or archive
	 * recovery.  Protected by info_lck.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>SharedRecoveryInProgress</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * SharedHotStandbyActive indicates if we're still in crash or archive
	 * recovery.  Protected by info_lck.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>SharedHotStandbyActive</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * WalWriterSleeping indicates whether the WAL writer is currently in
	 * low-power mode (and hence should be nudged if an async commit occurs).
	 * Protected by info_lck.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>WalWriterSleeping</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * recoveryWakeupLatch is used to wake up the startup process to continue
	 * WAL replay, if it is waiting for WAL to arrive or failover trigger file
	 * to appear.
	 */</comment>
	<decl_stmt><decl><type><name>Latch</name></type>		<name>recoveryWakeupLatch</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * During recovery, we keep a copy of the latest checkpoint record here.
	 * lastCheckPointRecPtr points to start of checkpoint record and
	 * lastCheckPointEndPtr points to end+1 of checkpoint record.  Used by the
	 * checkpointer when it wants to create a restartpoint.
	 *
	 * Protected by info_lck.
	 */</comment>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lastCheckPointRecPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lastCheckPointEndPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CheckPoint</name></type>	<name>lastCheckPoint</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * lastReplayedEndRecPtr points to end+1 of the last record successfully
	 * replayed. When we're currently replaying a record, ie. in a redo
	 * function, replayEndRecPtr points to the end+1 of the record being
	 * replayed, otherwise it's equal to lastReplayedEndRecPtr.
	 */</comment>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lastReplayedEndRecPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>lastReplayedTLI</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>replayEndRecPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>replayEndTLI</name></decl>;</decl_stmt>
	<comment type="block">/* timestamp of last COMMIT/ABORT record replayed (or being replayed) */</comment>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>recoveryLastXTime</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * timestamp of when we started replaying the current chunk of WAL data,
	 * only relevant for replication or archive recovery
	 */</comment>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>currentChunkStartTime</name></decl>;</decl_stmt>
	<comment type="block">/* Are we requested to pause recovery? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>recoveryPause</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * lastFpwDisableRecPtr points to the start of the last replayed
	 * XLOG_FPW_CHANGE record that instructs full_page_writes is disabled.
	 */</comment>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lastFpwDisableRecPtr</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>slock_t</name></type>		<name>info_lck</name></decl>;</decl_stmt>		<comment type="block">/* locks shared variables shown above */</comment>
}</block></struct></type> <name>XLogCtlData</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>XLogCtlData</name> <modifier>*</modifier></type><name>XLogCtl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* a private copy of XLogCtl-&gt;Insert.WALInsertLocks, for convenience */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>WALInsertLockPadded</name> <modifier>*</modifier></type><name>WALInsertLocks</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * We maintain an image of pg_control in shared memory.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>ControlFileData</name> <modifier>*</modifier></type><name>ControlFile</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Calculate the amount of space left on the page after 'endptr'. Beware
 * multiple evaluation!
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INSERT_FREESPACE</name><parameter_list>(<parameter><type><name>endptr</name></type></parameter>)</parameter_list></cpp:macro>	\
	<cpp:value>(((endptr) % XLOG_BLCKSZ == 0) ? 0 : (XLOG_BLCKSZ - (endptr) % XLOG_BLCKSZ))</cpp:value></cpp:define>

<comment type="block">/* Macro to advance to next buffer index. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NextBufIdx</name><parameter_list>(<parameter><type><name>idx</name></type></parameter>)</parameter_list></cpp:macro>		\
		<cpp:value>(((idx) == XLogCtl-&gt;XLogCacheBlck) ? 0 : ((idx) + 1))</cpp:value></cpp:define>

<comment type="block">/*
 * XLogRecPtrToBufIdx returns the index of the WAL buffer that holds, or
 * would hold if it was in cache, the page containing 'recptr'.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XLogRecPtrToBufIdx</name><parameter_list>(<parameter><type><name>recptr</name></type></parameter>)</parameter_list></cpp:macro>	\
	<cpp:value>(((recptr) / XLOG_BLCKSZ) % (XLogCtl-&gt;XLogCacheBlck + 1))</cpp:value></cpp:define>

<comment type="block">/*
 * These are the number of bytes in a WAL page usable for WAL data.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UsableBytesInPage</name></cpp:macro> <cpp:value>(XLOG_BLCKSZ - SizeOfXLogShortPHD)</cpp:value></cpp:define>

<comment type="block">/* Convert min_wal_size_mb and max wal_size_mb to equivalent segment count */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ConvertToXSegs</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>segsize</name></type></parameter>)</parameter_list></cpp:macro>	\
	<cpp:value>(x / ((segsize) / (1024 * 1024)))</cpp:value></cpp:define>

<comment type="block">/* The number of bytes in a WAL segment usable for WAL data. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>UsableBytesInSegment</name></decl>;</decl_stmt>

<comment type="block">/*
 * Private, possibly out-of-date copy of shared LogwrtResult.
 * See discussion above.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>XLogwrtResult</name></type> <name>LogwrtResult</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Codes indicating where we got a WAL file from during recovery, or where
 * to attempt to get one.
 */</comment>
<typedef>typedef <type><enum>enum
<block>{
	<decl><name>XLOG_FROM_ANY</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,			<comment type="block">/* request to read WAL from any source */</comment>
	<decl><name>XLOG_FROM_ARCHIVE</name></decl>,			<comment type="block">/* restored using restore_command */</comment>
	<decl><name>XLOG_FROM_PG_WAL</name></decl>,			<comment type="block">/* existing file in pg_wal */</comment>
	<decl><name>XLOG_FROM_STREAM</name></decl>			<comment type="block">/* streamed from master */</comment>
}</block></enum></type> <name>XLogSource</name>;</typedef>

<comment type="block">/* human-readable names for XLogSources, for debugging output */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>xlogSourceNames</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"any"</literal></expr>, <expr><literal type="string">"archive"</literal></expr>, <expr><literal type="string">"pg_wal"</literal></expr>, <expr><literal type="string">"stream"</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * openLogFile is -1 or a kernel FD for an open log file segment.
 * When it's open, openLogOff is the current seek offset in the file.
 * openLogSegNo identifies the segment.  These variables are only
 * used to write the XLOG, and so will normally refer to the active segment.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>openLogFile</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>XLogSegNo</name></type> <name>openLogSegNo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32</name></type> <name>openLogOff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * These variables are used similarly to the ones above, but for reading
 * the XLOG.  Note, however, that readOff generally represents the offset
 * of the page just read, not the seek position of the FD itself, which
 * will be just past that page. readLen indicates how much of the current
 * page has been read into readBuf, and readSource indicates where we got
 * the currently open file from.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>readFile</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>XLogSegNo</name></type> <name>readSegNo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32</name></type> <name>readOff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32</name></type> <name>readLen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>XLogSource</name></type> <name>readSource</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* XLOG_FROM_* code */</comment>

<comment type="block">/*
 * Keeps track of which source we're currently reading from. This is
 * different from readSource in that this is always set, even when we don't
 * currently have a WAL file open. If lastSourceFailed is set, our last
 * attempt to read from currentSource failed, and we should try another source
 * next.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>XLogSource</name></type> <name>currentSource</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* XLOG_FROM_* code */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>lastSourceFailed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct <name>XLogPageReadPrivate</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>emode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>fetching_ckpt</name></decl>;</decl_stmt>	<comment type="block">/* are we fetching a checkpoint record? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>randAccess</name></decl>;</decl_stmt>
}</block></struct></type> <name>XLogPageReadPrivate</name>;</typedef>

<comment type="block">/*
 * These variables track when we last obtained some WAL data to process,
 * and where we got it from.  (XLogReceiptSource is initially the same as
 * readSource, but readSource gets reset to zero when we don't have data
 * to process right now.  It is also different from currentSource, which
 * also changes when we try to read from a source and fail, while
 * XLogReceiptSource tracks where we last successfully read some WAL.)
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>XLogReceiptTime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>XLogSource</name></type> <name>XLogReceiptSource</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* XLOG_FROM_* code */</comment>

<comment type="block">/* State information for XLOG reading */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>ReadRecPtr</name></decl>;</decl_stmt>	<comment type="block">/* start of last record read */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>EndRecPtr</name></decl>;</decl_stmt>	<comment type="block">/* end+1 of last record read */</comment>

<comment type="block">/*
 * Local copies of equivalent fields in the control file.  When running
 * crash recovery, minRecoveryPoint is set to InvalidXLogRecPtr as we
 * expect to replay all the WAL available, and updateMinRecoveryPoint is
 * switched to false to prevent any updates while replaying records.
 * Those values are kept consistent as long as crash recovery runs.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>minRecoveryPoint</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>TimeLineID</name></type> <name>minRecoveryPointTLI</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>updateMinRecoveryPoint</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Have we reached a consistent database state? In crash recovery, we have
 * to replay all the WAL, so reachedConsistency is never set. During archive
 * recovery, the database is consistent once minRecoveryPoint is reached.
 */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>reachedConsistency</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>InRedo</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Have we launched bgwriter during recovery? */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>bgwriterLaunched</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* For WALInsertLockAcquire/Release functions */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>MyLockNo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>holdingAllLocks</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WAL_DEBUG</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>walDebugCxt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>readRecoveryCommandFile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>exitArchiveRecovery</name><parameter_list>(<parameter><decl><type><name>TimeLineID</name></type> <name>endTLI</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>endOfLog</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>recoveryStopsBefore</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>recoveryStopsAfter</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>recoveryPausesHere</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>recoveryApplyDelay</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SetLatestXTime</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>xtime</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SetCurrentChunkStartTime</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>xtime</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CheckRequiredParameterValues</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>XLogReportParameters</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>checkTimeLineSwitch</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name></type> <name>newTLI</name></decl></parameter>,
					<parameter><decl><type><name>TimeLineID</name></type> <name>prevTLI</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>LocalSetXLogInsertAllowed</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CreateEndOfRecoveryRecord</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CheckPointGuts</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>checkPointRedo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>KeepLogSeg</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>recptr</name></decl></parameter>, <parameter><decl><type><name>XLogSegNo</name> <modifier>*</modifier></type><name>logSegNo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>XLogGetReplicationSlotMinimumLSN</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AdvanceXLInsertBuffer</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>upto</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>opportunistic</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>XLogCheckpointNeeded</name><parameter_list>(<parameter><decl><type><name>XLogSegNo</name></type> <name>new_segno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>XLogWrite</name><parameter_list>(<parameter><decl><type><name>XLogwrtRqst</name></type> <name>WriteRqst</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>flexible</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>InstallXLogFileSegment</name><parameter_list>(<parameter><decl><type><name>XLogSegNo</name> <modifier>*</modifier></type><name>segno</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>tmppath</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>find_free</name></decl></parameter>, <parameter><decl><type><name>XLogSegNo</name></type> <name>max_segno</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>use_lock</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>XLogFileRead</name><parameter_list>(<parameter><decl><type><name>XLogSegNo</name></type> <name>segno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>emode</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name></type> <name>tli</name></decl></parameter>,
			 <parameter><decl><type><name>int</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>notfoundOk</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>XLogFileReadAnyTLI</name><parameter_list>(<parameter><decl><type><name>XLogSegNo</name></type> <name>segno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>emode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>XLogPageRead</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>xlogreader</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>targetPagePtr</name></decl></parameter>,
			 <parameter><decl><type><name>int</name></type> <name>reqLen</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>targetRecPtr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>readBuf</name></decl></parameter>,
			 <parameter><decl><type><name>TimeLineID</name> <modifier>*</modifier></type><name>readTLI</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>WaitForWALToBecomeAvailable</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>RecPtr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>randAccess</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>fetching_ckpt</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>tliRecPtr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>emode_for_corrupt_record</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>emode</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>RecPtr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>XLogFileClose</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PreallocXlogFiles</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>endptr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RemoveOldXlogFiles</name><parameter_list>(<parameter><decl><type><name>XLogSegNo</name></type> <name>segno</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>RedoRecPtr</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>endptr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RemoveXlogFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>segname</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>RedoRecPtr</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>endptr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>UpdateLastRemovedPtr</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ValidateXLOGDirectoryStructure</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CleanupBackupHistory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>UpdateMinRecoveryPoint</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>XLogRecord</name> <modifier>*</modifier></type><name>ReadRecord</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>xlogreader</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>RecPtr</name></decl></parameter>,
		   <parameter><decl><type><name>int</name></type> <name>emode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fetching_ckpt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CheckRecoveryConsistency</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>XLogRecord</name> <modifier>*</modifier></type><name>ReadCheckpointRecord</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>xlogreader</name></decl></parameter>,
					 <parameter><decl><type><name>XLogRecPtr</name></type> <name>RecPtr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>whichChkpti</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>report</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>rescanLatestTimeLine</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WriteControlFile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReadControlFile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>str_time</name><parameter_list>(<parameter><decl><type><name>pg_time_t</name></type> <name>tnow</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CheckForStandbyTrigger</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WAL_DEBUG</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>xlog_outrec</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>xlog_outdesc</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pg_start_backup_callback</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pg_stop_backup_callback</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>read_backup_label</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>checkPointLoc</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>backupEndRequired</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>backupFromStandby</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>read_tablespace_map</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>tablespaces</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>rm_redo_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>get_sync_bit</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>method</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CopyXLogRecordToWAL</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>write_len</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isLogSwitch</name></decl></parameter>,
					<parameter><decl><type><name>XLogRecData</name> <modifier>*</modifier></type><name>rdata</name></decl></parameter>,
					<parameter><decl><type><name>XLogRecPtr</name></type> <name>StartPos</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>EndPos</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReserveXLogInsertLocation</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>StartPos</name></decl></parameter>,
						  <parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>EndPos</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>PrevPtr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ReserveXLogSwitch</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>StartPos</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>EndPos</name></decl></parameter>,
				  <parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>PrevPtr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>WaitXLogInsertionsToFinish</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>upto</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>GetXLogBuffer</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>ptr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>XLogBytePosToRecPtr</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>bytepos</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>XLogBytePosToEndRecPtr</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>bytepos</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>XLogRecPtrToBytePos</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>ptr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>checkXLogConsistency</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WALInsertLockAcquire</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WALInsertLockAcquireExclusive</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WALInsertLockRelease</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WALInsertLockUpdateInsertingAt</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>insertingAt</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Insert an XLOG record represented by an already-constructed chain of data
 * chunks.  This is a low-level routine; to construct the WAL record header
 * and data, use the higher-level routines in xloginsert.c.
 *
 * If 'fpw_lsn' is valid, it is the oldest LSN among the pages that this
 * WAL record applies to, that were not included in the record as full page
 * images.  If fpw_lsn &lt;= RedoRecPtr, the function does not perform the
 * insertion and returns InvalidXLogRecPtr.  The caller can then recalculate
 * which pages need a full-page image, and retry.  If fpw_lsn is invalid, the
 * record is always inserted.
 *
 * 'flags' gives more in-depth control on the record being inserted. See
 * XLogSetRecordFlags() for details.
 *
 * The first XLogRecData in the chain must be for the record header, and its
 * data must be MAXALIGNed.  XLogInsertRecord fills in the xl_prev and
 * xl_crc fields in the header, the rest of the header must already be filled
 * by the caller.
 *
 * Returns XLOG pointer to end of record (beginning of next record).
 * This can be used as LSN for data pages affected by the logged action.
 * (LSN is the XLOG point up to which the XLOG must be flushed to disk
 * before the data page can be written out.  This implements the basic
 * WAL rule "write the log before the data".)
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>XLogInsertRecord</name><parameter_list>(<parameter><decl><type><name>XLogRecData</name> <modifier>*</modifier></type><name>rdata</name></decl></parameter>,
				 <parameter><decl><type><name>XLogRecPtr</name></type> <name>fpw_lsn</name></decl></parameter>,
				 <parameter><decl><type><name>uint8</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogCtlInsert</name> <modifier>*</modifier></type><name>Insert</name> <init>= <expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_crc32c</name></type>	<name>rdata_crc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>inserted</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>rechdr</name> <init>= <expr><operator>(</operator><name>XLogRecord</name> <operator>*</operator><operator>)</operator> <name><name>rdata</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>info</name> <init>= <expr><name><name>rechdr</name><operator>-&gt;</operator><name>xl_info</name></name> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isLogSwitch</name> <init>= <expr><operator>(</operator><name><name>rechdr</name><operator>-&gt;</operator><name>xl_rmid</name></name> <operator>==</operator> <name>RM_XLOG_ID</name> <operator>&amp;&amp;</operator>
							   <name>info</name> <operator>==</operator> <name>XLOG_SWITCH</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>StartPos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>EndPos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>prevDoPageWrites</name> <init>= <expr><name>doPageWrites</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we assume that all of the record header is in the first chunk */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rdata</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;=</operator> <name>SizeOfXLogRecord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* cross-check on whether we should be here or not */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogInsertAllowed</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot make new WAL entries during recovery"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*----------
	 *
	 * We have now done all the preparatory work we can without holding a
	 * lock or modifying shared state. From here on, inserting the new WAL
	 * record to the shared WAL buffer cache is a two-step process:
	 *
	 * 1. Reserve the right amount of space from the WAL. The current head of
	 *	  reserved space is kept in Insert-&gt;CurrBytePos, and is protected by
	 *	  insertpos_lck.
	 *
	 * 2. Copy the record to the reserved WAL space. This involves finding the
	 *	  correct WAL buffer containing the reserved space, and copying the
	 *	  record in place. This can be done concurrently in multiple processes.
	 *
	 * To keep track of which insertions are still in-progress, each concurrent
	 * inserter acquires an insertion lock. In addition to just indicating that
	 * an insertion is in progress, the lock tells others how far the inserter
	 * has progressed. There is a small fixed number of insertion locks,
	 * determined by NUM_XLOGINSERT_LOCKS. When an inserter crosses a page
	 * boundary, it updates the value stored in the lock to the how far it has
	 * inserted, to allow the previous buffer to be flushed.
	 *
	 * Holding onto an insertion lock also protects RedoRecPtr and
	 * fullPageWrites from changing until the insertion is finished.
	 *
	 * Step 2 can usually be done completely in parallel. If the required WAL
	 * page is not initialized yet, you have to grab WALBufMappingLock to
	 * initialize it, but the WAL writer tries to do that ahead of insertions
	 * to avoid that from happening in the critical path.
	 *
	 *----------
	 */</comment>
	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isLogSwitch</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>WALInsertLockAcquireExclusive</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>WALInsertLockAcquire</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Check to see if my copy of RedoRecPtr is out of date. If so, may have
	 * to go back and have the caller recompute everything. This can only
	 * happen just after a checkpoint, so it's better to be slow in this case
	 * and fast otherwise.
	 *
	 * Also check to see if fullPageWrites or forcePageWrites was just turned
	 * on; if we weren't already doing full-page writes then go back and
	 * recompute.
	 *
	 * If we aren't doing full-page writes then RedoRecPtr doesn't actually
	 * affect the contents of the XLOG record, so we'll update our local copy
	 * but not force a recomputation.  (If doPageWrites was just turned off,
	 * we could recompute the record without full pages, but we choose not to
	 * bother.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>RedoRecPtr</name> <operator>!=</operator> <name><name>Insert</name><operator>-&gt;</operator><name>RedoRecPtr</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>RedoRecPtr</name> <operator>&lt;</operator> <name><name>Insert</name><operator>-&gt;</operator><name>RedoRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>RedoRecPtr</name> <operator>=</operator> <name><name>Insert</name><operator>-&gt;</operator><name>RedoRecPtr</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>doPageWrites</name> <operator>=</operator> <operator>(</operator><name><name>Insert</name><operator>-&gt;</operator><name>fullPageWrites</name></name> <operator>||</operator> <name><name>Insert</name><operator>-&gt;</operator><name>forcePageWrites</name></name><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>doPageWrites</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>!</operator><name>prevDoPageWrites</name> <operator>||</operator>
		 <operator>(</operator><name>fpw_lsn</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name> <operator>&amp;&amp;</operator> <name>fpw_lsn</name> <operator>&lt;=</operator> <name>RedoRecPtr</name><operator>)</operator><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Oops, some buffer now needs to be backed up that the caller didn't
		 * back up.  Start over.
		 */</comment>
		<expr_stmt><expr><call><name>WALInsertLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>InvalidXLogRecPtr</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Reserve space for the record in the WAL. This also sets the xl_prev
	 * pointer.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isLogSwitch</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>inserted</name> <operator>=</operator> <call><name>ReserveXLogSwitch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>StartPos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>EndPos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rechdr</name><operator>-&gt;</operator><name>xl_prev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReserveXLogInsertLocation</name><argument_list>(<argument><expr><name><name>rechdr</name><operator>-&gt;</operator><name>xl_tot_len</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>StartPos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>EndPos</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name><name>rechdr</name><operator>-&gt;</operator><name>xl_prev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>inserted</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>inserted</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Now that xl_prev has been filled in, calculate CRC of the record
		 * header.
		 */</comment>
		<expr_stmt><expr><name>rdata_crc</name> <operator>=</operator> <name><name>rechdr</name><operator>-&gt;</operator><name>xl_crc</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>rdata_crc</name></expr></argument>, <argument><expr><name>rechdr</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>XLogRecord</name></expr></argument>, <argument><expr><name>xl_crc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name>rdata_crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rechdr</name><operator>-&gt;</operator><name>xl_crc</name></name> <operator>=</operator> <name>rdata_crc</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * All the record data, including the header, is now ready to be
		 * inserted. Copy the record in the space reserved.
		 */</comment>
		<expr_stmt><expr><call><name>CopyXLogRecordToWAL</name><argument_list>(<argument><expr><name><name>rechdr</name><operator>-&gt;</operator><name>xl_tot_len</name></name></expr></argument>, <argument><expr><name>isLogSwitch</name></expr></argument>, <argument><expr><name>rdata</name></expr></argument>,
							<argument><expr><name>StartPos</name></expr></argument>, <argument><expr><name>EndPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Unless record is flagged as not important, update LSN of last
		 * important record in the current slot. When holding all locks, just
		 * update the first one.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>XLOG_MARK_UNIMPORTANT</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>lockno</name> <init>= <expr><ternary><condition><expr><name>holdingAllLocks</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>MyLockNo</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>WALInsertLocks</name><index>[<expr><name>lockno</name></expr>]</index></name><operator>.</operator><name><name>l</name><operator>.</operator><name>lastImportantAt</name></name> <operator>=</operator> <name>StartPos</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * This was an xlog-switch record, but the current insert location was
		 * already exactly at the beginning of a segment, so there was no need
		 * to do anything.
		 */</comment>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Done! Let others know that we're finished.
	 */</comment>
	<expr_stmt><expr><call><name>WALInsertLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MarkCurrentTransactionIdLoggedIfAny</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update shared LogwrtRqst.Write, if we crossed page boundary.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>StartPos</name> <operator>/</operator> <name>XLOG_BLCKSZ</name> <operator>!=</operator> <name>EndPos</name> <operator>/</operator> <name>XLOG_BLCKSZ</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* advance global request to include new block(s) */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtRqst</name><operator>.</operator><name>Write</name></name> <operator>&lt;</operator> <name>EndPos</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtRqst</name><operator>.</operator><name>Write</name></name> <operator>=</operator> <name>EndPos</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* update local result copy while I have the chance */</comment>
		<expr_stmt><expr><name>LogwrtResult</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtResult</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If this was an XLOG_SWITCH record, flush the record and the empty
	 * padding space that fills the rest of the segment, and perform
	 * end-of-segment actions (eg, notifying archiver).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isLogSwitch</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>TRACE_POSTGRESQL_WAL_SWITCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogFlush</name><argument_list>(<argument><expr><name>EndPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Even though we reserved the rest of the segment for us, which is
		 * reflected in EndPos, we return a pointer to just the end of the
		 * xlog-switch record.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>inserted</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>EndPos</name> <operator>=</operator> <name>StartPos</name> <operator>+</operator> <name>SizeOfXLogRecord</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>StartPos</name> <operator>/</operator> <name>XLOG_BLCKSZ</name> <operator>!=</operator> <name>EndPos</name> <operator>/</operator> <name>XLOG_BLCKSZ</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>uint64</name></type>		<name>offset</name> <init>= <expr><call><name>XLogSegmentOffset</name><argument_list>(<argument><expr><name>EndPos</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>==</operator> <name>EndPos</name> <operator>%</operator> <name>XLOG_BLCKSZ</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>EndPos</name> <operator>+=</operator> <name>SizeOfXLogLongPHD</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>EndPos</name> <operator>+=</operator> <name>SizeOfXLogShortPHD</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WAL_DEBUG</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>XLOG_DEBUG</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>static</specifier> <name>XLogReaderState</name> <modifier>*</modifier></type><name>debug_reader</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>recordBuf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>errormsg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCxt</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>oldCxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>walDebugCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"INSERT @ %X/%X: "</literal></expr></argument>,
						 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>EndPos</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>EndPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We have to piece together the WAL record data from the XLogRecData
		 * entries, so that we can pass it to the rm_desc function as one
		 * contiguous chunk.
		 */</comment>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>recordBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init>;</init> <condition><expr><name>rdata</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>rdata</name> <operator>=</operator> <name><name>rdata</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>recordBuf</name></expr></argument>, <argument><expr><name><name>rdata</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>rdata</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>debug_reader</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>debug_reader</name> <operator>=</operator> <call><name>XLogReaderAllocate</name><argument_list>(<argument><expr><name>wal_segment_size</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>debug_reader</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"error decoding record: out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>DecodeXLogRecord</name><argument_list>(<argument><expr><name>debug_reader</name></expr></argument>, <argument><expr><operator>(</operator><name>XLogRecord</name> <operator>*</operator><operator>)</operator> <name><name>recordBuf</name><operator>.</operator><name>data</name></name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>errormsg</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"error decoding record: %s"</literal></expr></argument>,
							 <argument><expr><ternary><condition><expr><name>errormsg</name></expr> ?</condition><then> <expr><name>errormsg</name></expr> </then><else>: <expr><literal type="string">"no error message"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" - "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>xlog_outdesc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>debug_reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>recordBuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Update our global variables
	 */</comment>
	<expr_stmt><expr><name>ProcLastRecPtr</name> <operator>=</operator> <name>StartPos</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>XactLastRecEnd</name> <operator>=</operator> <name>EndPos</name></expr>;</expr_stmt>

	<return>return <expr><name>EndPos</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Reserves the right amount of space for a record of given size from the WAL.
 * *StartPos is set to the beginning of the reserved section, *EndPos to
 * its end+1. *PrevPtr is set to the beginning of the previous record; it is
 * used to set the xl_prev of this record.
 *
 * This is the performance critical part of XLogInsert that must be serialized
 * across backends. The rest can happen mostly in parallel. Try to keep this
 * section as short as possible, insertpos_lck can be heavily contended on a
 * busy system.
 *
 * NB: The space calculation here must match the code in CopyXLogRecordToWAL,
 * where we actually copy the record to the reserved space.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReserveXLogInsertLocation</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>StartPos</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>EndPos</name></decl></parameter>,
						  <parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>PrevPtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogCtlInsert</name> <modifier>*</modifier></type><name>Insert</name> <init>= <expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>startbytepos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>endbytepos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>prevbytepos</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* All (non xlog-switch) records should contain data. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>size</name> <operator>&gt;</operator> <name>SizeOfXLogRecord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The duration the spinlock needs to be held is minimized by minimizing
	 * the calculations that have to be done while holding the lock. The
	 * current tip of reserved WAL is kept in CurrBytePos, as a byte position
	 * that only counts "usable" bytes in WAL, that is, it excludes all WAL
	 * page headers. The mapping between "usable" byte positions and physical
	 * positions (XLogRecPtrs) can be done outside the locked region, and
	 * because the usable byte position doesn't include any headers, reserving
	 * X bytes from WAL is almost as simple as "CurrBytePos += X".
	 */</comment>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>Insert</name><operator>-&gt;</operator><name>insertpos_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>startbytepos</name> <operator>=</operator> <name><name>Insert</name><operator>-&gt;</operator><name>CurrBytePos</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>endbytepos</name> <operator>=</operator> <name>startbytepos</name> <operator>+</operator> <name>size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prevbytepos</name> <operator>=</operator> <name><name>Insert</name><operator>-&gt;</operator><name>PrevBytePos</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Insert</name><operator>-&gt;</operator><name>CurrBytePos</name></name> <operator>=</operator> <name>endbytepos</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Insert</name><operator>-&gt;</operator><name>PrevBytePos</name></name> <operator>=</operator> <name>startbytepos</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>Insert</name><operator>-&gt;</operator><name>insertpos_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>StartPos</name> <operator>=</operator> <call><name>XLogBytePosToRecPtr</name><argument_list>(<argument><expr><name>startbytepos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>EndPos</name> <operator>=</operator> <call><name>XLogBytePosToEndRecPtr</name><argument_list>(<argument><expr><name>endbytepos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>PrevPtr</name> <operator>=</operator> <call><name>XLogBytePosToRecPtr</name><argument_list>(<argument><expr><name>prevbytepos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check that the conversions between "usable byte positions" and
	 * XLogRecPtrs work consistently in both directions.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>XLogRecPtrToBytePos</name><argument_list>(<argument><expr><operator>*</operator><name>StartPos</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>startbytepos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>XLogRecPtrToBytePos</name><argument_list>(<argument><expr><operator>*</operator><name>EndPos</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>endbytepos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>XLogRecPtrToBytePos</name><argument_list>(<argument><expr><operator>*</operator><name>PrevPtr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>prevbytepos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Like ReserveXLogInsertLocation(), but for an xlog-switch record.
 *
 * A log-switch record is handled slightly differently. The rest of the
 * segment will be reserved for this insertion, as indicated by the returned
 * *EndPos value. However, if we are already at the beginning of the current
 * segment, *StartPos and *EndPos are set to the current location without
 * reserving any space, and the function returns false.
*/</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ReserveXLogSwitch</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>StartPos</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>EndPos</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>PrevPtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogCtlInsert</name> <modifier>*</modifier></type><name>Insert</name> <init>= <expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>startbytepos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>endbytepos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>prevbytepos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>size</name> <init>= <expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><name>SizeOfXLogRecord</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>segleft</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * These calculations are a bit heavy-weight to be done while holding a
	 * spinlock, but since we're holding all the WAL insertion locks, there
	 * are no other inserters competing for it. GetXLogInsertRecPtr() does
	 * compete for it, but that's not called very frequently.
	 */</comment>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>Insert</name><operator>-&gt;</operator><name>insertpos_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>startbytepos</name> <operator>=</operator> <name><name>Insert</name><operator>-&gt;</operator><name>CurrBytePos</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>XLogBytePosToEndRecPtr</name><argument_list>(<argument><expr><name>startbytepos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>XLogSegmentOffset</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>Insert</name><operator>-&gt;</operator><name>insertpos_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>EndPos</name> <operator>=</operator> <operator>*</operator><name>StartPos</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>endbytepos</name> <operator>=</operator> <name>startbytepos</name> <operator>+</operator> <name>size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prevbytepos</name> <operator>=</operator> <name><name>Insert</name><operator>-&gt;</operator><name>PrevBytePos</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>StartPos</name> <operator>=</operator> <call><name>XLogBytePosToRecPtr</name><argument_list>(<argument><expr><name>startbytepos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>EndPos</name> <operator>=</operator> <call><name>XLogBytePosToEndRecPtr</name><argument_list>(<argument><expr><name>endbytepos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>segleft</name> <operator>=</operator> <name>wal_segment_size</name> <operator>-</operator> <call><name>XLogSegmentOffset</name><argument_list>(<argument><expr><operator>*</operator><name>EndPos</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>segleft</name> <operator>!=</operator> <name>wal_segment_size</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* consume the rest of the segment */</comment>
		<expr_stmt><expr><operator>*</operator><name>EndPos</name> <operator>+=</operator> <name>segleft</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>endbytepos</name> <operator>=</operator> <call><name>XLogRecPtrToBytePos</name><argument_list>(<argument><expr><operator>*</operator><name>EndPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>Insert</name><operator>-&gt;</operator><name>CurrBytePos</name></name> <operator>=</operator> <name>endbytepos</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Insert</name><operator>-&gt;</operator><name>PrevBytePos</name></name> <operator>=</operator> <name>startbytepos</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>Insert</name><operator>-&gt;</operator><name>insertpos_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>PrevPtr</name> <operator>=</operator> <call><name>XLogBytePosToRecPtr</name><argument_list>(<argument><expr><name>prevbytepos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>XLogSegmentOffset</name><argument_list>(<argument><expr><operator>*</operator><name>EndPos</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>XLogRecPtrToBytePos</name><argument_list>(<argument><expr><operator>*</operator><name>EndPos</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>endbytepos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>XLogRecPtrToBytePos</name><argument_list>(<argument><expr><operator>*</operator><name>StartPos</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>startbytepos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>XLogRecPtrToBytePos</name><argument_list>(<argument><expr><operator>*</operator><name>PrevPtr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>prevbytepos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Checks whether the current buffer page and backup page stored in the
 * WAL record are consistent or not. Before comparing the two pages, a
 * masking can be applied to the pages to ignore certain areas like hint bits,
 * unused space between pd_lower and pd_upper among other things. This
 * function should be called once WAL replay has been completed for a
 * given record.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkXLogConsistency</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RmgrId</name></type>		<name>rmid</name> <init>= <expr><call><name>XLogRecGetRmid</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForkNumber</name></type>	<name>forknum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>block_id</name></decl>;</decl_stmt>

	<comment type="block">/* Records with no backup blocks have no need for consistency checks. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecHasAnyBlockRefs</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>XLR_CHECK_CONSISTENCY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>block_id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>block_id</name> <operator>&lt;=</operator> <name><name>record</name><operator>-&gt;</operator><name>max_block_id</name></name></expr>;</condition> <incr><expr><name>block_id</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>buf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>block_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>forknum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * WAL record doesn't contain a block reference with the given id.
			 * Do nothing.
			 */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>XLogRecHasBlockImage</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>block_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>XLogRecBlockImageApply</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>block_id</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * WAL record has already applied the page, so bypass the
			 * consistency check as that would result in comparing the full
			 * page stored in the record with itself.
			 */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Read the contents from the current buffer and store it in a
		 * temporary page.
		 */</comment>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>XLogReadBufferExtended</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>,
									 <argument><expr><name>RBM_NORMAL_NO_LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Take a copy of the local page where WAL has been applied to have a
		 * comparison base before masking it...
		 */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>replay_image_masked</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* No need for this page anymore now that a copy is in. */</comment>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the block LSN is already ahead of this WAL record, we can't
		 * expect contents to match.  This can happen if recovery is
		 * restarted.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PageGetLSN</name><argument_list>(<argument><expr><name>replay_image_masked</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Read the contents from the backup copy, stored in WAL record and
		 * store it in a temporary page. There is no need to allocate a new
		 * page here, a local buffer is fine to hold its contents and a mask
		 * can be directly applied on it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RestoreBlockImage</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>block_id</name></expr></argument>, <argument><expr><name>master_image_masked</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to restore block image"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If masking function is defined, mask both the master and replay
		 * images
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>RmgrTable</name><index>[<expr><name>rmid</name></expr>]</index></name><operator>.</operator><name>rm_mask</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>RmgrTable</name><index>[<expr><name>rmid</name></expr>]</index></name><operator>.</operator><call><name>rm_mask</name><argument_list>(<argument><expr><name>replay_image_masked</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>RmgrTable</name><index>[<expr><name>rmid</name></expr>]</index></name><operator>.</operator><call><name>rm_mask</name><argument_list>(<argument><expr><name>master_image_masked</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Time to compare the master and replay images. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>replay_image_masked</name></expr></argument>, <argument><expr><name>master_image_masked</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				 <argument><expr><literal type="string">"inconsistent page found, rel %u/%u/%u, forknum %u, blkno %u"</literal></expr></argument>,
				 <argument><expr><name><name>rnode</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>.</operator><name>relNode</name></name></expr></argument>,
				 <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine of XLogInsertRecord.  Copies a WAL record to an already-reserved
 * area in the WAL.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CopyXLogRecordToWAL</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>write_len</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isLogSwitch</name></decl></parameter>, <parameter><decl><type><name>XLogRecData</name> <modifier>*</modifier></type><name>rdata</name></decl></parameter>,
					<parameter><decl><type><name>XLogRecPtr</name></type> <name>StartPos</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>EndPos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>currpos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>freespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>written</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>CurrPos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogPageHeader</name></type> <name>pagehdr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get a pointer to the right place in the right WAL buffer to start
	 * inserting to.
	 */</comment>
	<expr_stmt><expr><name>CurrPos</name> <operator>=</operator> <name>StartPos</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>currpos</name> <operator>=</operator> <call><name>GetXLogBuffer</name><argument_list>(<argument><expr><name>CurrPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>freespace</name> <operator>=</operator> <call><name>INSERT_FREESPACE</name><argument_list>(<argument><expr><name>CurrPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * there should be enough space for at least the first field (xl_tot_len)
	 * on this page.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>freespace</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy record data */</comment>
	<expr_stmt><expr><name>written</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>rdata</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rdata_data</name> <init>= <expr><name><name>rdata</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>rdata_len</name> <init>= <expr><name><name>rdata</name><operator>-&gt;</operator><name>len</name></name></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><name>rdata_len</name> <operator>&gt;</operator> <name>freespace</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Write what fits on this page, and continue on the next page.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CurrPos</name> <operator>%</operator> <name>XLOG_BLCKSZ</name> <operator>&gt;=</operator> <name>SizeOfXLogShortPHD</name> <operator>||</operator> <name>freespace</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>currpos</name></expr></argument>, <argument><expr><name>rdata_data</name></expr></argument>, <argument><expr><name>freespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rdata_data</name> <operator>+=</operator> <name>freespace</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>rdata_len</name> <operator>-=</operator> <name>freespace</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>written</name> <operator>+=</operator> <name>freespace</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>CurrPos</name> <operator>+=</operator> <name>freespace</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Get pointer to beginning of next page, and set the xlp_rem_len
			 * in the page header. Set XLP_FIRST_IS_CONTRECORD.
			 *
			 * It's safe to set the contrecord flag and xlp_rem_len without a
			 * lock on the page. All the other flags were already set when the
			 * page was initialized, in AdvanceXLInsertBuffer, and we're the
			 * only backend that needs to set the contrecord flag.
			 */</comment>
			<expr_stmt><expr><name>currpos</name> <operator>=</operator> <call><name>GetXLogBuffer</name><argument_list>(<argument><expr><name>CurrPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pagehdr</name> <operator>=</operator> <operator>(</operator><name>XLogPageHeader</name><operator>)</operator> <name>currpos</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pagehdr</name><operator>-&gt;</operator><name>xlp_rem_len</name></name> <operator>=</operator> <name>write_len</name> <operator>-</operator> <name>written</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pagehdr</name><operator>-&gt;</operator><name>xlp_info</name></name> <operator>|=</operator> <name>XLP_FIRST_IS_CONTRECORD</name></expr>;</expr_stmt>

			<comment type="block">/* skip over the page header */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>XLogSegmentOffset</name><argument_list>(<argument><expr><name>CurrPos</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>CurrPos</name> <operator>+=</operator> <name>SizeOfXLogLongPHD</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>currpos</name> <operator>+=</operator> <name>SizeOfXLogLongPHD</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>CurrPos</name> <operator>+=</operator> <name>SizeOfXLogShortPHD</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>currpos</name> <operator>+=</operator> <name>SizeOfXLogShortPHD</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><name>freespace</name> <operator>=</operator> <call><name>INSERT_FREESPACE</name><argument_list>(<argument><expr><name>CurrPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CurrPos</name> <operator>%</operator> <name>XLOG_BLCKSZ</name> <operator>&gt;=</operator> <name>SizeOfXLogShortPHD</name> <operator>||</operator> <name>rdata_len</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>currpos</name></expr></argument>, <argument><expr><name>rdata_data</name></expr></argument>, <argument><expr><name>rdata_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>currpos</name> <operator>+=</operator> <name>rdata_len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>CurrPos</name> <operator>+=</operator> <name>rdata_len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>freespace</name> <operator>-=</operator> <name>rdata_len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>written</name> <operator>+=</operator> <name>rdata_len</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>rdata</name> <operator>=</operator> <name><name>rdata</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>written</name> <operator>==</operator> <name>write_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this was an xlog-switch, it's not enough to write the switch record,
	 * we also have to consume all the remaining space in the WAL segment.  We
	 * have already reserved that space, but we need to actually fill it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isLogSwitch</name> <operator>&amp;&amp;</operator> <call><name>XLogSegmentOffset</name><argument_list>(<argument><expr><name>CurrPos</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* An xlog-switch record doesn't contain any data besides the header */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>write_len</name> <operator>==</operator> <name>SizeOfXLogRecord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Assert that we did reserve the right amount of space */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>XLogSegmentOffset</name><argument_list>(<argument><expr><name>EndPos</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Use up all the remaining space on the current page */</comment>
		<expr_stmt><expr><name>CurrPos</name> <operator>+=</operator> <name>freespace</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Cause all remaining pages in the segment to be flushed, leaving the
		 * XLog position where it should be, at the start of the next segment.
		 * We do this one page at a time, to make sure we don't deadlock
		 * against ourselves if wal_buffers &lt; wal_segment_size.
		 */</comment>
		<while>while <condition>(<expr><name>CurrPos</name> <operator>&lt;</operator> <name>EndPos</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The minimal action to flush the page would be to call
			 * WALInsertLockUpdateInsertingAt(CurrPos) followed by
			 * AdvanceXLInsertBuffer(...).  The page would be left initialized
			 * mostly to zeros, except for the page header (always the short
			 * variant, as this is never a segment's first page).
			 *
			 * The large vistas of zeros are good for compressibility, but the
			 * headers interrupting them every XLOG_BLCKSZ (with values that
			 * differ from page to page) are not.  The effect varies with
			 * compression tool, but bzip2 for instance compresses about an
			 * order of magnitude worse if those headers are left in place.
			 *
			 * Rather than complicating AdvanceXLInsertBuffer itself (which is
			 * called in heavily-loaded circumstances as well as this lightly-
			 * loaded one) with variant behavior, we just use GetXLogBuffer
			 * (which itself calls the two methods we need) to get the pointer
			 * and zero most of the page.  Then we just zero the page header.
			 */</comment>
			<expr_stmt><expr><name>currpos</name> <operator>=</operator> <call><name>GetXLogBuffer</name><argument_list>(<argument><expr><name>CurrPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>currpos</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SizeOfXLogShortPHD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>CurrPos</name> <operator>+=</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Align the end position, so that the next record starts aligned */</comment>
		<expr_stmt><expr><name>CurrPos</name> <operator>=</operator> <call><name>MAXALIGN64</name><argument_list>(<argument><expr><name>CurrPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>CurrPos</name> <operator>!=</operator> <name>EndPos</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"space reserved for WAL record does not match what was written"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Acquire a WAL insertion lock, for inserting to WAL.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WALInsertLockAcquire</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>immed</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * It doesn't matter which of the WAL insertion locks we acquire, so try
	 * the one we used last time.  If the system isn't particularly busy, it's
	 * a good bet that it's still available, and it's good to have some
	 * affinity to a particular lock so that you don't unnecessarily bounce
	 * cache lines between processes when there's no contention.
	 *
	 * If this is the first time through in this backend, pick a lock
	 * (semi-)randomly.  This allows the locks to be used evenly if you have a
	 * lot of very short connections.
	 */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>lockToTry</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>lockToTry</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>lockToTry</name> <operator>=</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>pgprocno</name></name> <operator>%</operator> <name>NUM_XLOGINSERT_LOCKS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>MyLockNo</name> <operator>=</operator> <name>lockToTry</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * The insertingAt value is initially set to 0, as we don't know our
	 * insert location yet.
	 */</comment>
	<expr_stmt><expr><name>immed</name> <operator>=</operator> <call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>WALInsertLocks</name><index>[<expr><name>MyLockNo</name></expr>]</index></name><operator>.</operator><name><name>l</name><operator>.</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>immed</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we couldn't get the lock immediately, try another lock next
		 * time.  On a system with more insertion locks than concurrent
		 * inserters, this causes all the inserters to eventually migrate to a
		 * lock that no-one else is using.  On a system with more inserters
		 * than locks, it still helps to distribute the inserters evenly
		 * across the locks.
		 */</comment>
		<expr_stmt><expr><name>lockToTry</name> <operator>=</operator> <operator>(</operator><name>lockToTry</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>NUM_XLOGINSERT_LOCKS</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Acquire all WAL insertion locks, to prevent other backends from inserting
 * to WAL.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WALInsertLockAcquireExclusive</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * When holding all the locks, all but the last lock's insertingAt
	 * indicator is set to 0xFFFFFFFFFFFFFFFF, which is higher than any real
	 * XLogRecPtr value, to make sure that no-one blocks waiting on those.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_XLOGINSERT_LOCKS</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>WALInsertLocks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>l</name><operator>.</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockUpdateVar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>WALInsertLocks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>l</name><operator>.</operator><name>lock</name></name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name><name>WALInsertLocks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>l</name><operator>.</operator><name>insertingAt</name></name></expr></argument>,
						<argument><expr><name>PG_UINT64_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Variable value reset to 0 at release */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>WALInsertLocks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>l</name><operator>.</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>holdingAllLocks</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Release our insertion lock (or locks, if we're holding them all).
 *
 * NB: Reset all variables to 0, so they cause LWLockWaitForVar to block the
 * next time the lock is acquired.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WALInsertLockRelease</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>holdingAllLocks</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_XLOGINSERT_LOCKS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LWLockReleaseClearVar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>WALInsertLocks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>l</name><operator>.</operator><name>lock</name></name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name><name>WALInsertLocks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>l</name><operator>.</operator><name>insertingAt</name></name></expr></argument>,
								  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

		<expr_stmt><expr><name>holdingAllLocks</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockReleaseClearVar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>WALInsertLocks</name><index>[<expr><name>MyLockNo</name></expr>]</index></name><operator>.</operator><name><name>l</name><operator>.</operator><name>lock</name></name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name><name>WALInsertLocks</name><index>[<expr><name>MyLockNo</name></expr>]</index></name><operator>.</operator><name><name>l</name><operator>.</operator><name>insertingAt</name></name></expr></argument>,
							  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Update our insertingAt value, to let others know that we've finished
 * inserting up to that point.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WALInsertLockUpdateInsertingAt</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>insertingAt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>holdingAllLocks</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We use the last lock to mark our actual position, see comments in
		 * WALInsertLockAcquireExclusive.
		 */</comment>
		<expr_stmt><expr><call><name>LWLockUpdateVar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>WALInsertLocks</name><index>[<expr><name>NUM_XLOGINSERT_LOCKS</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>l</name><operator>.</operator><name>lock</name></name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name><name>WALInsertLocks</name><index>[<expr><name>NUM_XLOGINSERT_LOCKS</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>l</name><operator>.</operator><name>insertingAt</name></name></expr></argument>,
						<argument><expr><name>insertingAt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockUpdateVar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>WALInsertLocks</name><index>[<expr><name>MyLockNo</name></expr>]</index></name><operator>.</operator><name><name>l</name><operator>.</operator><name>lock</name></name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name><name>WALInsertLocks</name><index>[<expr><name>MyLockNo</name></expr>]</index></name><operator>.</operator><name><name>l</name><operator>.</operator><name>insertingAt</name></name></expr></argument>,
						<argument><expr><name>insertingAt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Wait for any WAL insertions &lt; upto to finish.
 *
 * Returns the location of the oldest insertion that is still in-progress.
 * Any WAL prior to that point has been fully copied into WAL buffers, and
 * can be flushed out to disk. Because this waits for any insertions older
 * than 'upto' to finish, the return value is always &gt;= 'upto'.
 *
 * Note: When you are about to write out WAL, you must call this function
 * *before* acquiring WALWriteLock, to avoid deadlocks. This function might
 * need to wait for an insertion to finish (or at least advance to next
 * uninitialized page), and the inserter might need to evict an old WAL buffer
 * to make room for a new one, which in turn requires WALWriteLock.
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRecPtr</name></type>
<name>WaitXLogInsertionsToFinish</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>upto</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>bytepos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>reservedUpto</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>finishedUpto</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogCtlInsert</name> <modifier>*</modifier></type><name>Insert</name> <init>= <expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>MyProc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"cannot wait without a PGPROC structure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Read the current insert position */</comment>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>Insert</name><operator>-&gt;</operator><name>insertpos_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bytepos</name> <operator>=</operator> <name><name>Insert</name><operator>-&gt;</operator><name>CurrBytePos</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>Insert</name><operator>-&gt;</operator><name>insertpos_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>reservedUpto</name> <operator>=</operator> <call><name>XLogBytePosToEndRecPtr</name><argument_list>(<argument><expr><name>bytepos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * No-one should request to flush a piece of WAL that hasn't even been
	 * reserved yet. However, it can happen if there is a block with a bogus
	 * LSN on disk, for example. XLogFlush checks for that situation and
	 * complains, but only after the flush. Here we just assume that to mean
	 * that all WAL that has been reserved needs to be finished. In this
	 * corner-case, the return value can be smaller than 'upto' argument.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>upto</name> <operator>&gt;</operator> <name>reservedUpto</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"request to flush past end of generated WAL; request %X/%X, currpos %X/%X"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>upto</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>upto</name></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>reservedUpto</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>reservedUpto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>upto</name> <operator>=</operator> <name>reservedUpto</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Loop through all the locks, sleeping on any in-progress insert older
	 * than 'upto'.
	 *
	 * finishedUpto is our return value, indicating the point upto which all
	 * the WAL insertions have been finished. Initialize it to the head of
	 * reserved WAL, and as we iterate through the insertion locks, back it
	 * out for any insertion that's still in progress.
	 */</comment>
	<expr_stmt><expr><name>finishedUpto</name> <operator>=</operator> <name>reservedUpto</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_XLOGINSERT_LOCKS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>insertingat</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

		<do>do
		<block>{<block_content>
			<comment type="block">/*
			 * See if this insertion is in progress. LWLockWait will wait for
			 * the lock to be released, or for the 'value' to be set by a
			 * LWLockUpdateVar call.  When a lock is initially acquired, its
			 * value is 0 (InvalidXLogRecPtr), which means that we don't know
			 * where it's inserting yet.  We will have to wait for it.  If
			 * it's a small insertion, the record will most likely fit on the
			 * same page and the inserter will release the lock without ever
			 * calling LWLockUpdateVar.  But if it has to sleep, it will
			 * advertise the insertion point with LWLockUpdateVar before
			 * sleeping.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>LWLockWaitForVar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>WALInsertLocks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>l</name><operator>.</operator><name>lock</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>WALInsertLocks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>l</name><operator>.</operator><name>insertingAt</name></name></expr></argument>,
								 <argument><expr><name>insertingat</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>insertingat</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* the lock was free, so no insertion in progress */</comment>
				<expr_stmt><expr><name>insertingat</name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * This insertion is still in progress. Have to wait, unless the
			 * inserter has proceeded past 'upto'.
			 */</comment>
		</block_content>}</block> while <condition>(<expr><name>insertingat</name> <operator>&lt;</operator> <name>upto</name></expr>)</condition>;</do>

		<if_stmt><if>if <condition>(<expr><name>insertingat</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name> <operator>&amp;&amp;</operator> <name>insertingat</name> <operator>&lt;</operator> <name>finishedUpto</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>finishedUpto</name> <operator>=</operator> <name>insertingat</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>finishedUpto</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get a pointer to the right location in the WAL buffer containing the
 * given XLogRecPtr.
 *
 * If the page is not initialized yet, it is initialized. That might require
 * evicting an old dirty buffer from the buffer cache, which means I/O.
 *
 * The caller must ensure that the page containing the requested location
 * isn't evicted yet, and won't be evicted. The way to ensure that is to
 * hold onto a WAL insertion lock with the insertingAt position set to
 * something &lt;= ptr. GetXLogBuffer() will update insertingAt if it needs
 * to evict an old page from the buffer. (This means that once you call
 * GetXLogBuffer() with a given 'ptr', you must not access anything before
 * that point anymore, and must not call GetXLogBuffer() with an older 'ptr'
 * later, because older buffers might be recycled already)
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetXLogBuffer</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>idx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>endptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>uint64</name></type> <name>cachedPage</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>cachedPos</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>expectedEndPtr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Fast path for the common case that we need to access again the same
	 * page as last time.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>/</operator> <name>XLOG_BLCKSZ</name> <operator>==</operator> <name>cachedPage</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>XLogPageHeader</name><operator>)</operator> <name>cachedPos</name><operator>)</operator><operator>-&gt;</operator><name>xlp_magic</name> <operator>==</operator> <name>XLOG_PAGE_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>XLogPageHeader</name><operator>)</operator> <name>cachedPos</name><operator>)</operator><operator>-&gt;</operator><name>xlp_pageaddr</name> <operator>==</operator> <name>ptr</name> <operator>-</operator> <operator>(</operator><name>ptr</name> <operator>%</operator> <name>XLOG_BLCKSZ</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>cachedPos</name> <operator>+</operator> <name>ptr</name> <operator>%</operator> <name>XLOG_BLCKSZ</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The XLog buffer cache is organized so that a page is always loaded to a
	 * particular buffer.  That way we can easily calculate the buffer a given
	 * page must be loaded into, from the XLogRecPtr alone.
	 */</comment>
	<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>XLogRecPtrToBufIdx</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * See what page is loaded in the buffer at the moment. It could be the
	 * page we're looking for, or something older. It can't be anything newer
	 * - that would imply the page we're looking for has already been written
	 * out to disk and evicted, and the caller is responsible for making sure
	 * that doesn't happen.
	 *
	 * However, we don't hold a lock while we read the value. If someone has
	 * just initialized the page, it's possible that we get a "torn read" of
	 * the XLogRecPtr if 64-bit fetches are not atomic on this platform. In
	 * that case we will see a bogus value. That's ok, we'll grab the mapping
	 * lock (in AdvanceXLInsertBuffer) and retry if we see anything else than
	 * the page we're looking for. But it means that when we do this unlocked
	 * read, we might see a value that appears to be ahead of the page we're
	 * looking for. Don't PANIC on that, until we've verified the value while
	 * holding the lock.
	 */</comment>
	<expr_stmt><expr><name>expectedEndPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>expectedEndPtr</name> <operator>+=</operator> <name>XLOG_BLCKSZ</name> <operator>-</operator> <name>ptr</name> <operator>%</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>endptr</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>xlblocks</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>expectedEndPtr</name> <operator>!=</operator> <name>endptr</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>initializedUpto</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Before calling AdvanceXLInsertBuffer(), which can block, let others
		 * know how far we're finished with inserting the record.
		 *
		 * NB: If 'ptr' points to just after the page header, advertise a
		 * position at the beginning of the page rather than 'ptr' itself. If
		 * there are no other insertions running, someone might try to flush
		 * up to our advertised location. If we advertised a position after
		 * the page header, someone might try to flush the page header, even
		 * though page might actually not be initialized yet. As the first
		 * inserter on the page, we are effectively responsible for making
		 * sure that it's initialized, before we let insertingAt to move past
		 * the page header.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>%</operator> <name>XLOG_BLCKSZ</name> <operator>==</operator> <name>SizeOfXLogShortPHD</name> <operator>&amp;&amp;</operator>
			<call><name>XLogSegmentOffset</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>XLOG_BLCKSZ</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>initializedUpto</name> <operator>=</operator> <name>ptr</name> <operator>-</operator> <name>SizeOfXLogShortPHD</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>ptr</name> <operator>%</operator> <name>XLOG_BLCKSZ</name> <operator>==</operator> <name>SizeOfXLogLongPHD</name> <operator>&amp;&amp;</operator>
				 <call><name>XLogSegmentOffset</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>XLOG_BLCKSZ</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>initializedUpto</name> <operator>=</operator> <name>ptr</name> <operator>-</operator> <name>SizeOfXLogLongPHD</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>initializedUpto</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>WALInsertLockUpdateInsertingAt</name><argument_list>(<argument><expr><name>initializedUpto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>AdvanceXLInsertBuffer</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>endptr</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>xlblocks</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>expectedEndPtr</name> <operator>!=</operator> <name>endptr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"could not find WAL buffer for %X/%X"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>ptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Make sure the initialization of the page is visible to us, and
		 * won't arrive later to overwrite the WAL data we write on the page.
		 */</comment>
		<expr_stmt><expr><call><name>pg_memory_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Found the buffer holding this page. Return a pointer to the right
	 * offset within the page.
	 */</comment>
	<expr_stmt><expr><name>cachedPage</name> <operator>=</operator> <name>ptr</name> <operator>/</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cachedPos</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>pages</name></name> <operator>+</operator> <name>idx</name> <operator>*</operator> <operator>(</operator><name>Size</name><operator>)</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>XLogPageHeader</name><operator>)</operator> <name>cachedPos</name><operator>)</operator><operator>-&gt;</operator><name>xlp_magic</name> <operator>==</operator> <name>XLOG_PAGE_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>XLogPageHeader</name><operator>)</operator> <name>cachedPos</name><operator>)</operator><operator>-&gt;</operator><name>xlp_pageaddr</name> <operator>==</operator> <name>ptr</name> <operator>-</operator> <operator>(</operator><name>ptr</name> <operator>%</operator> <name>XLOG_BLCKSZ</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>cachedPos</name> <operator>+</operator> <name>ptr</name> <operator>%</operator> <name>XLOG_BLCKSZ</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Converts a "usable byte position" to XLogRecPtr. A usable byte position
 * is the position starting from the beginning of WAL, excluding all WAL
 * page headers.
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRecPtr</name></type>
<name>XLogBytePosToRecPtr</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>bytepos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>fullsegs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>fullpages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>bytesleft</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>seg_offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>fullsegs</name> <operator>=</operator> <name>bytepos</name> <operator>/</operator> <name>UsableBytesInSegment</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>bytesleft</name> <operator>=</operator> <name>bytepos</name> <operator>%</operator> <name>UsableBytesInSegment</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>bytesleft</name> <operator>&lt;</operator> <name>XLOG_BLCKSZ</name> <operator>-</operator> <name>SizeOfXLogLongPHD</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* fits on first page of segment */</comment>
		<expr_stmt><expr><name>seg_offset</name> <operator>=</operator> <name>bytesleft</name> <operator>+</operator> <name>SizeOfXLogLongPHD</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* account for the first page on segment with long header */</comment>
		<expr_stmt><expr><name>seg_offset</name> <operator>=</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bytesleft</name> <operator>-=</operator> <name>XLOG_BLCKSZ</name> <operator>-</operator> <name>SizeOfXLogLongPHD</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>fullpages</name> <operator>=</operator> <name>bytesleft</name> <operator>/</operator> <name>UsableBytesInPage</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bytesleft</name> <operator>=</operator> <name>bytesleft</name> <operator>%</operator> <name>UsableBytesInPage</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>seg_offset</name> <operator>+=</operator> <name>fullpages</name> <operator>*</operator> <name>XLOG_BLCKSZ</name> <operator>+</operator> <name>bytesleft</name> <operator>+</operator> <name>SizeOfXLogShortPHD</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>XLogSegNoOffsetToRecPtr</name><argument_list>(<argument><expr><name>fullsegs</name></expr></argument>, <argument><expr><name>seg_offset</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Like XLogBytePosToRecPtr, but if the position is at a page boundary,
 * returns a pointer to the beginning of the page (ie. before page header),
 * not to where the first xlog record on that page would go to. This is used
 * when converting a pointer to the end of a record.
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRecPtr</name></type>
<name>XLogBytePosToEndRecPtr</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>bytepos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>fullsegs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>fullpages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>bytesleft</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>seg_offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>fullsegs</name> <operator>=</operator> <name>bytepos</name> <operator>/</operator> <name>UsableBytesInSegment</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>bytesleft</name> <operator>=</operator> <name>bytepos</name> <operator>%</operator> <name>UsableBytesInSegment</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>bytesleft</name> <operator>&lt;</operator> <name>XLOG_BLCKSZ</name> <operator>-</operator> <name>SizeOfXLogLongPHD</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* fits on first page of segment */</comment>
		<if_stmt><if>if <condition>(<expr><name>bytesleft</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>seg_offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>seg_offset</name> <operator>=</operator> <name>bytesleft</name> <operator>+</operator> <name>SizeOfXLogLongPHD</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* account for the first page on segment with long header */</comment>
		<expr_stmt><expr><name>seg_offset</name> <operator>=</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bytesleft</name> <operator>-=</operator> <name>XLOG_BLCKSZ</name> <operator>-</operator> <name>SizeOfXLogLongPHD</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>fullpages</name> <operator>=</operator> <name>bytesleft</name> <operator>/</operator> <name>UsableBytesInPage</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bytesleft</name> <operator>=</operator> <name>bytesleft</name> <operator>%</operator> <name>UsableBytesInPage</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>bytesleft</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>seg_offset</name> <operator>+=</operator> <name>fullpages</name> <operator>*</operator> <name>XLOG_BLCKSZ</name> <operator>+</operator> <name>bytesleft</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>seg_offset</name> <operator>+=</operator> <name>fullpages</name> <operator>*</operator> <name>XLOG_BLCKSZ</name> <operator>+</operator> <name>bytesleft</name> <operator>+</operator> <name>SizeOfXLogShortPHD</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>XLogSegNoOffsetToRecPtr</name><argument_list>(<argument><expr><name>fullsegs</name></expr></argument>, <argument><expr><name>seg_offset</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert an XLogRecPtr to a "usable byte position".
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>XLogRecPtrToBytePos</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>fullsegs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>fullpages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>fullsegs</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fullpages</name> <operator>=</operator> <operator>(</operator><call><name>XLogSegmentOffset</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>/</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>offset</name> <operator>=</operator> <name>ptr</name> <operator>%</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fullpages</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>fullsegs</name> <operator>*</operator> <name>UsableBytesInSegment</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offset</name> <operator>&gt;=</operator> <name>SizeOfXLogLongPHD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>+=</operator> <name>offset</name> <operator>-</operator> <name>SizeOfXLogLongPHD</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>fullsegs</name> <operator>*</operator> <name>UsableBytesInSegment</name> <operator>+</operator>
			<operator>(</operator><name>XLOG_BLCKSZ</name> <operator>-</operator> <name>SizeOfXLogLongPHD</name><operator>)</operator> <operator>+</operator> <comment type="block">/* account for first page */</comment>
			<operator>(</operator><name>fullpages</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>UsableBytesInPage</name></expr>;</expr_stmt>	<comment type="block">/* full pages */</comment>
		<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offset</name> <operator>&gt;=</operator> <name>SizeOfXLogShortPHD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>+=</operator> <name>offset</name> <operator>-</operator> <name>SizeOfXLogShortPHD</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize XLOG buffers, writing out old buffers if they still contain
 * unwritten data, upto the page containing 'upto'. Or if 'opportunistic' is
 * true, initialize as many pages as we can without having to write out
 * unwritten data. Any new pages are initialized to zeros, with pages headers
 * initialized properly.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AdvanceXLInsertBuffer</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>upto</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>opportunistic</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogCtlInsert</name> <modifier>*</modifier></type><name>Insert</name> <init>= <expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nextidx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>OldPageRqstPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogwrtRqst</name></type> <name>WriteRqst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>NewPageEndPtr</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>NewPageBeginPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogPageHeader</name></type> <name>NewPage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>npages</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>WALBufMappingLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now that we have the lock, check if someone initialized the page
	 * already.
	 */</comment>
	<while>while <condition>(<expr><name>upto</name> <operator>&gt;=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>InitializedUpTo</name></name> <operator>||</operator> <name>opportunistic</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>nextidx</name> <operator>=</operator> <call><name>XLogRecPtrToBufIdx</name><argument_list>(<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>InitializedUpTo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Get ending-offset of the buffer page we need to replace (this may
		 * be zero if the buffer hasn't been used yet).  Fall through if it's
		 * already written out.
		 */</comment>
		<expr_stmt><expr><name>OldPageRqstPtr</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>xlblocks</name><index>[<expr><name>nextidx</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>LogwrtResult</name><operator>.</operator><name>Write</name></name> <operator>&lt;</operator> <name>OldPageRqstPtr</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Nope, got work to do. If we just want to pre-initialize as much
			 * as we can without flushing, give up now.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>opportunistic</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<comment type="block">/* Before waiting, get info_lck and update LogwrtResult */</comment>
			<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtRqst</name><operator>.</operator><name>Write</name></name> <operator>&lt;</operator> <name>OldPageRqstPtr</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtRqst</name><operator>.</operator><name>Write</name></name> <operator>=</operator> <name>OldPageRqstPtr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>LogwrtResult</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtResult</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Now that we have an up-to-date LogwrtResult value, see if we
			 * still need to write it or if someone else already did.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>LogwrtResult</name><operator>.</operator><name>Write</name></name> <operator>&lt;</operator> <name>OldPageRqstPtr</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Must acquire write lock. Release WALBufMappingLock first,
				 * to make sure that all insertions that we need to wait for
				 * can finish (up to this same position). Otherwise we risk
				 * deadlock.
				 */</comment>
				<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>WALBufMappingLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>WaitXLogInsertionsToFinish</name><argument_list>(<argument><expr><name>OldPageRqstPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>WALWriteLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>LogwrtResult</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtResult</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>LogwrtResult</name><operator>.</operator><name>Write</name></name> <operator>&gt;=</operator> <name>OldPageRqstPtr</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* OK, someone wrote it already */</comment>
					<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>WALWriteLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Have to write it ourselves */</comment>
					<expr_stmt><expr><call><name>TRACE_POSTGRESQL_WAL_BUFFER_WRITE_DIRTY_START</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>WriteRqst</name><operator>.</operator><name>Write</name></name> <operator>=</operator> <name>OldPageRqstPtr</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>WriteRqst</name><operator>.</operator><name>Flush</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>XLogWrite</name><argument_list>(<argument><expr><name>WriteRqst</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>WALWriteLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>TRACE_POSTGRESQL_WAL_BUFFER_WRITE_DIRTY_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<comment type="block">/* Re-acquire WALBufMappingLock and retry */</comment>
				<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>WALBufMappingLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Now the next buffer slot is free and we can set it up to be the
		 * next output page.
		 */</comment>
		<expr_stmt><expr><name>NewPageBeginPtr</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>InitializedUpTo</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>NewPageEndPtr</name> <operator>=</operator> <name>NewPageBeginPtr</name> <operator>+</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>XLogRecPtrToBufIdx</name><argument_list>(<argument><expr><name>NewPageBeginPtr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>nextidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>NewPage</name> <operator>=</operator> <operator>(</operator><name>XLogPageHeader</name><operator>)</operator> <operator>(</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>pages</name></name> <operator>+</operator> <name>nextidx</name> <operator>*</operator> <operator>(</operator><name>Size</name><operator>)</operator> <name>XLOG_BLCKSZ</name><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Be sure to re-zero the buffer so that bytes beyond what we've
		 * written will look like zeroes and not valid XLOG records...
		 */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>NewPage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>XLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Fill the new page's header
		 */</comment>
		<expr_stmt><expr><name><name>NewPage</name><operator>-&gt;</operator><name>xlp_magic</name></name> <operator>=</operator> <name>XLOG_PAGE_MAGIC</name></expr>;</expr_stmt>

		<comment type="block">/* NewPage-&gt;xlp_info = 0; */</comment>	<comment type="block">/* done by memset */</comment>
		<expr_stmt><expr><name><name>NewPage</name><operator>-&gt;</operator><name>xlp_tli</name></name> <operator>=</operator> <name>ThisTimeLineID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>NewPage</name><operator>-&gt;</operator><name>xlp_pageaddr</name></name> <operator>=</operator> <name>NewPageBeginPtr</name></expr>;</expr_stmt>

		<comment type="block">/* NewPage-&gt;xlp_rem_len = 0; */</comment>	<comment type="block">/* done by memset */</comment>

		<comment type="block">/*
		 * If online backup is not in progress, mark the header to indicate
		 * that WAL records beginning in this page have removable backup
		 * blocks.  This allows the WAL archiver to know whether it is safe to
		 * compress archived WAL data by transforming full-block records into
		 * the non-full-block format.  It is sufficient to record this at the
		 * page level because we force a page switch (in fact a segment
		 * switch) when starting a backup, so the flag will be off before any
		 * records can be written during the backup.  At the end of a backup,
		 * the last page will be marked as all unsafe when perhaps only part
		 * is unsafe, but at worst the archiver would miss the opportunity to
		 * compress a few records.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>Insert</name><operator>-&gt;</operator><name>forcePageWrites</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>NewPage</name><operator>-&gt;</operator><name>xlp_info</name></name> <operator>|=</operator> <name>XLP_BKP_REMOVABLE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If first page of an XLOG segment file, make it a long header.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>XLogSegmentOffset</name><argument_list>(<argument><expr><name><name>NewPage</name><operator>-&gt;</operator><name>xlp_pageaddr</name></name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>XLogLongPageHeader</name></type> <name>NewLongPage</name> <init>= <expr><operator>(</operator><name>XLogLongPageHeader</name><operator>)</operator> <name>NewPage</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>NewLongPage</name><operator>-&gt;</operator><name>xlp_sysid</name></name> <operator>=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>system_identifier</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>NewLongPage</name><operator>-&gt;</operator><name>xlp_seg_size</name></name> <operator>=</operator> <name>wal_segment_size</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>NewLongPage</name><operator>-&gt;</operator><name>xlp_xlog_blcksz</name></name> <operator>=</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>NewPage</name><operator>-&gt;</operator><name>xlp_info</name></name> <operator>|=</operator> <name>XLP_LONG_HEADER</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Make sure the initialization of the page becomes visible to others
		 * before the xlblocks update. GetXLogBuffer() reads xlblocks without
		 * holding a lock.
		 */</comment>
		<expr_stmt><expr><call><name>pg_write_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>volatile</specifier> <name>XLogRecPtr</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>xlblocks</name><index>[<expr><name>nextidx</name></expr>]</index></name><operator>)</operator> <operator>=</operator> <name>NewPageEndPtr</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>InitializedUpTo</name></name> <operator>=</operator> <name>NewPageEndPtr</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>npages</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>WALBufMappingLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WAL_DEBUG</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>XLOG_DEBUG</name> <operator>&amp;&amp;</operator> <name>npages</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"initialized %d pages, up to %X/%X"</literal></expr></argument>,
			 <argument><expr><name>npages</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>NewPageEndPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>NewPageEndPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Calculate CheckPointSegments based on max_wal_size_mb and
 * checkpoint_completion_target.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CalculateCheckpointSegments</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>target</name></decl>;</decl_stmt>

	<comment type="block">/*-------
	 * Calculate the distance at which to trigger a checkpoint, to avoid
	 * exceeding max_wal_size_mb. This is based on two assumptions:
	 *
	 * a) we keep WAL for only one checkpoint cycle (prior to PG11 we kept
	 *    WAL for two checkpoint cycles to allow us to recover from the
	 *    secondary checkpoint if the first checkpoint failed, though we
	 *    only did this on the master anyway, not on standby. Keeping just
	 *    one checkpoint simplifies processing and reduces disk space in
	 *    many smaller databases.)
	 * b) during checkpoint, we consume checkpoint_completion_target *
	 *	  number of segments consumed between checkpoints.
	 *-------
	 */</comment>
	<expr_stmt><expr><name>target</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <call><name>ConvertToXSegs</name><argument_list>(<argument><expr><name>max_wal_size_mb</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call> <operator>/</operator>
		<operator>(</operator><literal type="number">1.0</literal> <operator>+</operator> <name>CheckPointCompletionTarget</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* round down */</comment>
	<expr_stmt><expr><name>CheckPointSegments</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>target</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>CheckPointSegments</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>CheckPointSegments</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>assign_max_wal_size</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>max_wal_size_mb</name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CalculateCheckpointSegments</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>assign_checkpoint_completion_target</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>CheckPointCompletionTarget</name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CalculateCheckpointSegments</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * At a checkpoint, how many WAL segments to recycle as preallocated future
 * XLOG segments? Returns the highest segment that should be preallocated.
 */</comment>
<function><type><specifier>static</specifier> <name>XLogSegNo</name></type>
<name>XLOGfileslop</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>RedoRecPtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>minSegNo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>maxSegNo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>distance</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>recycleSegNo</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Calculate the segment numbers that min_wal_size_mb and max_wal_size_mb
	 * correspond to. Always recycle enough segments to meet the minimum, and
	 * remove enough segments to stay below the maximum.
	 */</comment>
	<expr_stmt><expr><name>minSegNo</name> <operator>=</operator> <name>RedoRecPtr</name> <operator>/</operator> <name>wal_segment_size</name> <operator>+</operator>
		<call><name>ConvertToXSegs</name><argument_list>(<argument><expr><name>min_wal_size_mb</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxSegNo</name> <operator>=</operator> <name>RedoRecPtr</name> <operator>/</operator> <name>wal_segment_size</name> <operator>+</operator>
		<call><name>ConvertToXSegs</name><argument_list>(<argument><expr><name>max_wal_size_mb</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Between those limits, recycle enough segments to get us through to the
	 * estimated end of next checkpoint.
	 *
	 * To estimate where the next checkpoint will finish, assume that the
	 * system runs steadily consuming CheckPointDistanceEstimate bytes between
	 * every checkpoint.
	 */</comment>
	<expr_stmt><expr><name>distance</name> <operator>=</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>+</operator> <name>CheckPointCompletionTarget</name><operator>)</operator> <operator>*</operator> <name>CheckPointDistanceEstimate</name></expr>;</expr_stmt>
	<comment type="block">/* add 10% for good measure. */</comment>
	<expr_stmt><expr><name>distance</name> <operator>*=</operator> <literal type="number">1.10</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>recycleSegNo</name> <operator>=</operator> <operator>(</operator><name>XLogSegNo</name><operator>)</operator> <call><name>ceil</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>RedoRecPtr</name> <operator>+</operator> <name>distance</name><operator>)</operator> <operator>/</operator>
									<name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>recycleSegNo</name> <operator>&lt;</operator> <name>minSegNo</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>recycleSegNo</name> <operator>=</operator> <name>minSegNo</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>recycleSegNo</name> <operator>&gt;</operator> <name>maxSegNo</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>recycleSegNo</name> <operator>=</operator> <name>maxSegNo</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>recycleSegNo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check whether we've consumed enough xlog space that a checkpoint is needed.
 *
 * new_segno indicates a log file that has just been filled up (or read
 * during recovery). We measure the distance from RedoRecPtr to new_segno
 * and see if that exceeds CheckPointSegments.
 *
 * Note: it is caller's responsibility that RedoRecPtr is up-to-date.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>XLogCheckpointNeeded</name><parameter_list>(<parameter><decl><type><name>XLogSegNo</name></type> <name>new_segno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>old_segno</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>RedoRecPtr</name></expr></argument>, <argument><expr><name>old_segno</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>new_segno</name> <operator>&gt;=</operator> <name>old_segno</name> <operator>+</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <operator>(</operator><name>CheckPointSegments</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Write and/or fsync the log at least as far as WriteRqst indicates.
 *
 * If flexible == true, we don't have to write as far as WriteRqst, but
 * may stop at any convenient boundary (such as a cache or logfile boundary).
 * This option allows us to avoid uselessly issuing multiple writes when a
 * single one would do.
 *
 * Must be called with WALWriteLock held. WaitXLogInsertionsToFinish(WriteRqst)
 * must be called before grabbing the lock, to make sure the data is ready to
 * write.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>XLogWrite</name><parameter_list>(<parameter><decl><type><name>XLogwrtRqst</name></type> <name>WriteRqst</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>flexible</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ispartialpage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>last_iteration</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>finishing_seg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>use_existent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>curridx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>npages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>startidx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>startoffset</name></decl>;</decl_stmt>

	<comment type="block">/* We should always be inside a critical section here */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CritSectionCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update local LogwrtResult (caller probably did this already, but...)
	 */</comment>
	<expr_stmt><expr><name>LogwrtResult</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtResult</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since successive pages in the xlog cache are consecutively allocated,
	 * we can usually gather multiple pages together and issue just one
	 * write() call.  npages is the number of pages we have determined can be
	 * written together; startidx is the cache block index of the first one,
	 * and startoffset is the file offset at which it should go. The latter
	 * two variables are only valid when npages &gt; 0, but we must initialize
	 * all of them to keep the compiler quiet.
	 */</comment>
	<expr_stmt><expr><name>npages</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>startidx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>startoffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Within the loop, curridx is the cache block index of the page to
	 * consider writing.  Begin at the buffer containing the next unwritten
	 * page, or last partially written page.
	 */</comment>
	<expr_stmt><expr><name>curridx</name> <operator>=</operator> <call><name>XLogRecPtrToBufIdx</name><argument_list>(<argument><expr><name><name>LogwrtResult</name><operator>.</operator><name>Write</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name><name>LogwrtResult</name><operator>.</operator><name>Write</name></name> <operator>&lt;</operator> <name><name>WriteRqst</name><operator>.</operator><name>Write</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Make sure we're not ahead of the insert process.  This could happen
		 * if we're passed a bogus WriteRqst.Write that is past the end of the
		 * last page that's been initialized by AdvanceXLInsertBuffer.
		 */</comment>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>EndPtr</name> <init>= <expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>xlblocks</name><index>[<expr><name>curridx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>LogwrtResult</name><operator>.</operator><name>Write</name></name> <operator>&gt;=</operator> <name>EndPtr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"xlog write request %X/%X is past end of log %X/%X"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>LogwrtResult</name><operator>.</operator><name>Write</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>LogwrtResult</name><operator>.</operator><name>Write</name></name></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>EndPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>EndPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Advance LogwrtResult.Write to end of current buffer page */</comment>
		<expr_stmt><expr><name><name>LogwrtResult</name><operator>.</operator><name>Write</name></name> <operator>=</operator> <name>EndPtr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ispartialpage</name> <operator>=</operator> <name><name>WriteRqst</name><operator>.</operator><name>Write</name></name> <operator>&lt;</operator> <name><name>LogwrtResult</name><operator>.</operator><name>Write</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLByteInPrevSeg</name><argument_list>(<argument><expr><name><name>LogwrtResult</name><operator>.</operator><name>Write</name></name></expr></argument>, <argument><expr><name>openLogSegNo</name></expr></argument>,
							 <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Switch to new logfile segment.  We cannot have any pending
			 * pages here (since we dump what we have at segment end).
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>npages</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>openLogFile</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>XLogFileClose</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>XLByteToPrevSeg</name><argument_list>(<argument><expr><name><name>LogwrtResult</name><operator>.</operator><name>Write</name></name></expr></argument>, <argument><expr><name>openLogSegNo</name></expr></argument>,
							<argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* create/use new log file */</comment>
			<expr_stmt><expr><name>use_existent</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>openLogFile</name> <operator>=</operator> <call><name>XLogFileInit</name><argument_list>(<argument><expr><name>openLogSegNo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>use_existent</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>openLogOff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Make sure we have the current logfile open */</comment>
		<if_stmt><if>if <condition>(<expr><name>openLogFile</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>XLByteToPrevSeg</name><argument_list>(<argument><expr><name><name>LogwrtResult</name><operator>.</operator><name>Write</name></name></expr></argument>, <argument><expr><name>openLogSegNo</name></expr></argument>,
							<argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>openLogFile</name> <operator>=</operator> <call><name>XLogFileOpen</name><argument_list>(<argument><expr><name>openLogSegNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>openLogOff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Add current page to the set of pending pages-to-dump */</comment>
		<if_stmt><if>if <condition>(<expr><name>npages</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* first of group */</comment>
			<expr_stmt><expr><name>startidx</name> <operator>=</operator> <name>curridx</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>startoffset</name> <operator>=</operator> <call><name>XLogSegmentOffset</name><argument_list>(<argument><expr><name><name>LogwrtResult</name><operator>.</operator><name>Write</name></name> <operator>-</operator> <name>XLOG_BLCKSZ</name></expr></argument>,
											<argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>npages</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Dump the set if this will be the last loop iteration, or if we are
		 * at the last page of the cache area (since the next page won't be
		 * contiguous in memory), or if we are at the end of the logfile
		 * segment.
		 */</comment>
		<expr_stmt><expr><name>last_iteration</name> <operator>=</operator> <name><name>WriteRqst</name><operator>.</operator><name>Write</name></name> <operator>&lt;=</operator> <name><name>LogwrtResult</name><operator>.</operator><name>Write</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>finishing_seg</name> <operator>=</operator> <operator>!</operator><name>ispartialpage</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>startoffset</name> <operator>+</operator> <name>npages</name> <operator>*</operator> <name>XLOG_BLCKSZ</name><operator>)</operator> <operator>&gt;=</operator> <name>wal_segment_size</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>last_iteration</name> <operator>||</operator>
			<name>curridx</name> <operator>==</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>XLogCacheBlck</name></name> <operator>||</operator>
			<name>finishing_seg</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>from</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Size</name></type>		<name>nbytes</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Size</name></type>		<name>nleft</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>written</name></decl>;</decl_stmt>

			<comment type="block">/* Need to seek in the file? */</comment>
			<if_stmt><if>if <condition>(<expr><name>openLogOff</name> <operator>!=</operator> <name>startoffset</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>lseek</name><argument_list>(<argument><expr><name>openLogFile</name></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator> <name>startoffset</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not seek in log file %s to offset %u: %m"</literal></expr></argument>,
									<argument><expr><call><name>XLogFileNameP</name><argument_list>(<argument><expr><name>ThisTimeLineID</name></expr></argument>, <argument><expr><name>openLogSegNo</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name>startoffset</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>openLogOff</name> <operator>=</operator> <name>startoffset</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* OK to write the page(s) */</comment>
			<expr_stmt><expr><name>from</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>pages</name></name> <operator>+</operator> <name>startidx</name> <operator>*</operator> <operator>(</operator><name>Size</name><operator>)</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <name>npages</name> <operator>*</operator> <operator>(</operator><name>Size</name><operator>)</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>nleft</name> <operator>=</operator> <name>nbytes</name></expr>;</expr_stmt>
			<do>do
			<block>{<block_content>
				<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_WAL_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>written</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name>openLogFile</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>nleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>written</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to log file %s "</literal>
									<literal type="string">"at offset %u, length %zu: %m"</literal></expr></argument>,
									<argument><expr><call><name>XLogFileNameP</name><argument_list>(<argument><expr><name>ThisTimeLineID</name></expr></argument>, <argument><expr><name>openLogSegNo</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name>openLogOff</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>nleft</name> <operator>-=</operator> <name>written</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>from</name> <operator>+=</operator> <name>written</name></expr>;</expr_stmt>
			</block_content>}</block> while <condition>(<expr><name>nleft</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>

			<comment type="block">/* Update state for write */</comment>
			<expr_stmt><expr><name>openLogOff</name> <operator>+=</operator> <name>nbytes</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>npages</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<comment type="block">/*
			 * If we just wrote the whole last page of a logfile segment,
			 * fsync the segment immediately.  This avoids having to go back
			 * and re-open prior segments when an fsync request comes along
			 * later. Doing it here ensures that one and only one backend will
			 * perform this fsync.
			 *
			 * This is also the right place to notify the Archiver that the
			 * segment is ready to copy to archival storage, and to update the
			 * timer for archive_timeout, and to signal for a checkpoint if
			 * too many logfile segments have been used since the last
			 * checkpoint.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>finishing_seg</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>issue_xlog_fsync</name><argument_list>(<argument><expr><name>openLogFile</name></expr></argument>, <argument><expr><name>openLogSegNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* signal that we need to wakeup walsenders later */</comment>
				<expr_stmt><expr><call><name>WalSndWakeupRequest</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>LogwrtResult</name><operator>.</operator><name>Flush</name></name> <operator>=</operator> <name><name>LogwrtResult</name><operator>.</operator><name>Write</name></name></expr>;</expr_stmt>	<comment type="block">/* end of page */</comment>

				<if_stmt><if>if <condition>(<expr><call><name>XLogArchivingActive</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>XLogArchiveNotifySeg</name><argument_list>(<argument><expr><name>openLogSegNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>lastSegSwitchTime</name></name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>lastSegSwitchLSN</name></name> <operator>=</operator> <name><name>LogwrtResult</name><operator>.</operator><name>Flush</name></name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Request a checkpoint if we've consumed too much xlog since
				 * the last one.  For speed, we first check using the local
				 * copy of RedoRecPtr, which might be out of date; if it looks
				 * like a checkpoint is needed, forcibly update RedoRecPtr and
				 * recheck.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator> <call><name>XLogCheckpointNeeded</name><argument_list>(<argument><expr><name>openLogSegNo</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>GetRedoRecPtr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>XLogCheckpointNeeded</name><argument_list>(<argument><expr><name>openLogSegNo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>RequestCheckpoint</name><argument_list>(<argument><expr><name>CHECKPOINT_CAUSE_XLOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>ispartialpage</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Only asked to write a partial page */</comment>
			<expr_stmt><expr><name><name>LogwrtResult</name><operator>.</operator><name>Write</name></name> <operator>=</operator> <name><name>WriteRqst</name><operator>.</operator><name>Write</name></name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>curridx</name> <operator>=</operator> <call><name>NextBufIdx</name><argument_list>(<argument><expr><name>curridx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If flexible, break out of loop as soon as we wrote something */</comment>
		<if_stmt><if>if <condition>(<expr><name>flexible</name> <operator>&amp;&amp;</operator> <name>npages</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>npages</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If asked to flush, do so
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>LogwrtResult</name><operator>.</operator><name>Flush</name></name> <operator>&lt;</operator> <name><name>WriteRqst</name><operator>.</operator><name>Flush</name></name> <operator>&amp;&amp;</operator>
		<name><name>LogwrtResult</name><operator>.</operator><name>Flush</name></name> <operator>&lt;</operator> <name><name>LogwrtResult</name><operator>.</operator><name>Write</name></name></expr>)</condition>

	<block>{<block_content>
		<comment type="block">/*
		 * Could get here without iterating above loop, in which case we might
		 * have no open file or the wrong one.  However, we do not need to
		 * fsync more than one file.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>sync_method</name> <operator>!=</operator> <name>SYNC_METHOD_OPEN</name> <operator>&amp;&amp;</operator>
			<name>sync_method</name> <operator>!=</operator> <name>SYNC_METHOD_OPEN_DSYNC</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>openLogFile</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>XLByteInPrevSeg</name><argument_list>(<argument><expr><name><name>LogwrtResult</name><operator>.</operator><name>Write</name></name></expr></argument>, <argument><expr><name>openLogSegNo</name></expr></argument>,
								 <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>XLogFileClose</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>openLogFile</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>XLByteToPrevSeg</name><argument_list>(<argument><expr><name><name>LogwrtResult</name><operator>.</operator><name>Write</name></name></expr></argument>, <argument><expr><name>openLogSegNo</name></expr></argument>,
								<argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>openLogFile</name> <operator>=</operator> <call><name>XLogFileOpen</name><argument_list>(<argument><expr><name>openLogSegNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>openLogOff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>issue_xlog_fsync</name><argument_list>(<argument><expr><name>openLogFile</name></expr></argument>, <argument><expr><name>openLogSegNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* signal that we need to wakeup walsenders later */</comment>
		<expr_stmt><expr><call><name>WalSndWakeupRequest</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>LogwrtResult</name><operator>.</operator><name>Flush</name></name> <operator>=</operator> <name><name>LogwrtResult</name><operator>.</operator><name>Write</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Update shared-memory status
	 *
	 * We make sure that the shared 'request' values do not fall behind the
	 * 'result' values.  This is not absolutely essential, but it saves some
	 * code in a couple of places.
	 */</comment>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtResult</name></name> <operator>=</operator> <name>LogwrtResult</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtRqst</name><operator>.</operator><name>Write</name></name> <operator>&lt;</operator> <name><name>LogwrtResult</name><operator>.</operator><name>Write</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtRqst</name><operator>.</operator><name>Write</name></name> <operator>=</operator> <name><name>LogwrtResult</name><operator>.</operator><name>Write</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtRqst</name><operator>.</operator><name>Flush</name></name> <operator>&lt;</operator> <name><name>LogwrtResult</name><operator>.</operator><name>Flush</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtRqst</name><operator>.</operator><name>Flush</name></name> <operator>=</operator> <name><name>LogwrtResult</name><operator>.</operator><name>Flush</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Record the LSN for an asynchronous transaction commit/abort
 * and nudge the WALWriter if there is work for it to do.
 * (This should not be called for synchronous commits.)
 */</comment>
<function><type><name>void</name></type>
<name>XLogSetAsyncXactLSN</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>asyncXactLSN</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>WriteRqstPtr</name> <init>= <expr><name>asyncXactLSN</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>sleeping</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>LogwrtResult</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtResult</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sleeping</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>WalWriterSleeping</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>asyncXactLSN</name></name> <operator>&lt;</operator> <name>asyncXactLSN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>asyncXactLSN</name></name> <operator>=</operator> <name>asyncXactLSN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the WALWriter is sleeping, we should kick it to make it come out of
	 * low-power mode.  Otherwise, determine whether there's a full page of
	 * WAL available to write.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sleeping</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* back off to last completed page boundary */</comment>
		<expr_stmt><expr><name>WriteRqstPtr</name> <operator>-=</operator> <name>WriteRqstPtr</name> <operator>%</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt>

		<comment type="block">/* if we have already flushed that far, we're done */</comment>
		<if_stmt><if>if <condition>(<expr><name>WriteRqstPtr</name> <operator>&lt;=</operator> <name><name>LogwrtResult</name><operator>.</operator><name>Flush</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Nudge the WALWriter: it has a full page of WAL to write, or we want it
	 * to come out of low-power mode so that this async commit will reach disk
	 * within the expected amount of time.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ProcGlobal</name><operator>-&gt;</operator><name>walwriterLatch</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name><name>ProcGlobal</name><operator>-&gt;</operator><name>walwriterLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Record the LSN up to which we can remove WAL because it's not required by
 * any replication slot.
 */</comment>
<function><type><name>void</name></type>
<name>XLogSetReplicationSlotMinimumLSN</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>replicationSlotMinLSN</name></name> <operator>=</operator> <name>lsn</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Return the oldest LSN we must retain to satisfy the needs of some
 * replication slot.
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRecPtr</name></type>
<name>XLogGetReplicationSlotMinimumLSN</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>retval</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>retval</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>replicationSlotMinLSN</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Advance minRecoveryPoint in control file.
 *
 * If we crash during recovery, we must reach this point again before the
 * database is consistent.
 *
 * If 'force' is true, 'lsn' argument is ignored. Otherwise, minRecoveryPoint
 * is only updated if it's not already greater than or equal to 'lsn'.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>UpdateMinRecoveryPoint</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Quick check using our local copy of the variable */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>updateMinRecoveryPoint</name> <operator>||</operator> <operator>(</operator><operator>!</operator><name>force</name> <operator>&amp;&amp;</operator> <name>lsn</name> <operator>&lt;=</operator> <name>minRecoveryPoint</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * An invalid minRecoveryPoint means that we need to recover all the WAL,
	 * i.e., we're doing crash recovery.  We never modify the control file's
	 * value in that case, so we can short-circuit future checks here too. The
	 * local values of minRecoveryPoint and minRecoveryPointTLI should not be
	 * updated until crash recovery finishes.  We only do this for the startup
	 * process as it should not update its own reference of minRecoveryPoint
	 * until it has finished crash recovery to make sure that all WAL
	 * available is replayed in this case.  This also saves from extra locks
	 * taken on the control file from the startup process.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>minRecoveryPoint</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>InRecovery</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>updateMinRecoveryPoint</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ControlFileLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* update local copy */</comment>
	<expr_stmt><expr><name>minRecoveryPoint</name> <operator>=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPoint</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>minRecoveryPointTLI</name> <operator>=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPointTLI</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>minRecoveryPoint</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>updateMinRecoveryPoint</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>force</name> <operator>||</operator> <name>minRecoveryPoint</name> <operator>&lt;</operator> <name>lsn</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>newMinRecoveryPoint</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>newMinRecoveryPointTLI</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * To avoid having to update the control file too often, we update it
		 * all the way to the last record being replayed, even though 'lsn'
		 * would suffice for correctness.  This also allows the 'force' case
		 * to not need a valid 'lsn' value.
		 *
		 * Another important reason for doing it this way is that the passed
		 * 'lsn' value could be bogus, i.e., past the end of available WAL, if
		 * the caller got it from a corrupted heap page.  Accepting such a
		 * value as the min recovery point would prevent us from coming up at
		 * all.  Instead, we just log a warning and continue with recovery.
		 * (See also the comments about corrupt LSNs in XLogFlush.)
		 */</comment>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newMinRecoveryPoint</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>replayEndRecPtr</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>newMinRecoveryPointTLI</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>replayEndTLI</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>force</name> <operator>&amp;&amp;</operator> <name>newMinRecoveryPoint</name> <operator>&lt;</operator> <name>lsn</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				 <argument><expr><literal type="string">"xlog min recovery request %X/%X is past current point %X/%X"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>lsn</name></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>newMinRecoveryPoint</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>newMinRecoveryPoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* update control file */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPoint</name></name> <operator>&lt;</operator> <name>newMinRecoveryPoint</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPoint</name></name> <operator>=</operator> <name>newMinRecoveryPoint</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPointTLI</name></name> <operator>=</operator> <name>newMinRecoveryPointTLI</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>UpdateControlFile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>minRecoveryPoint</name> <operator>=</operator> <name>newMinRecoveryPoint</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>minRecoveryPointTLI</name> <operator>=</operator> <name>newMinRecoveryPointTLI</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"updated min recovery point to %X/%X on timeline %u"</literal></expr></argument>,
							<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>minRecoveryPoint</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
							<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>minRecoveryPoint</name></expr></argument>,
							<argument><expr><name>newMinRecoveryPointTLI</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ControlFileLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Ensure that all XLOG data through the given position is flushed to disk.
 *
 * NOTE: this differs from XLogWrite mainly in that the WALWriteLock is not
 * already held, and we try to avoid acquiring it if possible.
 */</comment>
<function><type><name>void</name></type>
<name>XLogFlush</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>WriteRqstPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogwrtRqst</name></type> <name>WriteRqst</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * During REDO, we are reading not writing WAL.  Therefore, instead of
	 * trying to flush the WAL, we should update minRecoveryPoint instead. We
	 * test XLogInsertAllowed(), not InRecovery, because we need checkpointer
	 * to act this way too, and because when it tries to write the
	 * end-of-recovery checkpoint, it should indeed flush.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogInsertAllowed</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UpdateMinRecoveryPoint</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Quick exit if already known flushed */</comment>
	<if_stmt><if>if <condition>(<expr><name>record</name> <operator>&lt;=</operator> <name><name>LogwrtResult</name><operator>.</operator><name>Flush</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WAL_DEBUG</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>XLOG_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"xlog flush request %X/%X; write %X/%X; flush %X/%X"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>record</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>record</name></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>LogwrtResult</name><operator>.</operator><name>Write</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>LogwrtResult</name><operator>.</operator><name>Write</name></name></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>LogwrtResult</name><operator>.</operator><name>Flush</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>LogwrtResult</name><operator>.</operator><name>Flush</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since fsync is usually a horribly expensive operation, we try to
	 * piggyback as much data as we can on each fsync: if we see any more data
	 * entered into the xlog buffer, we'll write and fsync that too, so that
	 * the final value of LogwrtResult.Flush is as large as possible. This
	 * gives us some chance of avoiding another fsync immediately after.
	 */</comment>

	<comment type="block">/* initialize to given target; may increase below */</comment>
	<expr_stmt><expr><name>WriteRqstPtr</name> <operator>=</operator> <name>record</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now wait until we get the write lock, or someone else does the flush
	 * for us.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>insertpos</name></decl>;</decl_stmt>

		<comment type="block">/* read LogwrtResult and update local state */</comment>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>WriteRqstPtr</name> <operator>&lt;</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtRqst</name><operator>.</operator><name>Write</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>WriteRqstPtr</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtRqst</name><operator>.</operator><name>Write</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>LogwrtResult</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtResult</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* done already? */</comment>
		<if_stmt><if>if <condition>(<expr><name>record</name> <operator>&lt;=</operator> <name><name>LogwrtResult</name><operator>.</operator><name>Flush</name></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Before actually performing the write, wait for all in-flight
		 * insertions to the pages we're about to write to finish.
		 */</comment>
		<expr_stmt><expr><name>insertpos</name> <operator>=</operator> <call><name>WaitXLogInsertionsToFinish</name><argument_list>(<argument><expr><name>WriteRqstPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Try to get the write lock. If we can't get it immediately, wait
		 * until it's released, and recheck if we still need to do the flush
		 * or if the backend that held the lock did it for us already. This
		 * helps to maintain a good rate of group committing when the system
		 * is bottlenecked by the speed of fsyncing.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>LWLockAcquireOrWait</name><argument_list>(<argument><expr><name>WALWriteLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The lock is now free, but we didn't acquire it yet. Before we
			 * do, loop back to check if someone else flushed the record for
			 * us already.
			 */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Got the lock; recheck whether request is satisfied */</comment>
		<expr_stmt><expr><name>LogwrtResult</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtResult</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>record</name> <operator>&lt;=</operator> <name><name>LogwrtResult</name><operator>.</operator><name>Flush</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>WALWriteLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Sleep before flush! By adding a delay here, we may give further
		 * backends the opportunity to join the backlog of group commit
		 * followers; this can significantly improve transaction throughput,
		 * at the risk of increasing transaction latency.
		 *
		 * We do not sleep if enableFsync is not turned on, nor if there are
		 * fewer than CommitSiblings other backends with active transactions.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>CommitDelay</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>enableFsync</name> <operator>&amp;&amp;</operator>
			<call><name>MinimumActiveBackends</name><argument_list>(<argument><expr><name>CommitSiblings</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>CommitDelay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Re-check how far we can now flush the WAL. It's generally not
			 * safe to call WaitXLogInsertionsToFinish while holding
			 * WALWriteLock, because an in-progress insertion might need to
			 * also grab WALWriteLock to make progress. But we know that all
			 * the insertions up to insertpos have already finished, because
			 * that's what the earlier WaitXLogInsertionsToFinish() returned.
			 * We're only calling it again to allow insertpos to be moved
			 * further forward, not to actually wait for anyone.
			 */</comment>
			<expr_stmt><expr><name>insertpos</name> <operator>=</operator> <call><name>WaitXLogInsertionsToFinish</name><argument_list>(<argument><expr><name>insertpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* try to write/flush later additions to XLOG as well */</comment>
		<expr_stmt><expr><name><name>WriteRqst</name><operator>.</operator><name>Write</name></name> <operator>=</operator> <name>insertpos</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>WriteRqst</name><operator>.</operator><name>Flush</name></name> <operator>=</operator> <name>insertpos</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogWrite</name><argument_list>(<argument><expr><name>WriteRqst</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>WALWriteLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* done */</comment>
		<break>break;</break>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* wake up walsenders now that we've released heavily contended locks */</comment>
	<expr_stmt><expr><call><name>WalSndWakeupProcessRequests</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we still haven't flushed to the request point then we have a
	 * problem; most likely, the requested flush point is past end of XLOG.
	 * This has been seen to occur when a disk page has a corrupted LSN.
	 *
	 * Formerly we treated this as a PANIC condition, but that hurts the
	 * system's robustness rather than helping it: we do not want to take down
	 * the whole system due to corruption on one data page.  In particular, if
	 * the bad page is encountered again during recovery then we would be
	 * unable to restart the database at all!  (This scenario actually
	 * happened in the field several times with 7.1 releases.)	As of 8.4, bad
	 * LSNs encountered during recovery are UpdateMinRecoveryPoint's problem;
	 * the only time we can reach here during recovery is while flushing the
	 * end-of-recovery checkpoint record, and we don't expect that to have a
	 * bad LSN.
	 *
	 * Note that for calls from xact.c, the ERROR will be promoted to PANIC
	 * since xact.c calls this routine inside a critical section.  However,
	 * calls from bufmgr.c are not within critical sections and so we will not
	 * force a restart for a bad LSN on a data page.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>LogwrtResult</name><operator>.</operator><name>Flush</name></name> <operator>&lt;</operator> <name>record</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			 <argument><expr><literal type="string">"xlog flush request %X/%X is not satisfied --- flushed only to %X/%X"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>record</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>record</name></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>LogwrtResult</name><operator>.</operator><name>Flush</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>LogwrtResult</name><operator>.</operator><name>Flush</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Write &amp; flush xlog, but without specifying exactly where to.
 *
 * We normally write only completed blocks; but if there is nothing to do on
 * that basis, we check for unwritten async commits in the current incomplete
 * block, and write through the latest one of those.  Thus, if async commits
 * are not being used, we will write complete blocks only.
 *
 * If, based on the above, there's anything to write we do so immediately. But
 * to avoid calling fsync, fdatasync et. al. at a rate that'd impact
 * concurrent IO, we only flush WAL every wal_writer_delay ms, or if there's
 * more than wal_writer_flush_after unflushed blocks.
 *
 * We can guarantee that async commits reach disk after at most three
 * wal_writer_delay cycles. (When flushing complete blocks, we allow XLogWrite
 * to write "flexibly", meaning it can stop at the end of the buffer ring;
 * this makes a difference only with very high load or long wal_writer_delay,
 * but imposes one extra cycle for the worst case for async commits.)
 *
 * This routine is invoked periodically by the background walwriter process.
 *
 * Returns true if there was any work to do, even if we skipped flushing due
 * to wal_writer_delay/wal_writer_flush_after.
 */</comment>
<function><type><name>bool</name></type>
<name>XLogBackgroundFlush</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogwrtRqst</name></type> <name>WriteRqst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>flexible</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>lastflush</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>now</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>flushbytes</name></decl>;</decl_stmt>

	<comment type="block">/* XLOG doesn't need flushing during recovery */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* read LogwrtResult and update local state */</comment>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>LogwrtResult</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtResult</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>WriteRqst</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtRqst</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* back off to last completed page boundary */</comment>
	<expr_stmt><expr><name><name>WriteRqst</name><operator>.</operator><name>Write</name></name> <operator>-=</operator> <name><name>WriteRqst</name><operator>.</operator><name>Write</name></name> <operator>%</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt>

	<comment type="block">/* if we have already flushed that far, consider async commit records */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>WriteRqst</name><operator>.</operator><name>Write</name></name> <operator>&lt;=</operator> <name><name>LogwrtResult</name><operator>.</operator><name>Flush</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>WriteRqst</name><operator>.</operator><name>Write</name></name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>asyncXactLSN</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>flexible</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>		<comment type="block">/* ensure it all gets written */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If already known flushed, we're done. Just need to check if we are
	 * holding an open file handle to a logfile that's no longer in use,
	 * preventing the file from being deleted.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>WriteRqst</name><operator>.</operator><name>Write</name></name> <operator>&lt;=</operator> <name><name>LogwrtResult</name><operator>.</operator><name>Flush</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>openLogFile</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLByteInPrevSeg</name><argument_list>(<argument><expr><name><name>LogwrtResult</name><operator>.</operator><name>Write</name></name></expr></argument>, <argument><expr><name>openLogSegNo</name></expr></argument>,
								 <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>XLogFileClose</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Determine how far to flush WAL, based on the wal_writer_delay and
	 * wal_writer_flush_after GUCs.
	 */</comment>
	<expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>flushbytes</name> <operator>=</operator>
		<name><name>WriteRqst</name><operator>.</operator><name>Write</name></name> <operator>/</operator> <name>XLOG_BLCKSZ</name> <operator>-</operator> <name><name>LogwrtResult</name><operator>.</operator><name>Flush</name></name> <operator>/</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>WalWriterFlushAfter</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>lastflush</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* first call, or block based limits disabled */</comment>
		<expr_stmt><expr><name><name>WriteRqst</name><operator>.</operator><name>Flush</name></name> <operator>=</operator> <name><name>WriteRqst</name><operator>.</operator><name>Write</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>lastflush</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name>lastflush</name></expr></argument>, <argument><expr><name>now</name></expr></argument>, <argument><expr><name>WalWriterDelay</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Flush the writes at least every WalWriteDelay ms. This is important
		 * to bound the amount of time it takes for an asynchronous commit to
		 * hit disk.
		 */</comment>
		<expr_stmt><expr><name><name>WriteRqst</name><operator>.</operator><name>Flush</name></name> <operator>=</operator> <name><name>WriteRqst</name><operator>.</operator><name>Write</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>lastflush</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>flushbytes</name> <operator>&gt;=</operator> <name>WalWriterFlushAfter</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* exceeded wal_writer_flush_after blocks, flush */</comment>
		<expr_stmt><expr><name><name>WriteRqst</name><operator>.</operator><name>Flush</name></name> <operator>=</operator> <name><name>WriteRqst</name><operator>.</operator><name>Write</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>lastflush</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* no flushing, this time round */</comment>
		<expr_stmt><expr><name><name>WriteRqst</name><operator>.</operator><name>Flush</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WAL_DEBUG</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>XLOG_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"xlog bg flush request write %X/%X; flush: %X/%X, current is write %X/%X; flush %X/%X"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>WriteRqst</name><operator>.</operator><name>Write</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>WriteRqst</name><operator>.</operator><name>Write</name></name></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>WriteRqst</name><operator>.</operator><name>Flush</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>WriteRqst</name><operator>.</operator><name>Flush</name></name></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>LogwrtResult</name><operator>.</operator><name>Write</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>LogwrtResult</name><operator>.</operator><name>Write</name></name></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>LogwrtResult</name><operator>.</operator><name>Flush</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>LogwrtResult</name><operator>.</operator><name>Flush</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* now wait for any in-progress insertions to finish and get write lock */</comment>
	<expr_stmt><expr><call><name>WaitXLogInsertionsToFinish</name><argument_list>(<argument><expr><name><name>WriteRqst</name><operator>.</operator><name>Write</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>WALWriteLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>LogwrtResult</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtResult</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>WriteRqst</name><operator>.</operator><name>Write</name></name> <operator>&gt;</operator> <name><name>LogwrtResult</name><operator>.</operator><name>Write</name></name> <operator>||</operator>
		<name><name>WriteRqst</name><operator>.</operator><name>Flush</name></name> <operator>&gt;</operator> <name><name>LogwrtResult</name><operator>.</operator><name>Flush</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>XLogWrite</name><argument_list>(<argument><expr><name>WriteRqst</name></expr></argument>, <argument><expr><name>flexible</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>WALWriteLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* wake up walsenders now that we've released heavily contended locks */</comment>
	<expr_stmt><expr><call><name>WalSndWakeupProcessRequests</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Great, done. To take some work off the critical path, try to initialize
	 * as many of the no-longer-needed WAL buffers for future use as we can.
	 */</comment>
	<expr_stmt><expr><call><name>AdvanceXLInsertBuffer</name><argument_list>(<argument><expr><name>InvalidXLogRecPtr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we determined that we need to write data, but somebody else
	 * wrote/flushed already, it should be considered as being active, to
	 * avoid hibernating too early.
	 */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Test whether XLOG data has been flushed up to (at least) the given position.
 *
 * Returns true if a flush is still needed.  (It may be that someone else
 * is already in process of flushing that far, however.)
 */</comment>
<function><type><name>bool</name></type>
<name>XLogNeedsFlush</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * During recovery, we don't flush WAL but update minRecoveryPoint
	 * instead. So "needs flush" is taken to mean whether minRecoveryPoint
	 * would need to be updated.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * An invalid minRecoveryPoint means that we need to recover all the
		 * WAL, i.e., we're doing crash recovery.  We never modify the control
		 * file's value in that case, so we can short-circuit future checks
		 * here too.  This triggers a quick exit path for the startup process,
		 * which cannot update its local copy of minRecoveryPoint as long as
		 * it has not replayed all WAL available when doing crash recovery.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>minRecoveryPoint</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>InRecovery</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>updateMinRecoveryPoint</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Quick exit if already known to be updated or cannot be updated */</comment>
		<if_stmt><if>if <condition>(<expr><name>record</name> <operator>&lt;=</operator> <name>minRecoveryPoint</name> <operator>||</operator> <operator>!</operator><name>updateMinRecoveryPoint</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Update local copy of minRecoveryPoint. But if the lock is busy,
		 * just return a conservative guess.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>LWLockConditionalAcquire</name><argument_list>(<argument><expr><name>ControlFileLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>minRecoveryPoint</name> <operator>=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPoint</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>minRecoveryPointTLI</name> <operator>=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPointTLI</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ControlFileLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check minRecoveryPoint for any other process than the startup
		 * process doing crash recovery, which should not update the control
		 * file value if crash recovery is still running.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>minRecoveryPoint</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>updateMinRecoveryPoint</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* check again */</comment>
		<if_stmt><if>if <condition>(<expr><name>record</name> <operator>&lt;=</operator> <name>minRecoveryPoint</name> <operator>||</operator> <operator>!</operator><name>updateMinRecoveryPoint</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Quick exit if already known flushed */</comment>
	<if_stmt><if>if <condition>(<expr><name>record</name> <operator>&lt;=</operator> <name><name>LogwrtResult</name><operator>.</operator><name>Flush</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* read LogwrtResult and update local state */</comment>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>LogwrtResult</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtResult</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* check again */</comment>
	<if_stmt><if>if <condition>(<expr><name>record</name> <operator>&lt;=</operator> <name><name>LogwrtResult</name><operator>.</operator><name>Flush</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create a new XLOG file segment, or open a pre-existing one.
 *
 * log, seg: identify segment to be created/opened.
 *
 * *use_existent: if true, OK to use a pre-existing file (else, any
 * pre-existing file will be deleted).  On return, true if a pre-existing
 * file was used.
 *
 * use_lock: if true, acquire ControlFileLock while moving file into
 * place.  This should be true except during bootstrap log creation.  The
 * caller must *not* hold the lock at call.
 *
 * Returns FD of opened file.
 *
 * Note: errors here are ERROR not PANIC because we might or might not be
 * inside a critical section (eg, during checkpoint there is no reason to
 * take down the system on failure).  They will promote to PANIC if we are
 * in a critical section.
 */</comment>
<function><type><name>int</name></type>
<name>XLogFileInit</name><parameter_list>(<parameter><decl><type><name>XLogSegNo</name></type> <name>logsegno</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>use_existent</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_lock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>tmppath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGAlignedXLogBlock</name></type> <name>zbuffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>installed_segno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>max_segno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbytes</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>XLogFilePath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>ThisTimeLineID</name></expr></argument>, <argument><expr><name>logsegno</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Try to use existent file (checkpoint maker may have created it already)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>use_existent</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>BasicOpenFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name> <operator>|</operator> <call><name>get_sync_bit</name><argument_list>(<argument><expr><name>sync_method</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>fd</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Initialize an empty (all zeroes) segment.  NOTE: it is possible that
	 * another process is doing the same thing.  If so, we will end up
	 * pre-creating an extra log segment.  That seems OK, and better than
	 * holding the lock throughout this lengthy process.
	 */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"creating and filling new WAL file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><name>XLOGDIR</name> <literal type="string">"/xlogtemp.%d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* do not use get_sync_bit() here --- want to fsync only at end of fill */</comment>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>BasicOpenFile</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>O_EXCL</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Zero-fill the file.  We have to do this the hard way to ensure that all
	 * the file space has really been allocated --- on platforms that allow
	 * "holes" in files, just seeking to the end doesn't allocate intermediate
	 * space.  This way, we know that we have all the space and (after the
	 * fsync below) that all the indirect blocks are down on disk.  Therefore,
	 * fdatasync(2) or O_DSYNC will be sufficient to sync future writes to the
	 * log file.
	 */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>zbuffer</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>XLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>nbytes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>nbytes</name> <operator>&lt;</operator> <name>wal_segment_size</name></expr>;</condition> <incr><expr><name>nbytes</name> <operator>+=</operator> <name>XLOG_BLCKSZ</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_WAL_INIT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>zbuffer</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>XLOG_BLCKSZ</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>XLOG_BLCKSZ</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * If we fail to make the file, delete it to release disk space
			 */</comment>
			<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <ternary><condition><expr><name>save_errno</name></expr> ?</condition><then> <expr><name>save_errno</name></expr> </then><else>: <expr><name>ENOSPC</name></expr></else></ternary></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_WAL_INIT_SYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pg_fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fsync file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Now move the segment into place with its final name.
	 *
	 * If caller didn't want to use a pre-existing file, get rid of any
	 * pre-existing file.  Otherwise, cope with possibility that someone else
	 * has created the file while we were filling ours: if so, use ours to
	 * pre-create a future log segment.
	 */</comment>
	<expr_stmt><expr><name>installed_segno</name> <operator>=</operator> <name>logsegno</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * XXX: What should we use as max_segno? We used to use XLOGfileslop when
	 * that was a constant, but that was always a bit dubious: normally, at a
	 * checkpoint, XLOGfileslop was the offset from the checkpoint record, but
	 * here, it was the offset from the insert location. We can't do the
	 * normal XLOGfileslop calculation here because we don't have access to
	 * the prior checkpoint's redo location. So somewhat arbitrarily, just use
	 * CheckPointSegments.
	 */</comment>
	<expr_stmt><expr><name>max_segno</name> <operator>=</operator> <name>logsegno</name> <operator>+</operator> <name>CheckPointSegments</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>InstallXLogFileSegment</name><argument_list>(<argument><expr><operator>&amp;</operator><name>installed_segno</name></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>,
								<argument><expr><operator>*</operator><name>use_existent</name></expr></argument>, <argument><expr><name>max_segno</name></expr></argument>,
								<argument><expr><name>use_lock</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * No need for any more future segments, or InstallXLogFileSegment()
		 * failed to rename the file into place. If the rename failed, opening
		 * the file below will fail.
		 */</comment>
		<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Set flag to tell caller there was no existent file */</comment>
	<expr_stmt><expr><operator>*</operator><name>use_existent</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Now open original target segment (might not be file I just made) */</comment>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>BasicOpenFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name> <operator>|</operator> <call><name>get_sync_bit</name><argument_list>(<argument><expr><name>sync_method</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"done creating and filling new WAL file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>fd</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create a new XLOG file segment by copying a pre-existing one.
 *
 * destsegno: identify segment to be created.
 *
 * srcTLI, srcsegno: identify segment to be copied (could be from
 *		a different timeline)
 *
 * upto: how much of the source file to copy (the rest is filled with
 *		zeros)
 *
 * Currently this is only used during recovery, and so there are no locking
 * considerations.  But we should be just as tense as XLogFileInit to avoid
 * emplacing a bogus file.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>XLogFileCopy</name><parameter_list>(<parameter><decl><type><name>XLogSegNo</name></type> <name>destsegno</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name></type> <name>srcTLI</name></decl></parameter>, <parameter><decl><type><name>XLogSegNo</name></type> <name>srcsegno</name></decl></parameter>,
			 <parameter><decl><type><name>int</name></type> <name>upto</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>tmppath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGAlignedXLogBlock</name></type> <name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>srcfd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbytes</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Open the source file
	 */</comment>
	<expr_stmt><expr><call><name>XLogFilePath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>srcTLI</name></expr></argument>, <argument><expr><name>srcsegno</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>srcfd</name> <operator>=</operator> <call><name>OpenTransientFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>srcfd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Copy into a temp file name.
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><name>XLOGDIR</name> <literal type="string">"/xlogtemp.%d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* do not use get_sync_bit() here --- want to fsync only at end of fill */</comment>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>OpenTransientFile</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>O_EXCL</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Do the data copying.
	 */</comment>
	<for>for <control>(<init><expr><name>nbytes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>nbytes</name> <operator>&lt;</operator> <name>wal_segment_size</name></expr>;</condition> <incr><expr><name>nbytes</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>nread</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>nread</name> <operator>=</operator> <name>upto</name> <operator>-</operator> <name>nbytes</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * The part that is not read from the source file is filled with
		 * zeros.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>nread</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>buffer</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>nread</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>nread</name> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>nread</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_WAL_COPY_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>read</name><argument_list>(<argument><expr><name>srcfd</name></expr></argument>, <argument><expr><name><name>buffer</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>nread</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>nread</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read file \"%s\": %m"</literal></expr></argument>,
									<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"not enough data in file \"%s\""</literal></expr></argument>,
									<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_WAL_COPY_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>buffer</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>(</operator><name>int</name><operator>)</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * If we fail to make the file, delete it to release disk space
			 */</comment>
			<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <ternary><condition><expr><name>save_errno</name></expr> ?</condition><then> <expr><name>save_errno</name></expr> </then><else>: <expr><name>ENOSPC</name></expr></else></ternary></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_WAL_COPY_SYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pg_fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><call><name>data_sync_elevel</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fsync file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>srcfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now move the segment into place with its final name.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>InstallXLogFileSegment</name><argument_list>(<argument><expr><operator>&amp;</operator><name>destsegno</name></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"InstallXLogFileSegment should not have failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Install a new XLOG segment file as a current or future log segment.
 *
 * This is used both to install a newly-created segment (which has a temp
 * filename while it's being created) and to recycle an old segment.
 *
 * *segno: identify segment to install as (or first possible target).
 * When find_free is true, this is modified on return to indicate the
 * actual installation location or last segment searched.
 *
 * tmppath: initial name of file to install.  It will be renamed into place.
 *
 * find_free: if true, install the new segment at the first empty segno
 * number at or after the passed numbers.  If false, install the new segment
 * exactly where specified, deleting any existing segment file there.
 *
 * max_segno: maximum segment number to install the new file as.  Fail if no
 * free slot is found between *segno and max_segno. (Ignored when find_free
 * is false.)
 *
 * use_lock: if true, acquire ControlFileLock while moving file into
 * place.  This should be true except during bootstrap log creation.  The
 * caller must *not* hold the lock at call.
 *
 * Returns true if the file was installed successfully.  false indicates that
 * max_segno limit was exceeded, or an error occurred while renaming the
 * file into place.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>InstallXLogFileSegment</name><parameter_list>(<parameter><decl><type><name>XLogSegNo</name> <modifier>*</modifier></type><name>segno</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>tmppath</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>find_free</name></decl></parameter>, <parameter><decl><type><name>XLogSegNo</name></type> <name>max_segno</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>use_lock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>XLogFilePath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>ThisTimeLineID</name></expr></argument>, <argument><expr><operator>*</operator><name>segno</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We want to be sure that only one process does this at a time.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>use_lock</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ControlFileLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>find_free</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Force installation: get rid of any pre-existing segment file */</comment>
		<expr_stmt><expr><call><name>durable_unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>DEBUG1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Find a free slot to put it in */</comment>
		<while>while <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>segno</name><operator>)</operator> <operator>&gt;=</operator> <name>max_segno</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Failed to find a free slot within specified range */</comment>
				<if_stmt><if>if <condition>(<expr><name>use_lock</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ControlFileLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>segno</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogFilePath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>ThisTimeLineID</name></expr></argument>, <argument><expr><operator>*</operator><name>segno</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Perform the rename using link if available, paranoidly trying to avoid
	 * overwriting an existing file (there shouldn't be one).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>durable_link_or_rename</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>use_lock</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ControlFileLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* durable_link_or_rename already emitted log message */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>use_lock</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ControlFileLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Open a pre-existing logfile segment for writing.
 */</comment>
<function><type><name>int</name></type>
<name>XLogFileOpen</name><parameter_list>(<parameter><decl><type><name>XLogSegNo</name></type> <name>segno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>XLogFilePath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>ThisTimeLineID</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>BasicOpenFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name> <operator>|</operator> <call><name>get_sync_bit</name><argument_list>(<argument><expr><name>sync_method</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open write-ahead log file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>fd</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Open a logfile segment for reading (during recovery).
 *
 * If source == XLOG_FROM_ARCHIVE, the segment is retrieved from archive.
 * Otherwise, it's assumed to be already available in pg_wal.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>XLogFileRead</name><parameter_list>(<parameter><decl><type><name>XLogSegNo</name></type> <name>segno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>emode</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name></type> <name>tli</name></decl></parameter>,
			 <parameter><decl><type><name>int</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>notfoundOk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>xlogfname</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>activitymsg</name><index>[<expr><name>MAXFNAMELEN</name> <operator>+</operator> <literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>xlogfname</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>source</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XLOG_FROM_ARCHIVE</name></expr>:</case>
			<comment type="block">/* Report recovery progress in PS display */</comment>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>activitymsg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>activitymsg</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"waiting for %s"</literal></expr></argument>,
					 <argument><expr><name>xlogfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><name>activitymsg</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>restoredFromArchive</name> <operator>=</operator> <call><name>RestoreArchivedFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>xlogfname</name></expr></argument>,
													  <argument><expr><literal type="string">"RECOVERYXLOG"</literal></expr></argument>,
													  <argument><expr><name>wal_segment_size</name></expr></argument>,
													  <argument><expr><name>InRedo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>restoredFromArchive</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_FROM_PG_WAL</name></expr>:</case>
		<case>case <expr><name>XLOG_FROM_STREAM</name></expr>:</case>
			<expr_stmt><expr><call><name>XLogFilePath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>restoredFromArchive</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid XLogFileRead source %d"</literal></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * If the segment was fetched from archival storage, replace the existing
	 * xlog segment (if any) with the archival version.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>source</name> <operator>==</operator> <name>XLOG_FROM_ARCHIVE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>KeepFileRestoredFromArchive</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>xlogfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Set path to point at the new file in pg_wal.
		 */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><name>XLOGDIR</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><name>xlogfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>BasicOpenFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Success! */</comment>
		<expr_stmt><expr><name>curFileTLI</name> <operator>=</operator> <name>tli</name></expr>;</expr_stmt>

		<comment type="block">/* Report recovery progress in PS display */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>activitymsg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>activitymsg</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"recovering %s"</literal></expr></argument>,
				 <argument><expr><name>xlogfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><name>activitymsg</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Track source of data in assorted state variables */</comment>
		<expr_stmt><expr><name>readSource</name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>XLogReceiptSource</name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
		<comment type="block">/* In FROM_STREAM case, caller tracks receipt time, not me */</comment>
		<if_stmt><if>if <condition>(<expr><name>source</name> <operator>!=</operator> <name>XLOG_FROM_STREAM</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>XLogReceiptTime</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><name>fd</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name> <operator>||</operator> <operator>!</operator><name>notfoundOk</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* unexpected failure? */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Open a logfile segment for reading (during recovery).
 *
 * This version searches for the segment with any TLI listed in expectedTLEs.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>XLogFileReadAnyTLI</name><parameter_list>(<parameter><decl><type><name>XLogSegNo</name></type> <name>segno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>emode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tles</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Loop looking for a suitable timeline ID: we might need to read any of
	 * the timelines listed in expectedTLEs.
	 *
	 * We expect curFileTLI on entry to be the TLI of the preceding file in
	 * sequence, or 0 if there was no predecessor.  We do not allow curFileTLI
	 * to go backwards; this prevents us from picking up the wrong file when a
	 * parent timeline extends to higher segment numbers than the child we
	 * want to read.
	 *
	 * If we haven't read the timeline history file yet, read it now, so that
	 * we know which TLIs to scan.  We don't save the list in expectedTLEs,
	 * however, unless we actually find a valid segment.  That way if there is
	 * neither a timeline history file nor a WAL segment in the archive, and
	 * streaming replication is set up, we'll read the timeline history file
	 * streamed from the master when we start streaming, instead of recovering
	 * with a dummy history generated here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>expectedTLEs</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tles</name> <operator>=</operator> <name>expectedTLEs</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>tles</name> <operator>=</operator> <call><name>readTimeLineHistory</name><argument_list>(<argument><expr><name>recoveryTargetTLI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>tles</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>tli</name> <init>= <expr><operator>(</operator><operator>(</operator><name>TimeLineHistoryEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>tli</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>tli</name> <operator>&lt;</operator> <name>curFileTLI</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* don't bother looking at too-old TLIs */</comment>

		<if_stmt><if>if <condition>(<expr><name>source</name> <operator>==</operator> <name>XLOG_FROM_ANY</name> <operator>||</operator> <name>source</name> <operator>==</operator> <name>XLOG_FROM_ARCHIVE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>XLogFileRead</name><argument_list>(<argument><expr><name>segno</name></expr></argument>, <argument><expr><name>emode</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>,
							  <argument><expr><name>XLOG_FROM_ARCHIVE</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"got WAL segment from archive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>expectedTLEs</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>expectedTLEs</name> <operator>=</operator> <name>tles</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<return>return <expr><name>fd</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>source</name> <operator>==</operator> <name>XLOG_FROM_ANY</name> <operator>||</operator> <name>source</name> <operator>==</operator> <name>XLOG_FROM_PG_WAL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>XLogFileRead</name><argument_list>(<argument><expr><name>segno</name></expr></argument>, <argument><expr><name>emode</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>,
							  <argument><expr><name>XLOG_FROM_PG_WAL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>expectedTLEs</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>expectedTLEs</name> <operator>=</operator> <name>tles</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<return>return <expr><name>fd</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Couldn't find it.  For simplicity, complain about front timeline */</comment>
	<expr_stmt><expr><call><name>XLogFilePath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>recoveryTargetTLI</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOENT</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>emode</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Close the current logfile segment for writing.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>XLogFileClose</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>openLogFile</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * WAL segment files will not be re-read in normal operation, so we advise
	 * the OS to release any cached pages.  But do not do so if WAL archiving
	 * or streaming is active, because archiver and walsender process could
	 * use the cache to read the WAL segment.
	 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_POSIX_FADVISE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>POSIX_FADV_DONTNEED</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogIsNeeded</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>posix_fadvise</name><argument_list>(<argument><expr><name>openLogFile</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>POSIX_FADV_DONTNEED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><call><name>close</name><argument_list>(<argument><expr><name>openLogFile</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close log file %s: %m"</literal></expr></argument>,
						<argument><expr><call><name>XLogFileNameP</name><argument_list>(<argument><expr><name>ThisTimeLineID</name></expr></argument>, <argument><expr><name>openLogSegNo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>openLogFile</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Preallocate log files beyond the specified log endpoint.
 *
 * XXX this is currently extremely conservative, since it forces only one
 * future log segment to exist, and even that only if we are 75% done with
 * the current one.  This is only appropriate for very low-WAL-volume systems.
 * High-volume systems will be OK once they've built up a sufficient set of
 * recycled log segments, but the startup transient is likely to include
 * a lot of segment creations by foreground processes, which is not so good.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PreallocXlogFiles</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>endptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>_logSegNo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>lf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>use_existent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>offset</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>XLByteToPrevSeg</name><argument_list>(<argument><expr><name>endptr</name></expr></argument>, <argument><expr><name>_logSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>XLogSegmentOffset</name><argument_list>(<argument><expr><name>endptr</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><literal type="number">0.75</literal> <operator>*</operator> <name>wal_segment_size</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>_logSegNo</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>use_existent</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>lf</name> <operator>=</operator> <call><name>XLogFileInit</name><argument_list>(<argument><expr><name>_logSegNo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>use_existent</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>lf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>use_existent</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>CheckpointStats</name><operator>.</operator><name>ckpt_segs_added</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Throws an error if the given log segment has already been removed or
 * recycled. The caller should only pass a segment that it knows to have
 * existed while the server has been running, as this function always
 * succeeds if no WAL segments have been removed since startup.
 * 'tli' is only used in the error message.
 *
 * Note: this function guarantees to keep errno unchanged on return.
 * This supports callers that use this to possibly deliver a better
 * error message about a missing file, while still being able to throw
 * a normal file-access error afterwards, if this does return.
 */</comment>
<function><type><name>void</name></type>
<name>CheckXLogRemoved</name><parameter_list>(<parameter><decl><type><name>XLogSegNo</name></type> <name>segno</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name></type> <name>tli</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>lastRemovedSegNo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lastRemovedSegNo</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>lastRemovedSegNo</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>segno</name> <operator>&lt;=</operator> <name>lastRemovedSegNo</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>filename</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"requested WAL segment %s has already been removed"</literal></expr></argument>,
						<argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return the last WAL segment removed, or 0 if no segment has been removed
 * since startup.
 *
 * NB: the result can be out of date arbitrarily fast, the caller has to deal
 * with that.
 */</comment>
<function><type><name>XLogSegNo</name></type>
<name>XLogGetLastRemovedSegno</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>lastRemovedSegNo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lastRemovedSegNo</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>lastRemovedSegNo</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>lastRemovedSegNo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Update the last removed segno pointer in shared memory, to reflect
 * that the given XLOG file has been removed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>UpdateLastRemovedPtr</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>tli</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>segno</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>XLogFromFileName</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tli</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>segno</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>segno</name> <operator>&gt;</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>lastRemovedSegNo</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>lastRemovedSegNo</name></name> <operator>=</operator> <name>segno</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Recycle or remove all log files older or equal to passed segno.
 *
 * endptr is current (or recent) end of xlog, and RedoRecPtr is the
 * redo pointer of the last checkpoint. These are used to determine
 * whether we want to recycle rather than delete no-longer-wanted log files.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RemoveOldXlogFiles</name><parameter_list>(<parameter><decl><type><name>XLogSegNo</name></type> <name>segno</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>RedoRecPtr</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>endptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>xldir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>xlde</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>lastoff</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Construct a filename of the last segment to be kept. The timeline ID
	 * doesn't matter, we ignore that in the comparison. (During recovery,
	 * ThisTimeLineID isn't set, so we can't use that.)
	 */</comment>
	<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>lastoff</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"attempting to remove WAL segments older than log file %s"</literal></expr></argument>,
		 <argument><expr><name>lastoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>xldir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><name>XLOGDIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>xlde</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>xldir</name></expr></argument>, <argument><expr><name>XLOGDIR</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Ignore files that are not XLOG segments */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsXLogFileName</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>IsPartialXLogFileName</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We ignore the timeline part of the XLOG segment identifiers in
		 * deciding whether a segment is still needed.  This ensures that we
		 * won't prematurely remove a segment from a parent timeline. We could
		 * probably be a little more proactive about removing segments of
		 * non-parent timelines, but that would be a whole lot more
		 * complicated.
		 *
		 * We use the alphanumeric sorting property of the filenames to decide
		 * which ones are earlier than the lastoff segment.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><name>lastoff</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>XLogArchiveCheckDone</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Update the last removed location in shared memory first */</comment>
				<expr_stmt><expr><call><name>UpdateLastRemovedPtr</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>RemoveXlogFile</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>RedoRecPtr</name></expr></argument>, <argument><expr><name>endptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>xldir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Remove WAL files that are not part of the given timeline's history.
 *
 * This is called during recovery, whenever we switch to follow a new
 * timeline, and at the end of recovery when we create a new timeline. We
 * wouldn't otherwise care about extra WAL files lying in pg_wal, but they
 * might be leftover pre-allocated or recycled WAL segments on the old timeline
 * that we haven't used yet, and contain garbage. If we just leave them in
 * pg_wal, they will eventually be archived, and we can't let that happen.
 * Files that belong to our timeline history are valid, because we have
 * successfully replayed them, but from others we can't be sure.
 *
 * 'switchpoint' is the current point in WAL where we switch to new timeline,
 * and 'newTLI' is the new timeline we switch to.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RemoveNonParentXlogFiles</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>switchpoint</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name></type> <name>newTLI</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>xldir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>xlde</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>switchseg</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>endLogSegNo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>XLByteToPrevSeg</name><argument_list>(<argument><expr><name>switchpoint</name></expr></argument>, <argument><expr><name>endLogSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Construct a filename of the last segment to be kept.
	 */</comment>
	<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>switchseg</name></expr></argument>, <argument><expr><name>newTLI</name></expr></argument>, <argument><expr><name>endLogSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"attempting to remove WAL segments newer than log file %s"</literal></expr></argument>,
		 <argument><expr><name>switchseg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>xldir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><name>XLOGDIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>xlde</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>xldir</name></expr></argument>, <argument><expr><name>XLOGDIR</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Ignore files that are not XLOG segments */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsXLogFileName</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Remove files that are on a timeline older than the new one we're
		 * switching to, but with a segment number &gt;= the first segment on the
		 * new timeline.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>switchseg</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><name>switchseg</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the file has already been marked as .ready, however, don't
			 * remove it yet. It should be OK to remove it - files that are
			 * not part of our timeline history are not required for recovery
			 * - but seems safer to let them be archived and removed later.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogArchiveIsReady</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>RemoveXlogFile</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>, <argument><expr><name>switchpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>xldir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Recycle or remove a log file that's no longer needed.
 *
 * endptr is current (or recent) end of xlog, and RedoRecPtr is the
 * redo pointer of the last checkpoint. These are used to determine
 * whether we want to recycle rather than delete no-longer-wanted log files.
 * If RedoRecPtr is not known, pass invalid, and the function will recycle,
 * somewhat arbitrarily, 10 future segments.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RemoveXlogFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>segname</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>RedoRecPtr</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>endptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>newpath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>endlogSegNo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>recycleSegNo</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Initialize info about where to try to recycle to.
	 */</comment>
	<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>endptr</name></expr></argument>, <argument><expr><name>endlogSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>RedoRecPtr</name> <operator>==</operator> <name>InvalidXLogRecPtr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>recycleSegNo</name> <operator>=</operator> <name>endlogSegNo</name> <operator>+</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>recycleSegNo</name> <operator>=</operator> <call><name>XLOGfileslop</name><argument_list>(<argument><expr><name>RedoRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><name>XLOGDIR</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><name>segname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Before deleting the file, see if it can be recycled as a future log
	 * segment. Only recycle normal files, pg_standby for example can create
	 * symbolic links pointing to a separate archive directory.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>endlogSegNo</name> <operator>&lt;=</operator> <name>recycleSegNo</name> <operator>&amp;&amp;</operator>
		<call><name>lstat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>statbuf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>InstallXLogFileSegment</name><argument_list>(<argument><expr><operator>&amp;</operator><name>endlogSegNo</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
							   <argument><expr><name>true</name></expr></argument>, <argument><expr><name>recycleSegNo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"recycled write-ahead log file \"%s\""</literal></expr></argument>,
						<argument><expr><name>segname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>CheckpointStats</name><operator>.</operator><name>ckpt_segs_recycled</name></name><operator>++</operator></expr>;</expr_stmt>
		<comment type="block">/* Needn't recheck that slot on future iterations */</comment>
		<expr_stmt><expr><name>endlogSegNo</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* No need for any more future segments... */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"removing write-ahead log file \"%s\""</literal></expr></argument>,
						<argument><expr><name>segname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>

		<comment type="block">/*
		 * On Windows, if another process (e.g another backend) holds the file
		 * open in FILE_SHARE_DELETE mode, unlink will succeed, but the file
		 * will still show up in directory listing until the last handle is
		 * closed. To avoid confusing the lingering deleted file for a live
		 * WAL file that needs to be archived, rename it before deleting it.
		 *
		 * If another process holds the file open without FILE_SHARE_DELETE
		 * flag, rename will fail. We'll try again at the next checkpoint.
		 */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>newpath</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s.deleted"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>rename</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>newpath</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not rename old write-ahead log file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>durable_unlink</name><argument_list>(<argument><expr><name>newpath</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>durable_unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Message already logged by durable_unlink() */</comment>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>CheckpointStats</name><operator>.</operator><name>ckpt_segs_removed</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>XLogArchiveCleanup</name><argument_list>(<argument><expr><name>segname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Verify whether pg_wal and pg_wal/archive_status exist.
 * If the latter does not exist, recreate it.
 *
 * It is not the goal of this function to verify the contents of these
 * directories, but to help in cases where someone has performed a cluster
 * copy for PITR purposes but omitted pg_wal from the copy.
 *
 * We could also recreate pg_wal if it doesn't exist, but a deliberate
 * policy decision was made not to.  It is fairly common for pg_wal to be
 * a symlink, and if that was the DBA's intent then automatically making a
 * plain directory would result in degraded performance with no notice.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ValidateXLOGDirectoryStructure</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>

	<comment type="block">/* Check for pg_wal; if it doesn't exist, error out */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>XLOGDIR</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
		<operator>!</operator><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>stat_buf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"required WAL directory \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>XLOGDIR</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Check for archive_status */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><name>XLOGDIR</name> <literal type="string">"/archive_status"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Check for weird cases where it exists but isn't a directory */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>stat_buf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"required WAL directory \"%s\" does not exist"</literal></expr></argument>,
							<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"creating missing WAL directory \"%s\""</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>MakePGDirectory</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create missing directory \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Remove previous backup history files.  This also retries creation of
 * .ready files for any backup history files for which XLogArchiveNotify
 * failed earlier.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CleanupBackupHistory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>xldir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>xlde</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLOGDIR</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>xldir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><name>XLOGDIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>xlde</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>xldir</name></expr></argument>, <argument><expr><name>XLOGDIR</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsBackupHistoryFileName</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>XLogArchiveCheckDone</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"removing WAL backup history file \"%s\""</literal></expr></argument>,
					 <argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>XLOGDIR</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>XLogArchiveCleanup</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>xldir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Attempt to read an XLOG record.
 *
 * If RecPtr is valid, try to read a record at that position.  Otherwise
 * try to read a record just after the last one previously read.
 *
 * If no valid record is available, returns NULL, or fails if emode is PANIC.
 * (emode must be either PANIC, LOG). In standby mode, retries until a valid
 * record is available.
 *
 * The record is copied into readRecordBuf, so that on successful return,
 * the returned record pointer always points there.
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRecord</name> <modifier>*</modifier></type>
<name>ReadRecord</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>xlogreader</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>RecPtr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>emode</name></decl></parameter>,
		   <parameter><decl><type><name>bool</name></type> <name>fetching_ckpt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogPageReadPrivate</name> <modifier>*</modifier></type><name>private</name> <init>= <expr><operator>(</operator><name>XLogPageReadPrivate</name> <operator>*</operator><operator>)</operator> <name><name>xlogreader</name><operator>-&gt;</operator><name>private_data</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Pass through parameters to XLogPageRead */</comment>
	<expr_stmt><expr><name><name>private</name><operator>-&gt;</operator><name>fetching_ckpt</name></name> <operator>=</operator> <name>fetching_ckpt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>private</name><operator>-&gt;</operator><name>emode</name></name> <operator>=</operator> <name>emode</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>private</name><operator>-&gt;</operator><name>randAccess</name></name> <operator>=</operator> <operator>(</operator><name>RecPtr</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* This is the first attempt to read this page. */</comment>
	<expr_stmt><expr><name>lastSourceFailed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>errormsg</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>XLogReadRecord</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>, <argument><expr><name>RecPtr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errormsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ReadRecPtr</name> <operator>=</operator> <name><name>xlogreader</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>EndRecPtr</name> <operator>=</operator> <name><name>xlogreader</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>record</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>readFile</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>readFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>readFile</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * We only end up here without a message when XLogPageRead()
			 * failed - in that case we already logged something. In
			 * StandbyMode that only happens if we have been triggered, so we
			 * shouldn't loop anymore in that case.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>errormsg</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><call><name>emode_for_corrupt_record</name><argument_list>(<argument><expr><name>emode</name></expr></argument>,
												 <argument><expr><ternary><condition><expr><name>RecPtr</name></expr> ?</condition><then> <expr><name>RecPtr</name></expr> </then><else>: <expr><name>EndRecPtr</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>errormsg</name></expr></argument>)</argument_list></call> <comment type="block">/* already translated */</comment> <operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>

		<comment type="block">/*
		 * Check page TLI is one of the expected values.
		 */</comment>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>tliInHistory</name><argument_list>(<argument><expr><name><name>xlogreader</name><operator>-&gt;</operator><name>latestPageTLI</name></name></expr></argument>, <argument><expr><name>expectedTLEs</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>fname</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>segno</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>offset</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name><name>xlogreader</name><operator>-&gt;</operator><name>latestPagePtr</name></name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>XLogSegmentOffset</name><argument_list>(<argument><expr><name><name>xlogreader</name><operator>-&gt;</operator><name>latestPagePtr</name></name></expr></argument>,
									   <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name><name>xlogreader</name><operator>-&gt;</operator><name>readPageTLI</name></name></expr></argument>, <argument><expr><name>segno</name></expr></argument>,
						 <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><call><name>emode_for_corrupt_record</name><argument_list>(<argument><expr><name>emode</name></expr></argument>,
											 <argument><expr><ternary><condition><expr><name>RecPtr</name></expr> ?</condition><then> <expr><name>RecPtr</name></expr> </then><else>: <expr><name>EndRecPtr</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected timeline ID %u in log segment %s, offset %u"</literal></expr></argument>,
							<argument><expr><name><name>xlogreader</name><operator>-&gt;</operator><name>latestPageTLI</name></name></expr></argument>,
							<argument><expr><name>fname</name></expr></argument>,
							<argument><expr><name>offset</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>record</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>record</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Great, got a record */</comment>
			<return>return <expr><name>record</name></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* No valid record available from this source */</comment>
			<expr_stmt><expr><name>lastSourceFailed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * If archive recovery was requested, but we were still doing
			 * crash recovery, switch to archive recovery and retry using the
			 * offline archive. We have now replayed all the valid WAL in
			 * pg_wal, so we are presumably now consistent.
			 *
			 * We require that there's at least some valid WAL present in
			 * pg_wal, however (!fetching_ckpt).  We could recover using the
			 * WAL from the archive, even if pg_wal is completely empty, but
			 * we'd have no idea how far we'd have to replay to reach
			 * consistency.  So err on the safe side and give up.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>InArchiveRecovery</name> <operator>&amp;&amp;</operator> <name>ArchiveRecoveryRequested</name> <operator>&amp;&amp;</operator>
				<operator>!</operator><name>fetching_ckpt</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"reached end of WAL in pg_wal, entering archive recovery"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>InArchiveRecovery</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>StandbyModeRequested</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>StandbyMode</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* initialize minRecoveryPoint to this record */</comment>
				<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ControlFileLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>DB_IN_ARCHIVE_RECOVERY</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPoint</name></name> <operator>&lt;</operator> <name>EndRecPtr</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPoint</name></name> <operator>=</operator> <name>EndRecPtr</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPointTLI</name></name> <operator>=</operator> <name>ThisTimeLineID</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* update local copy */</comment>
				<expr_stmt><expr><name>minRecoveryPoint</name> <operator>=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPoint</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>minRecoveryPointTLI</name> <operator>=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPointTLI</name></name></expr>;</expr_stmt>

				<comment type="block">/*
				 * The startup process can update its local copy of
				 * minRecoveryPoint from this point.
				 */</comment>
				<expr_stmt><expr><name>updateMinRecoveryPoint</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>UpdateControlFile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ControlFileLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>CheckRecoveryConsistency</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Before we retry, reset lastSourceFailed and currentSource
				 * so that we will check the archive next.
				 */</comment>
				<expr_stmt><expr><name>lastSourceFailed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>currentSource</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* In standby mode, loop back to retry. Otherwise, give up. */</comment>
			<if_stmt><if>if <condition>(<expr><name>StandbyMode</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>CheckForStandbyTrigger</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Scan for new timelines that might have appeared in the archive since we
 * started recovery.
 *
 * If there are any, the function changes recovery target TLI to the latest
 * one and returns 'true'.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>rescanLatestTimeLine</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newExpectedTLEs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>newtarget</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>oldtarget</name> <init>= <expr><name>recoveryTargetTLI</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineHistoryEntry</name> <modifier>*</modifier></type><name>currentTle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>newtarget</name> <operator>=</operator> <call><name>findNewestTimeLine</name><argument_list>(<argument><expr><name>recoveryTargetTLI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>newtarget</name> <operator>==</operator> <name>recoveryTargetTLI</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No new timelines found */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Determine the list of expected TLIs for the new TLI
	 */</comment>

	<expr_stmt><expr><name>newExpectedTLEs</name> <operator>=</operator> <call><name>readTimeLineHistory</name><argument_list>(<argument><expr><name>newtarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the current timeline is not part of the history of the new timeline,
	 * we cannot proceed to it.
	 */</comment>
	<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>newExpectedTLEs</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>currentTle</name> <operator>=</operator> <operator>(</operator><name>TimeLineHistoryEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>currentTle</name><operator>-&gt;</operator><name>tli</name></name> <operator>==</operator> <name>recoveryTargetTLI</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"new timeline %u is not a child of database system timeline %u"</literal></expr></argument>,
						<argument><expr><name>newtarget</name></expr></argument>,
						<argument><expr><name>ThisTimeLineID</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The current timeline was found in the history file, but check that the
	 * next timeline was forked off from it *after* the current recovery
	 * location.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>currentTle</name><operator>-&gt;</operator><name>end</name></name> <operator>&lt;</operator> <name>EndRecPtr</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"new timeline %u forked off current database system timeline %u before current recovery point %X/%X"</literal></expr></argument>,
						<argument><expr><name>newtarget</name></expr></argument>,
						<argument><expr><name>ThisTimeLineID</name></expr></argument>,
						<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>EndRecPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>EndRecPtr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* The new timeline history seems valid. Switch target */</comment>
	<expr_stmt><expr><name>recoveryTargetTLI</name> <operator>=</operator> <name>newtarget</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>expectedTLEs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>expectedTLEs</name> <operator>=</operator> <name>newExpectedTLEs</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * As in StartupXLOG(), try to ensure we have all the history files
	 * between the old target and new target in pg_wal.
	 */</comment>
	<expr_stmt><expr><call><name>restoreTimeLineHistoryFiles</name><argument_list>(<argument><expr><name>oldtarget</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>newtarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"new target timeline is %u"</literal></expr></argument>,
					<argument><expr><name>recoveryTargetTLI</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * I/O routines for pg_control
 *
 * *ControlFile is a buffer in shared memory that holds an image of the
 * contents of pg_control.  WriteControlFile() initializes pg_control
 * given a preloaded buffer, ReadControlFile() loads the buffer from
 * the pg_control file (during postmaster or standalone-backend startup),
 * and UpdateControlFile() rewrites pg_control after we modify xlog state.
 *
 * For simplicity, WriteControlFile() initializes the fields of pg_control
 * that are related to checking backend/database compatibility, and
 * ReadControlFile() verifies they are correct.  We could split out the
 * I/O and compatibility-check functions, but there seems no need currently.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WriteControlFile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buffer</name><index>[<expr><name>PG_CONTROL_FILE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* need not be aligned */</comment>

	<comment type="block">/*
	 * Ensure that the size of the pg_control data structure is sane.  See the
	 * comments for these symbols in pg_control.h.
	 */</comment>
	<expr_stmt><expr><call><name>StaticAssertStmt</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ControlFileData</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <name>PG_CONTROL_MAX_SAFE_SIZE</name></expr></argument>,
					 <argument><expr><literal type="string">"pg_control is too large for atomic disk writes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>StaticAssertStmt</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ControlFileData</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <name>PG_CONTROL_FILE_SIZE</name></expr></argument>,
					 <argument><expr><literal type="string">"sizeof(ControlFileData) exceeds PG_CONTROL_FILE_SIZE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize version and compatibility-check fields
	 */</comment>
	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>pg_control_version</name></name> <operator>=</operator> <name>PG_CONTROL_VERSION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>catalog_version_no</name></name> <operator>=</operator> <name>CATALOG_VERSION_NO</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>maxAlign</name></name> <operator>=</operator> <name>MAXIMUM_ALIGNOF</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>floatFormat</name></name> <operator>=</operator> <name>FLOATFORMAT_VALUE</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>blcksz</name></name> <operator>=</operator> <name>BLCKSZ</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>relseg_size</name></name> <operator>=</operator> <name>RELSEG_SIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>xlog_blcksz</name></name> <operator>=</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>xlog_seg_size</name></name> <operator>=</operator> <name>wal_segment_size</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>nameDataLen</name></name> <operator>=</operator> <name>NAMEDATALEN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>indexMaxKeys</name></name> <operator>=</operator> <name>INDEX_MAX_KEYS</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>toast_max_chunk_size</name></name> <operator>=</operator> <name>TOAST_MAX_CHUNK_SIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>loblksize</name></name> <operator>=</operator> <name>LOBLKSIZE</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>float4ByVal</name></name> <operator>=</operator> <name>FLOAT4PASSBYVAL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>float8ByVal</name></name> <operator>=</operator> <name>FLOAT8PASSBYVAL</name></expr>;</expr_stmt>

	<comment type="block">/* Contents are protected with a CRC */</comment>
	<expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>crc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>crc</name></name></expr></argument>,
				<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>ControlFile</name></expr></argument>,
				<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ControlFileData</name></expr></argument>, <argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>crc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We write out PG_CONTROL_FILE_SIZE bytes into pg_control, zero-padding
	 * the excess over sizeof(ControlFileData).  This reduces the odds of
	 * premature-EOF errors when reading pg_control.  We'll still fail when we
	 * check the contents of the file, but hopefully with a more specific
	 * error than "couldn't read pg_control".
	 */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>PG_CONTROL_FILE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>ControlFile</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ControlFileData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>BasicOpenFile</name><argument_list>(<argument><expr><name>XLOG_CONTROL_FILE</name></expr></argument>,
					   <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>O_EXCL</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create control file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>XLOG_CONTROL_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_CONTROL_FILE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>PG_CONTROL_FILE_SIZE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PG_CONTROL_FILE_SIZE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOSPC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to control file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_CONTROL_FILE_SYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pg_fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fsync control file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close control file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReadControlFile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pg_crc32c</name></type>	<name>crc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>wal_segsz_str</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Read data...
	 */</comment>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>BasicOpenFile</name><argument_list>(<argument><expr><name>XLOG_CONTROL_FILE</name></expr></argument>,
					   <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open control file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>XLOG_CONTROL_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_CONTROL_FILE_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>ControlFile</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ControlFileData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ControlFileData</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from control file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from control file: read %d bytes, expected %d"</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ControlFileData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check for expected pg_control format version.  If this is wrong, the
	 * CRC check will likely fail because we'll be checking the wrong number
	 * of bytes.  Complaining about wrong version will probably be more
	 * enlightening than complaining about wrong CRC.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>pg_control_version</name></name> <operator>!=</operator> <name>PG_CONTROL_VERSION</name> <operator>&amp;&amp;</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>pg_control_version</name></name> <operator>%</operator> <literal type="number">65536</literal> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>pg_control_version</name></name> <operator>/</operator> <literal type="number">65536</literal> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database files are incompatible with server"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The database cluster was initialized with PG_CONTROL_VERSION %d (0x%08x),"</literal>
						   <literal type="string">" but the server was compiled with PG_CONTROL_VERSION %d (0x%08x)."</literal></expr></argument>,
						   <argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>pg_control_version</name></name></expr></argument>, <argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>pg_control_version</name></name></expr></argument>,
						   <argument><expr><name>PG_CONTROL_VERSION</name></expr></argument>, <argument><expr><name>PG_CONTROL_VERSION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"This could be a problem of mismatched byte ordering.  It looks like you need to initdb."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>pg_control_version</name></name> <operator>!=</operator> <name>PG_CONTROL_VERSION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database files are incompatible with server"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The database cluster was initialized with PG_CONTROL_VERSION %d,"</literal>
						   <literal type="string">" but the server was compiled with PG_CONTROL_VERSION %d."</literal></expr></argument>,
						   <argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>pg_control_version</name></name></expr></argument>, <argument><expr><name>PG_CONTROL_VERSION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"It looks like you need to initdb."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Now check the CRC. */</comment>
	<expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>,
				<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>ControlFile</name></expr></argument>,
				<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ControlFileData</name></expr></argument>, <argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EQ_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>, <argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>crc</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"incorrect checksum in control file"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Do compatibility checking immediately.  If the database isn't
	 * compatible with the backend executable, we want to abort before we can
	 * possibly do any damage.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>catalog_version_no</name></name> <operator>!=</operator> <name>CATALOG_VERSION_NO</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database files are incompatible with server"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The database cluster was initialized with CATALOG_VERSION_NO %d,"</literal>
						   <literal type="string">" but the server was compiled with CATALOG_VERSION_NO %d."</literal></expr></argument>,
						   <argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>catalog_version_no</name></name></expr></argument>, <argument><expr><name>CATALOG_VERSION_NO</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"It looks like you need to initdb."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>maxAlign</name></name> <operator>!=</operator> <name>MAXIMUM_ALIGNOF</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database files are incompatible with server"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The database cluster was initialized with MAXALIGN %d,"</literal>
						   <literal type="string">" but the server was compiled with MAXALIGN %d."</literal></expr></argument>,
						   <argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>maxAlign</name></name></expr></argument>, <argument><expr><name>MAXIMUM_ALIGNOF</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"It looks like you need to initdb."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>floatFormat</name></name> <operator>!=</operator> <name>FLOATFORMAT_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database files are incompatible with server"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The database cluster appears to use a different floating-point number format than the server executable."</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"It looks like you need to initdb."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>blcksz</name></name> <operator>!=</operator> <name>BLCKSZ</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database files are incompatible with server"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The database cluster was initialized with BLCKSZ %d,"</literal>
						   <literal type="string">" but the server was compiled with BLCKSZ %d."</literal></expr></argument>,
						   <argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>blcksz</name></name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"It looks like you need to recompile or initdb."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>relseg_size</name></name> <operator>!=</operator> <name>RELSEG_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database files are incompatible with server"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The database cluster was initialized with RELSEG_SIZE %d,"</literal>
						   <literal type="string">" but the server was compiled with RELSEG_SIZE %d."</literal></expr></argument>,
						   <argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>relseg_size</name></name></expr></argument>, <argument><expr><name>RELSEG_SIZE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"It looks like you need to recompile or initdb."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>xlog_blcksz</name></name> <operator>!=</operator> <name>XLOG_BLCKSZ</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database files are incompatible with server"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The database cluster was initialized with XLOG_BLCKSZ %d,"</literal>
						   <literal type="string">" but the server was compiled with XLOG_BLCKSZ %d."</literal></expr></argument>,
						   <argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>xlog_blcksz</name></name></expr></argument>, <argument><expr><name>XLOG_BLCKSZ</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"It looks like you need to recompile or initdb."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>nameDataLen</name></name> <operator>!=</operator> <name>NAMEDATALEN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database files are incompatible with server"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The database cluster was initialized with NAMEDATALEN %d,"</literal>
						   <literal type="string">" but the server was compiled with NAMEDATALEN %d."</literal></expr></argument>,
						   <argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>nameDataLen</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"It looks like you need to recompile or initdb."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>indexMaxKeys</name></name> <operator>!=</operator> <name>INDEX_MAX_KEYS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database files are incompatible with server"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The database cluster was initialized with INDEX_MAX_KEYS %d,"</literal>
						   <literal type="string">" but the server was compiled with INDEX_MAX_KEYS %d."</literal></expr></argument>,
						   <argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>indexMaxKeys</name></name></expr></argument>, <argument><expr><name>INDEX_MAX_KEYS</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"It looks like you need to recompile or initdb."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>toast_max_chunk_size</name></name> <operator>!=</operator> <name>TOAST_MAX_CHUNK_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database files are incompatible with server"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The database cluster was initialized with TOAST_MAX_CHUNK_SIZE %d,"</literal>
						   <literal type="string">" but the server was compiled with TOAST_MAX_CHUNK_SIZE %d."</literal></expr></argument>,
						   <argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>toast_max_chunk_size</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>TOAST_MAX_CHUNK_SIZE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"It looks like you need to recompile or initdb."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>loblksize</name></name> <operator>!=</operator> <name>LOBLKSIZE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database files are incompatible with server"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The database cluster was initialized with LOBLKSIZE %d,"</literal>
						   <literal type="string">" but the server was compiled with LOBLKSIZE %d."</literal></expr></argument>,
						   <argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>loblksize</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>LOBLKSIZE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"It looks like you need to recompile or initdb."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_FLOAT4_BYVAL</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>float4ByVal</name></name> <operator>!=</operator> <name>true</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database files are incompatible with server"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The database cluster was initialized without USE_FLOAT4_BYVAL"</literal>
						   <literal type="string">" but the server was compiled with USE_FLOAT4_BYVAL."</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"It looks like you need to recompile or initdb."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if_stmt><if>if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>float4ByVal</name></name> <operator>!=</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database files are incompatible with server"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The database cluster was initialized with USE_FLOAT4_BYVAL"</literal>
						   <literal type="string">" but the server was compiled without USE_FLOAT4_BYVAL."</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"It looks like you need to recompile or initdb."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_FLOAT8_BYVAL</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>float8ByVal</name></name> <operator>!=</operator> <name>true</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database files are incompatible with server"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The database cluster was initialized without USE_FLOAT8_BYVAL"</literal>
						   <literal type="string">" but the server was compiled with USE_FLOAT8_BYVAL."</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"It looks like you need to recompile or initdb."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if_stmt><if>if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>float8ByVal</name></name> <operator>!=</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database files are incompatible with server"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The database cluster was initialized with USE_FLOAT8_BYVAL"</literal>
						   <literal type="string">" but the server was compiled without USE_FLOAT8_BYVAL."</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"It looks like you need to recompile or initdb."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>wal_segment_size</name> <operator>=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>xlog_seg_size</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsValidWalSegSize</name><argument_list>(<argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg_plural</name><argument_list>(<argument><expr><literal type="string">"WAL segment size must be a power of two between 1 MB and 1 GB, but the control file specifies %d byte"</literal></expr></argument>,
									  <argument><expr><literal type="string">"WAL segment size must be a power of two between 1 MB and 1 GB, but the control file specifies %d bytes"</literal></expr></argument>,
									  <argument><expr><name>wal_segment_size</name></expr></argument>,
									  <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>wal_segsz_str</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>wal_segsz_str</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"wal_segment_size"</literal></expr></argument>, <argument><expr><name>wal_segsz_str</name></expr></argument>, <argument><expr><name>PGC_INTERNAL</name></expr></argument>,
					<argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* check and update variables dependent on wal_segment_size */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ConvertToXSegs</name><argument_list>(<argument><expr><name>min_wal_size_mb</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"min_wal_size\" must be at least twice \"wal_segment_size\""</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ConvertToXSegs</name><argument_list>(<argument><expr><name>max_wal_size_mb</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"max_wal_size\" must be at least twice \"wal_segment_size\""</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>UsableBytesInSegment</name> <operator>=</operator>
		<operator>(</operator><name>wal_segment_size</name> <operator>/</operator> <name>XLOG_BLCKSZ</name> <operator>*</operator> <name>UsableBytesInPage</name><operator>)</operator> <operator>-</operator>
		<operator>(</operator><name>SizeOfXLogLongPHD</name> <operator>-</operator> <name>SizeOfXLogShortPHD</name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CalculateCheckpointSegments</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make the initdb settings visible as GUC variables, too */</comment>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"data_checksums"</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>DataChecksumsEnabled</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"yes"</literal></expr> </then><else>: <expr><literal type="string">"no"</literal></expr></else></ternary></expr></argument>,
					<argument><expr><name>PGC_INTERNAL</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>UpdateControlFile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>crc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>crc</name></name></expr></argument>,
				<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>ControlFile</name></expr></argument>,
				<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ControlFileData</name></expr></argument>, <argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>crc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>BasicOpenFile</name><argument_list>(<argument><expr><name>XLOG_CONTROL_FILE</name></expr></argument>,
					   <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open control file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>XLOG_CONTROL_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_CONTROL_FILE_WRITE_UPDATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>ControlFile</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ControlFileData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ControlFileData</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOSPC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to control file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_CONTROL_FILE_SYNC_UPDATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pg_fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fsync control file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close control file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns the unique system identifier from control file.
 */</comment>
<function><type><name>uint64</name></type>
<name>GetSystemIdentifier</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ControlFile</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>ControlFile</name><operator>-&gt;</operator><name>system_identifier</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns the random nonce from control file.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>GetMockAuthenticationNonce</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ControlFile</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>ControlFile</name><operator>-&gt;</operator><name>mock_authentication_nonce</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Are checksums enabled for data pages?
 */</comment>
<function><type><name>bool</name></type>
<name>DataChecksumsEnabled</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ControlFile</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name><name>ControlFile</name><operator>-&gt;</operator><name>data_checksum_version</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns a fake LSN for unlogged relations.
 *
 * Each call generates an LSN that is greater than any previous value
 * returned. The current counter value is saved and restored across clean
 * shutdowns, but like unlogged relations, does not survive a crash. This can
 * be used in lieu of real LSN values returned by XLogInsert, if you need an
 * LSN-like increasing sequence of numbers without writing any WAL.
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>GetFakeLSNForUnloggedRel</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>nextUnloggedLSN</name></decl>;</decl_stmt>

	<comment type="block">/* increment the unloggedLSN counter, need SpinLock */</comment>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>ulsn_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nextUnloggedLSN</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>unloggedLSN</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>ulsn_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>nextUnloggedLSN</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Auto-tune the number of XLOG buffers.
 *
 * The preferred setting for wal_buffers is about 3% of shared_buffers, with
 * a maximum of one XLOG segment (there is little reason to think that more
 * is helpful, at least so long as we force an fsync when switching log files)
 * and a minimum of 8 blocks (which was the default value prior to PostgreSQL
 * 9.1, when auto-tuning was added).
 *
 * This should not be called until NBuffers has received its final value.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>XLOGChooseNumBuffers</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>xbuffers</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>xbuffers</name> <operator>=</operator> <name>NBuffers</name> <operator>/</operator> <literal type="number">32</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>xbuffers</name> <operator>&gt;</operator> <operator>(</operator><name>wal_segment_size</name> <operator>/</operator> <name>XLOG_BLCKSZ</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>xbuffers</name> <operator>=</operator> <operator>(</operator><name>wal_segment_size</name> <operator>/</operator> <name>XLOG_BLCKSZ</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>xbuffers</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>xbuffers</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>xbuffers</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GUC check_hook for wal_buffers
 */</comment>
<function><type><name>bool</name></type>
<name>check_wal_buffers</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * -1 indicates a request for auto-tune.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>newval</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we haven't yet changed the boot_val default of -1, just let it
		 * be.  We'll fix it when XLOGShmemSize is called.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>XLOGbuffers</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Otherwise, substitute the auto-tune value */</comment>
		<expr_stmt><expr><operator>*</operator><name>newval</name> <operator>=</operator> <call><name>XLOGChooseNumBuffers</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We clamp manually-set values to at least 4 blocks.  Prior to PostgreSQL
	 * 9.1, a minimum of 4 was enforced by guc.c, but since that is no longer
	 * the case, we just silently treat such values as a request for the
	 * minimum.  (We could throw an error instead, but that doesn't seem very
	 * helpful.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>newval</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>newval</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Read the control file, set respective GUCs.
 *
 * This is to be called during startup, including a crash recovery cycle,
 * unless in bootstrap mode, where no control file yet exists.  As there's no
 * usable shared memory yet (its sizing can depend on the contents of the
 * control file!), first store the contents in local memory. XLOGShmemInit()
 * will then copy it to shared memory later.
 *
 * reset just controls whether previous contents are to be expected (in the
 * reset case, there's a dangling pointer into old shared memory), or not.
 */</comment>
<function><type><name>void</name></type>
<name>LocalProcessControlFile</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>reset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>reset</name> <operator>||</operator> <name>ControlFile</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ControlFile</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ControlFileData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReadControlFile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialization of shared memory for XLOG
 */</comment>
<function><type><name>Size</name></type>
<name>XLOGShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the value of wal_buffers is -1, use the preferred auto-tune value.
	 * This isn't an amazingly clean place to do this, but we must wait till
	 * NBuffers has received its final value, and must do it before using the
	 * value of XLOGbuffers to do anything important.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>XLOGbuffers</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><call><name>XLOGChooseNumBuffers</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"wal_buffers"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>XLOGbuffers</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* XLogCtl */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogCtlData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<comment type="block">/* WAL insertion locks, plus alignment */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WALInsertLockPadded</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NUM_XLOGINSERT_LOCKS</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* xlblocks array */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecPtr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>XLOGbuffers</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* extra alignment padding for XLOG I/O buffers */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>XLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* and the buffers themselves */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>XLOG_BLCKSZ</name></expr></argument>, <argument><expr><name>XLOGbuffers</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note: we don't count ControlFileData, it comes out of the "slop factor"
	 * added by CreateSharedMemoryAndSemaphores.  This lets us use this
	 * routine again below to compute the actual allocation size.
	 */</comment>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>XLOGShmemInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>foundCFile</name></decl>,
				<decl><type ref="prev"/><name>foundXLog</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>allocptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ControlFileData</name> <modifier>*</modifier></type><name>localControlFile</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WAL_DEBUG</name></cpp:ifdef>

	<comment type="block">/*
	 * Create a memory context for WAL debugging that's exempt from the normal
	 * "no pallocs in critical section" rule. Yes, that can lead to a PANIC if
	 * an allocation fails, but wal_debug is not for production use anyway.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>walDebugCxt</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>walDebugCxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
											<argument><expr><literal type="string">"WAL Debug"</literal></expr></argument>,
											<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextAllowInCriticalSection</name><argument_list>(<argument><expr><name>walDebugCxt</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


	<expr_stmt><expr><name>XLogCtl</name> <operator>=</operator> <operator>(</operator><name>XLogCtlData</name> <operator>*</operator><operator>)</operator>
		<call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"XLOG Ctl"</literal></expr></argument>, <argument><expr><call><name>XLOGShmemSize</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>foundXLog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>localControlFile</name> <operator>=</operator> <name>ControlFile</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ControlFile</name> <operator>=</operator> <operator>(</operator><name>ControlFileData</name> <operator>*</operator><operator>)</operator>
		<call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Control File"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ControlFileData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>foundCFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>foundCFile</name> <operator>||</operator> <name>foundXLog</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* both should be present or neither */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>foundCFile</name> <operator>&amp;&amp;</operator> <name>foundXLog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Initialize local copy of WALInsertLocks and register the tranche */</comment>
		<expr_stmt><expr><name>WALInsertLocks</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>WALInsertLocks</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name>LWTRANCHE_WAL_INSERT</name></expr></argument>,
							  <argument><expr><literal type="string">"wal_insert"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>localControlFile</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>localControlFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>XLogCtl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogCtlData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Already have read control file locally, unless in bootstrap mode. Move
	 * contents into shared memory.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>localControlFile</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ControlFile</name></expr></argument>, <argument><expr><name>localControlFile</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ControlFileData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>localControlFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Since XLogCtlData contains XLogRecPtr fields, its sizeof should be a
	 * multiple of the alignment for same, so no extra alignment padding is
	 * needed here.
	 */</comment>
	<expr_stmt><expr><name>allocptr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>XLogCtl</name><operator>)</operator> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogCtlData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>xlblocks</name></name> <operator>=</operator> <operator>(</operator><name>XLogRecPtr</name> <operator>*</operator><operator>)</operator> <name>allocptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>xlblocks</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecPtr</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>XLOGbuffers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>allocptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecPtr</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>XLOGbuffers</name></expr>;</expr_stmt>


	<comment type="block">/* WAL insertion locks. Ensure they're aligned to the full padded size */</comment>
	<expr_stmt><expr><name>allocptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WALInsertLockPadded</name></expr></argument>)</argument_list></sizeof> <operator>-</operator>
		<operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator> <name>allocptr</name><operator>)</operator> <operator>%</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WALInsertLockPadded</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>WALInsertLocks</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>WALInsertLocks</name></name> <operator>=</operator>
		<operator>(</operator><name>WALInsertLockPadded</name> <operator>*</operator><operator>)</operator> <name>allocptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>allocptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WALInsertLockPadded</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>NUM_XLOGINSERT_LOCKS</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name>LWTRANCHE_WAL_INSERT</name></expr></argument>, <argument><expr><literal type="string">"wal_insert"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_XLOGINSERT_LOCKS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>WALInsertLocks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>l</name><operator>.</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LWTRANCHE_WAL_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>WALInsertLocks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>l</name><operator>.</operator><name>insertingAt</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>WALInsertLocks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>l</name><operator>.</operator><name>lastImportantAt</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Align the start of the page buffers to a full xlog block size boundary.
	 * This simplifies some calculations in XLOG insertion. It is also
	 * required for O_DIRECT.
	 */</comment>
	<expr_stmt><expr><name>allocptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>TYPEALIGN</name><argument_list>(<argument><expr><name>XLOG_BLCKSZ</name></expr></argument>, <argument><expr><name>allocptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>pages</name></name> <operator>=</operator> <name>allocptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>pages</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>Size</name><operator>)</operator> <name>XLOG_BLCKSZ</name> <operator>*</operator> <name>XLOGbuffers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do basic initialization of XLogCtl shared data. (StartupXLOG will fill
	 * in additional info.)
	 */</comment>
	<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>XLogCacheBlck</name></name> <operator>=</operator> <name>XLOGbuffers</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>SharedRecoveryInProgress</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>SharedHotStandbyActive</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>WalWriterSleeping</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>insertpos_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>ulsn_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitSharedLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>recoveryWakeupLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This func must be called ONCE on system install.  It creates pg_control
 * and the initial XLOG segment.
 */</comment>
<function><type><name>void</name></type>
<name>BootStrapXLOG</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CheckPoint</name></type>	<name>checkPoint</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogPageHeader</name></type> <name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogLongPageHeader</name></type> <name>longpage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>recptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>use_existent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>sysidentifier</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>mock_auth_nonce</name><index>[<expr><name>MOCK_AUTH_NONCE_LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_crc32c</name></type>	<name>crc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Select a hopefully-unique system identifier code for this installation.
	 * We use the result of gettimeofday(), including the fractional seconds
	 * field, as being about as unique as we can easily get.  (Think not to
	 * use random(), since it hasn't been seeded and there's no portable way
	 * to seed it other than the system clock value...)  The upper half of the
	 * uint64 value is just the tv_sec part, while the lower half contains the
	 * tv_usec part (which must fit in 20 bits), plus 12 bits from our current
	 * PID for a little extra uniqueness.  A person knowing this encoding can
	 * determine the initialization time of the installation, which could
	 * perhaps be useful sometimes.
	 */</comment>
	<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sysidentifier</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <name><name>tv</name><operator>.</operator><name>tv_sec</name></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">32</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>sysidentifier</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <name><name>tv</name><operator>.</operator><name>tv_usec</name></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">12</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>sysidentifier</name> <operator>|=</operator> <call><name>getpid</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <literal type="number">0xFFF</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Generate a random nonce. This is used for authentication requests that
	 * will fail because the user does not exist. The nonce is used to create
	 * a genuine-looking password challenge for the non-existent user, in lieu
	 * of an actual stored password.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_backend_random</name><argument_list>(<argument><expr><name>mock_auth_nonce</name></expr></argument>, <argument><expr><name>MOCK_AUTH_NONCE_LEN</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not generate secret authorization token"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* First timeline ID is always 1 */</comment>
	<expr_stmt><expr><name>ThisTimeLineID</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* page buffer must be aligned suitably for O_DIRECT */</comment>
	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>XLOG_BLCKSZ</name> <operator>+</operator> <name>XLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>XLogPageHeader</name><operator>)</operator> <call><name>TYPEALIGN</name><argument_list>(<argument><expr><name>XLOG_BLCKSZ</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>XLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up information for the initial checkpoint record
	 *
	 * The initial checkpoint record is written to the beginning of the WAL
	 * segment with logid=0 logseg=1. The very first WAL segment, 0/0, is not
	 * used, so that we can use 0/0 to mean "before any valid WAL segment".
	 */</comment>
	<expr_stmt><expr><name><name>checkPoint</name><operator>.</operator><name>redo</name></name> <operator>=</operator> <name>wal_segment_size</name> <operator>+</operator> <name>SizeOfXLogLongPHD</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkPoint</name><operator>.</operator><name>ThisTimeLineID</name></name> <operator>=</operator> <name>ThisTimeLineID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkPoint</name><operator>.</operator><name>PrevTimeLineID</name></name> <operator>=</operator> <name>ThisTimeLineID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkPoint</name><operator>.</operator><name>fullPageWrites</name></name> <operator>=</operator> <name>fullPageWrites</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkPoint</name><operator>.</operator><name>nextXidEpoch</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkPoint</name><operator>.</operator><name>nextXid</name></name> <operator>=</operator> <name>FirstNormalTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkPoint</name><operator>.</operator><name>nextOid</name></name> <operator>=</operator> <name>FirstBootstrapObjectId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkPoint</name><operator>.</operator><name>nextMulti</name></name> <operator>=</operator> <name>FirstMultiXactId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkPoint</name><operator>.</operator><name>nextMultiOffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkPoint</name><operator>.</operator><name>oldestXid</name></name> <operator>=</operator> <name>FirstNormalTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkPoint</name><operator>.</operator><name>oldestXidDB</name></name> <operator>=</operator> <name>TemplateDbOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkPoint</name><operator>.</operator><name>oldestMulti</name></name> <operator>=</operator> <name>FirstMultiXactId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkPoint</name><operator>.</operator><name>oldestMultiDB</name></name> <operator>=</operator> <name>TemplateDbOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkPoint</name><operator>.</operator><name>oldestCommitTsXid</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkPoint</name><operator>.</operator><name>newestCommitTsXid</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkPoint</name><operator>.</operator><name>time</name></name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkPoint</name><operator>.</operator><name>oldestActiveXid</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name> <operator>=</operator> <name><name>checkPoint</name><operator>.</operator><name>nextXid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextOid</name></name> <operator>=</operator> <name><name>checkPoint</name><operator>.</operator><name>nextOid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oidCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MultiXactSetNextMXact</name><argument_list>(<argument><expr><name><name>checkPoint</name><operator>.</operator><name>nextMulti</name></name></expr></argument>, <argument><expr><name><name>checkPoint</name><operator>.</operator><name>nextMultiOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AdvanceOldestClogXid</name><argument_list>(<argument><expr><name><name>checkPoint</name><operator>.</operator><name>oldestXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetTransactionIdLimit</name><argument_list>(<argument><expr><name><name>checkPoint</name><operator>.</operator><name>oldestXid</name></name></expr></argument>, <argument><expr><name><name>checkPoint</name><operator>.</operator><name>oldestXidDB</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetMultiXactIdLimit</name><argument_list>(<argument><expr><name><name>checkPoint</name><operator>.</operator><name>oldestMulti</name></name></expr></argument>, <argument><expr><name><name>checkPoint</name><operator>.</operator><name>oldestMultiDB</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetCommitTsLimit</name><argument_list>(<argument><expr><name>InvalidTransactionId</name></expr></argument>, <argument><expr><name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up the XLOG page header */</comment>
	<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>xlp_magic</name></name> <operator>=</operator> <name>XLOG_PAGE_MAGIC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>xlp_info</name></name> <operator>=</operator> <name>XLP_LONG_HEADER</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>xlp_tli</name></name> <operator>=</operator> <name>ThisTimeLineID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>xlp_pageaddr</name></name> <operator>=</operator> <name>wal_segment_size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>longpage</name> <operator>=</operator> <operator>(</operator><name>XLogLongPageHeader</name><operator>)</operator> <name>page</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>longpage</name><operator>-&gt;</operator><name>xlp_sysid</name></name> <operator>=</operator> <name>sysidentifier</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>longpage</name><operator>-&gt;</operator><name>xlp_seg_size</name></name> <operator>=</operator> <name>wal_segment_size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>longpage</name><operator>-&gt;</operator><name>xlp_xlog_blcksz</name></name> <operator>=</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt>

	<comment type="block">/* Insert the initial checkpoint record */</comment>
	<expr_stmt><expr><name>recptr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>page</name> <operator>+</operator> <name>SizeOfXLogLongPHD</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>record</name> <operator>=</operator> <operator>(</operator><name>XLogRecord</name> <operator>*</operator><operator>)</operator> <name>recptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>xl_prev</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>xl_xid</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>xl_tot_len</name></name> <operator>=</operator> <name>SizeOfXLogRecord</name> <operator>+</operator> <name>SizeOfXLogRecordDataHeaderShort</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>checkPoint</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>xl_info</name></name> <operator>=</operator> <name>XLOG_CHECKPOINT_SHUTDOWN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>xl_rmid</name></name> <operator>=</operator> <name>RM_XLOG_ID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>recptr</name> <operator>+=</operator> <name>SizeOfXLogRecord</name></expr>;</expr_stmt>
	<comment type="block">/* fill the XLogRecordDataHeaderShort struct */</comment>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><name>recptr</name><operator>++</operator><operator>)</operator> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator> <name>XLR_BLOCK_ID_DATA_SHORT</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><name>recptr</name><operator>++</operator><operator>)</operator> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>checkPoint</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>checkPoint</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>checkPoint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>recptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>checkPoint</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>recptr</name> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>record</name> <operator>==</operator> <name><name>record</name><operator>-&gt;</operator><name>xl_tot_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>record</name><operator>)</operator> <operator>+</operator> <name>SizeOfXLogRecord</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>xl_tot_len</name></name> <operator>-</operator> <name>SizeOfXLogRecord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>XLogRecord</name></expr></argument>, <argument><expr><name>xl_crc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>xl_crc</name></name> <operator>=</operator> <name>crc</name></expr>;</expr_stmt>

	<comment type="block">/* Create first XLOG segment file */</comment>
	<expr_stmt><expr><name>use_existent</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>openLogFile</name> <operator>=</operator> <call><name>XLogFileInit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>use_existent</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Write the first page with the initial record */</comment>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_WAL_BOOTSTRAP_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name>openLogFile</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>XLOG_BLCKSZ</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XLOG_BLCKSZ</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOSPC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write bootstrap write-ahead log file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_WAL_BOOTSTRAP_SYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pg_fsync</name><argument_list>(<argument><expr><name>openLogFile</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fsync bootstrap write-ahead log file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>close</name><argument_list>(<argument><expr><name>openLogFile</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close bootstrap write-ahead log file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>openLogFile</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* Now create pg_control */</comment>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ControlFile</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ControlFileData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Initialize pg_control status fields */</comment>
	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>system_identifier</name></name> <operator>=</operator> <name>sysidentifier</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>mock_authentication_nonce</name></name></expr></argument>, <argument><expr><name>mock_auth_nonce</name></expr></argument>, <argument><expr><name>MOCK_AUTH_NONCE_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>DB_SHUTDOWNED</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <name><name>checkPoint</name><operator>.</operator><name>time</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>checkPoint</name></name> <operator>=</operator> <name><name>checkPoint</name><operator>.</operator><name>redo</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>checkPointCopy</name></name> <operator>=</operator> <name>checkPoint</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>unloggedLSN</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* Set important parameter values for use when replaying WAL */</comment>
	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>MaxConnections</name></name> <operator>=</operator> <name>MaxConnections</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>max_worker_processes</name></name> <operator>=</operator> <name>max_worker_processes</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>max_prepared_xacts</name></name> <operator>=</operator> <name>max_prepared_xacts</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>max_locks_per_xact</name></name> <operator>=</operator> <name>max_locks_per_xact</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>wal_level</name></name> <operator>=</operator> <name>wal_level</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>wal_log_hints</name></name> <operator>=</operator> <name>wal_log_hints</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>track_commit_timestamp</name></name> <operator>=</operator> <name>track_commit_timestamp</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>data_checksum_version</name></name> <operator>=</operator> <name>bootstrap_data_checksum_version</name></expr>;</expr_stmt>

	<comment type="block">/* some additional ControlFile fields are set in WriteControlFile() */</comment>

	<expr_stmt><expr><call><name>WriteControlFile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Bootstrap the commit log, too */</comment>
	<expr_stmt><expr><call><name>BootStrapCLOG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BootStrapCommitTs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BootStrapSUBTRANS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BootStrapMultiXact</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Force control file to be read - in contrast to normal processing we'd
	 * otherwise never run the checks and GUC related initializations therein.
	 */</comment>
	<expr_stmt><expr><call><name>ReadControlFile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>str_time</name><parameter_list>(<parameter><decl><type><name>pg_time_t</name></type> <name>tnow</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pg_strftime</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				<argument><expr><literal type="string">"%Y-%m-%d %H:%M:%S %Z"</literal></expr></argument>,
				<argument><expr><call><name>pg_localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tnow</name></expr></argument>, <argument><expr><name>log_timezone</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * See if there is a recovery command file (recovery.conf), and if so
 * read in parameters for archive recovery and XLOG streaming.
 *
 * The file is parsed using the main configuration parser.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>readRecoveryCommandFile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>rtli</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>rtliGiven</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConfigVariable</name> <modifier>*</modifier></type><name>item</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>head</name> <init>= <expr><name>NULL</name></expr></init></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tail</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>recoveryTargetActionSet</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>RECOVERY_COMMAND_FILE</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>				<comment type="block">/* not there, so no archive recovery */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open recovery command file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>RECOVERY_COMMAND_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Since we're asking ParseConfigFp() to report errors as FATAL, there's
	 * no need to check the return value.
	 */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>ParseConfigFp</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>RECOVERY_COMMAND_FILE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>head</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>item</name> <operator>=</operator> <name>head</name></expr>;</init> <condition><expr><name>item</name></expr>;</condition> <incr><expr><name>item</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"restore_command"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>recoveryRestoreCommand</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"restore_command = '%s'"</literal></expr></argument>,
									 <argument><expr><name>recoveryRestoreCommand</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"recovery_end_command"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>recoveryEndCommand</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"recovery_end_command = '%s'"</literal></expr></argument>,
									 <argument><expr><name>recoveryEndCommand</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"archive_cleanup_command"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>archiveCleanupCommand</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"archive_cleanup_command = '%s'"</literal></expr></argument>,
									 <argument><expr><name>archiveCleanupCommand</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"recovery_target_action"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"pause"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>recoveryTargetAction</name> <operator>=</operator> <name>RECOVERY_TARGET_ACTION_PAUSE</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"promote"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>recoveryTargetAction</name> <operator>=</operator> <name>RECOVERY_TARGET_ACTION_PROMOTE</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"shutdown"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>recoveryTargetAction</name> <operator>=</operator> <name>RECOVERY_TARGET_ACTION_SHUTDOWN</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid value for recovery parameter \"%s\": \"%s\""</literal></expr></argument>,
								<argument><expr><literal type="string">"recovery_target_action"</literal></expr></argument>,
								<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Valid values are \"pause\", \"promote\", and \"shutdown\"."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"recovery_target_action = '%s'"</literal></expr></argument>,
									 <argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>recoveryTargetActionSet</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"recovery_target_timeline"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>rtliGiven</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"latest"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>rtli</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>rtli</name> <operator>=</operator> <operator>(</operator><name>TimeLineID</name><operator>)</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINVAL</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"recovery_target_timeline is not a valid number: \"%s\""</literal></expr></argument>,
									<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>rtli</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"recovery_target_timeline = %u"</literal></expr></argument>, <argument><expr><name>rtli</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"recovery_target_timeline = latest"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"recovery_target_xid"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>recoveryTargetXid</name> <operator>=</operator> <operator>(</operator><name>TransactionId</name><operator>)</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINVAL</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"recovery_target_xid is not a valid number: \"%s\""</literal></expr></argument>,
								<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"recovery_target_xid = %u"</literal></expr></argument>,
									 <argument><expr><name>recoveryTargetXid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>recoveryTarget</name> <operator>=</operator> <name>RECOVERY_TARGET_XID</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"recovery_target_time"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>recoveryTarget</name> <operator>=</operator> <name>RECOVERY_TARGET_TIME</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"epoch"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"infinity"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"-infinity"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"now"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"today"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"tomorrow"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"yesterday"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"recovery_target_time is not a valid timestamp: \"%s\""</literal></expr></argument>,
								<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Convert the time string given by the user to TimestampTz form.
			 */</comment>
			<expr_stmt><expr><name>recoveryTargetTime</name> <operator>=</operator>
				<call><name>DatumGetTimestampTz</name><argument_list>(<argument><expr><call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>timestamptz_in</name></expr></argument>,
														<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></argument>,
														<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>,
														<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"recovery_target_time = '%s'"</literal></expr></argument>,
									 <argument><expr><call><name>timestamptz_to_str</name><argument_list>(<argument><expr><name>recoveryTargetTime</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"recovery_target_name"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>recoveryTarget</name> <operator>=</operator> <name>RECOVERY_TARGET_NAME</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>recoveryTargetName</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>recoveryTargetName</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>MAXFNAMELEN</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"recovery_target_name is too long (maximum %d characters)"</literal></expr></argument>,
								<argument><expr><name>MAXFNAMELEN</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"recovery_target_name = '%s'"</literal></expr></argument>,
									 <argument><expr><name>recoveryTargetName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"recovery_target_lsn"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>recoveryTarget</name> <operator>=</operator> <name>RECOVERY_TARGET_LSN</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Convert the LSN string given by the user to XLogRecPtr form.
			 */</comment>
			<expr_stmt><expr><name>recoveryTargetLSN</name> <operator>=</operator>
				<call><name>DatumGetLSN</name><argument_list>(<argument><expr><call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>pg_lsn_in</name></expr></argument>,
												<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"recovery_target_lsn = '%X/%X'"</literal></expr></argument>,
									 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>recoveryTargetLSN</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
									 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>recoveryTargetLSN</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"recovery_target"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"immediate"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>recoveryTarget</name> <operator>=</operator> <name>RECOVERY_TARGET_IMMEDIATE</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid value for recovery parameter \"%s\": \"%s\""</literal></expr></argument>,
								<argument><expr><literal type="string">"recovery_target"</literal></expr></argument>,
								<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The only allowed value is \"immediate\"."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"recovery_target = '%s'"</literal></expr></argument>,
									 <argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"recovery_target_inclusive"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * does nothing if a recovery_target is not also set
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_bool</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>recoveryTargetInclusive</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" requires a Boolean value"</literal></expr></argument>,
								<argument><expr><literal type="string">"recovery_target_inclusive"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"recovery_target_inclusive = %s"</literal></expr></argument>,
									 <argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"standby_mode"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_bool</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>StandbyModeRequested</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" requires a Boolean value"</literal></expr></argument>,
								<argument><expr><literal type="string">"standby_mode"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"standby_mode = '%s'"</literal></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"primary_conninfo"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>PrimaryConnInfo</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"primary_conninfo = '%s'"</literal></expr></argument>,
									 <argument><expr><name>PrimaryConnInfo</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"primary_slot_name"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReplicationSlotValidateName</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>PrimarySlotName</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"primary_slot_name = '%s'"</literal></expr></argument>,
									 <argument><expr><name>PrimarySlotName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"trigger_file"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>TriggerFile</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"trigger_file = '%s'"</literal></expr></argument>,
									 <argument><expr><name>TriggerFile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"recovery_min_apply_delay"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hintmsg</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_int</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>recovery_min_apply_delay</name></expr></argument>, <argument><expr><name>GUC_UNIT_MS</name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name>hintmsg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" requires a temporal value"</literal></expr></argument>,
								<argument><expr><literal type="string">"recovery_min_apply_delay"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <ternary><condition><expr><name>hintmsg</name></expr> ?</condition><then> <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name>hintmsg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"recovery_min_apply_delay = '%s'"</literal></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized recovery parameter \"%s\""</literal></expr></argument>,
							<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Check for compulsory parameters
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>StandbyModeRequested</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>PrimaryConnInfo</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>recoveryRestoreCommand</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"recovery command file \"%s\" specified neither primary_conninfo nor restore_command"</literal></expr></argument>,
							<argument><expr><name>RECOVERY_COMMAND_FILE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The database server will regularly poll the pg_wal subdirectory to check for files placed there."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>recoveryRestoreCommand</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"recovery command file \"%s\" must specify restore_command when standby mode is not enabled"</literal></expr></argument>,
							<argument><expr><name>RECOVERY_COMMAND_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Override any inconsistent requests. Not that this is a change of
	 * behaviour in 9.5; prior to this we simply ignored a request to pause if
	 * hot_standby = off, which was surprising behaviour.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>recoveryTargetAction</name> <operator>==</operator> <name>RECOVERY_TARGET_ACTION_PAUSE</name> <operator>&amp;&amp;</operator>
		<name>recoveryTargetActionSet</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name>EnableHotStandby</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>recoveryTargetAction</name> <operator>=</operator> <name>RECOVERY_TARGET_ACTION_SHUTDOWN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We don't support standby_mode in standalone backends; that requires
	 * other processes such as the WAL receiver to be alive.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>StandbyModeRequested</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"standby mode is not supported by single-user servers"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Enable fetching from archive recovery area */</comment>
	<expr_stmt><expr><name>ArchiveRecoveryRequested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If user specified recovery_target_timeline, validate it or compute the
	 * "latest" value.  We can't do this until after we've gotten the restore
	 * command and set InArchiveRecovery, because we need to fetch timeline
	 * history files from the archive.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>rtliGiven</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>rtli</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Timeline 1 does not have a history file, all else should */</comment>
			<if_stmt><if>if <condition>(<expr><name>rtli</name> <operator>!=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>existsTimeLineHistory</name><argument_list>(<argument><expr><name>rtli</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"recovery target timeline %u does not exist"</literal></expr></argument>,
								<argument><expr><name>rtli</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>recoveryTargetTLI</name> <operator>=</operator> <name>rtli</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>recoveryTargetIsLatest</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* We start the "latest" search from pg_control's timeline */</comment>
			<expr_stmt><expr><name>recoveryTargetTLI</name> <operator>=</operator> <call><name>findNewestTimeLine</name><argument_list>(<argument><expr><name>recoveryTargetTLI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>recoveryTargetIsLatest</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>FreeConfigVariables</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Exit archive-recovery state
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exitArchiveRecovery</name><parameter_list>(<parameter><decl><type><name>TimeLineID</name></type> <name>endTLI</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>endOfLog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>recoveryPath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>xlogfname</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>endLogSegNo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>startLogSegNo</name></decl>;</decl_stmt>

	<comment type="block">/* we always switch to a new timeline after archive recovery */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>endTLI</name> <operator>!=</operator> <name>ThisTimeLineID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We are no longer in archive recovery state.
	 */</comment>
	<expr_stmt><expr><name>InArchiveRecovery</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update min recovery point one last time.
	 */</comment>
	<expr_stmt><expr><call><name>UpdateMinRecoveryPoint</name><argument_list>(<argument><expr><name>InvalidXLogRecPtr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the ending log segment is still open, close it (to avoid problems on
	 * Windows with trying to rename or delete an open file).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>readFile</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>readFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>readFile</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Calculate the last segment on the old timeline, and the first segment
	 * on the new timeline. If the switch happens in the middle of a segment,
	 * they are the same, but if the switch happens exactly at a segment
	 * boundary, startLogSegNo will be endLogSegNo + 1.
	 */</comment>
	<expr_stmt><expr><call><name>XLByteToPrevSeg</name><argument_list>(<argument><expr><name>endOfLog</name></expr></argument>, <argument><expr><name>endLogSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>endOfLog</name></expr></argument>, <argument><expr><name>startLogSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize the starting WAL segment for the new timeline. If the switch
	 * happens in the middle of a segment, copy data from the last WAL segment
	 * of the old timeline up to the switch point, to the starting WAL segment
	 * on the new timeline.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>endLogSegNo</name> <operator>==</operator> <name>startLogSegNo</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Make a copy of the file on the new timeline.
		 *
		 * Writing WAL isn't allowed yet, so there are no locking
		 * considerations. But we should be just as tense as XLogFileInit to
		 * avoid emplacing a bogus file.
		 */</comment>
		<expr_stmt><expr><call><name>XLogFileCopy</name><argument_list>(<argument><expr><name>endLogSegNo</name></expr></argument>, <argument><expr><name>endTLI</name></expr></argument>, <argument><expr><name>endLogSegNo</name></expr></argument>,
					 <argument><expr><call><name>XLogSegmentOffset</name><argument_list>(<argument><expr><name>endOfLog</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * The switch happened at a segment boundary, so just create the next
		 * segment on the new timeline.
		 */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>use_existent</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>XLogFileInit</name><argument_list>(<argument><expr><name>startLogSegNo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>use_existent</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close log file %s: %m"</literal></expr></argument>,
							<argument><expr><call><name>XLogFileNameP</name><argument_list>(<argument><expr><name>ThisTimeLineID</name></expr></argument>, <argument><expr><name>startLogSegNo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Let's just make real sure there are not .ready or .done flags posted
	 * for the new segment.
	 */</comment>
	<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>xlogfname</name></expr></argument>, <argument><expr><name>ThisTimeLineID</name></expr></argument>, <argument><expr><name>startLogSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogArchiveCleanup</name><argument_list>(<argument><expr><name>xlogfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since there might be a partial WAL segment named RECOVERYXLOG, get rid
	 * of it.
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>recoveryPath</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><name>XLOGDIR</name> <literal type="string">"/RECOVERYXLOG"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>recoveryPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* ignore any error */</comment>

	<comment type="block">/* Get rid of any remaining recovered timeline-history file, too */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>recoveryPath</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><name>XLOGDIR</name> <literal type="string">"/RECOVERYHISTORY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>recoveryPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* ignore any error */</comment>

	<comment type="block">/*
	 * Rename the config file out of the way, so that we don't accidentally
	 * re-enter archive recovery mode in a subsequent crash.
	 */</comment>
	<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>RECOVERY_COMMAND_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>durable_rename</name><argument_list>(<argument><expr><name>RECOVERY_COMMAND_FILE</name></expr></argument>, <argument><expr><name>RECOVERY_COMMAND_DONE</name></expr></argument>, <argument><expr><name>FATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"archive recovery complete"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Extract timestamp from WAL record.
 *
 * If the record contains a timestamp, returns true, and saves the timestamp
 * in *recordXtime. If the record type has no timestamp, returns false.
 * Currently, only transaction commit/abort records and restore points contain
 * timestamps.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>getRecordTimestamp</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name> <modifier>*</modifier></type><name>recordXtime</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>info</name> <init>= <expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>xact_info</name> <init>= <expr><name>info</name> <operator>&amp;</operator> <name>XLOG_XACT_OPMASK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>rmid</name> <init>= <expr><call><name>XLogRecGetRmid</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>rmid</name> <operator>==</operator> <name>RM_XLOG_ID</name> <operator>&amp;&amp;</operator> <name>info</name> <operator>==</operator> <name>XLOG_RESTORE_POINT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>recordXtime</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>xl_restore_point</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>rp_time</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>rmid</name> <operator>==</operator> <name>RM_XACT_ID</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>xact_info</name> <operator>==</operator> <name>XLOG_XACT_COMMIT</name> <operator>||</operator>
							   <name>xact_info</name> <operator>==</operator> <name>XLOG_XACT_COMMIT_PREPARED</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>recordXtime</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>xl_xact_commit</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>xact_time</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>rmid</name> <operator>==</operator> <name>RM_XACT_ID</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>xact_info</name> <operator>==</operator> <name>XLOG_XACT_ABORT</name> <operator>||</operator>
							   <name>xact_info</name> <operator>==</operator> <name>XLOG_XACT_ABORT_PREPARED</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>recordXtime</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>xl_xact_abort</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>xact_time</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * For point-in-time recovery, this function decides whether we want to
 * stop applying the XLOG before the current record.
 *
 * Returns true if we are stopping, false otherwise. If stopping, some
 * information is saved in recoveryStopXid et al for use in annotating the
 * new timeline's history file.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>recoveryStopsBefore</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>stopsHere</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>xact_info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isCommit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>recordXtime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>recordXid</name></decl>;</decl_stmt>

	<comment type="block">/* Check if we should stop as soon as reaching consistency */</comment>
	<if_stmt><if>if <condition>(<expr><name>recoveryTarget</name> <operator>==</operator> <name>RECOVERY_TARGET_IMMEDIATE</name> <operator>&amp;&amp;</operator> <name>reachedConsistency</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"recovery stopping after reaching consistency"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>recoveryStopAfter</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>recoveryStopXid</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>recoveryStopLSN</name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>recoveryStopTime</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>recoveryStopName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Check if target LSN has been reached */</comment>
	<if_stmt><if>if <condition>(<expr><name>recoveryTarget</name> <operator>==</operator> <name>RECOVERY_TARGET_LSN</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name>recoveryTargetInclusive</name> <operator>&amp;&amp;</operator>
		<name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;=</operator> <name>recoveryTargetLSN</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>recoveryStopAfter</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>recoveryStopXid</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>recoveryStopLSN</name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>recoveryStopTime</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>recoveryStopName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"recovery stopping before WAL location (LSN) \"%X/%X\""</literal></expr></argument>,
						<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>recoveryStopLSN</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
						<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>recoveryStopLSN</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Otherwise we only consider stopping before COMMIT or ABORT records. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>XLogRecGetRmid</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RM_XACT_ID</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>xact_info</name> <operator>=</operator> <call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>XLOG_XACT_OPMASK</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>xact_info</name> <operator>==</operator> <name>XLOG_XACT_COMMIT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>isCommit</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>recordXid</name> <operator>=</operator> <call><name>XLogRecGetXid</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>xact_info</name> <operator>==</operator> <name>XLOG_XACT_COMMIT_PREPARED</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xl_xact_commit</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_xact_commit</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>xl_xact_parsed_commit</name></type> <name>parsed</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>isCommit</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ParseCommitRecord</name><argument_list>(<argument><expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>xlrec</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>parsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>recordXid</name> <operator>=</operator> <name><name>parsed</name><operator>.</operator><name>twophase_xid</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>xact_info</name> <operator>==</operator> <name>XLOG_XACT_ABORT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>isCommit</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>recordXid</name> <operator>=</operator> <call><name>XLogRecGetXid</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>xact_info</name> <operator>==</operator> <name>XLOG_XACT_ABORT_PREPARED</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xl_xact_abort</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_xact_abort</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>xl_xact_parsed_abort</name></type> <name>parsed</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>isCommit</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ParseAbortRecord</name><argument_list>(<argument><expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>xlrec</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>parsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>recordXid</name> <operator>=</operator> <name><name>parsed</name><operator>.</operator><name>twophase_xid</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>recoveryTarget</name> <operator>==</operator> <name>RECOVERY_TARGET_XID</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>recoveryTargetInclusive</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * There can be only one transaction end record with this exact
		 * transactionid
		 *
		 * when testing for an xid, we MUST test for equality only, since
		 * transactions are numbered in the order they start, not the order
		 * they complete. A higher numbered xid will complete before you about
		 * 50% of the time...
		 */</comment>
		<expr_stmt><expr><name>stopsHere</name> <operator>=</operator> <operator>(</operator><name>recordXid</name> <operator>==</operator> <name>recoveryTargetXid</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>recoveryTarget</name> <operator>==</operator> <name>RECOVERY_TARGET_TIME</name> <operator>&amp;&amp;</operator>
		<call><name>getRecordTimestamp</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>recordXtime</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * There can be many transactions that share the same commit time, so
		 * we stop after the last one, if we are inclusive, or stop at the
		 * first one if we are exclusive
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>recoveryTargetInclusive</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>stopsHere</name> <operator>=</operator> <operator>(</operator><name>recordXtime</name> <operator>&gt;</operator> <name>recoveryTargetTime</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>stopsHere</name> <operator>=</operator> <operator>(</operator><name>recordXtime</name> <operator>&gt;=</operator> <name>recoveryTargetTime</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>stopsHere</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>recoveryStopAfter</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>recoveryStopXid</name> <operator>=</operator> <name>recordXid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>recoveryStopTime</name> <operator>=</operator> <name>recordXtime</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>recoveryStopLSN</name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>recoveryStopName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>isCommit</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"recovery stopping before commit of transaction %u, time %s"</literal></expr></argument>,
							<argument><expr><name>recoveryStopXid</name></expr></argument>,
							<argument><expr><call><name>timestamptz_to_str</name><argument_list>(<argument><expr><name>recoveryStopTime</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"recovery stopping before abort of transaction %u, time %s"</literal></expr></argument>,
							<argument><expr><name>recoveryStopXid</name></expr></argument>,
							<argument><expr><call><name>timestamptz_to_str</name><argument_list>(<argument><expr><name>recoveryStopTime</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>stopsHere</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Same as recoveryStopsBefore, but called after applying the record.
 *
 * We also track the timestamp of the latest applied COMMIT/ABORT
 * record in XLogCtl-&gt;recoveryLastXTime.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>recoveryStopsAfter</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>xact_info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>rmid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>recordXtime</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rmid</name> <operator>=</operator> <call><name>XLogRecGetRmid</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * There can be many restore points that share the same name; we stop at
	 * the first one.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>recoveryTarget</name> <operator>==</operator> <name>RECOVERY_TARGET_NAME</name> <operator>&amp;&amp;</operator>
		<name>rmid</name> <operator>==</operator> <name>RM_XLOG_ID</name> <operator>&amp;&amp;</operator> <name>info</name> <operator>==</operator> <name>XLOG_RESTORE_POINT</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xl_restore_point</name> <modifier>*</modifier></type><name>recordRestorePointData</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>recordRestorePointData</name> <operator>=</operator> <operator>(</operator><name>xl_restore_point</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>recordRestorePointData</name><operator>-&gt;</operator><name>rp_name</name></name></expr></argument>, <argument><expr><name>recoveryTargetName</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>recoveryStopAfter</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>recoveryStopXid</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>recoveryStopLSN</name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>getRecordTimestamp</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>recoveryStopTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>recoveryStopName</name></expr></argument>, <argument><expr><name><name>recordRestorePointData</name><operator>-&gt;</operator><name>rp_name</name></name></expr></argument>, <argument><expr><name>MAXFNAMELEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"recovery stopping at restore point \"%s\", time %s"</literal></expr></argument>,
							<argument><expr><name>recoveryStopName</name></expr></argument>,
							<argument><expr><call><name>timestamptz_to_str</name><argument_list>(<argument><expr><name>recoveryStopTime</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Check if the target LSN has been reached */</comment>
	<if_stmt><if>if <condition>(<expr><name>recoveryTarget</name> <operator>==</operator> <name>RECOVERY_TARGET_LSN</name> <operator>&amp;&amp;</operator>
		<name>recoveryTargetInclusive</name> <operator>&amp;&amp;</operator>
		<name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;=</operator> <name>recoveryTargetLSN</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>recoveryStopAfter</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>recoveryStopXid</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>recoveryStopLSN</name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>recoveryStopTime</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>recoveryStopName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"recovery stopping after WAL location (LSN) \"%X/%X\""</literal></expr></argument>,
						<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>recoveryStopLSN</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
						<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>recoveryStopLSN</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>rmid</name> <operator>!=</operator> <name>RM_XACT_ID</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>xact_info</name> <operator>=</operator> <name>info</name> <operator>&amp;</operator> <name>XLOG_XACT_OPMASK</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>xact_info</name> <operator>==</operator> <name>XLOG_XACT_COMMIT</name> <operator>||</operator>
		<name>xact_info</name> <operator>==</operator> <name>XLOG_XACT_COMMIT_PREPARED</name> <operator>||</operator>
		<name>xact_info</name> <operator>==</operator> <name>XLOG_XACT_ABORT</name> <operator>||</operator>
		<name>xact_info</name> <operator>==</operator> <name>XLOG_XACT_ABORT_PREPARED</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>recordXid</name></decl>;</decl_stmt>

		<comment type="block">/* Update the last applied transaction timestamp */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>getRecordTimestamp</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>recordXtime</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SetLatestXTime</name><argument_list>(<argument><expr><name>recordXtime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Extract the XID of the committed/aborted transaction */</comment>
		<if_stmt><if>if <condition>(<expr><name>xact_info</name> <operator>==</operator> <name>XLOG_XACT_COMMIT_PREPARED</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>xl_xact_commit</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_xact_commit</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>xl_xact_parsed_commit</name></type> <name>parsed</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ParseCommitRecord</name><argument_list>(<argument><expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>xlrec</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>parsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>recordXid</name> <operator>=</operator> <name><name>parsed</name><operator>.</operator><name>twophase_xid</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>xact_info</name> <operator>==</operator> <name>XLOG_XACT_ABORT_PREPARED</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>xl_xact_abort</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_xact_abort</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>xl_xact_parsed_abort</name></type> <name>parsed</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ParseAbortRecord</name><argument_list>(<argument><expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>xlrec</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>parsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>recordXid</name> <operator>=</operator> <name><name>parsed</name><operator>.</operator><name>twophase_xid</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>recordXid</name> <operator>=</operator> <call><name>XLogRecGetXid</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * There can be only one transaction end record with this exact
		 * transactionid
		 *
		 * when testing for an xid, we MUST test for equality only, since
		 * transactions are numbered in the order they start, not the order
		 * they complete. A higher numbered xid will complete before you about
		 * 50% of the time...
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>recoveryTarget</name> <operator>==</operator> <name>RECOVERY_TARGET_XID</name> <operator>&amp;&amp;</operator> <name>recoveryTargetInclusive</name> <operator>&amp;&amp;</operator>
			<name>recordXid</name> <operator>==</operator> <name>recoveryTargetXid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>recoveryStopAfter</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>recoveryStopXid</name> <operator>=</operator> <name>recordXid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>recoveryStopTime</name> <operator>=</operator> <name>recordXtime</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>recoveryStopLSN</name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>recoveryStopName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>xact_info</name> <operator>==</operator> <name>XLOG_XACT_COMMIT</name> <operator>||</operator>
				<name>xact_info</name> <operator>==</operator> <name>XLOG_XACT_COMMIT_PREPARED</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"recovery stopping after commit of transaction %u, time %s"</literal></expr></argument>,
								<argument><expr><name>recoveryStopXid</name></expr></argument>,
								<argument><expr><call><name>timestamptz_to_str</name><argument_list>(<argument><expr><name>recoveryStopTime</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>xact_info</name> <operator>==</operator> <name>XLOG_XACT_ABORT</name> <operator>||</operator>
					 <name>xact_info</name> <operator>==</operator> <name>XLOG_XACT_ABORT_PREPARED</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"recovery stopping after abort of transaction %u, time %s"</literal></expr></argument>,
								<argument><expr><name>recoveryStopXid</name></expr></argument>,
								<argument><expr><call><name>timestamptz_to_str</name><argument_list>(<argument><expr><name>recoveryStopTime</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Check if we should stop as soon as reaching consistency */</comment>
	<if_stmt><if>if <condition>(<expr><name>recoveryTarget</name> <operator>==</operator> <name>RECOVERY_TARGET_IMMEDIATE</name> <operator>&amp;&amp;</operator> <name>reachedConsistency</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"recovery stopping after reaching consistency"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>recoveryStopAfter</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>recoveryStopXid</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>recoveryStopTime</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>recoveryStopLSN</name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>recoveryStopName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Wait until shared recoveryPause flag is cleared.
 *
 * XXX Could also be done with shared latch, avoiding the pg_usleep loop.
 * Probably not worth the trouble though.  This state shouldn't be one that
 * anyone cares about server power consumption in.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>recoveryPausesHere</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Don't pause unless users can connect! */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>LocalHotStandbyActive</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"recovery has paused"</literal></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Execute pg_wal_replay_resume() to continue."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>RecoveryIsPaused</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* 1000 ms */</comment>
		<expr_stmt><expr><call><name>HandleStartupProcInterrupts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>RecoveryIsPaused</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>recoveryPause</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>recoveryPause</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>recoveryPause</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>recoveryPause</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>SetRecoveryPause</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>recoveryPause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>recoveryPause</name></name> <operator>=</operator> <name>recoveryPause</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * When recovery_min_apply_delay is set, we wait long enough to make sure
 * certain record types are applied at least that interval behind the master.
 *
 * Returns true if we waited.
 *
 * Note that the delay is calculated between the WAL record log time and
 * the current time on standby. We would prefer to keep track of when this
 * standby received each WAL record, which would allow a more consistent
 * approach and one not affected by time synchronisation issues, but that
 * is significantly more effort and complexity for little actual gain in
 * usability.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>recoveryApplyDelay</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>xact_info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>xtime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>secs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>microsecs</name></decl>;</decl_stmt>

	<comment type="block">/* nothing to do if no delay configured */</comment>
	<if_stmt><if>if <condition>(<expr><name>recovery_min_apply_delay</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* no delay is applied on a database not yet consistent */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>reachedConsistency</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Is it a COMMIT record?
	 *
	 * We deliberately choose not to delay aborts since they have no effect on
	 * MVCC. We already allow replay of records that don't have a timestamp,
	 * so there is already opportunity for issues caused by early conflicts on
	 * standbys.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>XLogRecGetRmid</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RM_XACT_ID</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>xact_info</name> <operator>=</operator> <call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>XLOG_XACT_OPMASK</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>xact_info</name> <operator>!=</operator> <name>XLOG_XACT_COMMIT</name> <operator>&amp;&amp;</operator>
		<name>xact_info</name> <operator>!=</operator> <name>XLOG_XACT_COMMIT_PREPARED</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getRecordTimestamp</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xtime</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>recoveryDelayUntilTime</name> <operator>=</operator>
		<call><name>TimestampTzPlusMilliseconds</name><argument_list>(<argument><expr><name>xtime</name></expr></argument>, <argument><expr><name>recovery_min_apply_delay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Exit without arming the latch if it's already past time to apply this
	 * record
	 */</comment>
	<expr_stmt><expr><call><name>TimestampDifference</name><argument_list>(<argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>recoveryDelayUntilTime</name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>secs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>microsecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>secs</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>microsecs</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>recoveryWakeupLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* might change the trigger file's location */</comment>
		<expr_stmt><expr><call><name>HandleStartupProcInterrupts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>CheckForStandbyTrigger</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Wait for difference between GetCurrentTimestamp() and
		 * recoveryDelayUntilTime
		 */</comment>
		<expr_stmt><expr><call><name>TimestampDifference</name><argument_list>(<argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>recoveryDelayUntilTime</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>secs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>microsecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* NB: We're ignoring waits below min_apply_delay's resolution. */</comment>
		<if_stmt><if>if <condition>(<expr><name>secs</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>microsecs</name> <operator>/</operator> <literal type="number">1000</literal> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"recovery apply delay %ld seconds, %d milliseconds"</literal></expr></argument>,
			 <argument><expr><name>secs</name></expr></argument>, <argument><expr><name>microsecs</name> <operator>/</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>WaitLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>recoveryWakeupLatch</name></name></expr></argument>,
				  <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_TIMEOUT</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name></expr></argument>,
				  <argument><expr><name>secs</name> <operator>*</operator> <literal type="number">1000L</literal> <operator>+</operator> <name>microsecs</name> <operator>/</operator> <literal type="number">1000</literal></expr></argument>,
				  <argument><expr><name>WAIT_EVENT_RECOVERY_APPLY_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Save timestamp of latest processed commit/abort record.
 *
 * We keep this in XLogCtl, not a simple static variable, so that it can be
 * seen by processes other than the startup process.  Note in particular
 * that CreateRestartPoint is executed in the checkpointer.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SetLatestXTime</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>xtime</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>recoveryLastXTime</name></name> <operator>=</operator> <name>xtime</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch timestamp of latest processed commit/abort record.
 */</comment>
<function><type><name>TimestampTz</name></type>
<name>GetLatestXTime</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>xtime</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>xtime</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>recoveryLastXTime</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>xtime</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Save timestamp of the next chunk of WAL records to apply.
 *
 * We keep this in XLogCtl, not a simple static variable, so that it can be
 * seen by all backends.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SetCurrentChunkStartTime</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>xtime</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>currentChunkStartTime</name></name> <operator>=</operator> <name>xtime</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch timestamp of latest processed commit/abort record.
 * Startup process maintains an accurate local copy in XLogReceiptTime
 */</comment>
<function><type><name>TimestampTz</name></type>
<name>GetCurrentChunkReplayStartTime</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>xtime</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>xtime</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>currentChunkStartTime</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>xtime</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns time of receipt of current chunk of XLOG data, as well as
 * whether it was received from streaming replication or from archives.
 */</comment>
<function><type><name>void</name></type>
<name>GetXLogReceiptTime</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name> <modifier>*</modifier></type><name>rtime</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>fromStream</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * This must be executed in the startup process, since we don't export the
	 * relevant state to shared memory.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>InRecovery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>rtime</name> <operator>=</operator> <name>XLogReceiptTime</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>fromStream</name> <operator>=</operator> <operator>(</operator><name>XLogReceiptSource</name> <operator>==</operator> <name>XLOG_FROM_STREAM</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Note that text field supplied is a parameter name and does not require
 * translation
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RecoveryRequiresIntParameter</name><parameter_list>(<parameter><type><name>param_name</name></type></parameter>, <parameter><type><name>currValue</name></type></parameter>, <parameter><type><name>minValue</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do { \
	if ((currValue) &lt; (minValue)) \
		ereport(ERROR, \
				(errcode(ERRCODE_INVALID_PARAMETER_VALUE), \
				 errmsg("hot standby is not possible because " \
						"%s = %d is a lower setting than on the master server " \
						"(its value was %d)", \
						param_name, \
						currValue, \
						minValue))); \
} while(0)</cpp:value></cpp:define>

<comment type="block">/*
 * Check to see if required parameters are set high enough on this server
 * for various aspects of recovery operation.
 *
 * Note that all the parameters which this function tests need to be
 * listed in Administrator's Overview section in high-availability.sgml.
 * If you change them, don't forget to update the list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CheckRequiredParameterValues</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * For archive recovery, the WAL must be generated with at least 'replica'
	 * wal_level.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ArchiveRecoveryRequested</name> <operator>&amp;&amp;</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>wal_level</name></name> <operator>==</operator> <name>WAL_LEVEL_MINIMAL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"WAL was generated with wal_level=minimal, data may be missing"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"This happens if you temporarily set wal_level=minimal without taking a new base backup."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * For Hot Standby, the WAL must be generated with 'replica' mode, and we
	 * must have at least as many backend slots as the primary.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ArchiveRecoveryRequested</name> <operator>&amp;&amp;</operator> <name>EnableHotStandby</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>wal_level</name></name> <operator>&lt;</operator> <name>WAL_LEVEL_REPLICA</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hot standby is not possible because wal_level was not set to \"replica\" or higher on the master server"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Either set wal_level to \"replica\" on the master, or turn off hot_standby here."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* We ignore autovacuum_max_workers when we make this test. */</comment>
		<expr_stmt><expr><call><name>RecoveryRequiresIntParameter</name><argument_list>(<argument><expr><literal type="string">"max_connections"</literal></expr></argument>,
									 <argument><expr><name>MaxConnections</name></expr></argument>,
									 <argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>MaxConnections</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RecoveryRequiresIntParameter</name><argument_list>(<argument><expr><literal type="string">"max_worker_processes"</literal></expr></argument>,
									 <argument><expr><name>max_worker_processes</name></expr></argument>,
									 <argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>max_worker_processes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RecoveryRequiresIntParameter</name><argument_list>(<argument><expr><literal type="string">"max_prepared_transactions"</literal></expr></argument>,
									 <argument><expr><name>max_prepared_xacts</name></expr></argument>,
									 <argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>max_prepared_xacts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RecoveryRequiresIntParameter</name><argument_list>(<argument><expr><literal type="string">"max_locks_per_transaction"</literal></expr></argument>,
									 <argument><expr><name>max_locks_per_xact</name></expr></argument>,
									 <argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>max_locks_per_xact</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This must be called ONCE during postmaster or standalone-backend startup
 */</comment>
<function><type><name>void</name></type>
<name>StartupXLOG</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogCtlInsert</name> <modifier>*</modifier></type><name>Insert</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CheckPoint</name></type>	<name>checkPoint</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>wasShutdown</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>reachedStopPoint</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>haveBackupLabel</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>haveTblspcMap</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>RecPtr</name></decl>,
				<decl><type ref="prev"/><name>checkPointLoc</name></decl>,
				<decl><type ref="prev"/><name>EndOfLog</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>EndOfLogTLI</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>PrevTimeLineID</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>oldestActiveXID</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>backupEndRequired</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>backupFromStandby</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DBState</name></type>		<name>dbstate_at_startup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>xlogreader</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogPageReadPrivate</name></type> <name>private</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>fast_promoted</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Verify XLOG status looks valid.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>state</name></name> <operator>&lt;</operator> <name>DB_SHUTDOWNED</name> <operator>||</operator>
		<name><name>ControlFile</name><operator>-&gt;</operator><name>state</name></name> <operator>&gt;</operator> <name>DB_IN_PRODUCTION</name> <operator>||</operator>
		<operator>!</operator><call><name>XRecOffIsValid</name><argument_list>(<argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>checkPoint</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"control file contains invalid data"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DB_SHUTDOWNED</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* This is the expected case, so don't be chatty in standalone mode */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><name>IsPostmasterEnvironment</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>NOTICE</name></expr></else></ternary></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database system was shut down at %s"</literal></expr></argument>,
						<argument><expr><call><name>str_time</name><argument_list>(<argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>time</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DB_SHUTDOWNED_IN_RECOVERY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database system was shut down in recovery at %s"</literal></expr></argument>,
						<argument><expr><call><name>str_time</name><argument_list>(<argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>time</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DB_SHUTDOWNING</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database system shutdown was interrupted; last known up at %s"</literal></expr></argument>,
						<argument><expr><call><name>str_time</name><argument_list>(<argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>time</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DB_IN_CRASH_RECOVERY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database system was interrupted while in recovery at %s"</literal></expr></argument>,
						<argument><expr><call><name>str_time</name><argument_list>(<argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>time</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"This probably means that some data is corrupted and"</literal>
						 <literal type="string">" you will have to use the last backup for recovery."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DB_IN_ARCHIVE_RECOVERY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database system was interrupted while in recovery at log time %s"</literal></expr></argument>,
						<argument><expr><call><name>str_time</name><argument_list>(<argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>checkPointCopy</name><operator>.</operator><name>time</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"If this has occurred more than once some data might be corrupted"</literal>
						 <literal type="string">" and you might need to choose an earlier recovery target."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DB_IN_PRODUCTION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database system was interrupted; last known up at %s"</literal></expr></argument>,
						<argument><expr><call><name>str_time</name><argument_list>(<argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>time</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* This is just to allow attaching to startup process with a debugger */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XLOG_REPLAY_DELAY</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DB_SHUTDOWNED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">60000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Verify that pg_wal and pg_wal/archive_status exist.  In cases where
	 * someone has performed a copy for PITR, these directories may have been
	 * excluded and need to be re-created.
	 */</comment>
	<expr_stmt><expr><call><name>ValidateXLOGDirectoryStructure</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we previously crashed, there might be data which we had written,
	 * intending to fsync it, but which we had not actually fsync'd yet.
	 * Therefore, a power failure in the near future might cause earlier
	 * unflushed writes to be lost, even though more recent data written to
	 * disk from here on would be persisted.  To avoid that, fsync the entire
	 * data directory.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DB_SHUTDOWNED</name> <operator>&amp;&amp;</operator>
		<name><name>ControlFile</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DB_SHUTDOWNED_IN_RECOVERY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SyncDataDirectory</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Initialize on the assumption we want to recover to the latest timeline
	 * that's active according to pg_control.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPointTLI</name></name> <operator>&gt;</operator>
		<name><name>ControlFile</name><operator>-&gt;</operator><name>checkPointCopy</name><operator>.</operator><name>ThisTimeLineID</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>recoveryTargetTLI</name> <operator>=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPointTLI</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>recoveryTargetTLI</name> <operator>=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>checkPointCopy</name><operator>.</operator><name>ThisTimeLineID</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Check for recovery control file, and if so set up state for offline
	 * recovery
	 */</comment>
	<expr_stmt><expr><call><name>readRecoveryCommandFile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Save archive_cleanup_command in shared memory so that other processes
	 * can see it.
	 */</comment>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>archiveCleanupCommand</name></name></expr></argument>,
			<argument><expr><ternary><condition><expr><name>archiveCleanupCommand</name></expr> ?</condition><then> <expr><name>archiveCleanupCommand</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
			<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>archiveCleanupCommand</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ArchiveRecoveryRequested</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>StandbyModeRequested</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"entering standby mode"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>recoveryTarget</name> <operator>==</operator> <name>RECOVERY_TARGET_XID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"starting point-in-time recovery to XID %u"</literal></expr></argument>,
							<argument><expr><name>recoveryTargetXid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>recoveryTarget</name> <operator>==</operator> <name>RECOVERY_TARGET_TIME</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"starting point-in-time recovery to %s"</literal></expr></argument>,
							<argument><expr><call><name>timestamptz_to_str</name><argument_list>(<argument><expr><name>recoveryTargetTime</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>recoveryTarget</name> <operator>==</operator> <name>RECOVERY_TARGET_NAME</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"starting point-in-time recovery to \"%s\""</literal></expr></argument>,
							<argument><expr><name>recoveryTargetName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>recoveryTarget</name> <operator>==</operator> <name>RECOVERY_TARGET_LSN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"starting point-in-time recovery to WAL location (LSN) \"%X/%X\""</literal></expr></argument>,
							<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>recoveryTargetLSN</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
							<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>recoveryTargetLSN</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>recoveryTarget</name> <operator>==</operator> <name>RECOVERY_TARGET_IMMEDIATE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"starting point-in-time recovery to earliest consistent point"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"starting archive recovery"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Take ownership of the wakeup latch if we're going to sleep during
	 * recovery.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>StandbyModeRequested</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>OwnLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>recoveryWakeupLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Set up XLOG reader facility */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>private</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogPageReadPrivate</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>xlogreader</name> <operator>=</operator> <call><name>XLogReaderAllocate</name><argument_list>(<argument><expr><name>wal_segment_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>XLogPageRead</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>private</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>xlogreader</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed while allocating a WAL reading processor."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>xlogreader</name><operator>-&gt;</operator><name>system_identifier</name></name> <operator>=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>system_identifier</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate two page buffers dedicated to WAL consistency checks.  We do
	 * it this way, rather than just making static arrays, for two reasons:
	 * (1) no need to waste the storage in most instantiations of the backend;
	 * (2) a static char array isn't guaranteed to have any particular
	 * alignment, whereas palloc() will provide MAXALIGN'd storage.
	 */</comment>
	<expr_stmt><expr><name>replay_image_masked</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>master_image_masked</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>read_backup_label</name><argument_list>(<argument><expr><operator>&amp;</operator><name>checkPointLoc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>backupEndRequired</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>backupFromStandby</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tablespaces</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Archive recovery was requested, and thanks to the backup label
		 * file, we know how far we need to replay to reach consistency. Enter
		 * archive recovery directly.
		 */</comment>
		<expr_stmt><expr><name>InArchiveRecovery</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>StandbyModeRequested</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>StandbyMode</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * When a backup_label file is present, we want to roll forward from
		 * the checkpoint it identifies, rather than using pg_control.
		 */</comment>
		<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>ReadCheckpointRecord</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>, <argument><expr><name>checkPointLoc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>record</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>checkPoint</name></expr></argument>, <argument><expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CheckPoint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>wasShutdown</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>xl_info</name></name> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name><operator>)</operator> <operator>==</operator> <name>XLOG_CHECKPOINT_SHUTDOWN</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"checkpoint record is at %X/%X"</literal></expr></argument>,
							<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>checkPointLoc</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>checkPointLoc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>InRecovery</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* force recovery even if SHUTDOWNED */</comment>

			<comment type="block">/*
			 * Make sure that REDO location exists. This may not be the case
			 * if there was a crash during an online backup, which left a
			 * backup_label around that references a WAL segment that's
			 * already been archived.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>checkPoint</name><operator>.</operator><name>redo</name></name> <operator>&lt;</operator> <name>checkPointLoc</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ReadRecord</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>, <argument><expr><name><name>checkPoint</name><operator>.</operator><name>redo</name></name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find redo location referenced by checkpoint record"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"If you are not restoring from a backup, try removing the file \"%s/backup_label\"."</literal></expr></argument>, <argument><expr><name>DataDir</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not locate required checkpoint record"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"If you are not restoring from a backup, try removing the file \"%s/backup_label\"."</literal></expr></argument>, <argument><expr><name>DataDir</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>wasShutdown</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* read the tablespace_map file if present and create symlinks. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>read_tablespace_map</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tablespaces</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>tablespaces</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>tablespaceinfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>linkloc</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>linkloc</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"pg_tblspc/%s"</literal></expr></argument>, <argument><expr><name><name>ti</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Remove the existing symlink if any and Create the symlink
				 * under PGDATA.
				 */</comment>
				<expr_stmt><expr><call><name>remove_tablespace_symlink</name><argument_list>(<argument><expr><name>linkloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>symlink</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>linkloc</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create symbolic link \"%s\": %m"</literal></expr></argument>,
									<argument><expr><name>linkloc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>

			<comment type="block">/* set flag to delete it later */</comment>
			<expr_stmt><expr><name>haveTblspcMap</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* set flag to delete it later */</comment>
		<expr_stmt><expr><name>haveBackupLabel</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If tablespace_map file is present without backup_label file, there
		 * is no use of such file.  There is no harm in retaining it, but it
		 * is better to get rid of the map file so that we don't have any
		 * redundant file in data directory and it will avoid any sort of
		 * confusion.  It seems prudent though to just rename the file out of
		 * the way rather than delete it completely, also we ignore any error
		 * that occurs in rename operation as even if map file is present
		 * without backup_label file, it is harmless.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>TABLESPACE_MAP</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>TABLESPACE_MAP_OLD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>durable_rename</name><argument_list>(<argument><expr><name>TABLESPACE_MAP</name></expr></argument>, <argument><expr><name>TABLESPACE_MAP_OLD</name></expr></argument>, <argument><expr><name>DEBUG1</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ignoring file \"%s\" because no file \"%s\" exists"</literal></expr></argument>,
								<argument><expr><name>TABLESPACE_MAP</name></expr></argument>, <argument><expr><name>BACKUP_LABEL_FILE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"File \"%s\" was renamed to \"%s\"."</literal></expr></argument>,
								   <argument><expr><name>TABLESPACE_MAP</name></expr></argument>, <argument><expr><name>TABLESPACE_MAP_OLD</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ignoring file \"%s\" because no file \"%s\" exists"</literal></expr></argument>,
								<argument><expr><name>TABLESPACE_MAP</name></expr></argument>, <argument><expr><name>BACKUP_LABEL_FILE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Could not rename file \"%s\" to \"%s\": %m."</literal></expr></argument>,
								   <argument><expr><name>TABLESPACE_MAP</name></expr></argument>, <argument><expr><name>TABLESPACE_MAP_OLD</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * It's possible that archive recovery was requested, but we don't
		 * know how far we need to replay the WAL before we reach consistency.
		 * This can happen for example if a base backup is taken from a
		 * running server using an atomic filesystem snapshot, without calling
		 * pg_start/stop_backup. Or if you just kill a running master server
		 * and put it into archive recovery by creating a recovery.conf file.
		 *
		 * Our strategy in that case is to perform crash recovery first,
		 * replaying all the WAL present in pg_wal, and only enter archive
		 * recovery after that.
		 *
		 * But usually we already know how far we need to replay the WAL (up
		 * to minRecoveryPoint, up to backupEndPoint, or until we see an
		 * end-of-backup record), and we can enter archive recovery directly.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>ArchiveRecoveryRequested</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPoint</name></name> <operator>!=</operator> <name>InvalidXLogRecPtr</name> <operator>||</operator>
			 <name><name>ControlFile</name><operator>-&gt;</operator><name>backupEndRequired</name></name> <operator>||</operator>
			 <name><name>ControlFile</name><operator>-&gt;</operator><name>backupEndPoint</name></name> <operator>!=</operator> <name>InvalidXLogRecPtr</name> <operator>||</operator>
			 <name><name>ControlFile</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DB_SHUTDOWNED</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>InArchiveRecovery</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>StandbyModeRequested</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>StandbyMode</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Get the last valid checkpoint record. */</comment>
		<expr_stmt><expr><name>checkPointLoc</name> <operator>=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>checkPoint</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>RedoStartLSN</name> <operator>=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>checkPointCopy</name><operator>.</operator><name>redo</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>ReadCheckpointRecord</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>, <argument><expr><name>checkPointLoc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>record</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"checkpoint record is at %X/%X"</literal></expr></argument>,
							<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>checkPointLoc</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>checkPointLoc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * We used to attempt to go back to a secondary checkpoint record
			 * here, but only when not in standby_mode. We now just fail if we
			 * can't read the last checkpoint because this allows us to
			 * simplify processing around checkpoints.
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not locate a valid checkpoint record"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>checkPoint</name></expr></argument>, <argument><expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CheckPoint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>wasShutdown</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>xl_info</name></name> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name><operator>)</operator> <operator>==</operator> <name>XLOG_CHECKPOINT_SHUTDOWN</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Clear out any old relcache cache files.  This is *necessary* if we do
	 * any WAL replay, since that would probably result in the cache files
	 * being out of sync with database reality.  In theory we could leave them
	 * in place if the database had been cleanly shut down, but it seems
	 * safest to just remove them always and let them be rebuilt during the
	 * first backend startup.  These files needs to be removed from all
	 * directories including pg_tblspc, however the symlinks are created only
	 * after reading tablespace_map file in case of archive recovery from
	 * backup, so needs to clear old relcache files here after creating
	 * symlinks.
	 */</comment>
	<expr_stmt><expr><call><name>RelationCacheInitFileRemove</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the location of the checkpoint record is not on the expected
	 * timeline in the history of the requested timeline, we cannot proceed:
	 * the backup is not part of the history of the requested timeline.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>expectedTLEs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* was initialized by reading checkpoint
								 * record */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>tliOfPointInHistory</name><argument_list>(<argument><expr><name>checkPointLoc</name></expr></argument>, <argument><expr><name>expectedTLEs</name></expr></argument>)</argument_list></call> <operator>!=</operator>
		<name><name>checkPoint</name><operator>.</operator><name>ThisTimeLineID</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>switchpoint</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * tliSwitchPoint will throw an error if the checkpoint's timeline is
		 * not in expectedTLEs at all.
		 */</comment>
		<expr_stmt><expr><name>switchpoint</name> <operator>=</operator> <call><name>tliSwitchPoint</name><argument_list>(<argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>checkPointCopy</name><operator>.</operator><name>ThisTimeLineID</name></name></expr></argument>, <argument><expr><name>expectedTLEs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"requested timeline %u is not a child of this server's history"</literal></expr></argument>,
						<argument><expr><name>recoveryTargetTLI</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Latest checkpoint is at %X/%X on timeline %u, but in the history of the requested timeline, the server forked off from that timeline at %X/%X."</literal></expr></argument>,
						   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>ControlFile</name><operator>-&gt;</operator><name>checkPoint</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
						   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>checkPoint</name></name></expr></argument>,
						   <argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>checkPointCopy</name><operator>.</operator><name>ThisTimeLineID</name></name></expr></argument>,
						   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>switchpoint</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
						   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>switchpoint</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The min recovery point should be part of the requested timeline's
	 * history, too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPoint</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>tliOfPointInHistory</name><argument_list>(<argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPoint</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>expectedTLEs</name></expr></argument>)</argument_list></call> <operator>!=</operator>
		<name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPointTLI</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"requested timeline %u does not contain minimum recovery point %X/%X on timeline %u"</literal></expr></argument>,
						<argument><expr><name>recoveryTargetTLI</name></expr></argument>,
						<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPoint</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
						<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPoint</name></name></expr></argument>,
						<argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPointTLI</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>LastRec</name> <operator>=</operator> <name>RecPtr</name> <operator>=</operator> <name>checkPointLoc</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"redo record is at %X/%X; shutdown %s"</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>checkPoint</name><operator>.</operator><name>redo</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>checkPoint</name><operator>.</operator><name>redo</name></name></expr></argument>,
							 <argument><expr><ternary><condition><expr><name>wasShutdown</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"next transaction ID: %u:%u; next OID: %u"</literal></expr></argument>,
							 <argument><expr><name><name>checkPoint</name><operator>.</operator><name>nextXidEpoch</name></name></expr></argument>, <argument><expr><name><name>checkPoint</name><operator>.</operator><name>nextXid</name></name></expr></argument>,
							 <argument><expr><name><name>checkPoint</name><operator>.</operator><name>nextOid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"next MultiXactId: %u; next MultiXactOffset: %u"</literal></expr></argument>,
							 <argument><expr><name><name>checkPoint</name><operator>.</operator><name>nextMulti</name></name></expr></argument>, <argument><expr><name><name>checkPoint</name><operator>.</operator><name>nextMultiOffset</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"oldest unfrozen transaction ID: %u, in database %u"</literal></expr></argument>,
							 <argument><expr><name><name>checkPoint</name><operator>.</operator><name>oldestXid</name></name></expr></argument>, <argument><expr><name><name>checkPoint</name><operator>.</operator><name>oldestXidDB</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"oldest MultiXactId: %u, in database %u"</literal></expr></argument>,
							 <argument><expr><name><name>checkPoint</name><operator>.</operator><name>oldestMulti</name></name></expr></argument>, <argument><expr><name><name>checkPoint</name><operator>.</operator><name>oldestMultiDB</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"commit timestamp Xid oldest/newest: %u/%u"</literal></expr></argument>,
							 <argument><expr><name><name>checkPoint</name><operator>.</operator><name>oldestCommitTsXid</name></name></expr></argument>,
							 <argument><expr><name><name>checkPoint</name><operator>.</operator><name>newestCommitTsXid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name><name>checkPoint</name><operator>.</operator><name>nextXid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid next transaction ID"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* initialize shared memory variables from the checkpoint record */</comment>
	<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name> <operator>=</operator> <name><name>checkPoint</name><operator>.</operator><name>nextXid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextOid</name></name> <operator>=</operator> <name><name>checkPoint</name><operator>.</operator><name>nextOid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oidCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MultiXactSetNextMXact</name><argument_list>(<argument><expr><name><name>checkPoint</name><operator>.</operator><name>nextMulti</name></name></expr></argument>, <argument><expr><name><name>checkPoint</name><operator>.</operator><name>nextMultiOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AdvanceOldestClogXid</name><argument_list>(<argument><expr><name><name>checkPoint</name><operator>.</operator><name>oldestXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetTransactionIdLimit</name><argument_list>(<argument><expr><name><name>checkPoint</name><operator>.</operator><name>oldestXid</name></name></expr></argument>, <argument><expr><name><name>checkPoint</name><operator>.</operator><name>oldestXidDB</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetMultiXactIdLimit</name><argument_list>(<argument><expr><name><name>checkPoint</name><operator>.</operator><name>oldestMulti</name></name></expr></argument>, <argument><expr><name><name>checkPoint</name><operator>.</operator><name>oldestMultiDB</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetCommitTsLimit</name><argument_list>(<argument><expr><name><name>checkPoint</name><operator>.</operator><name>oldestCommitTsXid</name></name></expr></argument>,
					 <argument><expr><name><name>checkPoint</name><operator>.</operator><name>newestCommitTsXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>ckptXidEpoch</name></name> <operator>=</operator> <name><name>checkPoint</name><operator>.</operator><name>nextXidEpoch</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>ckptXid</name></name> <operator>=</operator> <name><name>checkPoint</name><operator>.</operator><name>nextXid</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize replication slots, before there's a chance to remove
	 * required resources.
	 */</comment>
	<expr_stmt><expr><call><name>StartupReplicationSlots</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Startup logical state, needs to be setup now so we have proper data
	 * during crash recovery.
	 */</comment>
	<expr_stmt><expr><call><name>StartupReorderBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Startup MultiXact. We need to do this early to be able to replay
	 * truncations.
	 */</comment>
	<expr_stmt><expr><call><name>StartupMultiXact</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Ditto for commit timestamps.  Activate the facility if the setting is
	 * enabled in the control file, as there should be no tracking of commit
	 * timestamps done when the setting was disabled.  This facility can be
	 * started or stopped when replaying a XLOG_PARAMETER_CHANGE record.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>track_commit_timestamp</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>StartupCommitTs</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Recover knowledge about replay progress of known replication partners.
	 */</comment>
	<expr_stmt><expr><call><name>StartupReplicationOrigin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize unlogged LSN. On a clean shutdown, it's restored from the
	 * control file. On recovery, all unlogged relations are blown away, so
	 * the unlogged LSN counter can be reset too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DB_SHUTDOWNED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>unloggedLSN</name></name> <operator>=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>unloggedLSN</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>unloggedLSN</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * We must replay WAL entries using the same TimeLineID they were created
	 * under, so temporarily adopt the TLI indicated by the checkpoint (see
	 * also xlog_redo()).
	 */</comment>
	<expr_stmt><expr><name>ThisTimeLineID</name> <operator>=</operator> <name><name>checkPoint</name><operator>.</operator><name>ThisTimeLineID</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy any missing timeline history files between 'now' and the recovery
	 * target timeline from archive to pg_wal. While we don't need those files
	 * ourselves - the history file of the recovery target timeline covers all
	 * the previous timelines in the history too - a cascading standby server
	 * might be interested in them. Or, if you archive the WAL from this
	 * server to a different archive than the master, it'd be good for all the
	 * history files to get archived there after failover, so that you can use
	 * one of the old timelines as a PITR target. Timeline history files are
	 * small, so it's better to copy them unnecessarily than not copy them and
	 * regret later.
	 */</comment>
	<expr_stmt><expr><call><name>restoreTimeLineHistoryFiles</name><argument_list>(<argument><expr><name>ThisTimeLineID</name></expr></argument>, <argument><expr><name>recoveryTargetTLI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Before running in recovery, scan pg_twophase and fill in its status to
	 * be able to work on entries generated by redo.  Doing a scan before
	 * taking any recovery action has the merit to discard any 2PC files that
	 * are newer than the first record to replay, saving from any conflicts at
	 * replay.  This avoids as well any subsequent scans when doing recovery
	 * of the on-disk two-phase data.
	 */</comment>
	<expr_stmt><expr><call><name>restoreTwoPhaseData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>lastFullPageWrites</name> <operator>=</operator> <name><name>checkPoint</name><operator>.</operator><name>fullPageWrites</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>RedoRecPtr</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>RedoRecPtr</name></name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>RedoRecPtr</name></name> <operator>=</operator> <name><name>checkPoint</name><operator>.</operator><name>redo</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>doPageWrites</name> <operator>=</operator> <name>lastFullPageWrites</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>RecPtr</name> <operator>&lt;</operator> <name><name>checkPoint</name><operator>.</operator><name>redo</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid redo in checkpoint record"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check whether we need to force recovery from WAL.  If it appears to
	 * have been a clean shutdown and we did not have a recovery.conf file,
	 * then assume no recovery needed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>checkPoint</name><operator>.</operator><name>redo</name></name> <operator>&lt;</operator> <name>RecPtr</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>wasShutdown</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid redo record in shutdown checkpoint"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>InRecovery</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DB_SHUTDOWNED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>InRecovery</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>ArchiveRecoveryRequested</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* force recovery due to presence of recovery.conf */</comment>
		<expr_stmt><expr><name>InRecovery</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* REDO */</comment>
	<if_stmt><if>if <condition>(<expr><name>InRecovery</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>rmid</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Update pg_control to show that we are recovering and to show the
		 * selected checkpoint as the place we are starting from. We also mark
		 * pg_control with any minimum recovery stop point obtained from a
		 * backup history file.
		 */</comment>
		<expr_stmt><expr><name>dbstate_at_startup</name> <operator>=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>InArchiveRecovery</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>DB_IN_ARCHIVE_RECOVERY</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database system was not properly shut down; "</literal>
							<literal type="string">"automatic recovery in progress"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>recoveryTargetTLI</name> <operator>&gt;</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>checkPointCopy</name><operator>.</operator><name>ThisTimeLineID</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"crash recovery starts in timeline %u "</literal>
								<literal type="string">"and has target timeline %u"</literal></expr></argument>,
								<argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>checkPointCopy</name><operator>.</operator><name>ThisTimeLineID</name></name></expr></argument>,
								<argument><expr><name>recoveryTargetTLI</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>DB_IN_CRASH_RECOVERY</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>checkPoint</name></name> <operator>=</operator> <name>checkPointLoc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>checkPointCopy</name></name> <operator>=</operator> <name>checkPoint</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>InArchiveRecovery</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* initialize minRecoveryPoint if not set yet */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPoint</name></name> <operator>&lt;</operator> <name><name>checkPoint</name><operator>.</operator><name>redo</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPoint</name></name> <operator>=</operator> <name><name>checkPoint</name><operator>.</operator><name>redo</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPointTLI</name></name> <operator>=</operator> <name><name>checkPoint</name><operator>.</operator><name>ThisTimeLineID</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Set backupStartPoint if we're starting recovery from a base backup.
		 *
		 * Also set backupEndPoint and use minRecoveryPoint as the backup end
		 * location if we're starting recovery from a base backup which was
		 * taken from a standby. In this case, the database system status in
		 * pg_control must indicate that the database was already in recovery.
		 * Usually that will be DB_IN_ARCHIVE_RECOVERY but also can be
		 * DB_SHUTDOWNED_IN_RECOVERY if recovery previously was interrupted
		 * before reaching this point; e.g. because restore_command or
		 * primary_conninfo were faulty.
		 *
		 * Any other state indicates that the backup somehow became corrupted
		 * and we can't sensibly continue with recovery.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>haveBackupLabel</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>backupStartPoint</name></name> <operator>=</operator> <name><name>checkPoint</name><operator>.</operator><name>redo</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>backupEndRequired</name></name> <operator>=</operator> <name>backupEndRequired</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>backupFromStandby</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>dbstate_at_startup</name> <operator>!=</operator> <name>DB_IN_ARCHIVE_RECOVERY</name> <operator>&amp;&amp;</operator>
					<name>dbstate_at_startup</name> <operator>!=</operator> <name>DB_SHUTDOWNED_IN_RECOVERY</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"backup_label contains data inconsistent with control file"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"This means that the backup is corrupted and you will "</literal>
									 <literal type="string">"have to use another backup for recovery."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>backupEndPoint</name></name> <operator>=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPoint</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* No need to hold ControlFileLock yet, we aren't up far enough */</comment>
		<expr_stmt><expr><call><name>UpdateControlFile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Initialize our local copy of minRecoveryPoint.  When doing crash
		 * recovery we want to replay up to the end of WAL.  Particularly, in
		 * the case of a promoted standby minRecoveryPoint value in the
		 * control file is only updated after the first checkpoint.  However,
		 * if the instance crashes before the first post-recovery checkpoint
		 * is completed then recovery will use a stale location causing the
		 * startup process to think that there are still invalid page
		 * references when checking for data consistency.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>InArchiveRecovery</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>minRecoveryPoint</name> <operator>=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPoint</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>minRecoveryPointTLI</name> <operator>=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPointTLI</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>minRecoveryPoint</name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>minRecoveryPointTLI</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Reset pgstat data, because it may be invalid after recovery.
		 */</comment>
		<expr_stmt><expr><call><name>pgstat_reset_all</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If there was a backup label file, it's done its job and the info
		 * has now been propagated into pg_control.  We must get rid of the
		 * label file so that if we crash during recovery, we'll pick up at
		 * the latest recovery restartpoint instead of going all the way back
		 * to the backup start point.  It seems prudent though to just rename
		 * the file out of the way rather than delete it completely.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>haveBackupLabel</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>BACKUP_LABEL_OLD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>durable_rename</name><argument_list>(<argument><expr><name>BACKUP_LABEL_FILE</name></expr></argument>, <argument><expr><name>BACKUP_LABEL_OLD</name></expr></argument>, <argument><expr><name>FATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If there was a tablespace_map file, it's done its job and the
		 * symlinks have been created.  We must get rid of the map file so
		 * that if we crash during recovery, we don't create symlinks again.
		 * It seems prudent though to just rename the file out of the way
		 * rather than delete it completely.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>haveTblspcMap</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>TABLESPACE_MAP_OLD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>durable_rename</name><argument_list>(<argument><expr><name>TABLESPACE_MAP</name></expr></argument>, <argument><expr><name>TABLESPACE_MAP_OLD</name></expr></argument>, <argument><expr><name>FATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Check that the GUCs used to generate the WAL allow recovery */</comment>
		<expr_stmt><expr><call><name>CheckRequiredParameterValues</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We're in recovery, so unlogged relations may be trashed and must be
		 * reset.  This should be done BEFORE allowing Hot Standby
		 * connections, so that read-only backends don't try to read whatever
		 * garbage is left over from before.
		 */</comment>
		<expr_stmt><expr><call><name>ResetUnloggedRelations</name><argument_list>(<argument><expr><name>UNLOGGED_RELATION_CLEANUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Likewise, delete any saved transaction snapshot files that got left
		 * behind by crashed backends.
		 */</comment>
		<expr_stmt><expr><call><name>DeleteAllExportedSnapshotFiles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Initialize for Hot Standby, if enabled. We won't let backends in
		 * yet, not until we've reached the min recovery point specified in
		 * control file and we've established a recovery snapshot from a
		 * running-xacts WAL record.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>ArchiveRecoveryRequested</name> <operator>&amp;&amp;</operator> <name>EnableHotStandby</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>xids</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>nxids</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"initializing for hot standby"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>InitRecoveryTransactionEnvironment</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>wasShutdown</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>oldestActiveXID</name> <operator>=</operator> <call><name>PrescanPreparedTransactions</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nxids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>oldestActiveXID</name> <operator>=</operator> <name><name>checkPoint</name><operator>.</operator><name>oldestActiveXid</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>oldestActiveXID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Tell procarray about the range of xids it has to deal with */</comment>
			<expr_stmt><expr><call><name>ProcArrayInitRecovery</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Startup commit log and subtrans only.  MultiXact and commit
			 * timestamp have already been started up and other SLRUs are not
			 * maintained during recovery and need not be started yet.
			 */</comment>
			<expr_stmt><expr><call><name>StartupCLOG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>StartupSUBTRANS</name><argument_list>(<argument><expr><name>oldestActiveXID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If we're beginning at a shutdown checkpoint, we know that
			 * nothing was running on the master at this point. So fake-up an
			 * empty running-xacts record and use that here and now. Recover
			 * additional standby state for prepared transactions.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>wasShutdown</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RunningTransactionsData</name></type> <name>running</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TransactionId</name></type> <name>latestCompletedXid</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Construct a RunningTransactions snapshot representing a
				 * shut down server, with only prepared transactions still
				 * alive. We're never overflowed at this point because all
				 * subxids are listed with their parent prepared transactions.
				 */</comment>
				<expr_stmt><expr><name><name>running</name><operator>.</operator><name>xcnt</name></name> <operator>=</operator> <name>nxids</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>running</name><operator>.</operator><name>subxcnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>running</name><operator>.</operator><name>subxid_overflow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>running</name><operator>.</operator><name>nextXid</name></name> <operator>=</operator> <name><name>checkPoint</name><operator>.</operator><name>nextXid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>running</name><operator>.</operator><name>oldestRunningXid</name></name> <operator>=</operator> <name>oldestActiveXID</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>latestCompletedXid</name> <operator>=</operator> <name><name>checkPoint</name><operator>.</operator><name>nextXid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>TransactionIdRetreat</name><argument_list>(<argument><expr><name>latestCompletedXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>latestCompletedXid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>running</name><operator>.</operator><name>latestCompletedXid</name></name> <operator>=</operator> <name>latestCompletedXid</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>running</name><operator>.</operator><name>xids</name></name> <operator>=</operator> <name>xids</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ProcArrayApplyRecoveryInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>running</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>StandbyRecoverPreparedTransactions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Initialize resource managers */</comment>
		<for>for <control>(<init><expr><name>rmid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>rmid</name> <operator>&lt;=</operator> <name>RM_MAX_ID</name></expr>;</condition> <incr><expr><name>rmid</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>RmgrTable</name><index>[<expr><name>rmid</name></expr>]</index></name><operator>.</operator><name>rm_startup</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>RmgrTable</name><index>[<expr><name>rmid</name></expr>]</index></name><operator>.</operator><call><name>rm_startup</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Initialize shared variables for tracking progress of WAL replay, as
		 * if we had just replayed the record before the REDO location (or the
		 * checkpoint record itself, if it's a shutdown checkpoint).
		 */</comment>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>checkPoint</name><operator>.</operator><name>redo</name></name> <operator>&lt;</operator> <name>RecPtr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>replayEndRecPtr</name></name> <operator>=</operator> <name><name>checkPoint</name><operator>.</operator><name>redo</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>replayEndRecPtr</name></name> <operator>=</operator> <name>EndRecPtr</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>replayEndTLI</name></name> <operator>=</operator> <name>ThisTimeLineID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>lastReplayedEndRecPtr</name></name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>replayEndRecPtr</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>lastReplayedTLI</name></name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>replayEndTLI</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>recoveryLastXTime</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>currentChunkStartTime</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>recoveryPause</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Also ensure XLogReceiptTime has a sane value */</comment>
		<expr_stmt><expr><name>XLogReceiptTime</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Let postmaster know we've started redo now, so that it can launch
		 * checkpointer to perform restartpoints.  We don't bother during
		 * crash recovery as restartpoints can only be performed during
		 * archive recovery.  And we'd like to keep crash recovery simple, to
		 * avoid introducing bugs that could affect you when recovering after
		 * crash.
		 *
		 * After this point, we can no longer assume that we're the only
		 * process in addition to postmaster!  Also, fsync requests are
		 * subsequently to be handled by the checkpointer, not locally.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>ArchiveRecoveryRequested</name> <operator>&amp;&amp;</operator> <name>IsUnderPostmaster</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PublishStartupProcessInformation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SetForwardFsyncRequests</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SendPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_RECOVERY_STARTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bgwriterLaunched</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Allow read-only connections immediately if we're consistent
		 * already.
		 */</comment>
		<expr_stmt><expr><call><name>CheckRecoveryConsistency</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Find the first record that logically follows the checkpoint --- it
		 * might physically precede it, though.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>checkPoint</name><operator>.</operator><name>redo</name></name> <operator>&lt;</operator> <name>RecPtr</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* back up to find the record */</comment>
			<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>ReadRecord</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>, <argument><expr><name><name>checkPoint</name><operator>.</operator><name>redo</name></name></expr></argument>, <argument><expr><name>PANIC</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* just have to read next record after CheckPoint */</comment>
			<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>ReadRecord</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>record</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>errcallback</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TimestampTz</name></type> <name>xtime</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>InRedo</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"redo starts at %X/%X"</literal></expr></argument>,
							<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>ReadRecPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>ReadRecPtr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * main redo apply loop
			 */</comment>
			<do>do
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type>		<name>switchedTLI</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WAL_DEBUG</name></cpp:ifdef>
				<if_stmt><if>if <condition>(<expr><name>XLOG_DEBUG</name> <operator>||</operator>
					<operator>(</operator><name>rmid</name> <operator>==</operator> <name>RM_XACT_ID</name> <operator>&amp;&amp;</operator> <name>trace_recovery_messages</name> <operator>&lt;=</operator> <name>DEBUG2</name><operator>)</operator> <operator>||</operator>
					<operator>(</operator><name>rmid</name> <operator>!=</operator> <name>RM_XACT_ID</name> <operator>&amp;&amp;</operator> <name>trace_recovery_messages</name> <operator>&lt;=</operator> <name>DEBUG3</name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"REDO @ %X/%X; LSN %X/%X: "</literal></expr></argument>,
									 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>ReadRecPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>ReadRecPtr</name></expr></argument>,
									 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>EndRecPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>EndRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>xlog_outrec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>xlogreader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" - "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>xlog_outdesc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>xlogreader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

				<comment type="block">/* Handle interrupt signals of startup process */</comment>
				<expr_stmt><expr><call><name>HandleStartupProcInterrupts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Pause WAL replay, if requested by a hot-standby session via
				 * SetRecoveryPause().
				 *
				 * Note that we intentionally don't take the info_lck spinlock
				 * here.  We might therefore read a slightly stale value of
				 * the recoveryPause flag, but it can't be very stale (no
				 * worse than the last spinlock we did acquire).  Since a
				 * pause request is a pretty asynchronous thing anyway,
				 * possibly responding to it one WAL record later than we
				 * otherwise would is a minor issue, so it doesn't seem worth
				 * adding another spinlock cycle to prevent that.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><specifier>volatile</specifier> <name>XLogCtlData</name> <operator>*</operator><operator>)</operator> <name>XLogCtl</name><operator>)</operator><operator>-&gt;</operator><name>recoveryPause</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>recoveryPausesHere</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Have we reached our recovery target?
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>recoveryStopsBefore</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>reachedStopPoint</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* see below */</comment>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * If we've been asked to lag the master, wait on latch until
				 * enough time has passed.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>recoveryApplyDelay</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * We test for paused recovery again here. If user sets
					 * delayed apply, it may be because they expect to pause
					 * recovery in case of problems, so we must test again
					 * here otherwise pausing during the delay-wait wouldn't
					 * work.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><specifier>volatile</specifier> <name>XLogCtlData</name> <operator>*</operator><operator>)</operator> <name>XLogCtl</name><operator>)</operator><operator>-&gt;</operator><name>recoveryPause</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>recoveryPausesHere</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Setup error traceback support for ereport() */</comment>
				<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>rm_redo_error_callback</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>xlogreader</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>errcallback</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * ShmemVariableCache-&gt;nextXid must be beyond record's xid.
				 *
				 * We don't expect anyone else to modify nextXid, hence we
				 * don't need to hold a lock while examining it.  We still
				 * acquire the lock to modify it, though.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>xl_xid</name></name></expr></argument>,
												 <argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>xl_xid</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>TransactionIdAdvance</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Before replaying this record, check if this record causes
				 * the current timeline to change. The record is already
				 * considered to be part of the new timeline, so we update
				 * ThisTimeLineID before replaying it. That's important so
				 * that replayEndTLI, which is recorded as the minimum
				 * recovery point's TLI if recovery stops after this record,
				 * is set correctly.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>xl_rmid</name></name> <operator>==</operator> <name>RM_XLOG_ID</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>newTLI</name> <init>= <expr><name>ThisTimeLineID</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>prevTLI</name> <init>= <expr><name>ThisTimeLineID</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>uint8</name></type>		<name>info</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>xl_info</name></name> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>info</name> <operator>==</operator> <name>XLOG_CHECKPOINT_SHUTDOWN</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>CheckPoint</name></type>	<name>checkPoint</name></decl>;</decl_stmt>

						<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>checkPoint</name></expr></argument>, <argument><expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CheckPoint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>newTLI</name> <operator>=</operator> <name><name>checkPoint</name><operator>.</operator><name>ThisTimeLineID</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name>prevTLI</name> <operator>=</operator> <name><name>checkPoint</name><operator>.</operator><name>PrevTimeLineID</name></name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name>info</name> <operator>==</operator> <name>XLOG_END_OF_RECOVERY</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>xl_end_of_recovery</name></type> <name>xlrec</name></decl>;</decl_stmt>

						<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xl_end_of_recovery</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>newTLI</name> <operator>=</operator> <name><name>xlrec</name><operator>.</operator><name>ThisTimeLineID</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name>prevTLI</name> <operator>=</operator> <name><name>xlrec</name><operator>.</operator><name>PrevTimeLineID</name></name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name>newTLI</name> <operator>!=</operator> <name>ThisTimeLineID</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* Check that it's OK to switch to this TLI */</comment>
						<expr_stmt><expr><call><name>checkTimeLineSwitch</name><argument_list>(<argument><expr><name>EndRecPtr</name></expr></argument>, <argument><expr><name>newTLI</name></expr></argument>, <argument><expr><name>prevTLI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/* Following WAL records should be run with new TLI */</comment>
						<expr_stmt><expr><name>ThisTimeLineID</name> <operator>=</operator> <name>newTLI</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>switchedTLI</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Update shared replayEndRecPtr before replaying this record,
				 * so that XLogFlush will update minRecoveryPoint correctly.
				 */</comment>
				<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>replayEndRecPtr</name></name> <operator>=</operator> <name>EndRecPtr</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>replayEndTLI</name></name> <operator>=</operator> <name>ThisTimeLineID</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If we are attempting to enter Hot Standby mode, process
				 * XIDs we see
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>standbyState</name> <operator>&gt;=</operator> <name>STANDBY_INITIALIZED</name> <operator>&amp;&amp;</operator>
					<call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>xl_xid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>RecordKnownAssignedTransactionIds</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>xl_xid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Now apply the WAL record itself */</comment>
				<expr_stmt><expr><name><name>RmgrTable</name><index>[<expr><name><name>record</name><operator>-&gt;</operator><name>xl_rmid</name></name></expr>]</index></name><operator>.</operator><call><name>rm_redo</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * After redo, check whether the backup pages associated with
				 * the WAL record are consistent with the existing pages. This
				 * check is done only if consistency check is enabled for this
				 * record.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>xl_info</name></name> <operator>&amp;</operator> <name>XLR_CHECK_CONSISTENCY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>checkXLogConsistency</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Pop the error context stack */</comment>
				<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>errcallback</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Update lastReplayedEndRecPtr after this record has been
				 * successfully replayed.
				 */</comment>
				<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>lastReplayedEndRecPtr</name></name> <operator>=</operator> <name>EndRecPtr</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>lastReplayedTLI</name></name> <operator>=</operator> <name>ThisTimeLineID</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If rm_redo called XLogRequestWalReceiverReply, then we wake
				 * up the receiver so that it notices the updated
				 * lastReplayedEndRecPtr and sends a reply to the master.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>doRequestWalReceiverReply</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>doRequestWalReceiverReply</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>WalRcvForceReply</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Remember this record as the last-applied one */</comment>
				<expr_stmt><expr><name>LastRec</name> <operator>=</operator> <name>ReadRecPtr</name></expr>;</expr_stmt>

				<comment type="block">/* Allow read-only connections if we're consistent now */</comment>
				<expr_stmt><expr><call><name>CheckRecoveryConsistency</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Is this a timeline switch? */</comment>
				<if_stmt><if>if <condition>(<expr><name>switchedTLI</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Before we continue on the new timeline, clean up any
					 * (possibly bogus) future WAL segments on the old
					 * timeline.
					 */</comment>
					<expr_stmt><expr><call><name>RemoveNonParentXlogFiles</name><argument_list>(<argument><expr><name>EndRecPtr</name></expr></argument>, <argument><expr><name>ThisTimeLineID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Wake up any walsenders to notice that we are on a new
					 * timeline.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>switchedTLI</name> <operator>&amp;&amp;</operator> <call><name>AllowCascadeReplication</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>WalSndWakeup</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Exit loop if we reached inclusive recovery target */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>recoveryStopsAfter</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>reachedStopPoint</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Else, try to fetch the next WAL record */</comment>
				<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>ReadRecord</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block> while <condition>(<expr><name>record</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>;</do>

			<comment type="block">/*
			 * end of main redo apply loop
			 */</comment>

			<if_stmt><if>if <condition>(<expr><name>reachedStopPoint</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>reachedConsistency</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"requested recovery stop point is before consistent recovery point"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * This is the last point where we can restart recovery with a
				 * new recovery target, if we shutdown and begin again. After
				 * this, Resource Managers may choose to do permanent
				 * corrective actions at end of recovery.
				 */</comment>
				<switch>switch <condition>(<expr><name>recoveryTargetAction</name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>RECOVERY_TARGET_ACTION_SHUTDOWN</name></expr>:</case>

						<comment type="block">/*
						 * exit with special return code to request shutdown
						 * of postmaster.  Log messages issued from
						 * postmaster.
						 */</comment>
						<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<case>case <expr><name>RECOVERY_TARGET_ACTION_PAUSE</name></expr>:</case>
						<expr_stmt><expr><call><name>SetRecoveryPause</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>recoveryPausesHere</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/* drop into promote */</comment>
						<expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

					<case>case <expr><name>RECOVERY_TARGET_ACTION_PROMOTE</name></expr>:</case>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Allow resource managers to do any required cleanup. */</comment>
			<for>for <control>(<init><expr><name>rmid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>rmid</name> <operator>&lt;=</operator> <name>RM_MAX_ID</name></expr>;</condition> <incr><expr><name>rmid</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>RmgrTable</name><index>[<expr><name>rmid</name></expr>]</index></name><operator>.</operator><name>rm_cleanup</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>RmgrTable</name><index>[<expr><name>rmid</name></expr>]</index></name><operator>.</operator><call><name>rm_cleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"redo done at %X/%X"</literal></expr></argument>,
							<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>ReadRecPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>ReadRecPtr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>xtime</name> <operator>=</operator> <call><name>GetLatestXTime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>xtime</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"last completed transaction was at log time %s"</literal></expr></argument>,
								<argument><expr><call><name>timestamptz_to_str</name><argument_list>(<argument><expr><name>xtime</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>InRedo</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* there are no WAL records following the checkpoint */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"redo is not required"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Kill WAL receiver, if it's still running, before we continue to write
	 * the startup checkpoint record. It will trump over the checkpoint and
	 * subsequent records if it's still alive when we start writing WAL.
	 */</comment>
	<expr_stmt><expr><call><name>ShutdownWalRcv</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reset unlogged relations to the contents of their INIT fork. This is
	 * done AFTER recovery is complete so as to include any unlogged relations
	 * created during recovery, but BEFORE recovery is marked as having
	 * completed successfully. Otherwise we'd not retry if any of the post
	 * end-of-recovery steps fail.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>InRecovery</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResetUnloggedRelations</name><argument_list>(<argument><expr><name>UNLOGGED_RELATION_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We don't need the latch anymore. It's not strictly necessary to disown
	 * it, but let's do it for the sake of tidiness.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>StandbyModeRequested</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>DisownLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>recoveryWakeupLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We are now done reading the xlog from stream. Turn off streaming
	 * recovery to force fetching the files (which would be required at end of
	 * recovery, e.g., timeline history file) from archive or pg_wal.
	 */</comment>
	<expr_stmt><expr><name>StandbyMode</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Re-fetch the last valid or last applied record, so we can identify the
	 * exact endpoint of what we consider the valid portion of WAL.
	 */</comment>
	<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>ReadRecord</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>, <argument><expr><name>LastRec</name></expr></argument>, <argument><expr><name>PANIC</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>EndOfLog</name> <operator>=</operator> <name>EndRecPtr</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * EndOfLogTLI is the TLI in the filename of the XLOG segment containing
	 * the end-of-log. It could be different from the timeline that EndOfLog
	 * nominally belongs to, if there was a timeline switch in that segment,
	 * and we were reading the old WAL from a segment belonging to a higher
	 * timeline.
	 */</comment>
	<expr_stmt><expr><name>EndOfLogTLI</name> <operator>=</operator> <name><name>xlogreader</name><operator>-&gt;</operator><name>readPageTLI</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Complain if we did not roll forward far enough to render the backup
	 * dump consistent.  Note: it is indeed okay to look at the local variable
	 * minRecoveryPoint here, even though ControlFile-&gt;minRecoveryPoint might
	 * be further ahead --- ControlFile-&gt;minRecoveryPoint cannot have been
	 * advanced beyond the WAL we processed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>InRecovery</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>EndOfLog</name> <operator>&lt;</operator> <name>minRecoveryPoint</name> <operator>||</operator>
		 <operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>backupStartPoint</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Ran off end of WAL before reaching end-of-backup WAL record, or
		 * minRecoveryPoint. That's usually a bad sign, indicating that you
		 * tried to recover from an online backup but never called
		 * pg_stop_backup(), or you didn't archive all the WAL up to that
		 * point. However, this also happens in crash recovery, if the system
		 * crashes while an online backup is in progress. We must not treat
		 * that as an error, or the database will refuse to start up.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>ArchiveRecoveryRequested</name> <operator>||</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>backupEndRequired</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>backupEndRequired</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"WAL ends before end of online backup"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"All WAL generated while online backup was taken must be available at recovery."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>backupStartPoint</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"WAL ends before end of online backup"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Online backup started with pg_start_backup() must be ended with pg_stop_backup(), and all WAL up to that point must be available at recovery."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"WAL ends before consistent recovery point"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Pre-scan prepared transactions to find out the range of XIDs present.
	 * This information is not quite needed yet, but it is positioned here so
	 * as potential problems are detected before any on-disk change is done.
	 */</comment>
	<expr_stmt><expr><name>oldestActiveXID</name> <operator>=</operator> <call><name>PrescanPreparedTransactions</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Consider whether we need to assign a new timeline ID.
	 *
	 * If we are doing an archive recovery, we always assign a new ID.  This
	 * handles a couple of issues.  If we stopped short of the end of WAL
	 * during recovery, then we are clearly generating a new timeline and must
	 * assign it a unique new ID.  Even if we ran to the end, modifying the
	 * current last segment is problematic because it may result in trying to
	 * overwrite an already-archived copy of that segment, and we encourage
	 * DBAs to make their archive_commands reject that.  We can dodge the
	 * problem by making the new active segment have a new timeline ID.
	 *
	 * In a normal crash recovery, we can just extend the timeline we were in.
	 */</comment>
	<expr_stmt><expr><name>PrevTimeLineID</name> <operator>=</operator> <name>ThisTimeLineID</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ArchiveRecoveryRequested</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>reason</name><index>[<expr><literal type="number">200</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>InArchiveRecovery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ThisTimeLineID</name> <operator>=</operator> <call><name>findNewestTimeLine</name><argument_list>(<argument><expr><name>recoveryTargetTLI</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"selected new timeline ID: %u"</literal></expr></argument>, <argument><expr><name>ThisTimeLineID</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Create a comment for the history file to explain why and where
		 * timeline changed.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>recoveryTarget</name> <operator>==</operator> <name>RECOVERY_TARGET_XID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>reason</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>reason</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					 <argument><expr><literal type="string">"%s transaction %u"</literal></expr></argument>,
					 <argument><expr><ternary><condition><expr><name>recoveryStopAfter</name></expr> ?</condition><then> <expr><literal type="string">"after"</literal></expr> </then><else>: <expr><literal type="string">"before"</literal></expr></else></ternary></expr></argument>,
					 <argument><expr><name>recoveryStopXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>recoveryTarget</name> <operator>==</operator> <name>RECOVERY_TARGET_TIME</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>reason</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>reason</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					 <argument><expr><literal type="string">"%s %s\n"</literal></expr></argument>,
					 <argument><expr><ternary><condition><expr><name>recoveryStopAfter</name></expr> ?</condition><then> <expr><literal type="string">"after"</literal></expr> </then><else>: <expr><literal type="string">"before"</literal></expr></else></ternary></expr></argument>,
					 <argument><expr><call><name>timestamptz_to_str</name><argument_list>(<argument><expr><name>recoveryStopTime</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>recoveryTarget</name> <operator>==</operator> <name>RECOVERY_TARGET_LSN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>reason</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>reason</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					 <argument><expr><literal type="string">"%s LSN %X/%X\n"</literal></expr></argument>,
					 <argument><expr><ternary><condition><expr><name>recoveryStopAfter</name></expr> ?</condition><then> <expr><literal type="string">"after"</literal></expr> </then><else>: <expr><literal type="string">"before"</literal></expr></else></ternary></expr></argument>,
					 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>recoveryStopLSN</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
					 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>recoveryStopLSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>recoveryTarget</name> <operator>==</operator> <name>RECOVERY_TARGET_NAME</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>reason</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>reason</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					 <argument><expr><literal type="string">"at restore point \"%s\""</literal></expr></argument>,
					 <argument><expr><name>recoveryStopName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>recoveryTarget</name> <operator>==</operator> <name>RECOVERY_TARGET_IMMEDIATE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>reason</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>reason</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"reached consistency"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>reason</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>reason</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"no recovery target specified"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * We are now done reading the old WAL.  Turn off archive fetching if
		 * it was active, and make a writable copy of the last WAL segment.
		 * (Note that we also have a copy of the last block of the old WAL in
		 * readBuf; we will use that below.)
		 */</comment>
		<expr_stmt><expr><call><name>exitArchiveRecovery</name><argument_list>(<argument><expr><name>EndOfLogTLI</name></expr></argument>, <argument><expr><name>EndOfLog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Write the timeline history file, and have it archived. After this
		 * point (or rather, as soon as the file is archived), the timeline
		 * will appear as "taken" in the WAL archive and to any standby
		 * servers.  If we crash before actually switching to the new
		 * timeline, standby servers will nevertheless think that we switched
		 * to the new timeline, and will try to connect to the new timeline.
		 * To minimize the window for that, try to do as little as possible
		 * between here and writing the end-of-recovery record.
		 */</comment>
		<expr_stmt><expr><call><name>writeTimeLineHistory</name><argument_list>(<argument><expr><name>ThisTimeLineID</name></expr></argument>, <argument><expr><name>recoveryTargetTLI</name></expr></argument>,
							 <argument><expr><name>EndRecPtr</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Save the selected TimeLineID in shared memory, too */</comment>
	<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>ThisTimeLineID</name></name> <operator>=</operator> <name>ThisTimeLineID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>PrevTimeLineID</name></name> <operator>=</operator> <name>PrevTimeLineID</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prepare to write WAL starting at EndOfLog location, and init xlog
	 * buffer cache using the block containing the last record from the
	 * previous incarnation.
	 */</comment>
	<expr_stmt><expr><name>Insert</name> <operator>=</operator> <operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Insert</name><operator>-&gt;</operator><name>PrevBytePos</name></name> <operator>=</operator> <call><name>XLogRecPtrToBytePos</name><argument_list>(<argument><expr><name>LastRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Insert</name><operator>-&gt;</operator><name>CurrBytePos</name></name> <operator>=</operator> <call><name>XLogRecPtrToBytePos</name><argument_list>(<argument><expr><name>EndOfLog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Tricky point here: readBuf contains the *last* block that the LastRec
	 * record spans, not the one it starts in.  The last block is indeed the
	 * one we want to use.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>EndOfLog</name> <operator>%</operator> <name>XLOG_BLCKSZ</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>firstIdx</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>pageBeginPtr</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>pageBeginPtr</name> <operator>=</operator> <name>EndOfLog</name> <operator>-</operator> <operator>(</operator><name>EndOfLog</name> <operator>%</operator> <name>XLOG_BLCKSZ</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>readOff</name> <operator>==</operator> <call><name>XLogSegmentOffset</name><argument_list>(<argument><expr><name>pageBeginPtr</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>firstIdx</name> <operator>=</operator> <call><name>XLogRecPtrToBufIdx</name><argument_list>(<argument><expr><name>EndOfLog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Copy the valid part of the last block, and zero the rest */</comment>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>pages</name><index>[<expr><name>firstIdx</name> <operator>*</operator> <name>XLOG_BLCKSZ</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <name>EndOfLog</name> <operator>%</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>xlogreader</name><operator>-&gt;</operator><name>readBuf</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>page</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>XLOG_BLCKSZ</name> <operator>-</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>xlblocks</name><index>[<expr><name>firstIdx</name></expr>]</index></name> <operator>=</operator> <name>pageBeginPtr</name> <operator>+</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>InitializedUpTo</name></name> <operator>=</operator> <name>pageBeginPtr</name> <operator>+</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * There is no partial block to copy. Just set InitializedUpTo, and
		 * let the first attempt to insert a log record to initialize the next
		 * buffer.
		 */</comment>
		<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>InitializedUpTo</name></name> <operator>=</operator> <name>EndOfLog</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>LogwrtResult</name><operator>.</operator><name>Write</name></name> <operator>=</operator> <name><name>LogwrtResult</name><operator>.</operator><name>Flush</name></name> <operator>=</operator> <name>EndOfLog</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtResult</name></name> <operator>=</operator> <name>LogwrtResult</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtRqst</name><operator>.</operator><name>Write</name></name> <operator>=</operator> <name>EndOfLog</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtRqst</name><operator>.</operator><name>Flush</name></name> <operator>=</operator> <name>EndOfLog</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update full_page_writes in shared memory and write an XLOG_FPW_CHANGE
	 * record before resource manager writes cleanup WAL records or checkpoint
	 * record is written.
	 */</comment>
	<expr_stmt><expr><name><name>Insert</name><operator>-&gt;</operator><name>fullPageWrites</name></name> <operator>=</operator> <name>lastFullPageWrites</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LocalSetXLogInsertAllowed</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UpdateFullPageWrites</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>LocalXLogInsertAllowed</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>InRecovery</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Perform a checkpoint to update all our recovery activity to disk.
		 *
		 * Note that we write a shutdown checkpoint rather than an on-line
		 * one. This is not particularly critical, but since we may be
		 * assigning a new TLI, using a shutdown checkpoint allows us to have
		 * the rule that TLI only changes in shutdown checkpoints, which
		 * allows some extra error checking in xlog_redo.
		 *
		 * In fast promotion, only create a lightweight end-of-recovery record
		 * instead of a full checkpoint. A checkpoint is requested later,
		 * after we're fully out of recovery mode and already accepting
		 * queries.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>bgwriterLaunched</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>fast_promote</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>checkPointLoc</name> <operator>=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>checkPoint</name></name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Confirm the last checkpoint is available for us to recover
				 * from if we fail.
				 */</comment>
				<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>ReadCheckpointRecord</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>, <argument><expr><name>checkPointLoc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>record</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>fast_promoted</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

					<comment type="block">/*
					 * Insert a special WAL record to mark the end of
					 * recovery, since we aren't doing a checkpoint. That
					 * means that the checkpointer process may likely be in
					 * the middle of a time-smoothed restartpoint and could
					 * continue to be for minutes after this. That sounds
					 * strange, but the effect is roughly the same and it
					 * would be stranger to try to come out of the
					 * restartpoint and then checkpoint. We request a
					 * checkpoint later anyway, just for safety.
					 */</comment>
					<expr_stmt><expr><call><name>CreateEndOfRecoveryRecord</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fast_promoted</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>RequestCheckpoint</name><argument_list>(<argument><expr><name>CHECKPOINT_END_OF_RECOVERY</name> <operator>|</operator>
								  <name>CHECKPOINT_IMMEDIATE</name> <operator>|</operator>
								  <name>CHECKPOINT_WAIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CreateCheckPoint</name><argument_list>(<argument><expr><name>CHECKPOINT_END_OF_RECOVERY</name> <operator>|</operator> <name>CHECKPOINT_IMMEDIATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * And finally, execute the recovery_end_command, if any.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>recoveryEndCommand</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecuteRecoveryCommand</name><argument_list>(<argument><expr><name>recoveryEndCommand</name></expr></argument>,
								   <argument><expr><literal type="string">"recovery_end_command"</literal></expr></argument>,
								   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ArchiveRecoveryRequested</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We switched to a new timeline. Clean up segments on the old
		 * timeline.
		 *
		 * If there are any higher-numbered segments on the old timeline,
		 * remove them. They might contain valid WAL, but they might also be
		 * pre-allocated files containing garbage. In any case, they are not
		 * part of the new timeline's history so we don't need them.
		 */</comment>
		<expr_stmt><expr><call><name>RemoveNonParentXlogFiles</name><argument_list>(<argument><expr><name>EndOfLog</name></expr></argument>, <argument><expr><name>ThisTimeLineID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the switch happened in the middle of a segment, what to do with
		 * the last, partial segment on the old timeline? If we don't archive
		 * it, and the server that created the WAL never archives it either
		 * (e.g. because it was hit by a meteor), it will never make it to the
		 * archive. That's OK from our point of view, because the new segment
		 * that we created with the new TLI contains all the WAL from the old
		 * timeline up to the switch point. But if you later try to do PITR to
		 * the "missing" WAL on the old timeline, recovery won't find it in
		 * the archive. It's physically present in the new file with new TLI,
		 * but recovery won't look there when it's recovering to the older
		 * timeline. On the other hand, if we archive the partial segment, and
		 * the original server on that timeline is still running and archives
		 * the completed version of the same segment later, it will fail. (We
		 * used to do that in 9.4 and below, and it caused such problems).
		 *
		 * As a compromise, we rename the last segment with the .partial
		 * suffix, and archive it. Archive recovery will never try to read
		 * .partial segments, so they will normally go unused. But in the odd
		 * PITR case, the administrator can copy them manually to the pg_wal
		 * directory (removing the suffix). They can be useful in debugging,
		 * too.
		 *
		 * If a .done or .ready file already exists for the old timeline,
		 * however, we had already determined that the segment is complete, so
		 * we can let it be archived normally. (In particular, if it was
		 * restored from the archive to begin with, it's expected to have a
		 * .done file).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>XLogSegmentOffset</name><argument_list>(<argument><expr><name>EndOfLog</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>XLogArchivingActive</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>origfname</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>endLogSegNo</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>XLByteToPrevSeg</name><argument_list>(<argument><expr><name>EndOfLog</name></expr></argument>, <argument><expr><name>endLogSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>origfname</name></expr></argument>, <argument><expr><name>EndOfLogTLI</name></expr></argument>, <argument><expr><name>endLogSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogArchiveIsReadyOrDone</name><argument_list>(<argument><expr><name>origfname</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type>		<name><name>origpath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name></type>		<name><name>partialfname</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name></type>		<name><name>partialpath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>XLogFilePath</name><argument_list>(<argument><expr><name>origpath</name></expr></argument>, <argument><expr><name>EndOfLogTLI</name></expr></argument>, <argument><expr><name>endLogSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>partialfname</name></expr></argument>, <argument><expr><name>MAXFNAMELEN</name></expr></argument>, <argument><expr><literal type="string">"%s.partial"</literal></expr></argument>, <argument><expr><name>origfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>partialpath</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s.partial"</literal></expr></argument>, <argument><expr><name>origpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Make sure there's no .done or .ready file for the .partial
				 * file.
				 */</comment>
				<expr_stmt><expr><call><name>XLogArchiveCleanup</name><argument_list>(<argument><expr><name>partialfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>durable_rename</name><argument_list>(<argument><expr><name>origpath</name></expr></argument>, <argument><expr><name>partialpath</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>XLogArchiveNotify</name><argument_list>(<argument><expr><name>partialfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Preallocate additional log files, if wanted.
	 */</comment>
	<expr_stmt><expr><call><name>PreallocXlogFiles</name><argument_list>(<argument><expr><name>EndOfLog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Okay, we're officially UP.
	 */</comment>
	<expr_stmt><expr><name>InRecovery</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* start the archive_timeout timer and LSN running */</comment>
	<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>lastSegSwitchTime</name></name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>lastSegSwitchLSN</name></name> <operator>=</operator> <name>EndOfLog</name></expr>;</expr_stmt>

	<comment type="block">/* also initialize latestCompletedXid, to nextXid - 1 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>latestCompletedXid</name></name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TransactionIdRetreat</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>latestCompletedXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Start up the commit log and subtrans, if not already done for hot
	 * standby.  (commit timestamps are started below, if necessary.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>standbyState</name> <operator>==</operator> <name>STANDBY_DISABLED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>StartupCLOG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>StartupSUBTRANS</name><argument_list>(<argument><expr><name>oldestActiveXID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Perform end of recovery actions for any SLRUs that need it.
	 */</comment>
	<expr_stmt><expr><call><name>TrimCLOG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TrimMultiXact</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reload shared-memory state for prepared transactions */</comment>
	<expr_stmt><expr><call><name>RecoverPreparedTransactions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Shutdown the recovery environment. This must occur after
	 * RecoverPreparedTransactions(), see notes for lock_twophase_recover()
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>standbyState</name> <operator>!=</operator> <name>STANDBY_DISABLED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ShutdownRecoveryTransactionEnvironment</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Shut down xlogreader */</comment>
	<if_stmt><if>if <condition>(<expr><name>readFile</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>readFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>readFile</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>XLogReaderFree</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If any of the critical GUCs have changed, log them before we allow
	 * backends to write WAL.
	 */</comment>
	<expr_stmt><expr><call><name>LocalSetXLogInsertAllowed</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogReportParameters</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Local WAL inserts enabled, so it's time to finish initialization of
	 * commit timestamp.
	 */</comment>
	<expr_stmt><expr><call><name>CompleteCommitTsInitialization</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * All done with end-of-recovery actions.
	 *
	 * Now allow backends to write WAL and update the control file status in
	 * consequence.  The boolean flag allowing backends to write WAL is
	 * updated while holding ControlFileLock to prevent other backends to look
	 * at an inconsistent state of the control file in shared memory.  There
	 * is still a small window during which backends can write WAL and the
	 * control file is still referring to a system not in DB_IN_PRODUCTION
	 * state while looking at the on-disk control file.
	 *
	 * Also, although the boolean flag to allow WAL is probably atomic in
	 * itself, we use the info_lck here to ensure that there are no race
	 * conditions concerning visibility of other recent updates to shared
	 * memory.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ControlFileLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>DB_IN_PRODUCTION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>SharedRecoveryInProgress</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UpdateControlFile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ControlFileLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there were cascading standby servers connected to us, nudge any wal
	 * sender processes to notice that we've been promoted.
	 */</comment>
	<expr_stmt><expr><call><name>WalSndWakeup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this was a fast promotion, request an (online) checkpoint now. This
	 * isn't required for consistency, but the last restartpoint might be far
	 * back, and in case of a crash, recovering from it might take a longer
	 * than is appropriate now that we're not in standby mode anymore.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>fast_promoted</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RequestCheckpoint</name><argument_list>(<argument><expr><name>CHECKPOINT_FORCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Checks if recovery has reached a consistent state. When consistency is
 * reached and we have a valid starting standby snapshot, tell postmaster
 * that it can start accepting read-only connections.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CheckRecoveryConsistency</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lastReplayedEndRecPtr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * During crash recovery, we don't reach a consistent state until we've
	 * replayed all the WAL.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>minRecoveryPoint</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>InArchiveRecovery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * assume that we are called in the startup process, and hence don't need
	 * a lock to read lastReplayedEndRecPtr
	 */</comment>
	<expr_stmt><expr><name>lastReplayedEndRecPtr</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>lastReplayedEndRecPtr</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Have we reached the point where our base backup was completed?
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>backupEndPoint</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name><name>ControlFile</name><operator>-&gt;</operator><name>backupEndPoint</name></name> <operator>&lt;=</operator> <name>lastReplayedEndRecPtr</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We have reached the end of base backup, as indicated by pg_control.
		 * The data on disk is now consistent. Reset backupStartPoint and
		 * backupEndPoint, and update minRecoveryPoint to make sure we don't
		 * allow starting up at an earlier point even if recovery is stopped
		 * and restarted soon after this.
		 */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"end of backup reached"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ControlFileLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPoint</name></name> <operator>&lt;</operator> <name>lastReplayedEndRecPtr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPoint</name></name> <operator>=</operator> <name>lastReplayedEndRecPtr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>backupStartPoint</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>backupEndPoint</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>backupEndRequired</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UpdateControlFile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ControlFileLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Have we passed our safe starting point? Note that minRecoveryPoint is
	 * known to be incorrectly set if ControlFile-&gt;backupEndRequired, until
	 * the XLOG_BACKUP_END arrives to advise us of the correct
	 * minRecoveryPoint. All we know prior to that is that we're not
	 * consistent yet.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>reachedConsistency</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>ControlFile</name><operator>-&gt;</operator><name>backupEndRequired</name></name> <operator>&amp;&amp;</operator>
		<name>minRecoveryPoint</name> <operator>&lt;=</operator> <name>lastReplayedEndRecPtr</name> <operator>&amp;&amp;</operator>
		<call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>backupStartPoint</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Check to see if the XLOG sequence contained any unresolved
		 * references to uninitialized pages.
		 */</comment>
		<expr_stmt><expr><call><name>XLogCheckInvalidPages</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>reachedConsistency</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"consistent recovery state reached at %X/%X"</literal></expr></argument>,
						<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>lastReplayedEndRecPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
						<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>lastReplayedEndRecPtr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Have we got a valid starting snapshot that will allow queries to be
	 * run? If so, we can tell postmaster that the database is consistent now,
	 * enabling connections.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>standbyState</name> <operator>==</operator> <name>STANDBY_SNAPSHOT_READY</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name>LocalHotStandbyActive</name> <operator>&amp;&amp;</operator>
		<name>reachedConsistency</name> <operator>&amp;&amp;</operator>
		<name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>SharedHotStandbyActive</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>LocalHotStandbyActive</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SendPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_BEGIN_HOT_STANDBY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Is the system still in recovery?
 *
 * Unlike testing InRecovery, this works in any process that's connected to
 * shared memory.
 *
 * As a side-effect, we initialize the local TimeLineID and RedoRecPtr
 * variables the first time we see that recovery is finished.
 */</comment>
<function><type><name>bool</name></type>
<name>RecoveryInProgress</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We check shared state each time only until we leave recovery mode. We
	 * can't re-enter recovery, so there's no need to keep checking after the
	 * shared variable has once been seen false.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>LocalRecoveryInProgress</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * use volatile pointer to make sure we make a fresh read of the
		 * shared variable.
		 */</comment>
		<decl_stmt><decl><type><specifier>volatile</specifier> <name>XLogCtlData</name> <modifier>*</modifier></type><name>xlogctl</name> <init>= <expr><name>XLogCtl</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>LocalRecoveryInProgress</name> <operator>=</operator> <name><name>xlogctl</name><operator>-&gt;</operator><name>SharedRecoveryInProgress</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Initialize TimeLineID and RedoRecPtr when we discover that recovery
		 * is finished. InitPostgres() relies upon this behaviour to ensure
		 * that InitXLOGAccess() is called at backend startup.  (If you change
		 * this, see also LocalSetXLogInsertAllowed.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>LocalRecoveryInProgress</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If we just exited recovery, make sure we read TimeLineID and
			 * RedoRecPtr after SharedRecoveryInProgress (for machines with
			 * weak memory ordering).
			 */</comment>
			<expr_stmt><expr><call><name>pg_memory_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>InitXLOGAccess</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Note: We don't need a memory barrier when we're still in recovery.
		 * We might exit recovery immediately after return, so the caller
		 * can't rely on 'true' meaning that we're still in recovery anyway.
		 */</comment>

		<return>return <expr><name>LocalRecoveryInProgress</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Is HotStandby active yet? This is only important in special backends
 * since normal backends won't ever be able to connect until this returns
 * true. Postmaster knows this by way of signal, not via shared memory.
 *
 * Unlike testing standbyState, this works in any process that's connected to
 * shared memory.  (And note that standbyState alone doesn't tell the truth
 * anyway.)
 */</comment>
<function><type><name>bool</name></type>
<name>HotStandbyActive</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We check shared state each time only until Hot Standby is active. We
	 * can't de-activate Hot Standby, so there's no need to keep checking
	 * after the shared variable has once been seen true.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>LocalHotStandbyActive</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* spinlock is essential on machines with weak memory ordering! */</comment>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>LocalHotStandbyActive</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>SharedHotStandbyActive</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>LocalHotStandbyActive</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Like HotStandbyActive(), but to be used only in WAL replay code,
 * where we don't need to ask any other process what the state is.
 */</comment>
<function><type><name>bool</name></type>
<name>HotStandbyActiveInReplay</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>AmStartupProcess</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><name>IsPostmasterEnvironment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>LocalHotStandbyActive</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Is this process allowed to insert new WAL records?
 *
 * Ordinarily this is essentially equivalent to !RecoveryInProgress().
 * But we also have provisions for forcing the result "true" or "false"
 * within specific processes regardless of the global state.
 */</comment>
<function><type><name>bool</name></type>
<name>XLogInsertAllowed</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If value is "unconditionally true" or "unconditionally false", just
	 * return it.  This provides the normal fast path once recovery is known
	 * done.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>LocalXLogInsertAllowed</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>bool</name><operator>)</operator> <name>LocalXLogInsertAllowed</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Else, must check to see if we're still in recovery.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * On exit from recovery, reset to "unconditionally true", since there is
	 * no need to keep checking.
	 */</comment>
	<expr_stmt><expr><name>LocalXLogInsertAllowed</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Make XLogInsertAllowed() return true in the current process only.
 *
 * Note: it is allowed to switch LocalXLogInsertAllowed back to -1 later,
 * and even call LocalSetXLogInsertAllowed() again after that.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>LocalSetXLogInsertAllowed</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>LocalXLogInsertAllowed</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>LocalXLogInsertAllowed</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* Initialize as RecoveryInProgress() would do when switching state */</comment>
	<expr_stmt><expr><call><name>InitXLOGAccess</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine to try to fetch and validate a prior checkpoint record.
 *
 * whichChkpt identifies the checkpoint (merely for reporting purposes).
 * 1 for "primary", 0 for "other" (backup_label)
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRecord</name> <modifier>*</modifier></type>
<name>ReadCheckpointRecord</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>xlogreader</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>RecPtr</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>whichChkpt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>report</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>info</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XRecOffIsValid</name><argument_list>(<argument><expr><name>RecPtr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>report</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<switch>switch <condition>(<expr><name>whichChkpt</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="number">1</literal></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid primary checkpoint link in control file"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid checkpoint link in backup_label file"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>ReadRecord</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>, <argument><expr><name>RecPtr</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>record</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>report</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<switch>switch <condition>(<expr><name>whichChkpt</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="number">1</literal></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid primary checkpoint record"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid checkpoint record"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>xl_rmid</name></name> <operator>!=</operator> <name>RM_XLOG_ID</name></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>whichChkpt</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="number">1</literal></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid resource manager ID in primary checkpoint record"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid resource manager ID in checkpoint record"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>info</name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>xl_info</name></name> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>info</name> <operator>!=</operator> <name>XLOG_CHECKPOINT_SHUTDOWN</name> <operator>&amp;&amp;</operator>
		<name>info</name> <operator>!=</operator> <name>XLOG_CHECKPOINT_ONLINE</name></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>whichChkpt</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="number">1</literal></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid xl_info in primary checkpoint record"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid xl_info in checkpoint record"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>xl_tot_len</name></name> <operator>!=</operator> <name>SizeOfXLogRecord</name> <operator>+</operator> <name>SizeOfXLogRecordDataHeaderShort</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CheckPoint</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>whichChkpt</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="number">1</literal></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid length of primary checkpoint record"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid length of checkpoint record"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>record</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This must be called in a backend process before creating WAL records
 * (except in a standalone backend, which does StartupXLOG instead).  We need
 * to initialize the local copies of ThisTimeLineID and RedoRecPtr.
 *
 * Note: before Postgres 8.0, we went to some effort to keep the postmaster
 * process's copies of ThisTimeLineID and RedoRecPtr valid too.  This was
 * unnecessary however, since the postmaster itself never touches XLOG anyway.
 */</comment>
<function><type><name>void</name></type>
<name>InitXLOGAccess</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogCtlInsert</name> <modifier>*</modifier></type><name>Insert</name> <init>= <expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* ThisTimeLineID doesn't change so we need no lock to copy it */</comment>
	<expr_stmt><expr><name>ThisTimeLineID</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>ThisTimeLineID</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ThisTimeLineID</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set wal_segment_size */</comment>
	<expr_stmt><expr><name>wal_segment_size</name> <operator>=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>xlog_seg_size</name></name></expr>;</expr_stmt>

	<comment type="block">/* Use GetRedoRecPtr to copy the RedoRecPtr safely */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>GetRedoRecPtr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Also update our copy of doPageWrites. */</comment>
	<expr_stmt><expr><name>doPageWrites</name> <operator>=</operator> <operator>(</operator><name><name>Insert</name><operator>-&gt;</operator><name>fullPageWrites</name></name> <operator>||</operator> <name><name>Insert</name><operator>-&gt;</operator><name>forcePageWrites</name></name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* Also initialize the working areas for constructing WAL records */</comment>
	<expr_stmt><expr><call><name>InitXLogInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return the current Redo pointer from shared memory.
 *
 * As a side-effect, the local RedoRecPtr copy is updated.
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>GetRedoRecPtr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>ptr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The possibly not up-to-date copy in XlogCtl is enough. Even if we
	 * grabbed a WAL insertion lock to read the master copy, someone might
	 * update it just after we've released the lock.
	 */</comment>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>RedoRecPtr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>RedoRecPtr</name> <operator>&lt;</operator> <name>ptr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>RedoRecPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>RedoRecPtr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return information needed to decide whether a modified block needs a
 * full-page image to be included in the WAL record.
 *
 * The returned values are cached copies from backend-private memory, and
 * possibly out-of-date.  XLogInsertRecord will re-check them against
 * up-to-date values, while holding the WAL insert lock.
 */</comment>
<function><type><name>void</name></type>
<name>GetFullPageWriteInfo</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>RedoRecPtr_p</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>doPageWrites_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>RedoRecPtr_p</name> <operator>=</operator> <name>RedoRecPtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>doPageWrites_p</name> <operator>=</operator> <name>doPageWrites</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * GetInsertRecPtr -- Returns the current insert position.
 *
 * NOTE: The value *actually* returned is the position of the last full
 * xlog page. It lags behind the real insert position by at most 1 page.
 * For that, we don't need to scan through WAL insertion locks, and an
 * approximation is enough for the current usage of this function.
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>GetInsertRecPtr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>recptr</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtRqst</name><operator>.</operator><name>Write</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>recptr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetFlushRecPtr -- Returns the current flush position, ie, the last WAL
 * position known to be fsync'd to disk.
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>GetFlushRecPtr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>LogwrtResult</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtResult</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>LogwrtResult</name><operator>.</operator><name>Flush</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetLastImportantRecPtr -- Returns the LSN of the last important record
 * inserted. All records not explicitly marked as unimportant are considered
 * important.
 *
 * The LSN is determined by computing the maximum of
 * WALInsertLocks[i].lastImportantAt.
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>GetLastImportantRecPtr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>res</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_XLOGINSERT_LOCKS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>last_important</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Need to take a lock to prevent torn reads of the LSN, which are
		 * possible on some of the supported platforms. WAL insert locks only
		 * support exclusive mode, so we have to use that.
		 */</comment>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>WALInsertLocks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>l</name><operator>.</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>last_important</name> <operator>=</operator> <name><name>WALInsertLocks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>l</name><operator>.</operator><name>lastImportantAt</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>WALInsertLocks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>l</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <name>last_important</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <name>last_important</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the time and LSN of the last xlog segment switch
 */</comment>
<function><type><name>pg_time_t</name></type>
<name>GetLastSegSwitchData</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>lastSwitchLSN</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Need WALWriteLock, but shared lock is sufficient */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>WALWriteLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>lastSegSwitchTime</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>lastSwitchLSN</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>lastSegSwitchLSN</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>WALWriteLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetNextXidAndEpoch - get the current nextXid value and associated epoch
 *
 * This is exported for use by code that would like to have 64-bit XIDs.
 * We don't really support such things, but all XIDs within the system
 * can be presumed "close to" the result, and thus the epoch associated
 * with them can be determined.
 */</comment>
<function><type><name>void</name></type>
<name>GetNextXidAndEpoch</name><parameter_list>(<parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>xid</name></decl></parameter>, <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>epoch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>ckptXidEpoch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>ckptXid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>nextXid</name></decl>;</decl_stmt>

	<comment type="block">/* Must read checkpoint info first, else have race condition */</comment>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ckptXidEpoch</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>ckptXidEpoch</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ckptXid</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>ckptXid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now fetch current nextXid */</comment>
	<expr_stmt><expr><name>nextXid</name> <operator>=</operator> <call><name>ReadNewTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * nextXid is certainly logically later than ckptXid.  So if it's
	 * numerically less, it must have wrapped into the next epoch.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nextXid</name> <operator>&lt;</operator> <name>ckptXid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ckptXidEpoch</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>xid</name> <operator>=</operator> <name>nextXid</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>epoch</name> <operator>=</operator> <name>ckptXidEpoch</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This must be called ONCE during postmaster or standalone-backend shutdown
 */</comment>
<function><type><name>void</name></type>
<name>ShutdownXLOG</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Don't be chatty in standalone mode */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><name>IsPostmasterEnvironment</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>NOTICE</name></expr></else></ternary></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"shutting down"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Signal walsenders to move to stopping state.
	 */</comment>
	<expr_stmt><expr><call><name>WalSndInitStopping</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Wait for WAL senders to be in stopping state.  This prevents commands
	 * from writing new WAL.
	 */</comment>
	<expr_stmt><expr><call><name>WalSndWaitStopping</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CreateRestartPoint</name><argument_list>(<argument><expr><name>CHECKPOINT_IS_SHUTDOWN</name> <operator>|</operator> <name>CHECKPOINT_IMMEDIATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If archiving is enabled, rotate the last XLOG file so that all the
		 * remaining records are archived (postmaster wakes up the archiver
		 * process one more time at the end of shutdown). The checkpoint
		 * record will go to the next XLOG file and won't be archived (yet).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>XLogArchivingActive</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>XLogArchiveCommandSet</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>RequestXLogSwitch</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>CreateCheckPoint</name><argument_list>(<argument><expr><name>CHECKPOINT_IS_SHUTDOWN</name> <operator>|</operator> <name>CHECKPOINT_IMMEDIATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>ShutdownCLOG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ShutdownCommitTs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ShutdownSUBTRANS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ShutdownMultiXact</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Log start of a checkpoint.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>LogCheckpointStart</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>restartpoint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"%s starting:%s%s%s%s%s%s%s%s"</literal></expr></argument>,
		 <argument><expr><ternary><condition><expr><name>restartpoint</name></expr> ?</condition><then> <expr><literal type="string">"restartpoint"</literal></expr> </then><else>: <expr><literal type="string">"checkpoint"</literal></expr></else></ternary></expr></argument>,
		 <argument><expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>CHECKPOINT_IS_SHUTDOWN</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">" shutdown"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
		 <argument><expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>CHECKPOINT_END_OF_RECOVERY</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">" end-of-recovery"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
		 <argument><expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>CHECKPOINT_IMMEDIATE</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">" immediate"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
		 <argument><expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>CHECKPOINT_FORCE</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">" force"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
		 <argument><expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>CHECKPOINT_WAIT</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">" wait"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
		 <argument><expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>CHECKPOINT_CAUSE_XLOG</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">" xlog"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
		 <argument><expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>CHECKPOINT_CAUSE_TIME</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">" time"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
		 <argument><expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>CHECKPOINT_FLUSH_ALL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">" flush-all"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Log end of a checkpoint.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>LogCheckpointEnd</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>restartpoint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>long</name></type>		<name>write_secs</name></decl>,
				<decl><type ref="prev"/><name>sync_secs</name></decl>,
				<decl><type ref="prev"/><name>total_secs</name></decl>,
				<decl><type ref="prev"/><name>longest_secs</name></decl>,
				<decl><type ref="prev"/><name>average_secs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>write_usecs</name></decl>,
				<decl><type ref="prev"/><name>sync_usecs</name></decl>,
				<decl><type ref="prev"/><name>total_usecs</name></decl>,
				<decl><type ref="prev"/><name>longest_usecs</name></decl>,
				<decl><type ref="prev"/><name>average_usecs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>average_sync_time</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>CheckpointStats</name><operator>.</operator><name>ckpt_end_t</name></name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TimestampDifference</name><argument_list>(<argument><expr><name><name>CheckpointStats</name><operator>.</operator><name>ckpt_write_t</name></name></expr></argument>,
						<argument><expr><name><name>CheckpointStats</name><operator>.</operator><name>ckpt_sync_t</name></name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>write_secs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>write_usecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TimestampDifference</name><argument_list>(<argument><expr><name><name>CheckpointStats</name><operator>.</operator><name>ckpt_sync_t</name></name></expr></argument>,
						<argument><expr><name><name>CheckpointStats</name><operator>.</operator><name>ckpt_sync_end_t</name></name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>sync_secs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sync_usecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Accumulate checkpoint timing summary data, in milliseconds. */</comment>
	<expr_stmt><expr><name><name>BgWriterStats</name><operator>.</operator><name>m_checkpoint_write_time</name></name> <operator>+=</operator>
		<name>write_secs</name> <operator>*</operator> <literal type="number">1000</literal> <operator>+</operator> <name>write_usecs</name> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>BgWriterStats</name><operator>.</operator><name>m_checkpoint_sync_time</name></name> <operator>+=</operator>
		<name>sync_secs</name> <operator>*</operator> <literal type="number">1000</literal> <operator>+</operator> <name>sync_usecs</name> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * All of the published timing statistics are accounted for.  Only
	 * continue if a log message is to be written.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>log_checkpoints</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>TimestampDifference</name><argument_list>(<argument><expr><name><name>CheckpointStats</name><operator>.</operator><name>ckpt_start_t</name></name></expr></argument>,
						<argument><expr><name><name>CheckpointStats</name><operator>.</operator><name>ckpt_end_t</name></name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>total_secs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>total_usecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Timing values returned from CheckpointStats are in microseconds.
	 * Convert to the second plus microsecond form that TimestampDifference
	 * returns for homogeneous printing.
	 */</comment>
	<expr_stmt><expr><name>longest_secs</name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name><name>CheckpointStats</name><operator>.</operator><name>ckpt_longest_sync</name></name> <operator>/</operator> <literal type="number">1000000</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>longest_usecs</name> <operator>=</operator> <name><name>CheckpointStats</name><operator>.</operator><name>ckpt_longest_sync</name></name> <operator>-</operator>
		<operator>(</operator><name>uint64</name><operator>)</operator> <name>longest_secs</name> <operator>*</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>average_sync_time</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>CheckpointStats</name><operator>.</operator><name>ckpt_sync_rels</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>average_sync_time</name> <operator>=</operator> <name><name>CheckpointStats</name><operator>.</operator><name>ckpt_agg_sync_time</name></name> <operator>/</operator>
			<name><name>CheckpointStats</name><operator>.</operator><name>ckpt_sync_rels</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>average_secs</name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name>average_sync_time</name> <operator>/</operator> <literal type="number">1000000</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>average_usecs</name> <operator>=</operator> <name>average_sync_time</name> <operator>-</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <name>average_secs</name> <operator>*</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"%s complete: wrote %d buffers (%.1f%%); "</literal>
		 <literal type="string">"%d WAL file(s) added, %d removed, %d recycled; "</literal>
		 <literal type="string">"write=%ld.%03d s, sync=%ld.%03d s, total=%ld.%03d s; "</literal>
		 <literal type="string">"sync files=%d, longest=%ld.%03d s, average=%ld.%03d s; "</literal>
		 <literal type="string">"distance=%d kB, estimate=%d kB"</literal></expr></argument>,
		 <argument><expr><ternary><condition><expr><name>restartpoint</name></expr> ?</condition><then> <expr><literal type="string">"restartpoint"</literal></expr> </then><else>: <expr><literal type="string">"checkpoint"</literal></expr></else></ternary></expr></argument>,
		 <argument><expr><name><name>CheckpointStats</name><operator>.</operator><name>ckpt_bufs_written</name></name></expr></argument>,
		 <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name><name>CheckpointStats</name><operator>.</operator><name>ckpt_bufs_written</name></name> <operator>*</operator> <literal type="number">100</literal> <operator>/</operator> <name>NBuffers</name></expr></argument>,
		 <argument><expr><name><name>CheckpointStats</name><operator>.</operator><name>ckpt_segs_added</name></name></expr></argument>,
		 <argument><expr><name><name>CheckpointStats</name><operator>.</operator><name>ckpt_segs_removed</name></name></expr></argument>,
		 <argument><expr><name><name>CheckpointStats</name><operator>.</operator><name>ckpt_segs_recycled</name></name></expr></argument>,
		 <argument><expr><name>write_secs</name></expr></argument>, <argument><expr><name>write_usecs</name> <operator>/</operator> <literal type="number">1000</literal></expr></argument>,
		 <argument><expr><name>sync_secs</name></expr></argument>, <argument><expr><name>sync_usecs</name> <operator>/</operator> <literal type="number">1000</literal></expr></argument>,
		 <argument><expr><name>total_secs</name></expr></argument>, <argument><expr><name>total_usecs</name> <operator>/</operator> <literal type="number">1000</literal></expr></argument>,
		 <argument><expr><name><name>CheckpointStats</name><operator>.</operator><name>ckpt_sync_rels</name></name></expr></argument>,
		 <argument><expr><name>longest_secs</name></expr></argument>, <argument><expr><name>longest_usecs</name> <operator>/</operator> <literal type="number">1000</literal></expr></argument>,
		 <argument><expr><name>average_secs</name></expr></argument>, <argument><expr><name>average_usecs</name> <operator>/</operator> <literal type="number">1000</literal></expr></argument>,
		 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>PrevCheckPointDistance</name> <operator>/</operator> <literal type="number">1024.0</literal><operator>)</operator></expr></argument>,
		 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>CheckPointDistanceEstimate</name> <operator>/</operator> <literal type="number">1024.0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Update the estimate of distance between checkpoints.
 *
 * The estimate is used to calculate the number of WAL segments to keep
 * preallocated, see XLOGFileSlop().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>UpdateCheckPointDistanceEstimate</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>nbytes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * To estimate the number of segments consumed between checkpoints, keep a
	 * moving average of the amount of WAL generated in previous checkpoint
	 * cycles. However, if the load is bursty, with quiet periods and busy
	 * periods, we want to cater for the peak load. So instead of a plain
	 * moving average, let the average decline slowly if the previous cycle
	 * used less WAL than estimated, but bump it up immediately if it used
	 * more.
	 *
	 * When checkpoints are triggered by max_wal_size, this should converge to
	 * CheckpointSegments * wal_segment_size,
	 *
	 * Note: This doesn't pay any attention to what caused the checkpoint.
	 * Checkpoints triggered manually with CHECKPOINT command, or by e.g.
	 * starting a base backup, are counted the same as those created
	 * automatically. The slow-decline will largely mask them out, if they are
	 * not frequent. If they are frequent, it seems reasonable to count them
	 * in as any others; if you issue a manual checkpoint every 5 minutes and
	 * never let a timed checkpoint happen, it makes sense to base the
	 * preallocation on that 5 minute interval rather than whatever
	 * checkpoint_timeout is set to.
	 */</comment>
	<expr_stmt><expr><name>PrevCheckPointDistance</name> <operator>=</operator> <name>nbytes</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>CheckPointDistanceEstimate</name> <operator>&lt;</operator> <name>nbytes</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>CheckPointDistanceEstimate</name> <operator>=</operator> <name>nbytes</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>CheckPointDistanceEstimate</name> <operator>=</operator>
			<operator>(</operator><literal type="number">0.90</literal> <operator>*</operator> <name>CheckPointDistanceEstimate</name> <operator>+</operator> <literal type="number">0.10</literal> <operator>*</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>nbytes</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Perform a checkpoint --- either during shutdown, or on-the-fly
 *
 * flags is a bitwise OR of the following:
 *	CHECKPOINT_IS_SHUTDOWN: checkpoint is for database shutdown.
 *	CHECKPOINT_END_OF_RECOVERY: checkpoint is for end of WAL recovery.
 *	CHECKPOINT_IMMEDIATE: finish the checkpoint ASAP,
 *		ignoring checkpoint_completion_target parameter.
 *	CHECKPOINT_FORCE: force a checkpoint even if no XLOG activity has occurred
 *		since the last one (implied by CHECKPOINT_IS_SHUTDOWN or
 *		CHECKPOINT_END_OF_RECOVERY).
 *	CHECKPOINT_FLUSH_ALL: also flush buffers of unlogged tables.
 *
 * Note: flags contains other bits, of interest here only for logging purposes.
 * In particular note that this routine is synchronous and does not pay
 * attention to CHECKPOINT_WAIT.
 *
 * If !shutdown then we are writing an online checkpoint. This is a very special
 * kind of operation and WAL record because the checkpoint action occurs over
 * a period of time yet logically occurs at just a single LSN. The logical
 * position of the WAL record (redo ptr) is the same or earlier than the
 * physical position. When we replay WAL we locate the checkpoint via its
 * physical position then read the redo ptr and actually start replay at the
 * earlier logical position. Note that we don't write *anything* to WAL at
 * the logical position, so that location could be any other kind of WAL record.
 * All of this mechanism allows us to continue working while we checkpoint.
 * As a result, timing of actions is critical here and be careful to note that
 * this function will likely take minutes to execute on a busy system.
 */</comment>
<function><type><name>void</name></type>
<name>CreateCheckPoint</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>shutdown</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CheckPoint</name></type>	<name>checkPoint</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>_logSegNo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogCtlInsert</name> <modifier>*</modifier></type><name>Insert</name> <init>= <expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>freespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>PriorRedoPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>curInsert</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>last_important_lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VirtualTransactionId</name> <modifier>*</modifier></type><name>vxids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nvxids</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * An end-of-recovery checkpoint is really a shutdown checkpoint, just
	 * issued at a different time.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>CHECKPOINT_IS_SHUTDOWN</name> <operator>|</operator> <name>CHECKPOINT_END_OF_RECOVERY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>shutdown</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>shutdown</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* sanity check */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>CHECKPOINT_END_OF_RECOVERY</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"can't create a checkpoint during recovery"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Initialize InitXLogInsert working areas before entering the critical
	 * section.  Normally, this is done by the first call to
	 * RecoveryInProgress() or LocalSetXLogInsertAllowed(), but when creating
	 * an end-of-recovery checkpoint, the LocalSetXLogInsertAllowed call is
	 * done below in a critical section, and InitXLogInsert cannot be called
	 * in a critical section.
	 */</comment>
	<expr_stmt><expr><call><name>InitXLogInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Acquire CheckpointLock to ensure only one checkpoint happens at a time.
	 * (This is just pro forma, since in the present system structure there is
	 * only one process that is allowed to issue checkpoints at any given
	 * time.)
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>CheckpointLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prepare to accumulate statistics.
	 *
	 * Note: because it is possible for log_checkpoints to change while a
	 * checkpoint proceeds, we always accumulate stats, even if
	 * log_checkpoints is currently off.
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>CheckpointStats</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CheckpointStats</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>CheckpointStats</name><operator>.</operator><name>ckpt_start_t</name></name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Use a critical section to force system panic if we have trouble.
	 */</comment>
	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>shutdown</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ControlFileLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>DB_SHUTDOWNING</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UpdateControlFile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ControlFileLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Let smgr prepare for checkpoint; this has to happen before we determine
	 * the REDO pointer.  Note that smgr must not do anything that'd have to
	 * be undone if we decide no checkpoint is needed.
	 */</comment>
	<expr_stmt><expr><call><name>smgrpreckpt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Begin filling in the checkpoint WAL record */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>checkPoint</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>checkPoint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkPoint</name><operator>.</operator><name>time</name></name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For Hot Standby, derive the oldestActiveXid before we fix the redo
	 * pointer. This allows us to begin accumulating changes to assemble our
	 * starting snapshot of locks and transactions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>shutdown</name> <operator>&amp;&amp;</operator> <call><name>XLogStandbyInfoActive</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>checkPoint</name><operator>.</operator><name>oldestActiveXid</name></name> <operator>=</operator> <call><name>GetOldestActiveTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>checkPoint</name><operator>.</operator><name>oldestActiveXid</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Get location of last important record before acquiring insert locks (as
	 * GetLastImportantRecPtr() also locks WAL locks).
	 */</comment>
	<expr_stmt><expr><name>last_important_lsn</name> <operator>=</operator> <call><name>GetLastImportantRecPtr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We must block concurrent insertions while examining insert state to
	 * determine the checkpoint REDO pointer.
	 */</comment>
	<expr_stmt><expr><call><name>WALInsertLockAcquireExclusive</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>curInsert</name> <operator>=</operator> <call><name>XLogBytePosToRecPtr</name><argument_list>(<argument><expr><name><name>Insert</name><operator>-&gt;</operator><name>CurrBytePos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this isn't a shutdown or forced checkpoint, and if there has been no
	 * WAL activity requiring a checkpoint, skip it.  The idea here is to
	 * avoid inserting duplicate checkpoints when the system is idle.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>CHECKPOINT_IS_SHUTDOWN</name> <operator>|</operator> <name>CHECKPOINT_END_OF_RECOVERY</name> <operator>|</operator>
				  <name>CHECKPOINT_FORCE</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>last_important_lsn</name> <operator>==</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>checkPoint</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>WALInsertLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>CheckpointLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"checkpoint skipped because system is idle"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * An end-of-recovery checkpoint is created before anyone is allowed to
	 * write WAL. To allow us to write the checkpoint record, temporarily
	 * enable XLogInsertAllowed.  (This also ensures ThisTimeLineID is
	 * initialized, which we need here and in AdvanceXLInsertBuffer.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>CHECKPOINT_END_OF_RECOVERY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LocalSetXLogInsertAllowed</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>checkPoint</name><operator>.</operator><name>ThisTimeLineID</name></name> <operator>=</operator> <name>ThisTimeLineID</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>CHECKPOINT_END_OF_RECOVERY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>checkPoint</name><operator>.</operator><name>PrevTimeLineID</name></name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>PrevTimeLineID</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>checkPoint</name><operator>.</operator><name>PrevTimeLineID</name></name> <operator>=</operator> <name>ThisTimeLineID</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>checkPoint</name><operator>.</operator><name>fullPageWrites</name></name> <operator>=</operator> <name><name>Insert</name><operator>-&gt;</operator><name>fullPageWrites</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute new REDO record ptr = location of next XLOG record.
	 *
	 * NB: this is NOT necessarily where the checkpoint record itself will be,
	 * since other backends may insert more XLOG records while we're off doing
	 * the buffer flush work.  Those XLOG records are logically after the
	 * checkpoint, even though physically before it.  Got that?
	 */</comment>
	<expr_stmt><expr><name>freespace</name> <operator>=</operator> <call><name>INSERT_FREESPACE</name><argument_list>(<argument><expr><name>curInsert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>freespace</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>XLogSegmentOffset</name><argument_list>(<argument><expr><name>curInsert</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>curInsert</name> <operator>+=</operator> <name>SizeOfXLogLongPHD</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>curInsert</name> <operator>+=</operator> <name>SizeOfXLogShortPHD</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>checkPoint</name><operator>.</operator><name>redo</name></name> <operator>=</operator> <name>curInsert</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Here we update the shared RedoRecPtr for future XLogInsert calls; this
	 * must be done while holding all the insertion locks.
	 *
	 * Note: if we fail to complete the checkpoint, RedoRecPtr will be left
	 * pointing past where it really needs to point.  This is okay; the only
	 * consequence is that XLogInsert might back up whole buffers that it
	 * didn't really need to.  We can't postpone advancing RedoRecPtr because
	 * XLogInserts that happen while we are dumping buffers must assume that
	 * their buffer changes are not included in the checkpoint.
	 */</comment>
	<expr_stmt><expr><name>RedoRecPtr</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>RedoRecPtr</name></name> <operator>=</operator> <name><name>checkPoint</name><operator>.</operator><name>redo</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now we can release the WAL insertion locks, allowing other xacts to
	 * proceed while we are flushing disk buffers.
	 */</comment>
	<expr_stmt><expr><call><name>WALInsertLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update the info_lck-protected copy of RedoRecPtr as well */</comment>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>RedoRecPtr</name></name> <operator>=</operator> <name><name>checkPoint</name><operator>.</operator><name>redo</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If enabled, log checkpoint start.  We postpone this until now so as not
	 * to log anything if we decided to skip the checkpoint.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>log_checkpoints</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LogCheckpointStart</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_CHECKPOINT_START</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get the other info we need for the checkpoint record.
	 *
	 * We don't need to save oldestClogXid in the checkpoint, it only matters
	 * for the short period in which clog is being truncated, and if we crash
	 * during that we'll redo the clog truncation and fix up oldestClogXid
	 * there.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkPoint</name><operator>.</operator><name>nextXid</name></name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkPoint</name><operator>.</operator><name>oldestXid</name></name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oldestXid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkPoint</name><operator>.</operator><name>oldestXidDB</name></name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oldestXidDB</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>CommitTsLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkPoint</name><operator>.</operator><name>oldestCommitTsXid</name></name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oldestCommitTsXid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkPoint</name><operator>.</operator><name>newestCommitTsXid</name></name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>newestCommitTsXid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>CommitTsLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Increase XID epoch if we've wrapped around since last checkpoint */</comment>
	<expr_stmt><expr><name><name>checkPoint</name><operator>.</operator><name>nextXidEpoch</name></name> <operator>=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>checkPointCopy</name><operator>.</operator><name>nextXidEpoch</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>checkPoint</name><operator>.</operator><name>nextXid</name></name> <operator>&lt;</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>checkPointCopy</name><operator>.</operator><name>nextXid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>checkPoint</name><operator>.</operator><name>nextXidEpoch</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>OidGenLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkPoint</name><operator>.</operator><name>nextOid</name></name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextOid</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>shutdown</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>checkPoint</name><operator>.</operator><name>nextOid</name></name> <operator>+=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oidCount</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>OidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MultiXactGetCheckptMulti</name><argument_list>(<argument><expr><name>shutdown</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>checkPoint</name><operator>.</operator><name>nextMulti</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>checkPoint</name><operator>.</operator><name>nextMultiOffset</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>checkPoint</name><operator>.</operator><name>oldestMulti</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>checkPoint</name><operator>.</operator><name>oldestMultiDB</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Having constructed the checkpoint record, ensure all shmem disk buffers
	 * and commit-log buffers are flushed to disk.
	 *
	 * This I/O could fail for various reasons.  If so, we will fail to
	 * complete the checkpoint, but there is no reason to force a system
	 * panic. Accordingly, exit critical section while doing it.
	 */</comment>
	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In some cases there are groups of actions that must all occur on one
	 * side or the other of a checkpoint record. Before flushing the
	 * checkpoint record we must explicitly wait for any backend currently
	 * performing those groups of actions.
	 *
	 * One example is end of transaction, so we must wait for any transactions
	 * that are currently in commit critical sections.  If an xact inserted
	 * its commit record into XLOG just before the REDO point, then a crash
	 * restart from the REDO point would not replay that record, which means
	 * that our flushing had better include the xact's update of pg_xact.  So
	 * we wait till he's out of his commit critical section before proceeding.
	 * See notes in RecordTransactionCommit().
	 *
	 * Because we've already released the insertion locks, this test is a bit
	 * fuzzy: it is possible that we will wait for xacts we didn't really need
	 * to wait for.  But the delay should be short and it seems better to make
	 * checkpoint take a bit longer than to hold off insertions longer than
	 * necessary. (In fact, the whole reason we have this issue is that xact.c
	 * does commit record XLOG insertion and clog update as two separate steps
	 * protected by different locks, but again that seems best on grounds of
	 * minimizing lock contention.)
	 *
	 * A transaction that has not yet set delayChkpt when we look cannot be at
	 * risk, since he's not inserted his commit record yet; and one that's
	 * already cleared it is not at risk either, since he's done fixing clog
	 * and we will correctly flush the update below.  So we cannot miss any
	 * xacts we need to wait for.
	 */</comment>
	<expr_stmt><expr><name>vxids</name> <operator>=</operator> <call><name>GetVirtualXIDsDelayingChkpt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nvxids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nvxids</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<do>do
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">10000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* wait for 10 msec */</comment>
		</block_content>}</block> while <condition>(<expr><call><name>HaveVirtualXIDsDelayingChkpt</name><argument_list>(<argument><expr><name>vxids</name></expr></argument>, <argument><expr><name>nvxids</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>vxids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CheckPointGuts</name><argument_list>(<argument><expr><name><name>checkPoint</name><operator>.</operator><name>redo</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Take a snapshot of running transactions and write this to WAL. This
	 * allows us to reconstruct the state of running transactions during
	 * archive recovery, if required. Skip, if this info disabled.
	 *
	 * If we are shutting down, or Startup process is completing crash
	 * recovery we don't need to write running xact data.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>shutdown</name> <operator>&amp;&amp;</operator> <call><name>XLogStandbyInfoActive</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LogStandbySnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now insert the checkpoint record into XLOG.
	 */</comment>
	<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>checkPoint</name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>checkPoint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_XLOG_ID</name></expr></argument>,
						<argument><expr><ternary><condition><expr><name>shutdown</name></expr> ?</condition><then> <expr><name>XLOG_CHECKPOINT_SHUTDOWN</name></expr> </then><else>:
						<expr><name>XLOG_CHECKPOINT_ONLINE</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XLogFlush</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We mustn't write any new WAL after a shutdown checkpoint, or it will be
	 * overwritten at next startup.  No-one should even try, this just allows
	 * sanity-checking.  In the case of an end-of-recovery checkpoint, we want
	 * to just temporarily disable writing until the system has exited
	 * recovery.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>shutdown</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>CHECKPOINT_END_OF_RECOVERY</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>LocalXLogInsertAllowed</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* return to "check" state */</comment>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>LocalXLogInsertAllowed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt> <comment type="block">/* never again write WAL */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We now have ProcLastRecPtr = start of actual checkpoint record, recptr
	 * = end of actual checkpoint record.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>shutdown</name> <operator>&amp;&amp;</operator> <name><name>checkPoint</name><operator>.</operator><name>redo</name></name> <operator>!=</operator> <name>ProcLastRecPtr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"concurrent write-ahead log activity while database system is shutting down"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Remember the prior checkpoint's redo ptr for
	 * UpdateCheckPointDistanceEstimate()
	 */</comment>
	<expr_stmt><expr><name>PriorRedoPtr</name> <operator>=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>checkPointCopy</name><operator>.</operator><name>redo</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update the control file.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ControlFileLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>shutdown</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>DB_SHUTDOWNED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>checkPoint</name></name> <operator>=</operator> <name>ProcLastRecPtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>checkPointCopy</name></name> <operator>=</operator> <name>checkPoint</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* crash recovery should always recover to the end of WAL */</comment>
	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPoint</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPointTLI</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Persist unloggedLSN value. It's reset on crash recovery, so this goes
	 * unused on non-shutdown checkpoints, but seems useful to store it always
	 * for debugging purposes.
	 */</comment>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>ulsn_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>unloggedLSN</name></name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>unloggedLSN</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>ulsn_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UpdateControlFile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ControlFileLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update shared-memory copy of checkpoint XID/epoch */</comment>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>ckptXidEpoch</name></name> <operator>=</operator> <name><name>checkPoint</name><operator>.</operator><name>nextXidEpoch</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>ckptXid</name></name> <operator>=</operator> <name><name>checkPoint</name><operator>.</operator><name>nextXid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We are now done with critical updates; no need for system panic if we
	 * have trouble while fooling with old log segments.
	 */</comment>
	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Let smgr do post-checkpoint cleanup (eg, deleting old files).
	 */</comment>
	<expr_stmt><expr><call><name>smgrpostckpt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update the average distance between checkpoints if the prior checkpoint
	 * exists.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>PriorRedoPtr</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UpdateCheckPointDistanceEstimate</name><argument_list>(<argument><expr><name>RedoRecPtr</name> <operator>-</operator> <name>PriorRedoPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Delete old log files, those no longer needed for last checkpoint to
	 * prevent the disk holding the xlog from growing full.
	 */</comment>
	<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>RedoRecPtr</name></expr></argument>, <argument><expr><name>_logSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>KeepLogSeg</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>_logSegNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>_logSegNo</name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RemoveOldXlogFiles</name><argument_list>(<argument><expr><name>_logSegNo</name></expr></argument>, <argument><expr><name>RedoRecPtr</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make more log segments if needed.  (Do this after recycling old log
	 * segments, since that may supply some of the needed files.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>shutdown</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PreallocXlogFiles</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Truncate pg_subtrans if possible.  We can throw away all data before
	 * the oldest XMIN of any running transaction.  No future transaction will
	 * attempt to reference any pg_subtrans entry older than that (see Asserts
	 * in subtrans.c).  During recovery, though, we mustn't do this because
	 * StartupSUBTRANS hasn't been called yet.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>TruncateSUBTRANS</name><argument_list>(<argument><expr><call><name>GetOldestXmin</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>PROCARRAY_FLAGS_DEFAULT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Real work is done, but log and update stats before releasing lock. */</comment>
	<expr_stmt><expr><call><name>LogCheckpointEnd</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_CHECKPOINT_DONE</name><argument_list>(<argument><expr><name><name>CheckpointStats</name><operator>.</operator><name>ckpt_bufs_written</name></name></expr></argument>,
									 <argument><expr><name>NBuffers</name></expr></argument>,
									 <argument><expr><name><name>CheckpointStats</name><operator>.</operator><name>ckpt_segs_added</name></name></expr></argument>,
									 <argument><expr><name><name>CheckpointStats</name><operator>.</operator><name>ckpt_segs_removed</name></name></expr></argument>,
									 <argument><expr><name><name>CheckpointStats</name><operator>.</operator><name>ckpt_segs_recycled</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>CheckpointLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Mark the end of recovery in WAL though without running a full checkpoint.
 * We can expect that a restartpoint is likely to be in progress as we
 * do this, though we are unwilling to wait for it to complete. So be
 * careful to avoid taking the CheckpointLock anywhere here.
 *
 * CreateRestartPoint() allows for the case where recovery may end before
 * the restartpoint completes so there is no concern of concurrent behaviour.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CreateEndOfRecoveryRecord</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>xl_end_of_recovery</name></type> <name>xlrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

	<comment type="block">/* sanity check */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"can only be used to end recovery"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>end_time</name></name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WALInsertLockAcquireExclusive</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>ThisTimeLineID</name></name> <operator>=</operator> <name>ThisTimeLineID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>PrevTimeLineID</name></name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>PrevTimeLineID</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WALInsertLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LocalSetXLogInsertAllowed</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xl_end_of_recovery</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_XLOG_ID</name></expr></argument>, <argument><expr><name>XLOG_END_OF_RECOVERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XLogFlush</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update the control file so that crash recovery can follow the timeline
	 * changes to this point.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ControlFileLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPoint</name></name> <operator>=</operator> <name>recptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPointTLI</name></name> <operator>=</operator> <name>ThisTimeLineID</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UpdateControlFile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ControlFileLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>LocalXLogInsertAllowed</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* return to "check" state */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Flush all data in shared memory to disk, and fsync
 *
 * This is the common code shared between regular checkpoints and
 * recovery restartpoints.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CheckPointGuts</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>checkPointRedo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckPointCLOG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CheckPointCommitTs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CheckPointSUBTRANS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CheckPointMultiXact</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CheckPointPredicate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CheckPointRelationMap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CheckPointReplicationSlots</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CheckPointSnapBuild</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CheckPointLogicalRewriteHeap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CheckPointBuffers</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* performs all required fsyncs */</comment>
	<expr_stmt><expr><call><name>CheckPointReplicationOrigin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* We deliberately delay 2PC checkpointing as long as possible */</comment>
	<expr_stmt><expr><call><name>CheckPointTwoPhase</name><argument_list>(<argument><expr><name>checkPointRedo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Save a checkpoint for recovery restart if appropriate
 *
 * This function is called each time a checkpoint record is read from XLOG.
 * It must determine whether the checkpoint represents a safe restartpoint or
 * not.  If so, the checkpoint record is stashed in shared memory so that
 * CreateRestartPoint can consult it.  (Note that the latter function is
 * executed by the checkpointer, while this one will be executed by the
 * startup process.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RecoveryRestartPoint</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CheckPoint</name> <modifier>*</modifier></type><name>checkPoint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Also refrain from creating a restartpoint if we have seen any
	 * references to non-existent pages. Restarting recovery from the
	 * restartpoint would not see the references, so we would lose the
	 * cross-check that the pages belonged to a relation that was dropped
	 * later.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>XLogHaveInvalidPages</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><call><name>trace_recovery</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><literal type="string">"could not record restart point at %X/%X because there "</literal>
			 <literal type="string">"are unresolved references to invalid pages"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>checkPoint</name><operator>-&gt;</operator><name>redo</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>checkPoint</name><operator>-&gt;</operator><name>redo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Copy the checkpoint record to shared memory, so that checkpointer can
	 * work out the next time it wants to perform a restartpoint.
	 */</comment>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>lastCheckPointRecPtr</name></name> <operator>=</operator> <name>ReadRecPtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>lastCheckPointEndPtr</name></name> <operator>=</operator> <name>EndRecPtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>lastCheckPoint</name></name> <operator>=</operator> <operator>*</operator><name>checkPoint</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Establish a restartpoint if possible.
 *
 * This is similar to CreateCheckPoint, but is used during WAL recovery
 * to establish a point from which recovery can roll forward without
 * replaying the entire recovery log.
 *
 * Returns true if a new restartpoint was established. We can only establish
 * a restartpoint if we have replayed a safe checkpoint record since last
 * restartpoint.
 */</comment>
<function><type><name>bool</name></type>
<name>CreateRestartPoint</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lastCheckPointRecPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lastCheckPointEndPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CheckPoint</name></type>	<name>lastCheckPoint</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>PriorRedoPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>receivePtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>replayPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>replayTLI</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>endptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>_logSegNo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>xtime</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Acquire CheckpointLock to ensure only one restartpoint or checkpoint
	 * happens at a time.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>CheckpointLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get a local copy of the last safe checkpoint record. */</comment>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lastCheckPointRecPtr</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>lastCheckPointRecPtr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lastCheckPointEndPtr</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>lastCheckPointEndPtr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lastCheckPoint</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>lastCheckPoint</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check that we're still in recovery mode. It's ok if we exit recovery
	 * mode after this check, the restart point is valid anyway.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping restartpoint, recovery has already ended"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>CheckpointLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the last checkpoint record we've replayed is already our last
	 * restartpoint, we can't perform a new restart point. We still update
	 * minRecoveryPoint in that case, so that if this is a shutdown restart
	 * point, we won't start up earlier than before. That's not strictly
	 * necessary, but when hot standby is enabled, it would be rather weird if
	 * the database opened up for read-only connections at a point-in-time
	 * before the last shutdown. Such time travel is still possible in case of
	 * immediate shutdown, though.
	 *
	 * We don't explicitly advance minRecoveryPoint when we do create a
	 * restartpoint. It's assumed that flushing the buffers will do that as a
	 * side-effect.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>lastCheckPointRecPtr</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<name><name>lastCheckPoint</name><operator>.</operator><name>redo</name></name> <operator>&lt;=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>checkPointCopy</name><operator>.</operator><name>redo</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping restartpoint, already performed at %X/%X"</literal></expr></argument>,
						<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>lastCheckPoint</name><operator>.</operator><name>redo</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
						<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>lastCheckPoint</name><operator>.</operator><name>redo</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>UpdateMinRecoveryPoint</name><argument_list>(<argument><expr><name>InvalidXLogRecPtr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>CHECKPOINT_IS_SHUTDOWN</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ControlFileLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>DB_SHUTDOWNED_IN_RECOVERY</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>UpdateControlFile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ControlFileLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>CheckpointLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Update the shared RedoRecPtr so that the startup process can calculate
	 * the number of segments replayed since last restartpoint, and request a
	 * restartpoint if it exceeds CheckPointSegments.
	 *
	 * Like in CreateCheckPoint(), hold off insertions to update it, although
	 * during recovery this is just pro forma, because no WAL insertions are
	 * happening.
	 */</comment>
	<expr_stmt><expr><call><name>WALInsertLockAcquireExclusive</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>RedoRecPtr</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>RedoRecPtr</name></name> <operator>=</operator> <name><name>lastCheckPoint</name><operator>.</operator><name>redo</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WALInsertLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Also update the info_lck-protected copy */</comment>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>RedoRecPtr</name></name> <operator>=</operator> <name><name>lastCheckPoint</name><operator>.</operator><name>redo</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prepare to accumulate statistics.
	 *
	 * Note: because it is possible for log_checkpoints to change while a
	 * checkpoint proceeds, we always accumulate stats, even if
	 * log_checkpoints is currently off.
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>CheckpointStats</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CheckpointStats</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>CheckpointStats</name><operator>.</operator><name>ckpt_start_t</name></name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>log_checkpoints</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LogCheckpointStart</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>CheckPointGuts</name><argument_list>(<argument><expr><name><name>lastCheckPoint</name><operator>.</operator><name>redo</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Remember the prior checkpoint's redo ptr for
	 * UpdateCheckPointDistanceEstimate()
	 */</comment>
	<expr_stmt><expr><name>PriorRedoPtr</name> <operator>=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>checkPointCopy</name><operator>.</operator><name>redo</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update pg_control, using current time.  Check that it still shows
	 * DB_IN_ARCHIVE_RECOVERY state and an older checkpoint, else do nothing;
	 * this is a quick hack to make sure nothing really bad happens if somehow
	 * we get here after the end-of-recovery checkpoint.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ControlFileLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DB_IN_ARCHIVE_RECOVERY</name> <operator>&amp;&amp;</operator>
		<name><name>ControlFile</name><operator>-&gt;</operator><name>checkPointCopy</name><operator>.</operator><name>redo</name></name> <operator>&lt;</operator> <name><name>lastCheckPoint</name><operator>.</operator><name>redo</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>checkPoint</name></name> <operator>=</operator> <name>lastCheckPointRecPtr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>checkPointCopy</name></name> <operator>=</operator> <name>lastCheckPoint</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Ensure minRecoveryPoint is past the checkpoint record.  Normally,
		 * this will have happened already while writing out dirty buffers,
		 * but not necessarily - e.g. because no buffers were dirtied.  We do
		 * this because a non-exclusive base backup uses minRecoveryPoint to
		 * determine which WAL files must be included in the backup, and the
		 * file (or files) containing the checkpoint record must be included,
		 * at a minimum. Note that for an ordinary restart of recovery there's
		 * no value in having the minimum recovery point any earlier than this
		 * anyway, because redo will begin just after the checkpoint record.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPoint</name></name> <operator>&lt;</operator> <name>lastCheckPointEndPtr</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPoint</name></name> <operator>=</operator> <name>lastCheckPointEndPtr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPointTLI</name></name> <operator>=</operator> <name><name>lastCheckPoint</name><operator>.</operator><name>ThisTimeLineID</name></name></expr>;</expr_stmt>

			<comment type="block">/* update local copy */</comment>
			<expr_stmt><expr><name>minRecoveryPoint</name> <operator>=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPoint</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>minRecoveryPointTLI</name> <operator>=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPointTLI</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>CHECKPOINT_IS_SHUTDOWN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>DB_SHUTDOWNED_IN_RECOVERY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>UpdateControlFile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ControlFileLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update the average distance between checkpoints/restartpoints if the
	 * prior checkpoint exists.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>PriorRedoPtr</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UpdateCheckPointDistanceEstimate</name><argument_list>(<argument><expr><name>RedoRecPtr</name> <operator>-</operator> <name>PriorRedoPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Delete old log files, those no longer needed for last restartpoint to
	 * prevent the disk holding the xlog from growing full.
	 */</comment>
	<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>RedoRecPtr</name></expr></argument>, <argument><expr><name>_logSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Retreat _logSegNo using the current end of xlog replayed or received,
	 * whichever is later.
	 */</comment>
	<expr_stmt><expr><name>receivePtr</name> <operator>=</operator> <call><name>GetWalRcvWriteRecPtr</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>replayPtr</name> <operator>=</operator> <call><name>GetXLogReplayRecPtr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>replayTLI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>endptr</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>receivePtr</name> <operator>&lt;</operator> <name>replayPtr</name><operator>)</operator></expr> ?</condition><then> <expr><name>replayPtr</name></expr> </then><else>: <expr><name>receivePtr</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>KeepLogSeg</name><argument_list>(<argument><expr><name>endptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>_logSegNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>_logSegNo</name><operator>--</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Try to recycle segments on a useful timeline. If we've been promoted
	 * since the beginning of this restartpoint, use the new timeline chosen
	 * at end of recovery (RecoveryInProgress() sets ThisTimeLineID in that
	 * case). If we're still in recovery, use the timeline we're currently
	 * replaying.
	 *
	 * There is no guarantee that the WAL segments will be useful on the
	 * current timeline; if recovery proceeds to a new timeline right after
	 * this, the pre-allocated WAL segments on this timeline will not be used,
	 * and will go wasted until recycled on the next restartpoint. We'll live
	 * with that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ThisTimeLineID</name> <operator>=</operator> <name>replayTLI</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>RemoveOldXlogFiles</name><argument_list>(<argument><expr><name>_logSegNo</name></expr></argument>, <argument><expr><name>RedoRecPtr</name></expr></argument>, <argument><expr><name>endptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make more log segments if needed.  (Do this after recycling old log
	 * segments, since that may supply some of the needed files.)
	 */</comment>
	<expr_stmt><expr><call><name>PreallocXlogFiles</name><argument_list>(<argument><expr><name>endptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * ThisTimeLineID is normally not set when we're still in recovery.
	 * However, recycling/preallocating segments above needed ThisTimeLineID
	 * to determine which timeline to install the segments on. Reset it now,
	 * to restore the normal state of affairs for debugging purposes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ThisTimeLineID</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Truncate pg_subtrans if possible.  We can throw away all data before
	 * the oldest XMIN of any running transaction.  No future transaction will
	 * attempt to reference any pg_subtrans entry older than that (see Asserts
	 * in subtrans.c).  When hot standby is disabled, though, we mustn't do
	 * this because StartupSUBTRANS hasn't been called yet.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>EnableHotStandby</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>TruncateSUBTRANS</name><argument_list>(<argument><expr><call><name>GetOldestXmin</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>PROCARRAY_FLAGS_DEFAULT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Real work is done, but log and update before releasing lock. */</comment>
	<expr_stmt><expr><call><name>LogCheckpointEnd</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>xtime</name> <operator>=</operator> <call><name>GetLatestXTime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>log_checkpoints</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>DEBUG2</name></expr></else></ternary><operator>)</operator></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"recovery restart point at %X/%X"</literal></expr></argument>,
					<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>lastCheckPoint</name><operator>.</operator><name>redo</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>lastCheckPoint</name><operator>.</operator><name>redo</name></name></expr></argument>)</argument_list></call><operator>,</operator>
			 <ternary><condition><expr><name>xtime</name></expr> ?</condition><then> <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Last completed transaction was at log time %s."</literal></expr></argument>,
							   <argument><expr><call><name>timestamptz_to_str</name><argument_list>(<argument><expr><name>xtime</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>CheckpointLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Finally, execute archive_cleanup_command, if any.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>archiveCleanupCommand</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecuteRecoveryCommand</name><argument_list>(<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>archiveCleanupCommand</name></name></expr></argument>,
							   <argument><expr><literal type="string">"archive_cleanup_command"</literal></expr></argument>,
							   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Retreat *logSegNo to the last segment that we need to retain because of
 * either wal_keep_segments or replication slots.
 *
 * This is calculated by subtracting wal_keep_segments from the given xlog
 * location, recptr and by making sure that that result is below the
 * requirement of replication slots.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>KeepLogSeg</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>recptr</name></decl></parameter>, <parameter><decl><type><name>XLogSegNo</name> <modifier>*</modifier></type><name>logSegNo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>segno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>keep</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>keep</name> <operator>=</operator> <call><name>XLogGetReplicationSlotMinimumLSN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* compute limit for wal_keep_segments first */</comment>
	<if_stmt><if>if <condition>(<expr><name>wal_keep_segments</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* avoid underflow, don't go below 1 */</comment>
		<if_stmt><if>if <condition>(<expr><name>segno</name> <operator>&lt;=</operator> <name>wal_keep_segments</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>segno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>segno</name> <operator>=</operator> <name>segno</name> <operator>-</operator> <name>wal_keep_segments</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* then check whether slots limit removal further */</comment>
	<if_stmt><if>if <condition>(<expr><name>max_replication_slots</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>keep</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>slotSegNo</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>keep</name></expr></argument>, <argument><expr><name>slotSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>slotSegNo</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>segno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>slotSegNo</name> <operator>&lt;</operator> <name>segno</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>segno</name> <operator>=</operator> <name>slotSegNo</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* don't delete WAL segments newer than the calculated segment */</comment>
	<if_stmt><if>if <condition>(<expr><name>segno</name> <operator>&lt;</operator> <operator>*</operator><name>logSegNo</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>logSegNo</name> <operator>=</operator> <name>segno</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Write a NEXTOID log record
 */</comment>
<function><type><name>void</name></type>
<name>XLogPutNextOid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>nextOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>nextOid</name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_XLOG_ID</name></expr></argument>, <argument><expr><name>XLOG_NEXTOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We need not flush the NEXTOID record immediately, because any of the
	 * just-allocated OIDs could only reach disk as part of a tuple insert or
	 * update that would have its own XLOG record that must follow the NEXTOID
	 * record.  Therefore, the standard buffer LSN interlock applied to those
	 * records will ensure no such OID reaches disk before the NEXTOID record
	 * does.
	 *
	 * Note, however, that the above statement only covers state "within" the
	 * database.  When we use a generated OID as a file or directory name, we
	 * are in a sense violating the basic WAL rule, because that filesystem
	 * change may reach disk before the NEXTOID WAL record does.  The impact
	 * of this is that if a database crash occurs immediately afterward, we
	 * might after restart re-generate the same OID and find that it conflicts
	 * with the leftover file or directory.  But since for safety's sake we
	 * always loop until finding a nonconflicting filename, this poses no real
	 * problem in practice. See pgsql-hackers discussion 27-Sep-2006.
	 */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Write an XLOG SWITCH record.
 *
 * Here we just blindly issue an XLogInsert request for the record.
 * All the magic happens inside XLogInsert.
 *
 * The return value is either the end+1 address of the switch record,
 * or the end+1 address of the prior segment if we did not need to
 * write a switch record because we are already at segment start.
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>RequestXLogSwitch</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>mark_unimportant</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>RecPtr</name></decl>;</decl_stmt>

	<comment type="block">/* XLOG SWITCH has no data */</comment>
	<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>mark_unimportant</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>XLogSetRecordFlags</name><argument_list>(<argument><expr><name>XLOG_MARK_UNIMPORTANT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>RecPtr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_XLOG_ID</name></expr></argument>, <argument><expr><name>XLOG_SWITCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>RecPtr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Write a RESTORE POINT record
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>XLogRestorePoint</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rpName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>RecPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_restore_point</name></type> <name>xlrec</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>rp_time</name></name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>.</operator><name>rp_name</name></name></expr></argument>, <argument><expr><name>rpName</name></expr></argument>, <argument><expr><name>MAXFNAMELEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xl_restore_point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>RecPtr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_XLOG_ID</name></expr></argument>, <argument><expr><name>XLOG_RESTORE_POINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"restore point \"%s\" created at %X/%X"</literal></expr></argument>,
					<argument><expr><name>rpName</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>RecPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>RecPtr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>RecPtr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if any of the GUC parameters that are critical for hot standby
 * have changed, and update the value in pg_control file if necessary.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>XLogReportParameters</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>wal_level</name> <operator>!=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>wal_level</name></name> <operator>||</operator>
		<name>wal_log_hints</name> <operator>!=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>wal_log_hints</name></name> <operator>||</operator>
		<name>MaxConnections</name> <operator>!=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>MaxConnections</name></name> <operator>||</operator>
		<name>max_worker_processes</name> <operator>!=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>max_worker_processes</name></name> <operator>||</operator>
		<name>max_prepared_xacts</name> <operator>!=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>max_prepared_xacts</name></name> <operator>||</operator>
		<name>max_locks_per_xact</name> <operator>!=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>max_locks_per_xact</name></name> <operator>||</operator>
		<name>track_commit_timestamp</name> <operator>!=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>track_commit_timestamp</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The change in number of backend slots doesn't need to be WAL-logged
		 * if archiving is not enabled, as you can't start archive recovery
		 * with wal_level=minimal anyway. We don't really care about the
		 * values in pg_control either if wal_level=minimal, but seems better
		 * to keep them up-to-date to avoid confusion.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>wal_level</name> <operator>!=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>wal_level</name></name> <operator>||</operator> <call><name>XLogIsNeeded</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>xl_parameter_change</name></type> <name>xlrec</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>MaxConnections</name></name> <operator>=</operator> <name>MaxConnections</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>max_worker_processes</name></name> <operator>=</operator> <name>max_worker_processes</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>max_prepared_xacts</name></name> <operator>=</operator> <name>max_prepared_xacts</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>max_locks_per_xact</name></name> <operator>=</operator> <name>max_locks_per_xact</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>wal_level</name></name> <operator>=</operator> <name>wal_level</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>wal_log_hints</name></name> <operator>=</operator> <name>wal_log_hints</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>track_commit_timestamp</name></name> <operator>=</operator> <name>track_commit_timestamp</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xlrec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_XLOG_ID</name></expr></argument>, <argument><expr><name>XLOG_PARAMETER_CHANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogFlush</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>MaxConnections</name></name> <operator>=</operator> <name>MaxConnections</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>max_worker_processes</name></name> <operator>=</operator> <name>max_worker_processes</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>max_prepared_xacts</name></name> <operator>=</operator> <name>max_prepared_xacts</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>max_locks_per_xact</name></name> <operator>=</operator> <name>max_locks_per_xact</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>wal_level</name></name> <operator>=</operator> <name>wal_level</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>wal_log_hints</name></name> <operator>=</operator> <name>wal_log_hints</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>track_commit_timestamp</name></name> <operator>=</operator> <name>track_commit_timestamp</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UpdateControlFile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Update full_page_writes in shared memory, and write an
 * XLOG_FPW_CHANGE record if necessary.
 *
 * Note: this function assumes there is no other process running
 * concurrently that could update it.
 */</comment>
<function><type><name>void</name></type>
<name>UpdateFullPageWrites</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogCtlInsert</name> <modifier>*</modifier></type><name>Insert</name> <init>= <expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>recoveryInProgress</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Do nothing if full_page_writes has not been changed.
	 *
	 * It's safe to check the shared full_page_writes without the lock,
	 * because we assume that there is no concurrently running process which
	 * can update it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>fullPageWrites</name> <operator>==</operator> <name><name>Insert</name><operator>-&gt;</operator><name>fullPageWrites</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Perform this outside critical section so that the WAL insert
	 * initialization done by RecoveryInProgress() doesn't trigger an
	 * assertion failure.
	 */</comment>
	<expr_stmt><expr><name>recoveryInProgress</name> <operator>=</operator> <call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * It's always safe to take full page images, even when not strictly
	 * required, but not the other round. So if we're setting full_page_writes
	 * to true, first set it true and then write the WAL record. If we're
	 * setting it to false, first write the WAL record and then set the global
	 * flag.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>fullPageWrites</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>WALInsertLockAcquireExclusive</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>Insert</name><operator>-&gt;</operator><name>fullPageWrites</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WALInsertLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Write an XLOG_FPW_CHANGE record. This allows us to keep track of
	 * full_page_writes during archive recovery, if required.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>XLogStandbyInfoActive</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>recoveryInProgress</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>fullPageWrites</name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_XLOG_ID</name></expr></argument>, <argument><expr><name>XLOG_FPW_CHANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fullPageWrites</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>WALInsertLockAcquireExclusive</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>Insert</name><operator>-&gt;</operator><name>fullPageWrites</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WALInsertLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check that it's OK to switch to new timeline during recovery.
 *
 * 'lsn' is the address of the shutdown checkpoint record we're about to
 * replay. (Currently, timeline can only change at a shutdown checkpoint).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkTimeLineSwitch</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name></type> <name>newTLI</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name></type> <name>prevTLI</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Check that the record agrees on what the current (old) timeline is */</comment>
	<if_stmt><if>if <condition>(<expr><name>prevTLI</name> <operator>!=</operator> <name>ThisTimeLineID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected previous timeline ID %u (current timeline ID %u) in checkpoint record"</literal></expr></argument>,
						<argument><expr><name>prevTLI</name></expr></argument>, <argument><expr><name>ThisTimeLineID</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The new timeline better be in the list of timelines we expect to see,
	 * according to the timeline history. It should also not decrease.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>newTLI</name> <operator>&lt;</operator> <name>ThisTimeLineID</name> <operator>||</operator> <operator>!</operator><call><name>tliInHistory</name><argument_list>(<argument><expr><name>newTLI</name></expr></argument>, <argument><expr><name>expectedTLEs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected timeline ID %u (after %u) in checkpoint record"</literal></expr></argument>,
						<argument><expr><name>newTLI</name></expr></argument>, <argument><expr><name>ThisTimeLineID</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we have not yet reached min recovery point, and we're about to
	 * switch to a timeline greater than the timeline of the min recovery
	 * point: trouble. After switching to the new timeline, we could not
	 * possibly visit the min recovery point on the correct timeline anymore.
	 * This can happen if there is a newer timeline in the archive that
	 * branched before the timeline the min recovery point is on, and you
	 * attempt to do PITR to the new timeline.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>minRecoveryPoint</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name><name>lsn</name> <argument_list type="generic">&lt; <argument><expr><name>minRecoveryPoint</name> <operator>&amp;&amp;</operator>
		<name>newTLI</name></expr></argument> &gt;</argument_list></name> <name>minRecoveryPointTLI</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected timeline ID %u in checkpoint record, before reaching minimum recovery point %X/%X on timeline %u"</literal></expr></argument>,
						<argument><expr><name>newTLI</name></expr></argument>,
						<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>minRecoveryPoint</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
						<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>minRecoveryPoint</name></expr></argument>,
						<argument><expr><name>minRecoveryPointTLI</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Looks good */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * XLOG resource manager's routines
 *
 * Definitions of info values are in include/catalog/pg_control.h, though
 * not all record types are related to control file updates.
 */</comment>
<function><type><name>void</name></type>
<name>xlog_redo</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>info</name> <init>= <expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* in XLOG rmgr, backup blocks are only used by XLOG_FPI records */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>info</name> <operator>==</operator> <name>XLOG_FPI</name> <operator>||</operator> <name>info</name> <operator>==</operator> <name>XLOG_FPI_FOR_HINT</name> <operator>||</operator>
		   <operator>!</operator><call><name>XLogRecHasAnyBlockRefs</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>info</name> <operator>==</operator> <name>XLOG_NEXTOID</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>nextOid</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We used to try to take the maximum of ShmemVariableCache-&gt;nextOid
		 * and the recorded nextOid, but that fails if the OID counter wraps
		 * around.  Since no OID allocation should be happening during replay
		 * anyway, better to just believe the record exactly.  We still take
		 * OidGenLock while setting the variable, just in case.
		 */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nextOid</name></expr></argument>, <argument><expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>OidGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextOid</name></name> <operator>=</operator> <name>nextOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oidCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>OidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>info</name> <operator>==</operator> <name>XLOG_CHECKPOINT_SHUTDOWN</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CheckPoint</name></type>	<name>checkPoint</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>checkPoint</name></expr></argument>, <argument><expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CheckPoint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* In a SHUTDOWN checkpoint, believe the counters exactly */</comment>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name> <operator>=</operator> <name><name>checkPoint</name><operator>.</operator><name>nextXid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>OidGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextOid</name></name> <operator>=</operator> <name><name>checkPoint</name><operator>.</operator><name>nextOid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oidCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>OidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MultiXactSetNextMXact</name><argument_list>(<argument><expr><name><name>checkPoint</name><operator>.</operator><name>nextMulti</name></name></expr></argument>,
							  <argument><expr><name><name>checkPoint</name><operator>.</operator><name>nextMultiOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MultiXactAdvanceOldest</name><argument_list>(<argument><expr><name><name>checkPoint</name><operator>.</operator><name>oldestMulti</name></name></expr></argument>,
							   <argument><expr><name><name>checkPoint</name><operator>.</operator><name>oldestMultiDB</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * No need to set oldestClogXid here as well; it'll be set when we
		 * redo an xl_clog_truncate if it changed since initialization.
		 */</comment>
		<expr_stmt><expr><call><name>SetTransactionIdLimit</name><argument_list>(<argument><expr><name><name>checkPoint</name><operator>.</operator><name>oldestXid</name></name></expr></argument>, <argument><expr><name><name>checkPoint</name><operator>.</operator><name>oldestXidDB</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we see a shutdown checkpoint while waiting for an end-of-backup
		 * record, the backup was canceled and the end-of-backup record will
		 * never arrive.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>ArchiveRecoveryRequested</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>backupStartPoint</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>backupEndPoint</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"online backup was canceled, recovery cannot continue"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If we see a shutdown checkpoint, we know that nothing was running
		 * on the master at this point. So fake-up an empty running-xacts
		 * record and use that here and now. Recover additional standby state
		 * for prepared transactions.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>standbyState</name> <operator>&gt;=</operator> <name>STANDBY_INITIALIZED</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>xids</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>nxids</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TransactionId</name></type> <name>oldestActiveXID</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TransactionId</name></type> <name>latestCompletedXid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RunningTransactionsData</name></type> <name>running</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>oldestActiveXID</name> <operator>=</operator> <call><name>PrescanPreparedTransactions</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nxids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Construct a RunningTransactions snapshot representing a shut
			 * down server, with only prepared transactions still alive. We're
			 * never overflowed at this point because all subxids are listed
			 * with their parent prepared transactions.
			 */</comment>
			<expr_stmt><expr><name><name>running</name><operator>.</operator><name>xcnt</name></name> <operator>=</operator> <name>nxids</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>running</name><operator>.</operator><name>subxcnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>running</name><operator>.</operator><name>subxid_overflow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>running</name><operator>.</operator><name>nextXid</name></name> <operator>=</operator> <name><name>checkPoint</name><operator>.</operator><name>nextXid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>running</name><operator>.</operator><name>oldestRunningXid</name></name> <operator>=</operator> <name>oldestActiveXID</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>latestCompletedXid</name> <operator>=</operator> <name><name>checkPoint</name><operator>.</operator><name>nextXid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>TransactionIdRetreat</name><argument_list>(<argument><expr><name>latestCompletedXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>latestCompletedXid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>running</name><operator>.</operator><name>latestCompletedXid</name></name> <operator>=</operator> <name>latestCompletedXid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>running</name><operator>.</operator><name>xids</name></name> <operator>=</operator> <name>xids</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ProcArrayApplyRecoveryInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>running</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>StandbyRecoverPreparedTransactions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* ControlFile-&gt;checkPointCopy always tracks the latest ckpt XID */</comment>
		<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>checkPointCopy</name><operator>.</operator><name>nextXidEpoch</name></name> <operator>=</operator> <name><name>checkPoint</name><operator>.</operator><name>nextXidEpoch</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>checkPointCopy</name><operator>.</operator><name>nextXid</name></name> <operator>=</operator> <name><name>checkPoint</name><operator>.</operator><name>nextXid</name></name></expr>;</expr_stmt>

		<comment type="block">/* Update shared-memory copy of checkpoint XID/epoch */</comment>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>ckptXidEpoch</name></name> <operator>=</operator> <name><name>checkPoint</name><operator>.</operator><name>nextXidEpoch</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>ckptXid</name></name> <operator>=</operator> <name><name>checkPoint</name><operator>.</operator><name>nextXid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We should've already switched to the new TLI before replaying this
		 * record.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>checkPoint</name><operator>.</operator><name>ThisTimeLineID</name></name> <operator>!=</operator> <name>ThisTimeLineID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected timeline ID %u (should be %u) in checkpoint record"</literal></expr></argument>,
							<argument><expr><name><name>checkPoint</name><operator>.</operator><name>ThisTimeLineID</name></name></expr></argument>, <argument><expr><name>ThisTimeLineID</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>RecoveryRestartPoint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>checkPoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>info</name> <operator>==</operator> <name>XLOG_CHECKPOINT_ONLINE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CheckPoint</name></type>	<name>checkPoint</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>checkPoint</name></expr></argument>, <argument><expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CheckPoint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* In an ONLINE checkpoint, treat the XID counter as a minimum */</comment>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr></argument>,
								  <argument><expr><name><name>checkPoint</name><operator>.</operator><name>nextXid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name> <operator>=</operator> <name><name>checkPoint</name><operator>.</operator><name>nextXid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We ignore the nextOid counter in an ONLINE checkpoint, preferring
		 * to track OID assignment through XLOG_NEXTOID records.  The nextOid
		 * counter is from the start of the checkpoint and might well be stale
		 * compared to later XLOG_NEXTOID records.  We could try to take the
		 * maximum of the nextOid counter and our latest value, but since
		 * there's no particular guarantee about the speed with which the OID
		 * counter wraps around, that's a risky thing to do.  In any case,
		 * users of the nextOid counter are required to avoid assignment of
		 * duplicates, so that a somewhat out-of-date value should be safe.
		 */</comment>

		<comment type="block">/* Handle multixact */</comment>
		<expr_stmt><expr><call><name>MultiXactAdvanceNextMXact</name><argument_list>(<argument><expr><name><name>checkPoint</name><operator>.</operator><name>nextMulti</name></name></expr></argument>,
								  <argument><expr><name><name>checkPoint</name><operator>.</operator><name>nextMultiOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * NB: This may perform multixact truncation when replaying WAL
		 * generated by an older primary.
		 */</comment>
		<expr_stmt><expr><call><name>MultiXactAdvanceOldest</name><argument_list>(<argument><expr><name><name>checkPoint</name><operator>.</operator><name>oldestMulti</name></name></expr></argument>,
							   <argument><expr><name><name>checkPoint</name><operator>.</operator><name>oldestMultiDB</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oldestXid</name></name></expr></argument>,
								  <argument><expr><name><name>checkPoint</name><operator>.</operator><name>oldestXid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SetTransactionIdLimit</name><argument_list>(<argument><expr><name><name>checkPoint</name><operator>.</operator><name>oldestXid</name></name></expr></argument>,
								  <argument><expr><name><name>checkPoint</name><operator>.</operator><name>oldestXidDB</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* ControlFile-&gt;checkPointCopy always tracks the latest ckpt XID */</comment>
		<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>checkPointCopy</name><operator>.</operator><name>nextXidEpoch</name></name> <operator>=</operator> <name><name>checkPoint</name><operator>.</operator><name>nextXidEpoch</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>checkPointCopy</name><operator>.</operator><name>nextXid</name></name> <operator>=</operator> <name><name>checkPoint</name><operator>.</operator><name>nextXid</name></name></expr>;</expr_stmt>

		<comment type="block">/* Update shared-memory copy of checkpoint XID/epoch */</comment>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>ckptXidEpoch</name></name> <operator>=</operator> <name><name>checkPoint</name><operator>.</operator><name>nextXidEpoch</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>ckptXid</name></name> <operator>=</operator> <name><name>checkPoint</name><operator>.</operator><name>nextXid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* TLI should not change in an on-line checkpoint */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>checkPoint</name><operator>.</operator><name>ThisTimeLineID</name></name> <operator>!=</operator> <name>ThisTimeLineID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected timeline ID %u (should be %u) in checkpoint record"</literal></expr></argument>,
							<argument><expr><name><name>checkPoint</name><operator>.</operator><name>ThisTimeLineID</name></name></expr></argument>, <argument><expr><name>ThisTimeLineID</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>RecoveryRestartPoint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>checkPoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>info</name> <operator>==</operator> <name>XLOG_END_OF_RECOVERY</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xl_end_of_recovery</name></type> <name>xlrec</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xl_end_of_recovery</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * For Hot Standby, we could treat this like a Shutdown Checkpoint,
		 * but this case is rarer and harder to test, so the benefit doesn't
		 * outweigh the potential extra cost of maintenance.
		 */</comment>

		<comment type="block">/*
		 * We should've already switched to the new TLI before replaying this
		 * record.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>.</operator><name>ThisTimeLineID</name></name> <operator>!=</operator> <name>ThisTimeLineID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected timeline ID %u (should be %u) in checkpoint record"</literal></expr></argument>,
							<argument><expr><name><name>xlrec</name><operator>.</operator><name>ThisTimeLineID</name></name></expr></argument>, <argument><expr><name>ThisTimeLineID</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>info</name> <operator>==</operator> <name>XLOG_NOOP</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* nothing to do here */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>info</name> <operator>==</operator> <name>XLOG_SWITCH</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* nothing to do here */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>info</name> <operator>==</operator> <name>XLOG_RESTORE_POINT</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* nothing to do here */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>info</name> <operator>==</operator> <name>XLOG_FPI</name> <operator>||</operator> <name>info</name> <operator>==</operator> <name>XLOG_FPI_FOR_HINT</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Full-page image (FPI) records contain nothing else but a backup
		 * block. The block reference must include a full-page image -
		 * otherwise there would be no point in this record.
		 *
		 * No recovery conflicts are generated by these generic records - if a
		 * resource manager needs to generate conflicts, it has to define a
		 * separate WAL record type and redo routine.
		 *
		 * XLOG_FPI_FOR_HINT records are generated when a page needs to be
		 * WAL- logged because of a hint bit update. They are only generated
		 * when checksums are enabled. There is no difference in handling
		 * XLOG_FPI and XLOG_FPI_FOR_HINT records, they use a different info
		 * code just to distinguish them for statistics purposes.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>BLK_RESTORED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected XLogReadBufferForRedo result when restoring backup block"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>info</name> <operator>==</operator> <name>XLOG_BACKUP_END</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>startpoint</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>startpoint</name></expr></argument>, <argument><expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>startpoint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>backupStartPoint</name></name> <operator>==</operator> <name>startpoint</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We have reached the end of base backup, the point where
			 * pg_stop_backup() was done. The data on disk is now consistent.
			 * Reset backupStartPoint, and update minRecoveryPoint to make
			 * sure we don't allow starting up at an earlier point even if
			 * recovery is stopped and restarted soon after this.
			 */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"end of backup reached"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ControlFileLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPoint</name></name> <operator>&lt;</operator> <name>lsn</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPoint</name></name> <operator>=</operator> <name>lsn</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPointTLI</name></name> <operator>=</operator> <name>ThisTimeLineID</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>backupStartPoint</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>backupEndRequired</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>UpdateControlFile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ControlFileLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>info</name> <operator>==</operator> <name>XLOG_PARAMETER_CHANGE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xl_parameter_change</name></type> <name>xlrec</name></decl>;</decl_stmt>

		<comment type="block">/* Update our copy of the parameters in pg_control */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xl_parameter_change</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ControlFileLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>MaxConnections</name></name> <operator>=</operator> <name><name>xlrec</name><operator>.</operator><name>MaxConnections</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>max_worker_processes</name></name> <operator>=</operator> <name><name>xlrec</name><operator>.</operator><name>max_worker_processes</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>max_prepared_xacts</name></name> <operator>=</operator> <name><name>xlrec</name><operator>.</operator><name>max_prepared_xacts</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>max_locks_per_xact</name></name> <operator>=</operator> <name><name>xlrec</name><operator>.</operator><name>max_locks_per_xact</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>wal_level</name></name> <operator>=</operator> <name><name>xlrec</name><operator>.</operator><name>wal_level</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>wal_log_hints</name></name> <operator>=</operator> <name><name>xlrec</name><operator>.</operator><name>wal_log_hints</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Update minRecoveryPoint to ensure that if recovery is aborted, we
		 * recover back up to this point before allowing hot standby again.
		 * This is important if the max_* settings are decreased, to ensure
		 * you don't run queries against the WAL preceding the change. The
		 * local copies cannot be updated as long as crash recovery is
		 * happening and we expect all the WAL to be replayed.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>InArchiveRecovery</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>minRecoveryPoint</name> <operator>=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPoint</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>minRecoveryPointTLI</name> <operator>=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPointTLI</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>minRecoveryPoint</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name> <operator>&amp;&amp;</operator> <name>minRecoveryPoint</name> <operator>&lt;</operator> <name>lsn</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPoint</name></name> <operator>=</operator> <name>lsn</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPointTLI</name></name> <operator>=</operator> <name>ThisTimeLineID</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>CommitTsParameterChange</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>.</operator><name>track_commit_timestamp</name></name></expr></argument>,
								<argument><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>track_commit_timestamp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ControlFile</name><operator>-&gt;</operator><name>track_commit_timestamp</name></name> <operator>=</operator> <name><name>xlrec</name><operator>.</operator><name>track_commit_timestamp</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>UpdateControlFile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ControlFileLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Check to see if any changes to max_connections give problems */</comment>
		<expr_stmt><expr><call><name>CheckRequiredParameterValues</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>info</name> <operator>==</operator> <name>XLOG_FPW_CHANGE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>fpw</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fpw</name></expr></argument>, <argument><expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Update the LSN of the last replayed XLOG_FPW_CHANGE record so that
		 * do_pg_start_backup() and do_pg_stop_backup() can check whether
		 * full_page_writes has been disabled during online backup.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fpw</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>lastFpwDisableRecPtr</name></name> <operator>&lt;</operator> <name>ReadRecPtr</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>lastFpwDisableRecPtr</name></name> <operator>=</operator> <name>ReadRecPtr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Keep track of full_page_writes */</comment>
		<expr_stmt><expr><name>lastFullPageWrites</name> <operator>=</operator> <name>fpw</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WAL_DEBUG</name></cpp:ifdef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>xlog_outrec</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>block_id</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"prev %X/%X; xid %u"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><call><name>XLogRecGetPrev</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
					 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <call><name>XLogRecGetPrev</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>XLogRecGetXid</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"; len %u"</literal></expr></argument>,
					 <argument><expr><call><name>XLogRecGetDataLen</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* decode block references */</comment>
	<for>for <control>(<init><expr><name>block_id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>block_id</name> <operator>&lt;=</operator> <name><name>record</name><operator>-&gt;</operator><name>max_block_id</name></name></expr>;</condition> <incr><expr><name>block_id</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ForkNumber</name></type>	<name>forknum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blk</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>block_id</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>block_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>forknum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>forknum</name> <operator>!=</operator> <name>MAIN_FORKNUM</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"; blkref #%u: rel %u/%u/%u, fork %u, blk %u"</literal></expr></argument>,
							 <argument><expr><name>block_id</name></expr></argument>,
							 <argument><expr><name><name>rnode</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>.</operator><name>relNode</name></name></expr></argument>,
							 <argument><expr><name>forknum</name></expr></argument>,
							 <argument><expr><name>blk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"; blkref #%u: rel %u/%u/%u, blk %u"</literal></expr></argument>,
							 <argument><expr><name>block_id</name></expr></argument>,
							 <argument><expr><name><name>rnode</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>.</operator><name>relNode</name></name></expr></argument>,
							 <argument><expr><name>blk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockImage</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>block_id</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" FPW"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WAL_DEBUG */</comment>

<comment type="block">/*
 * Returns a string describing an XLogRecord, consisting of its identity
 * optionally followed by a colon, a space, and a further description.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>xlog_outdesc</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RmgrId</name></type>		<name>rmid</name> <init>= <expr><call><name>XLogRecGetRmid</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>info</name> <init>= <expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>id</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>RmgrTable</name><index>[<expr><name>rmid</name></expr>]</index></name><operator>.</operator><name>rm_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>id</name> <operator>=</operator> <name><name>RmgrTable</name><index>[<expr><name>rmid</name></expr>]</index></name><operator>.</operator><call><name>rm_identify</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>id</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"UNKNOWN (%X): "</literal></expr></argument>, <argument><expr><name>info</name> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s: "</literal></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>RmgrTable</name><index>[<expr><name>rmid</name></expr>]</index></name><operator>.</operator><call><name>rm_desc</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Return the (possible) sync flag used for opening a file, depending on the
 * value of the GUC wal_sync_method.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_sync_bit</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>method</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>o_direct_flag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* If fsync is disabled, never open in sync mode */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enableFsync</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Optimize writes by bypassing kernel cache with O_DIRECT when using
	 * O_SYNC/O_FSYNC and O_DSYNC.  But only if archiving and streaming are
	 * disabled, otherwise the archive command or walsender process will read
	 * the WAL soon after writing it, which is guaranteed to cause a physical
	 * read if we bypassed the kernel cache. We also skip the
	 * posix_fadvise(POSIX_FADV_DONTNEED) call in XLogFileClose() for the same
	 * reason.
	 *
	 * Never use O_DIRECT in walreceiver process for similar reasons; the WAL
	 * written by walreceiver is normally read by the startup process soon
	 * after its written. Also, walreceiver performs unaligned writes, which
	 * don't work with O_DIRECT, so it is required for correctness too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogIsNeeded</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>AmWalReceiverProcess</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>o_direct_flag</name> <operator>=</operator> <name>PG_O_DIRECT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name>method</name></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/*
			 * enum values for all sync options are defined even if they are
			 * not supported on the current platform.  But if not, they are
			 * not included in the enum option array, and therefore will never
			 * be seen here.
			 */</comment>
		<case>case <expr><name>SYNC_METHOD_FSYNC</name></expr>:</case>
		<case>case <expr><name>SYNC_METHOD_FSYNC_WRITETHROUGH</name></expr>:</case>
		<case>case <expr><name>SYNC_METHOD_FDATASYNC</name></expr>:</case>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>OPEN_SYNC_FLAG</name></cpp:ifdef>
		<case>case <expr><name>SYNC_METHOD_OPEN</name></expr>:</case>
			<return>return <expr><name>OPEN_SYNC_FLAG</name> <operator>|</operator> <name>o_direct_flag</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>OPEN_DATASYNC_FLAG</name></cpp:ifdef>
		<case>case <expr><name>SYNC_METHOD_OPEN_DSYNC</name></expr>:</case>
			<return>return <expr><name>OPEN_DATASYNC_FLAG</name> <operator>|</operator> <name>o_direct_flag</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<default>default:</default>
			<comment type="block">/* can't happen (unless we are out of sync with option array) */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized wal_sync_method: %d"</literal></expr></argument>, <argument><expr><name>method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>			<comment type="block">/* silence warning */</comment>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * GUC support
 */</comment>
<function><type><name>void</name></type>
<name>assign_xlog_sync_method</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>new_sync_method</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>sync_method</name> <operator>!=</operator> <name>new_sync_method</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * To ensure that no blocks escape unsynced, force an fsync on the
		 * currently open log segment (if any).  Also, if the open flag is
		 * changing, close the log file so it will be reopened (with new flag
		 * bit) at next use.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>openLogFile</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_WAL_SYNC_METHOD_ASSIGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>pg_fsync</name><argument_list>(<argument><expr><name>openLogFile</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fsync log segment %s: %m"</literal></expr></argument>,
								<argument><expr><call><name>XLogFileNameP</name><argument_list>(<argument><expr><name>ThisTimeLineID</name></expr></argument>, <argument><expr><name>openLogSegNo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>get_sync_bit</name><argument_list>(<argument><expr><name>sync_method</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>get_sync_bit</name><argument_list>(<argument><expr><name>new_sync_method</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>XLogFileClose</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Issue appropriate kind of fsync (if any) for an XLOG output file.
 *
 * 'fd' is a file descriptor for the XLOG file to be fsync'd.
 * 'log' and 'seg' are for error reporting purposes.
 */</comment>
<function><type><name>void</name></type>
<name>issue_xlog_fsync</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>XLogSegNo</name></type> <name>segno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>sync_method</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SYNC_METHOD_FSYNC</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>pg_fsync_no_writethrough</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fsync log file %s: %m"</literal></expr></argument>,
								<argument><expr><call><name>XLogFileNameP</name><argument_list>(<argument><expr><name>ThisTimeLineID</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_FSYNC_WRITETHROUGH</name></cpp:ifdef>
		<case>case <expr><name>SYNC_METHOD_FSYNC_WRITETHROUGH</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>pg_fsync_writethrough</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fsync write-through log file %s: %m"</literal></expr></argument>,
								<argument><expr><call><name>XLogFileNameP</name><argument_list>(<argument><expr><name>ThisTimeLineID</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_FDATASYNC</name></cpp:ifdef>
		<case>case <expr><name>SYNC_METHOD_FDATASYNC</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>pg_fdatasync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fdatasync log file %s: %m"</literal></expr></argument>,
								<argument><expr><call><name>XLogFileNameP</name><argument_list>(<argument><expr><name>ThisTimeLineID</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<case>case <expr><name>SYNC_METHOD_OPEN</name></expr>:</case>
		<case>case <expr><name>SYNC_METHOD_OPEN_DSYNC</name></expr>:</case>
			<comment type="block">/* write synced it already */</comment>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"unrecognized wal_sync_method: %d"</literal></expr></argument>, <argument><expr><name>sync_method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Return the filename of given log segment, as a palloc'd string.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>XLogFileNameP</name><parameter_list>(<parameter><decl><type><name>TimeLineID</name></type> <name>tli</name></decl></parameter>, <parameter><decl><type><name>XLogSegNo</name></type> <name>segno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><name>MAXFNAMELEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * do_pg_start_backup is the workhorse of the user-visible pg_start_backup()
 * function. It creates the necessary starting checkpoint and constructs the
 * backup label file.
 *
 * There are two kind of backups: exclusive and non-exclusive. An exclusive
 * backup is started with pg_start_backup(), and there can be only one active
 * at a time. The backup and tablespace map files of an exclusive backup are
 * written to $PGDATA/backup_label and $PGDATA/tablespace_map, and they are
 * removed by pg_stop_backup().
 *
 * A non-exclusive backup is used for the streaming base backups (see
 * src/backend/replication/basebackup.c). The difference to exclusive backups
 * is that the backup label and tablespace map files are not written to disk.
 * Instead, their would-be contents are returned in *labelfile and *tblspcmapfile,
 * and the caller is responsible for including them in the backup archive as
 * 'backup_label' and 'tablespace_map'. There can be many non-exclusive backups
 * active at the same time, and they don't conflict with an exclusive backup
 * either.
 *
 * tblspcmapfile is required mainly for tar format in windows as native windows
 * utilities are not able to create symlinks while extracting files from tar.
 * However for consistency, the same is used for all platforms.
 *
 * needtblspcmapfile is true for the cases (exclusive backup and for
 * non-exclusive backup only when tar format is used for taking backup)
 * when backup needs to generate tablespace_map file, it is used to
 * embed escape character before newline character in tablespace path.
 *
 * Returns the minimum WAL location that must be present to restore from this
 * backup, and the corresponding timeline ID in *starttli_p.
 *
 * Every successfully started non-exclusive backup must be stopped by calling
 * do_pg_stop_backup() or do_pg_abort_backup().
 *
 * It is the responsibility of the caller of this function to verify the
 * permissions of the calling user!
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>do_pg_start_backup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>backupidstr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fast</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name> <modifier>*</modifier></type><name>starttli_p</name></decl></parameter>,
				   <parameter><decl><type><name>StringInfo</name></type> <name>labelfile</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>tablespaces</name></decl></parameter>,
				   <parameter><decl><type><name>StringInfo</name></type> <name>tblspcmapfile</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>infotbssize</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>needtblspcmapfile</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>exclusive</name> <init>= <expr><operator>(</operator><name>labelfile</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>backup_started_in_recovery</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>checkpointloc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>startpoint</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>starttli</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>stamp_time</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>strfbuf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>xlogfilename</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>_logSegNo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>backup_started_in_recovery</name> <operator>=</operator> <call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Currently only non-exclusive backup can be taken during recovery.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>backup_started_in_recovery</name> <operator>&amp;&amp;</operator> <name>exclusive</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"recovery is in progress"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"WAL control functions cannot be executed during recovery."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * During recovery, we don't need to check WAL level. Because, if WAL
	 * level is not sufficient, it's impossible to get here during recovery.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>backup_started_in_recovery</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>XLogIsNeeded</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"WAL level not sufficient for making an online backup"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"wal_level must be set to \"replica\" or \"logical\" at server start."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>backupidstr</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>MAXPGPATH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"backup label too long (max %d bytes)"</literal></expr></argument>,
						<argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Mark backup active in shared memory.  We must do full-page WAL writes
	 * during an on-line backup even if not doing so at other times, because
	 * it's quite possible for the backup dump to obtain a "torn" (partially
	 * written) copy of a database page if it reads the page concurrently with
	 * our write to the same page.  This can be fixed as long as the first
	 * write to the page in the WAL sequence is a full-page write. Hence, we
	 * turn on forcePageWrites and then force a CHECKPOINT, to ensure there
	 * are no dirty pages in shared memory that might get dumped while the
	 * backup is in progress without having a corresponding WAL record.  (Once
	 * the backup is complete, we need not force full-page writes anymore,
	 * since we expect that any pages not modified during the backup interval
	 * must have been correctly captured by the backup.)
	 *
	 * Note that forcePageWrites has no effect during an online backup from
	 * the standby.
	 *
	 * We must hold all the insertion locks to change the value of
	 * forcePageWrites, to ensure adequate interlocking against
	 * XLogInsertRecord().
	 */</comment>
	<expr_stmt><expr><call><name>WALInsertLockAcquireExclusive</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>exclusive</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * At first, mark that we're now starting an exclusive backup, to
		 * ensure that there are no other sessions currently running
		 * pg_start_backup() or pg_stop_backup().
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>exclusiveBackupState</name></name> <operator>!=</operator> <name>EXCLUSIVE_BACKUP_NONE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>WALInsertLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"a backup is already in progress"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Run pg_stop_backup() and try again."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>exclusiveBackupState</name></name> <operator>=</operator> <name>EXCLUSIVE_BACKUP_STARTING</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>nonExclusiveBackups</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>forcePageWrites</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WALInsertLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Ensure we release forcePageWrites if fail below */</comment>
	<expr_stmt><expr><call><name>PG_ENSURE_ERROR_CLEANUP</name><argument_list>(<argument><expr><name>pg_start_backup_callback</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>exclusive</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>gotUniqueStartpoint</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>tblspcdir</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>tablespaceinfo</name> <modifier>*</modifier></type><name>ti</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>datadirpathlen</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Force an XLOG file switch before the checkpoint, to ensure that the
		 * WAL segment the checkpoint is written to doesn't contain pages with
		 * old timeline IDs.  That would otherwise happen if you called
		 * pg_start_backup() right after restoring from a PITR archive: the
		 * first WAL segment containing the startup checkpoint has pages in
		 * the beginning with the old timeline ID.  That can cause trouble at
		 * recovery: we won't have a history file covering the old timeline if
		 * pg_wal directory was not included in the base backup and the WAL
		 * archive was cleared too before starting the backup.
		 *
		 * This also ensures that we have emitted a WAL page header that has
		 * XLP_BKP_REMOVABLE off before we emit the checkpoint record.
		 * Therefore, if a WAL archiver (such as pglesslog) is trying to
		 * compress out removable backup blocks, it won't remove any that
		 * occur after this point.
		 *
		 * During recovery, we skip forcing XLOG file switch, which means that
		 * the backup taken during recovery is not available for the special
		 * recovery case described above.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>backup_started_in_recovery</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>RequestXLogSwitch</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<do>do
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>checkpointfpw</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Force a CHECKPOINT.  Aside from being necessary to prevent torn
			 * page problems, this guarantees that two successive backup runs
			 * will have different checkpoint positions and hence different
			 * history file names, even if nothing happened in between.
			 *
			 * During recovery, establish a restartpoint if possible. We use
			 * the last restartpoint as the backup starting checkpoint. This
			 * means that two successive backup runs can have same checkpoint
			 * positions.
			 *
			 * Since the fact that we are executing do_pg_start_backup()
			 * during recovery means that checkpointer is running, we can use
			 * RequestCheckpoint() to establish a restartpoint.
			 *
			 * We use CHECKPOINT_IMMEDIATE only if requested by user (via
			 * passing fast = true).  Otherwise this can take awhile.
			 */</comment>
			<expr_stmt><expr><call><name>RequestCheckpoint</name><argument_list>(<argument><expr><name>CHECKPOINT_FORCE</name> <operator>|</operator> <name>CHECKPOINT_WAIT</name> <operator>|</operator>
							  <operator>(</operator><ternary><condition><expr><name>fast</name></expr> ?</condition><then> <expr><name>CHECKPOINT_IMMEDIATE</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Now we need to fetch the checkpoint record location, and also
			 * its REDO pointer.  The oldest point in WAL that would be needed
			 * to restore starting from the checkpoint is precisely the REDO
			 * pointer.
			 */</comment>
			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ControlFileLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>checkpointloc</name> <operator>=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>checkPoint</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>startpoint</name> <operator>=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>checkPointCopy</name><operator>.</operator><name>redo</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>starttli</name> <operator>=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>checkPointCopy</name><operator>.</operator><name>ThisTimeLineID</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>checkpointfpw</name> <operator>=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>checkPointCopy</name><operator>.</operator><name>fullPageWrites</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ControlFileLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>backup_started_in_recovery</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Check to see if all WAL replayed during online backup
				 * (i.e., since last restartpoint used as backup starting
				 * checkpoint) contain full-page writes.
				 */</comment>
				<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>recptr</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>lastFpwDisableRecPtr</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>checkpointfpw</name> <operator>||</operator> <name>startpoint</name> <operator>&lt;=</operator> <name>recptr</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"WAL generated with full_page_writes=off was replayed "</literal>
									<literal type="string">"since last restartpoint"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"This means that the backup being taken on the standby "</literal>
									 <literal type="string">"is corrupt and should not be used. "</literal>
									 <literal type="string">"Enable full_page_writes and run CHECKPOINT on the master, "</literal>
									 <literal type="string">"and then try an online backup again."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * During recovery, since we don't use the end-of-backup WAL
				 * record and don't write the backup history file, the
				 * starting WAL location doesn't need to be unique. This means
				 * that two base backups started at the same time might use
				 * the same checkpoint as starting locations.
				 */</comment>
				<expr_stmt><expr><name>gotUniqueStartpoint</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * If two base backups are started at the same time (in WAL sender
			 * processes), we need to make sure that they use different
			 * checkpoints as starting locations, because we use the starting
			 * WAL location as a unique identifier for the base backup in the
			 * end-of-backup WAL record and when we write the backup history
			 * file. Perhaps it would be better generate a separate unique ID
			 * for each backup instead of forcing another checkpoint, but
			 * taking a checkpoint right after another is not that expensive
			 * either because only few buffers have been dirtied yet.
			 */</comment>
			<expr_stmt><expr><call><name>WALInsertLockAcquireExclusive</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>lastBackupStart</name></name> <operator>&lt;</operator> <name>startpoint</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>lastBackupStart</name></name> <operator>=</operator> <name>startpoint</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>gotUniqueStartpoint</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>WALInsertLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block> while <condition>(<expr><operator>!</operator><name>gotUniqueStartpoint</name></expr>)</condition>;</do>

		<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>startpoint</name></expr></argument>, <argument><expr><name>_logSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>xlogfilename</name></expr></argument>, <argument><expr><name>starttli</name></expr></argument>, <argument><expr><name>_logSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Construct tablespace_map file
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>exclusive</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>tblspcmapfile</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>datadirpathlen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>DataDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Collect information about all tablespaces */</comment>
		<expr_stmt><expr><name>tblspcdir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><literal type="string">"pg_tblspc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>tblspcdir</name></expr></argument>, <argument><expr><literal type="string">"pg_tblspc"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>fullpath</name><index>[<expr><name>MAXPGPATH</name> <operator>+</operator> <literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>linkpath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>relpath</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>rllen</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buflinkpath</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>s</name> <init>= <expr><name>linkpath</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Skip special stuff */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">".."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>fullpath</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fullpath</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"pg_tblspc/%s"</literal></expr></argument>, <argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_READLINK</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
			<expr_stmt><expr><name>rllen</name> <operator>=</operator> <call><name>readlink</name><argument_list>(<argument><expr><name>fullpath</name></expr></argument>, <argument><expr><name>linkpath</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>linkpath</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>rllen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read symbolic link \"%s\": %m"</literal></expr></argument>,
								<argument><expr><name>fullpath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>rllen</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>linkpath</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"symbolic link \"%s\" target is too long"</literal></expr></argument>,
								<argument><expr><name>fullpath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>linkpath</name><index>[<expr><name>rllen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

			<comment type="block">/*
			 * Add the escape character '\\' before newline in a string to
			 * ensure that we can distinguish between the newline in the
			 * tablespace path and end of line while reading tablespace_map
			 * file during archive recovery.
			 */</comment>
			<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buflinkpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<while>while <condition>(<expr><operator>*</operator><name>s</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\r'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>needtblspcmapfile</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buflinkpath</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buflinkpath</name></expr></argument>, <argument><expr><operator>*</operator><name>s</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></while>

			<comment type="block">/*
			 * Relpath holds the relative path of the tablespace directory
			 * when it's located within PGDATA, or NULL if it's located
			 * elsewhere.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>rllen</name> <operator>&gt;</operator> <name>datadirpathlen</name> <operator>&amp;&amp;</operator>
				<call><name>strncmp</name><argument_list>(<argument><expr><name>linkpath</name></expr></argument>, <argument><expr><name>DataDir</name></expr></argument>, <argument><expr><name>datadirpathlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<call><name>IS_DIR_SEP</name><argument_list>(<argument><expr><name><name>linkpath</name><index>[<expr><name>datadirpathlen</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>relpath</name> <operator>=</operator> <name>linkpath</name> <operator>+</operator> <name>datadirpathlen</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>ti</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tablespaceinfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ti</name><operator>-&gt;</operator><name>oid</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ti</name><operator>-&gt;</operator><name>path</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>buflinkpath</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ti</name><operator>-&gt;</operator><name>rpath</name></name> <operator>=</operator> <ternary><condition><expr><name>relpath</name></expr> ?</condition><then> <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>relpath</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ti</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <ternary><condition><expr><name>infotbssize</name></expr> ?</condition><then> <expr><call><name>sendTablespace</name><argument_list>(<argument><expr><name>fullpath</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>tablespaces</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>tablespaces</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>tablespaces</name></expr></argument>, <argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>tblspcmapfile</name></expr></argument>, <argument><expr><literal type="string">"%s %s\n"</literal></expr></argument>, <argument><expr><name><name>ti</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name><name>ti</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buflinkpath</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

			<comment type="block">/*
			 * If the platform does not have symbolic links, it should not be
			 * possible to have tablespaces - clearly somebody else created
			 * them. Warn about it and ignore.
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tablespaces are not supported on this platform"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block></while>
		<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>tblspcdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Construct backup label file
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>exclusive</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>labelfile</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Use the log timezone here, not the session timezone */</comment>
		<expr_stmt><expr><name>stamp_time</name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_strftime</name><argument_list>(<argument><expr><name>strfbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>strfbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					<argument><expr><literal type="string">"%Y-%m-%d %H:%M:%S %Z"</literal></expr></argument>,
					<argument><expr><call><name>pg_localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stamp_time</name></expr></argument>, <argument><expr><name>log_timezone</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>labelfile</name></expr></argument>, <argument><expr><literal type="string">"START WAL LOCATION: %X/%X (file %s)\n"</literal></expr></argument>,
						 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>startpoint</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>startpoint</name></expr></argument>, <argument><expr><name>xlogfilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>labelfile</name></expr></argument>, <argument><expr><literal type="string">"CHECKPOINT LOCATION: %X/%X\n"</literal></expr></argument>,
						 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>checkpointloc</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>checkpointloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>labelfile</name></expr></argument>, <argument><expr><literal type="string">"BACKUP METHOD: %s\n"</literal></expr></argument>,
						 <argument><expr><ternary><condition><expr><name>exclusive</name></expr> ?</condition><then> <expr><literal type="string">"pg_start_backup"</literal></expr> </then><else>: <expr><literal type="string">"streamed"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>labelfile</name></expr></argument>, <argument><expr><literal type="string">"BACKUP FROM: %s\n"</literal></expr></argument>,
						 <argument><expr><ternary><condition><expr><name>backup_started_in_recovery</name></expr> ?</condition><then> <expr><literal type="string">"standby"</literal></expr> </then><else>: <expr><literal type="string">"master"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>labelfile</name></expr></argument>, <argument><expr><literal type="string">"START TIME: %s\n"</literal></expr></argument>, <argument><expr><name>strfbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>labelfile</name></expr></argument>, <argument><expr><literal type="string">"LABEL: %s\n"</literal></expr></argument>, <argument><expr><name>backupidstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>labelfile</name></expr></argument>, <argument><expr><literal type="string">"START TIMELINE: %u\n"</literal></expr></argument>, <argument><expr><name>starttli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Okay, write the file, or return its contents to caller.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>exclusive</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Check for existing backup label --- implies a backup is already
			 * running.  (XXX given that we checked exclusiveBackupState
			 * above, maybe it would be OK to just unlink any such label
			 * file?)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>BACKUP_LABEL_FILE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not stat file \"%s\": %m"</literal></expr></argument>,
									<argument><expr><name>BACKUP_LABEL_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"a backup is already in progress"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"If you're sure there is no backup in progress, remove file \"%s\" and try again."</literal></expr></argument>,
								 <argument><expr><name>BACKUP_LABEL_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>BACKUP_LABEL_FILE</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fp</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create file \"%s\": %m"</literal></expr></argument>,
								<argument><expr><name>BACKUP_LABEL_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><name><name>labelfile</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>labelfile</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
				<call><name>fflush</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>pg_fsync</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>ferror</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>FreeFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write file \"%s\": %m"</literal></expr></argument>,
								<argument><expr><name>BACKUP_LABEL_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* Allocated locally for exclusive backups, so free separately */</comment>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>labelfile</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>labelfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Write backup tablespace_map file. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tblspcmapfile</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>TABLESPACE_MAP</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not stat file \"%s\": %m"</literal></expr></argument>,
										<argument><expr><name>TABLESPACE_MAP</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"a backup is already in progress"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"If you're sure there is no backup in progress, remove file \"%s\" and try again."</literal></expr></argument>,
									 <argument><expr><name>TABLESPACE_MAP</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>TABLESPACE_MAP</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fp</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create file \"%s\": %m"</literal></expr></argument>,
									<argument><expr><name>TABLESPACE_MAP</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><name><name>tblspcmapfile</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>tblspcmapfile</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
					<call><name>fflush</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
					<call><name>pg_fsync</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
					<call><name>ferror</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>||</operator>
					<call><name>FreeFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write file \"%s\": %m"</literal></expr></argument>,
									<argument><expr><name>TABLESPACE_MAP</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Allocated locally for exclusive backups, so free separately */</comment>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>tblspcmapfile</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tblspcmapfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_ENSURE_ERROR_CLEANUP</name><argument_list>(<argument><expr><name>pg_start_backup_callback</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>exclusive</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Mark that start phase has correctly finished for an exclusive backup.
	 * Session-level locks are updated as well to reflect that state.
	 *
	 * Note that CHECK_FOR_INTERRUPTS() must not occur while updating backup
	 * counters and session-level lock. Otherwise they can be updated
	 * inconsistently, and which might cause do_pg_abort_backup() to fail.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>exclusive</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>WALInsertLockAcquireExclusive</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>exclusiveBackupState</name></name> <operator>=</operator> <name>EXCLUSIVE_BACKUP_IN_PROGRESS</name></expr>;</expr_stmt>

		<comment type="block">/* Set session-level lock */</comment>
		<expr_stmt><expr><name>sessionBackupState</name> <operator>=</operator> <name>SESSION_BACKUP_EXCLUSIVE</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WALInsertLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>sessionBackupState</name> <operator>=</operator> <name>SESSION_BACKUP_NON_EXCLUSIVE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * We're done.  As a convenience, return the starting WAL location.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>starttli_p</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>starttli_p</name> <operator>=</operator> <name>starttli</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>startpoint</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Error cleanup callback for pg_start_backup */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pg_start_backup_callback</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>exclusive</name> <init>= <expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Update backup counters and forcePageWrites on failure */</comment>
	<expr_stmt><expr><call><name>WALInsertLockAcquireExclusive</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>exclusive</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>exclusiveBackupState</name></name> <operator>==</operator> <name>EXCLUSIVE_BACKUP_STARTING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>exclusiveBackupState</name></name> <operator>=</operator> <name>EXCLUSIVE_BACKUP_NONE</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>nonExclusiveBackups</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>nonExclusiveBackups</name></name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>exclusiveBackupState</name></name> <operator>==</operator> <name>EXCLUSIVE_BACKUP_NONE</name> <operator>&amp;&amp;</operator>
		<name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>nonExclusiveBackups</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>forcePageWrites</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>WALInsertLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Error cleanup callback for pg_stop_backup
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pg_stop_backup_callback</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>exclusive</name> <init>= <expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Update backup status on failure */</comment>
	<expr_stmt><expr><call><name>WALInsertLockAcquireExclusive</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>exclusive</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>exclusiveBackupState</name></name> <operator>==</operator> <name>EXCLUSIVE_BACKUP_STOPPING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>exclusiveBackupState</name></name> <operator>=</operator> <name>EXCLUSIVE_BACKUP_IN_PROGRESS</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>WALInsertLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Utility routine to fetch the session-level status of a backup running.
 */</comment>
<function><type><name>SessionBackupState</name></type>
<name>get_backup_status</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>sessionBackupState</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * do_pg_stop_backup is the workhorse of the user-visible pg_stop_backup()
 * function.
 *
 * If labelfile is NULL, this stops an exclusive backup. Otherwise this stops
 * the non-exclusive backup specified by 'labelfile'.
 *
 * Returns the last WAL location that must be present to restore from this
 * backup, and the corresponding timeline ID in *stoptli_p.
 *
 * It is the responsibility of the caller of this function to verify the
 * permissions of the calling user!
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>do_pg_stop_backup</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>labelfile</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>waitforarchive</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name> <modifier>*</modifier></type><name>stoptli_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>exclusive</name> <init>= <expr><operator>(</operator><name>labelfile</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>backup_started_in_recovery</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>startpoint</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>stoppoint</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>stoptli</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>stamp_time</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>strfbuf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>histfilepath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>startxlogfilename</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>stopxlogfilename</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>lastxlogfilename</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>histfilename</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>backupfrom</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>_logSegNo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>lfp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>ch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>seconds_before_warning</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>waits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>reported_waiting</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>remaining</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>hi</name></decl>,
				<decl><type ref="prev"/><name>lo</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>backup_started_in_recovery</name> <operator>=</operator> <call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Currently only non-exclusive backup can be taken during recovery.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>backup_started_in_recovery</name> <operator>&amp;&amp;</operator> <name>exclusive</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"recovery is in progress"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"WAL control functions cannot be executed during recovery."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * During recovery, we don't need to check WAL level. Because, if WAL
	 * level is not sufficient, it's impossible to get here during recovery.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>backup_started_in_recovery</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>XLogIsNeeded</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"WAL level not sufficient for making an online backup"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"wal_level must be set to \"replica\" or \"logical\" at server start."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>exclusive</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * At first, mark that we're now stopping an exclusive backup, to
		 * ensure that there are no other sessions currently running
		 * pg_start_backup() or pg_stop_backup().
		 */</comment>
		<expr_stmt><expr><call><name>WALInsertLockAcquireExclusive</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>exclusiveBackupState</name></name> <operator>!=</operator> <name>EXCLUSIVE_BACKUP_IN_PROGRESS</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>WALInsertLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"exclusive backup not in progress"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>exclusiveBackupState</name></name> <operator>=</operator> <name>EXCLUSIVE_BACKUP_STOPPING</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WALInsertLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Remove backup_label. In case of failure, the state for an exclusive
		 * backup is switched back to in-progress.
		 */</comment>
		<expr_stmt><expr><call><name>PG_ENSURE_ERROR_CLEANUP</name><argument_list>(<argument><expr><name>pg_stop_backup_callback</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>exclusive</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<comment type="block">/*
			 * Read the existing label file into memory.
			 */</comment>
			<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>BACKUP_LABEL_FILE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* should not happen per the upper checks */</comment>
				<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not stat file \"%s\": %m"</literal></expr></argument>,
									<argument><expr><name>BACKUP_LABEL_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"a backup is not in progress"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>lfp</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>BACKUP_LABEL_FILE</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lfp</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read file \"%s\": %m"</literal></expr></argument>,
								<argument><expr><name>BACKUP_LABEL_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>labelfile</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>statbuf</name><operator>.</operator><name>st_size</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>fread</name><argument_list>(<argument><expr><name>labelfile</name></expr></argument>, <argument><expr><name><name>statbuf</name><operator>.</operator><name>st_size</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>lfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>labelfile</name><index>[<expr><name><name>statbuf</name><operator>.</operator><name>st_size</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

			<comment type="block">/*
			 * Close and remove the backup label file
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator> <call><name>ferror</name><argument_list>(<argument><expr><name>lfp</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>FreeFile</name><argument_list>(<argument><expr><name>lfp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read file \"%s\": %m"</literal></expr></argument>,
								<argument><expr><name>BACKUP_LABEL_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>durable_unlink</name><argument_list>(<argument><expr><name>BACKUP_LABEL_FILE</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Remove tablespace_map file if present, it is created only if
			 * there are tablespaces.
			 */</comment>
			<expr_stmt><expr><call><name>durable_unlink</name><argument_list>(<argument><expr><name>TABLESPACE_MAP</name></expr></argument>, <argument><expr><name>DEBUG1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_END_ENSURE_ERROR_CLEANUP</name><argument_list>(<argument><expr><name>pg_stop_backup_callback</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>exclusive</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * OK to update backup counters, forcePageWrites and session-level lock.
	 *
	 * Note that CHECK_FOR_INTERRUPTS() must not occur while updating them.
	 * Otherwise they can be updated inconsistently, and which might cause
	 * do_pg_abort_backup() to fail.
	 */</comment>
	<expr_stmt><expr><call><name>WALInsertLockAcquireExclusive</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>exclusive</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>exclusiveBackupState</name></name> <operator>=</operator> <name>EXCLUSIVE_BACKUP_NONE</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * The user-visible pg_start/stop_backup() functions that operate on
		 * exclusive backups can be called at any time, but for non-exclusive
		 * backups, it is expected that each do_pg_start_backup() call is
		 * matched by exactly one do_pg_stop_backup() call.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>nonExclusiveBackups</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>nonExclusiveBackups</name></name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>exclusiveBackupState</name></name> <operator>==</operator> <name>EXCLUSIVE_BACKUP_NONE</name> <operator>&amp;&amp;</operator>
		<name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>nonExclusiveBackups</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>forcePageWrites</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Clean up session-level lock.
	 *
	 * You might think that WALInsertLockRelease() can be called before
	 * cleaning up session-level lock because session-level lock doesn't need
	 * to be protected with WAL insertion lock. But since
	 * CHECK_FOR_INTERRUPTS() can occur in it, session-level lock must be
	 * cleaned up before it.
	 */</comment>
	<expr_stmt><expr><name>sessionBackupState</name> <operator>=</operator> <name>SESSION_BACKUP_NONE</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WALInsertLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Read and parse the START WAL LOCATION line (this code is pretty crude,
	 * but we are not expecting any variability in the file format).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>labelfile</name></expr></argument>, <argument><expr><literal type="string">"START WAL LOCATION: %X/%X (file %24s)%c"</literal></expr></argument>,
			   <argument><expr><operator>&amp;</operator><name>hi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lo</name></expr></argument>, <argument><expr><name>startxlogfilename</name></expr></argument>,
			   <argument><expr><operator>&amp;</operator><name>ch</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">4</literal> <operator>||</operator> <name>ch</name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid data in file \"%s\""</literal></expr></argument>, <argument><expr><name>BACKUP_LABEL_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>startpoint</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <name>hi</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">32</literal> <operator>|</operator> <name>lo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>remaining</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>labelfile</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* %n is not portable enough */</comment>

	<comment type="block">/*
	 * Parse the BACKUP FROM line. If we are taking an online backup from the
	 * standby, we confirm that the standby has not been promoted during the
	 * backup.
	 */</comment>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>remaining</name></expr></argument>, <argument><expr><literal type="string">"BACKUP FROM:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name> <operator>||</operator> <call><name>sscanf</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="string">"BACKUP FROM: %19s\n"</literal></expr></argument>, <argument><expr><name>backupfrom</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid data in file \"%s\""</literal></expr></argument>, <argument><expr><name>BACKUP_LABEL_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>backupfrom</name></expr></argument>, <argument><expr><literal type="string">"standby"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>backup_started_in_recovery</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"the standby was promoted during online backup"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"This means that the backup being taken is corrupt "</literal>
						 <literal type="string">"and should not be used. "</literal>
						 <literal type="string">"Try taking another online backup."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * During recovery, we don't write an end-of-backup record. We assume that
	 * pg_control was backed up last and its minimum recovery point can be
	 * available as the backup end location. Since we don't have an
	 * end-of-backup record, we use the pg_control value to check whether
	 * we've reached the end of backup when starting recovery from this
	 * backup. We have no way of checking if pg_control wasn't backed up last
	 * however.
	 *
	 * We don't force a switch to new WAL file but it is still possible to
	 * wait for all the required files to be archived if waitforarchive is
	 * true. This is okay if we use the backup to start a standby and fetch
	 * the missing WAL using streaming replication. But in the case of an
	 * archive recovery, a user should set waitforarchive to true and wait for
	 * them to be archived to ensure that all the required files are
	 * available.
	 *
	 * We return the current minimum recovery point as the backup end
	 * location. Note that it can be greater than the exact backup end
	 * location if the minimum recovery point is updated after the backup of
	 * pg_control. This is harmless for current uses.
	 *
	 * XXX currently a backup history file is for informational and debug
	 * purposes only. It's not essential for an online backup. Furthermore,
	 * even if it's created, it will not be archived during recovery because
	 * an archiver is not invoked. So it doesn't seem worthwhile to write a
	 * backup history file during recovery.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>backup_started_in_recovery</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Check to see if all WAL replayed during online backup contain
		 * full-page writes.
		 */</comment>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>recptr</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>lastFpwDisableRecPtr</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>startpoint</name> <operator>&lt;=</operator> <name>recptr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"WAL generated with full_page_writes=off was replayed "</literal>
							<literal type="string">"during online backup"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"This means that the backup being taken on the standby "</literal>
							 <literal type="string">"is corrupt and should not be used. "</literal>
							 <literal type="string">"Enable full_page_writes and run CHECKPOINT on the master, "</literal>
							 <literal type="string">"and then try an online backup again."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ControlFileLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>stoppoint</name> <operator>=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPoint</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>stoptli</name> <operator>=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>minRecoveryPointTLI</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ControlFileLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Write the backup-end xlog record
		 */</comment>
		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>startpoint</name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>startpoint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>stoppoint</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_XLOG_ID</name></expr></argument>, <argument><expr><name>XLOG_BACKUP_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>stoptli</name> <operator>=</operator> <name>ThisTimeLineID</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Force a switch to a new xlog segment file, so that the backup is
		 * valid as soon as archiver moves out the current segment file.
		 */</comment>
		<expr_stmt><expr><call><name>RequestXLogSwitch</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLByteToPrevSeg</name><argument_list>(<argument><expr><name>stoppoint</name></expr></argument>, <argument><expr><name>_logSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>stopxlogfilename</name></expr></argument>, <argument><expr><name>stoptli</name></expr></argument>, <argument><expr><name>_logSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Use the log timezone here, not the session timezone */</comment>
		<expr_stmt><expr><name>stamp_time</name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_strftime</name><argument_list>(<argument><expr><name>strfbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>strfbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					<argument><expr><literal type="string">"%Y-%m-%d %H:%M:%S %Z"</literal></expr></argument>,
					<argument><expr><call><name>pg_localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stamp_time</name></expr></argument>, <argument><expr><name>log_timezone</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Write the backup history file
		 */</comment>
		<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>startpoint</name></expr></argument>, <argument><expr><name>_logSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BackupHistoryFilePath</name><argument_list>(<argument><expr><name>histfilepath</name></expr></argument>, <argument><expr><name>stoptli</name></expr></argument>, <argument><expr><name>_logSegNo</name></expr></argument>,
							  <argument><expr><name>startpoint</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>histfilepath</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fp</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>histfilepath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"START WAL LOCATION: %X/%X (file %s)\n"</literal></expr></argument>,
				<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>startpoint</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>startpoint</name></expr></argument>, <argument><expr><name>startxlogfilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"STOP WAL LOCATION: %X/%X (file %s)\n"</literal></expr></argument>,
				<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>stoppoint</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>stoppoint</name></expr></argument>, <argument><expr><name>stopxlogfilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Transfer remaining lines including label and start timeline to
		 * history file.
		 */</comment>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>remaining</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"STOP TIME: %s\n"</literal></expr></argument>, <argument><expr><name>strfbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"STOP TIMELINE: %u\n"</literal></expr></argument>, <argument><expr><name>stoptli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>fflush</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ferror</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>FreeFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>histfilepath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Clean out any no-longer-needed history files.  As a side effect,
		 * this will post a .ready file for the newly created history file,
		 * notifying the archiver that history file may be archived
		 * immediately.
		 */</comment>
		<expr_stmt><expr><call><name>CleanupBackupHistory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If archiving is enabled, wait for all the required WAL files to be
	 * archived before returning. If archiving isn't enabled, the required WAL
	 * needs to be transported via streaming replication (hopefully with
	 * wal_keep_segments set high enough), or some more exotic mechanism like
	 * polling and copying files from pg_wal with script. We have no knowledge
	 * of those mechanisms, so it's up to the user to ensure that he gets all
	 * the required WAL.
	 *
	 * We wait until both the last WAL file filled during backup and the
	 * history file have been archived, and assume that the alphabetic sorting
	 * property of the WAL files ensures any earlier WAL files are safely
	 * archived as well.
	 *
	 * We wait forever, since archive_command is supposed to work and we
	 * assume the admin wanted his backup to work completely. If you don't
	 * wish to wait, then either waitforarchive should be passed in as false,
	 * or you can set statement_timeout.  Also, some notices are issued to
	 * clue in anyone who might be doing this interactively.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><name>waitforarchive</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><operator>!</operator><name>backup_started_in_recovery</name> <operator>&amp;&amp;</operator> <call><name>XLogArchivingActive</name><argument_list>()</argument_list></call><operator>)</operator> <operator>||</operator>
		 <operator>(</operator><name>backup_started_in_recovery</name> <operator>&amp;&amp;</operator> <call><name>XLogArchivingAlways</name><argument_list>()</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>XLByteToPrevSeg</name><argument_list>(<argument><expr><name>stoppoint</name></expr></argument>, <argument><expr><name>_logSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>lastxlogfilename</name></expr></argument>, <argument><expr><name>stoptli</name></expr></argument>, <argument><expr><name>_logSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>startpoint</name></expr></argument>, <argument><expr><name>_logSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BackupHistoryFileName</name><argument_list>(<argument><expr><name>histfilename</name></expr></argument>, <argument><expr><name>stoptli</name></expr></argument>, <argument><expr><name>_logSegNo</name></expr></argument>,
							  <argument><expr><name>startpoint</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>seconds_before_warning</name> <operator>=</operator> <literal type="number">60</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>waits</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<while>while <condition>(<expr><call><name>XLogArchiveIsBusy</name><argument_list>(<argument><expr><name>lastxlogfilename</name></expr></argument>)</argument_list></call> <operator>||</operator>
			   <call><name>XLogArchiveIsBusy</name><argument_list>(<argument><expr><name>histfilename</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>reported_waiting</name> <operator>&amp;&amp;</operator> <name>waits</name> <operator>&gt;</operator> <literal type="number">5</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pg_stop_backup cleanup done, waiting for required WAL segments to be archived"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>reported_waiting</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>++</operator><name>waits</name> <operator>&gt;=</operator> <name>seconds_before_warning</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>seconds_before_warning</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>	<comment type="block">/* This wraps in &gt;10 years... */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pg_stop_backup still waiting for all required WAL segments to be archived (%d seconds elapsed)"</literal></expr></argument>,
								<argument><expr><name>waits</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Check that your archive_command is executing properly.  "</literal>
								 <literal type="string">"pg_stop_backup can be canceled safely, "</literal>
								 <literal type="string">"but the database backup will not be usable without all the WAL segments."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pg_stop_backup complete, all required WAL segments have been archived"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>waitforarchive</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"WAL archiving is not enabled; you must ensure that all required WAL segments are copied through other means to complete the backup"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We're done.  As a convenience, return the ending WAL location.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>stoptli_p</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>stoptli_p</name> <operator>=</operator> <name>stoptli</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>stoppoint</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * do_pg_abort_backup: abort a running backup
 *
 * This does just the most basic steps of do_pg_stop_backup(), by taking the
 * system out of backup mode, thus making it a lot more safe to call from
 * an error handler.
 *
 * NB: This is only for aborting a non-exclusive backup that doesn't write
 * backup_label. A backup started with pg_start_backup() needs to be finished
 * with pg_stop_backup().
 */</comment>
<function><type><name>void</name></type>
<name>do_pg_abort_backup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Quick exit if session is not keeping around a non-exclusive backup
	 * already started.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>sessionBackupState</name> <operator>==</operator> <name>SESSION_BACKUP_NONE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>WALInsertLockAcquireExclusive</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>nonExclusiveBackups</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sessionBackupState</name> <operator>==</operator> <name>SESSION_BACKUP_NON_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>nonExclusiveBackups</name></name><operator>--</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>exclusiveBackupState</name></name> <operator>==</operator> <name>EXCLUSIVE_BACKUP_NONE</name> <operator>&amp;&amp;</operator>
		<name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>nonExclusiveBackups</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name><operator>.</operator><name>forcePageWrites</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>WALInsertLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get latest redo apply position.
 *
 * Exported to allow WALReceiver to read the pointer directly.
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>GetXLogReplayRecPtr</name><parameter_list>(<parameter><decl><type><name>TimeLineID</name> <modifier>*</modifier></type><name>replayTLI</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>tli</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>recptr</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>lastReplayedEndRecPtr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tli</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>lastReplayedTLI</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>replayTLI</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>replayTLI</name> <operator>=</operator> <name>tli</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>recptr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get latest WAL insert pointer
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>GetXLogInsertRecPtr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogCtlInsert</name> <modifier>*</modifier></type><name>Insert</name> <init>= <expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>Insert</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>current_bytepos</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>Insert</name><operator>-&gt;</operator><name>insertpos_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>current_bytepos</name> <operator>=</operator> <name><name>Insert</name><operator>-&gt;</operator><name>CurrBytePos</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>Insert</name><operator>-&gt;</operator><name>insertpos_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>XLogBytePosToRecPtr</name><argument_list>(<argument><expr><name>current_bytepos</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get latest WAL write pointer
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>GetXLogWriteRecPtr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>LogwrtResult</name> <operator>=</operator> <name><name>XLogCtl</name><operator>-&gt;</operator><name>LogwrtResult</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>LogwrtResult</name><operator>.</operator><name>Write</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns the redo pointer of the last checkpoint or restartpoint. This is
 * the oldest point in WAL that we still need, if we have to restart recovery.
 */</comment>
<function><type><name>void</name></type>
<name>GetOldestRestartPoint</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>oldrecptr</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name> <modifier>*</modifier></type><name>oldtli</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ControlFileLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>oldrecptr</name> <operator>=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>checkPointCopy</name><operator>.</operator><name>redo</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>oldtli</name> <operator>=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>checkPointCopy</name><operator>.</operator><name>ThisTimeLineID</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ControlFileLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * read_backup_label: check to see if a backup_label file is present
 *
 * If we see a backup_label during recovery, we assume that we are recovering
 * from a backup dump file, and we therefore roll forward from the checkpoint
 * identified by the label file, NOT what pg_control says.  This avoids the
 * problem that pg_control might have been archived one or more checkpoints
 * later than the start of the dump, and so if we rely on it as the start
 * point, we will fail to restore a consistent database state.
 *
 * Returns true if a backup_label was found (and fills the checkpoint
 * location and its REDO location into *checkPointLoc and RedoStartLSN,
 * respectively); returns false if not. If this backup_label came from a
 * streamed backup, *backupEndRequired is set to true. If this backup_label
 * was created during recovery, *backupFromStandby is set to true.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>read_backup_label</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>checkPointLoc</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>backupEndRequired</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>backupFromStandby</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>startxlogfilename</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>tli_from_walseg</name></decl>,
				<decl><type ref="prev"/><name>tli_from_file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>lfp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>ch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>backuptype</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>backupfrom</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>backuplabel</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>backuptime</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>hi</name></decl>,
				<decl><type ref="prev"/><name>lo</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>backupEndRequired</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>backupFromStandby</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * See if label file is present
	 */</comment>
	<expr_stmt><expr><name>lfp</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>BACKUP_LABEL_FILE</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lfp</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>BACKUP_LABEL_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>			<comment type="block">/* it's not there, all is fine */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Read and parse the START WAL LOCATION and CHECKPOINT lines (this code
	 * is pretty crude, but we are not expecting any variability in the file
	 * format).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>fscanf</name><argument_list>(<argument><expr><name>lfp</name></expr></argument>, <argument><expr><literal type="string">"START WAL LOCATION: %X/%X (file %08X%16s)%c"</literal></expr></argument>,
			   <argument><expr><operator>&amp;</operator><name>hi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tli_from_walseg</name></expr></argument>, <argument><expr><name>startxlogfilename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ch</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">5</literal> <operator>||</operator> <name>ch</name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid data in file \"%s\""</literal></expr></argument>, <argument><expr><name>BACKUP_LABEL_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>RedoStartLSN</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <name>hi</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">32</literal> <operator>|</operator> <name>lo</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>fscanf</name><argument_list>(<argument><expr><name>lfp</name></expr></argument>, <argument><expr><literal type="string">"CHECKPOINT LOCATION: %X/%X%c"</literal></expr></argument>,
			   <argument><expr><operator>&amp;</operator><name>hi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ch</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">3</literal> <operator>||</operator> <name>ch</name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid data in file \"%s\""</literal></expr></argument>, <argument><expr><name>BACKUP_LABEL_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>checkPointLoc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <name>hi</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">32</literal> <operator>|</operator> <name>lo</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * BACKUP METHOD and BACKUP FROM lines are new in 9.2. We can't restore
	 * from an older backup anyway, but since the information on it is not
	 * strictly required, don't error out if it's missing for some reason.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>fscanf</name><argument_list>(<argument><expr><name>lfp</name></expr></argument>, <argument><expr><literal type="string">"BACKUP METHOD: %19s\n"</literal></expr></argument>, <argument><expr><name>backuptype</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>backuptype</name></expr></argument>, <argument><expr><literal type="string">"streamed"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>backupEndRequired</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>fscanf</name><argument_list>(<argument><expr><name>lfp</name></expr></argument>, <argument><expr><literal type="string">"BACKUP FROM: %19s\n"</literal></expr></argument>, <argument><expr><name>backupfrom</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>backupfrom</name></expr></argument>, <argument><expr><literal type="string">"standby"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>backupFromStandby</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Parse START TIME and LABEL. Those are not mandatory fields for recovery
	 * but checking for their presence is useful for debugging and the next
	 * sanity checks. Cope also with the fact that the result buffers have a
	 * pre-allocated size, hence if the backup_label file has been generated
	 * with strings longer than the maximum assumed here an incorrect parsing
	 * happens. That's fine as only minor consistency checks are done
	 * afterwards.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>fscanf</name><argument_list>(<argument><expr><name>lfp</name></expr></argument>, <argument><expr><literal type="string">"START TIME: %127[^\n]\n"</literal></expr></argument>, <argument><expr><name>backuptime</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"backup time %s in file \"%s\""</literal></expr></argument>,
						<argument><expr><name>backuptime</name></expr></argument>, <argument><expr><name>BACKUP_LABEL_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>fscanf</name><argument_list>(<argument><expr><name>lfp</name></expr></argument>, <argument><expr><literal type="string">"LABEL: %1023[^\n]\n"</literal></expr></argument>, <argument><expr><name>backuplabel</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"backup label %s in file \"%s\""</literal></expr></argument>,
						<argument><expr><name>backuplabel</name></expr></argument>, <argument><expr><name>BACKUP_LABEL_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * START TIMELINE is new as of 11. Its parsing is not mandatory, still use
	 * it as a sanity check if present.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>fscanf</name><argument_list>(<argument><expr><name>lfp</name></expr></argument>, <argument><expr><literal type="string">"START TIMELINE: %u\n"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>tli_from_file</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>tli_from_walseg</name> <operator>!=</operator> <name>tli_from_file</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid data in file \"%s\""</literal></expr></argument>, <argument><expr><name>BACKUP_LABEL_FILE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Timeline ID parsed is %u, but expected %u"</literal></expr></argument>,
							   <argument><expr><name>tli_from_file</name></expr></argument>, <argument><expr><name>tli_from_walseg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"backup timeline %u in file \"%s\""</literal></expr></argument>,
						<argument><expr><name>tli_from_file</name></expr></argument>, <argument><expr><name>BACKUP_LABEL_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>lfp</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>FreeFile</name><argument_list>(<argument><expr><name>lfp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>BACKUP_LABEL_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * read_tablespace_map: check to see if a tablespace_map file is present
 *
 * If we see a tablespace_map file during recovery, we assume that we are
 * recovering from a backup dump file, and we therefore need to create symlinks
 * as per the information present in tablespace_map file.
 *
 * Returns true if a tablespace_map file was found (and fills the link
 * information for all the tablespace links present in file); returns false
 * if not.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>read_tablespace_map</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>tablespaces</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>tablespaceinfo</name> <modifier>*</modifier></type><name>ti</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>lfp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>tbsoid</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tbslinkpath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>str</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ch</name></decl>,
				<decl><type ref="prev"/><name>prev_ch</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * See if tablespace_map file is present
	 */</comment>
	<expr_stmt><expr><name>lfp</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>TABLESPACE_MAP</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lfp</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>TABLESPACE_MAP</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>			<comment type="block">/* it's not there, all is fine */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Read and parse the link name and path lines from tablespace_map file
	 * (this code is pretty crude, but we are not expecting any variability in
	 * the file format).  While taking backup we embed escape character '\\'
	 * before newline in tablespace path, so that during reading of
	 * tablespace_map file, we could distinguish newline in tablespace path
	 * and end of line.  Now while reading tablespace_map file, remove the
	 * escape character that has been added in tablespace path during backup.
	 */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>ch</name> <operator>=</operator> <call><name>fgetc</name><argument_list>(<argument><expr><name>lfp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>EOF</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ch</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator> <name>ch</name> <operator>==</operator> <literal type="char">'\r'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>prev_ch</name> <operator>!=</operator> <literal type="char">'\\'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"%s %n"</literal></expr></argument>, <argument><expr><name>tbsoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid data in file \"%s\""</literal></expr></argument>, <argument><expr><name>TABLESPACE_MAP</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>tbslinkpath</name> <operator>=</operator> <name>str</name> <operator>+</operator> <name>n</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<expr_stmt><expr><name>ti</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tablespaceinfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ti</name><operator>-&gt;</operator><name>oid</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>tbsoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ti</name><operator>-&gt;</operator><name>path</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>tbslinkpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><operator>*</operator><name>tablespaces</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>tablespaces</name></expr></argument>, <argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>(</operator><name>ch</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator> <name>ch</name> <operator>==</operator> <literal type="char">'\r'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>prev_ch</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>str</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>ch</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>str</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>ch</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>prev_ch</name> <operator>=</operator> <name>ch</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>lfp</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>FreeFile</name><argument_list>(<argument><expr><name>lfp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>TABLESPACE_MAP</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Error context callback for errors occurring during rm_redo().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>rm_redo_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name> <init>= <expr><operator>(</operator><name>XLogReaderState</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>xlog_outdesc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* translator: %s is a WAL record description */</comment>
	<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"WAL redo at %X/%X for %s"</literal></expr></argument>,
			   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
			   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>,
			   <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * BackupInProgress: check if online backup mode is active
 *
 * This is done by checking for existence of the "backup_label" file.
 */</comment>
<function><type><name>bool</name></type>
<name>BackupInProgress</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>

	<return>return <expr><operator>(</operator><call><name>stat</name><argument_list>(<argument><expr><name>BACKUP_LABEL_FILE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CancelBackup: rename the "backup_label" and "tablespace_map"
 *				 files to cancel backup mode
 *
 * If the "backup_label" file exists, it will be renamed to "backup_label.old".
 * Similarly, if the "tablespace_map" file exists, it will be renamed to
 * "tablespace_map.old".
 *
 * Note that this will render an online backup in progress
 * useless. To correctly finish an online backup, pg_stop_backup must be
 * called.
 */</comment>
<function><type><name>void</name></type>
<name>CancelBackup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>

	<comment type="block">/* if the backup_label file is not there, return */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>BACKUP_LABEL_FILE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* remove leftover file from previously canceled backup if it exists */</comment>
	<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>BACKUP_LABEL_OLD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>durable_rename</name><argument_list>(<argument><expr><name>BACKUP_LABEL_FILE</name></expr></argument>, <argument><expr><name>BACKUP_LABEL_OLD</name></expr></argument>, <argument><expr><name>DEBUG1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"online backup mode was not canceled"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"File \"%s\" could not be renamed to \"%s\": %m."</literal></expr></argument>,
						   <argument><expr><name>BACKUP_LABEL_FILE</name></expr></argument>, <argument><expr><name>BACKUP_LABEL_OLD</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* if the tablespace_map file is not there, return */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>TABLESPACE_MAP</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"online backup mode canceled"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"File \"%s\" was renamed to \"%s\"."</literal></expr></argument>,
						   <argument><expr><name>BACKUP_LABEL_FILE</name></expr></argument>, <argument><expr><name>BACKUP_LABEL_OLD</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* remove leftover file from previously canceled backup if it exists */</comment>
	<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>TABLESPACE_MAP_OLD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>durable_rename</name><argument_list>(<argument><expr><name>TABLESPACE_MAP</name></expr></argument>, <argument><expr><name>TABLESPACE_MAP_OLD</name></expr></argument>, <argument><expr><name>DEBUG1</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"online backup mode canceled"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Files \"%s\" and \"%s\" were renamed to "</literal>
						   <literal type="string">"\"%s\" and \"%s\", respectively."</literal></expr></argument>,
						   <argument><expr><name>BACKUP_LABEL_FILE</name></expr></argument>, <argument><expr><name>TABLESPACE_MAP</name></expr></argument>,
						   <argument><expr><name>BACKUP_LABEL_OLD</name></expr></argument>, <argument><expr><name>TABLESPACE_MAP_OLD</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"online backup mode canceled"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"File \"%s\" was renamed to \"%s\", but "</literal>
						   <literal type="string">"file \"%s\" could not be renamed to \"%s\": %m."</literal></expr></argument>,
						   <argument><expr><name>BACKUP_LABEL_FILE</name></expr></argument>, <argument><expr><name>BACKUP_LABEL_OLD</name></expr></argument>,
						   <argument><expr><name>TABLESPACE_MAP</name></expr></argument>, <argument><expr><name>TABLESPACE_MAP_OLD</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Read the XLOG page containing RecPtr into readBuf (if not read already).
 * Returns number of bytes read, if the page is read successfully, or -1
 * in case of errors.  When errors occur, they are ereport'ed, but only
 * if they have not been previously reported.
 *
 * This is responsible for restoring files from archive as needed, as well
 * as for waiting for the requested WAL record to arrive in standby mode.
 *
 * 'emode' specifies the log level used for reporting "file not found" or
 * "end of WAL" situations in archive recovery, or in standby mode when a
 * trigger file is found. If set to WARNING or below, XLogPageRead() returns
 * false in those situations, on higher log levels the ereport() won't
 * return.
 *
 * In standby mode, if after a successful return of XLogPageRead() the
 * caller finds the record it's interested in to be broken, it should
 * ereport the error with the level determined by
 * emode_for_corrupt_record(), and then set lastSourceFailed
 * and call XLogPageRead() again with the same arguments. This lets
 * XLogPageRead() to try fetching the record from another source, or to
 * sleep and retry.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>XLogPageRead</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>xlogreader</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>targetPagePtr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reqLen</name></decl></parameter>,
			 <parameter><decl><type><name>XLogRecPtr</name></type> <name>targetRecPtr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>readBuf</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name> <modifier>*</modifier></type><name>readTLI</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogPageReadPrivate</name> <modifier>*</modifier></type><name>private</name> <init>=
	<expr><operator>(</operator><name>XLogPageReadPrivate</name> <operator>*</operator><operator>)</operator> <name><name>xlogreader</name><operator>-&gt;</operator><name>private_data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>emode</name> <init>= <expr><name><name>private</name><operator>-&gt;</operator><name>emode</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>targetPageOff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name>	<name>targetSegNo</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>targetPagePtr</name></expr></argument>, <argument><expr><name>targetSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>targetPageOff</name> <operator>=</operator> <call><name>XLogSegmentOffset</name><argument_list>(<argument><expr><name>targetPagePtr</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * See if we need to switch to a new segment because the requested record
	 * is not in the currently open one.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>readFile</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>XLByteInSeg</name><argument_list>(<argument><expr><name>targetPagePtr</name></expr></argument>, <argument><expr><name>readSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Request a restartpoint if we've replayed too much xlog since the
		 * last one.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>bgwriterLaunched</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>XLogCheckpointNeeded</name><argument_list>(<argument><expr><name>readSegNo</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>GetRedoRecPtr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>XLogCheckpointNeeded</name><argument_list>(<argument><expr><name>readSegNo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>RequestCheckpoint</name><argument_list>(<argument><expr><name>CHECKPOINT_CAUSE_XLOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>readFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>readFile</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>readSource</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>targetPagePtr</name></expr></argument>, <argument><expr><name>readSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>retry</name>:</label>
	<comment type="block">/* See if we need to retrieve more data */</comment>
	<if_stmt><if>if <condition>(<expr><name>readFile</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<operator>(</operator><name>readSource</name> <operator>==</operator> <name>XLOG_FROM_STREAM</name> <operator>&amp;&amp;</operator>
		 <name>receivedUpto</name> <operator>&lt;</operator> <name>targetPagePtr</name> <operator>+</operator> <name>reqLen</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>WaitForWALToBecomeAvailable</name><argument_list>(<argument><expr><name>targetPagePtr</name> <operator>+</operator> <name>reqLen</name></expr></argument>,
										 <argument><expr><name><name>private</name><operator>-&gt;</operator><name>randAccess</name></name></expr></argument>,
										 <argument><expr><name><name>private</name><operator>-&gt;</operator><name>fetching_ckpt</name></name></expr></argument>,
										 <argument><expr><name>targetRecPtr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>readFile</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>readFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>readFile</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>readLen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>readSource</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * At this point, we have the right segment open and if we're streaming we
	 * know the requested record is in it.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>readFile</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the current segment is being streamed from master, calculate how
	 * much of the current page we have received already. We know the
	 * requested record has been received, but this is for the benefit of
	 * future calls, to allow quick exit at the top of this function.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>readSource</name> <operator>==</operator> <name>XLOG_FROM_STREAM</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>targetPagePtr</name><operator>)</operator> <operator>/</operator> <name>XLOG_BLCKSZ</name><operator>)</operator> <operator>!=</operator> <operator>(</operator><name>receivedUpto</name> <operator>/</operator> <name>XLOG_BLCKSZ</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>readLen</name> <operator>=</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>readLen</name> <operator>=</operator> <call><name>XLogSegmentOffset</name><argument_list>(<argument><expr><name>receivedUpto</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call> <operator>-</operator>
				<name>targetPageOff</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>readLen</name> <operator>=</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Read the requested page */</comment>
	<expr_stmt><expr><name>readOff</name> <operator>=</operator> <name>targetPageOff</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>lseek</name><argument_list>(<argument><expr><name>readFile</name></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator> <name>readOff</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>fname</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>curFileTLI</name></expr></argument>, <argument><expr><name>readSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><call><name>emode_for_corrupt_record</name><argument_list>(<argument><expr><name>emode</name></expr></argument>, <argument><expr><name>targetPagePtr</name> <operator>+</operator> <name>reqLen</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not seek in log segment %s to offset %u: %m"</literal></expr></argument>,
						<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>readOff</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>next_record_is_invalid</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_WAL_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>read</name><argument_list>(<argument><expr><name>readFile</name></expr></argument>, <argument><expr><name>readBuf</name></expr></argument>, <argument><expr><name>XLOG_BLCKSZ</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XLOG_BLCKSZ</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>fname</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>curFileTLI</name></expr></argument>, <argument><expr><name>readSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><call><name>emode_for_corrupt_record</name><argument_list>(<argument><expr><name>emode</name></expr></argument>, <argument><expr><name>targetPagePtr</name> <operator>+</operator> <name>reqLen</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from log segment %s, offset %u: %m"</literal></expr></argument>,
						<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>readOff</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>next_record_is_invalid</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>targetSegNo</name> <operator>==</operator> <name>readSegNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>targetPageOff</name> <operator>==</operator> <name>readOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>reqLen</name> <operator>&lt;=</operator> <name>readLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>readTLI</name> <operator>=</operator> <name>curFileTLI</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check the page header immediately, so that we can retry immediately if
	 * it's not valid. This may seem unnecessary, because XLogReadRecord()
	 * validates the page header anyway, and would propagate the failure up to
	 * ReadRecord(), which would retry. However, there's a corner case with
	 * continuation records, if a record is split across two pages such that
	 * we would need to read the two pages from different sources. For
	 * example, imagine a scenario where a streaming replica is started up,
	 * and replay reaches a record that's split across two WAL segments. The
	 * first page is only available locally, in pg_wal, because it's already
	 * been recycled in the master. The second page, however, is not present
	 * in pg_wal, and we should stream it from the master. There is a recycled
	 * WAL segment present in pg_wal, with garbage contents, however. We would
	 * read the first page from the local WAL segment, but when reading the
	 * second page, we would read the bogus, recycled, WAL segment. If we
	 * didn't catch that case here, we would never recover, because
	 * ReadRecord() would retry reading the whole record from the beginning.
	 *
	 * Of course, this only catches errors in the page header, which is what
	 * happens in the case of a recycled WAL segment. Other kinds of errors or
	 * corruption still has the same problem. But this at least fixes the
	 * common case, which can happen as part of normal operation.
	 *
	 * Validating the page header is cheap enough that doing it twice
	 * shouldn't be a big deal from a performance point of view.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogReaderValidatePageHeader</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>, <argument><expr><name>targetPagePtr</name></expr></argument>, <argument><expr><name>readBuf</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* reset any error XLogReaderValidatePageHeader() might have set */</comment>
		<expr_stmt><expr><name><name>xlogreader</name><operator>-&gt;</operator><name>errormsg_buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<goto>goto <name>next_record_is_invalid</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>readLen</name></expr>;</return>

<label><name>next_record_is_invalid</name>:</label>
	<expr_stmt><expr><name>lastSourceFailed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>readFile</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>readFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>readFile</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>readLen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>readSource</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* In standby-mode, keep trying */</comment>
	<if_stmt><if>if <condition>(<expr><name>StandbyMode</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>retry</name>;</goto></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Open the WAL segment containing WAL location 'RecPtr'.
 *
 * The segment can be fetched via restore_command, or via walreceiver having
 * streamed the record, or it can already be present in pg_wal. Checking
 * pg_wal is mainly for crash recovery, but it will be polled in standby mode
 * too, in case someone copies a new segment directly to pg_wal. That is not
 * documented or recommended, though.
 *
 * If 'fetching_ckpt' is true, we're fetching a checkpoint record, and should
 * prepare to read WAL starting from RedoStartLSN after this.
 *
 * 'RecPtr' might not point to the beginning of the record we're interested
 * in, it might also point to the page or segment header. In that case,
 * 'tliRecPtr' is the position of the WAL record we're interested in. It is
 * used to decide which timeline to stream the requested WAL from.
 *
 * If the record is not immediately available, the function returns false
 * if we're not in standby mode. In standby mode, waits for it to become
 * available.
 *
 * When the requested record becomes available, the function opens the file
 * containing it (if not open already), and returns true. When end of standby
 * mode is triggered by the user, and there is no more WAL available, returns
 * false.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>WaitForWALToBecomeAvailable</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>RecPtr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>randAccess</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>fetching_ckpt</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>tliRecPtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>last_fail_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>now</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>streaming_reply_sent</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*-------
	 * Standby mode is implemented by a state machine:
	 *
	 * 1. Read from either archive or pg_wal (XLOG_FROM_ARCHIVE), or just
	 *	  pg_wal (XLOG_FROM_PG_WAL)
	 * 2. Check trigger file
	 * 3. Read from primary server via walreceiver (XLOG_FROM_STREAM)
	 * 4. Rescan timelines
	 * 5. Sleep wal_retrieve_retry_interval milliseconds, and loop back to 1.
	 *
	 * Failure to read from the current source advances the state machine to
	 * the next state.
	 *
	 * 'currentSource' indicates the current state. There are no currentSource
	 * values for "check trigger", "rescan timelines", and "sleep" states,
	 * those actions are taken when reading from the previous source fails, as
	 * part of advancing to the next state.
	 *-------
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>InArchiveRecovery</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>currentSource</name> <operator>=</operator> <name>XLOG_FROM_PG_WAL</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>currentSource</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>currentSource</name> <operator>=</operator> <name>XLOG_FROM_ARCHIVE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>oldSource</name> <init>= <expr><name>currentSource</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * First check if we failed to read from the current source, and
		 * advance the state machine if so. The failure to read might've
		 * happened outside this function, e.g when a CRC check fails on a
		 * record, or within this loop.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>lastSourceFailed</name></expr>)</condition>
		<block>{<block_content>
			<switch>switch <condition>(<expr><name>currentSource</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>XLOG_FROM_ARCHIVE</name></expr>:</case>
				<case>case <expr><name>XLOG_FROM_PG_WAL</name></expr>:</case>

					<comment type="block">/*
					 * Check to see if the trigger file exists. Note that we
					 * do this only after failure, so when you create the
					 * trigger file, we still finish replaying as much as we
					 * can from archive and pg_wal before failover.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>StandbyMode</name> <operator>&amp;&amp;</operator> <call><name>CheckForStandbyTrigger</name><argument_list>()</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ShutdownWalRcv</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
						<return>return <expr><name>false</name></expr>;</return>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * Not in standby mode, and we've now tried the archive
					 * and pg_wal.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>StandbyMode</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

					<comment type="block">/*
					 * If primary_conninfo is set, launch walreceiver to try
					 * to stream the missing WAL.
					 *
					 * If fetching_ckpt is true, RecPtr points to the initial
					 * checkpoint location. In that case, we use RedoStartLSN
					 * as the streaming start position instead of RecPtr, so
					 * that when we later jump backwards to start redo at
					 * RedoStartLSN, we will have the logs streamed already.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>PrimaryConnInfo</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>ptr</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>tli</name></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name>fetching_ckpt</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>RedoStartLSN</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>tli</name> <operator>=</operator> <name><name>ControlFile</name><operator>-&gt;</operator><name>checkPointCopy</name><operator>.</operator><name>ThisTimeLineID</name></name></expr>;</expr_stmt>
						</block_content>}</block></if>
						<else>else
						<block>{<block_content>
							<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>RecPtr</name></expr>;</expr_stmt>

							<comment type="block">/*
							 * Use the record begin position to determine the
							 * TLI, rather than the position we're reading.
							 */</comment>
							<expr_stmt><expr><name>tli</name> <operator>=</operator> <call><name>tliOfPointInHistory</name><argument_list>(<argument><expr><name>tliRecPtr</name></expr></argument>, <argument><expr><name>expectedTLEs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<if_stmt><if>if <condition>(<expr><name>curFileTLI</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>tli</name> <operator>&lt;</operator> <name>curFileTLI</name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"according to history file, WAL location %X/%X belongs to timeline %u, but previous recovered WAL file came from timeline %u"</literal></expr></argument>,
									 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>tliRecPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
									 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>tliRecPtr</name></expr></argument>,
									 <argument><expr><name>tli</name></expr></argument>, <argument><expr><name>curFileTLI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						</block_content>}</block></else></if_stmt>
						<expr_stmt><expr><name>curFileTLI</name> <operator>=</operator> <name>tli</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>RequestXLogStreaming</name><argument_list>(<argument><expr><name>tli</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>PrimaryConnInfo</name></expr></argument>,
											 <argument><expr><name>PrimarySlotName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>receivedUpto</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * Move to XLOG_FROM_STREAM state in either case. We'll
					 * get immediate failure if we didn't launch walreceiver,
					 * and move on to the next state.
					 */</comment>
					<expr_stmt><expr><name>currentSource</name> <operator>=</operator> <name>XLOG_FROM_STREAM</name></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>XLOG_FROM_STREAM</name></expr>:</case>

					<comment type="block">/*
					 * Failure while streaming. Most likely, we got here
					 * because streaming replication was terminated, or
					 * promotion was triggered. But we also get here if we
					 * find an invalid record in the WAL streamed from master,
					 * in which case something is seriously wrong. There's
					 * little chance that the problem will just go away, but
					 * PANIC is not good for availability either, especially
					 * in hot standby mode. So, we treat that the same as
					 * disconnection, and retry from archive/pg_wal again. The
					 * WAL in the archive should be identical to what was
					 * streamed, so it's unlikely that it helps, but one can
					 * hope...
					 */</comment>

					<comment type="block">/*
					 * Before we leave XLOG_FROM_STREAM state, make sure that
					 * walreceiver is not active, so that it won't overwrite
					 * WAL that we restore from archive.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>WalRcvStreaming</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ShutdownWalRcv</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/*
					 * Before we sleep, re-scan for possible new timelines if
					 * we were requested to recover to the latest timeline.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>recoveryTargetIsLatest</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>rescanLatestTimeLine</name><argument_list>()</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>currentSource</name> <operator>=</operator> <name>XLOG_FROM_ARCHIVE</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * XLOG_FROM_STREAM is the last state in our state
					 * machine, so we've exhausted all the options for
					 * obtaining the requested WAL. We're going to loop back
					 * and retry from the archive, but if it hasn't been long
					 * since last attempt, sleep wal_retrieve_retry_interval
					 * milliseconds to avoid busy-waiting.
					 */</comment>
					<expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name>last_fail_time</name></expr></argument>, <argument><expr><name>now</name></expr></argument>,
													<argument><expr><name>wal_retrieve_retry_interval</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>long</name></type>		<name>secs</name></decl>,
									<decl><type ref="prev"/><name>wait_time</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>int</name></type>			<name>usecs</name></decl>;</decl_stmt>

						<expr_stmt><expr><call><name>TimestampDifference</name><argument_list>(<argument><expr><name>last_fail_time</name></expr></argument>, <argument><expr><name>now</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>secs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>usecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>wait_time</name> <operator>=</operator> <name>wal_retrieve_retry_interval</name> <operator>-</operator>
							<operator>(</operator><name>secs</name> <operator>*</operator> <literal type="number">1000</literal> <operator>+</operator> <name>usecs</name> <operator>/</operator> <literal type="number">1000</literal><operator>)</operator></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>WaitLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>recoveryWakeupLatch</name></name></expr></argument>,
								  <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_TIMEOUT</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name></expr></argument>,
								  <argument><expr><name>wait_time</name></expr></argument>, <argument><expr><name>WAIT_EVENT_RECOVERY_WAL_STREAM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>recoveryWakeupLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name>last_fail_time</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>currentSource</name> <operator>=</operator> <name>XLOG_FROM_ARCHIVE</name></expr>;</expr_stmt>
					<break>break;</break>

				<default>default:</default>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected WAL source %d"</literal></expr></argument>, <argument><expr><name>currentSource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></switch>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>currentSource</name> <operator>==</operator> <name>XLOG_FROM_PG_WAL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We just successfully read a file in pg_wal. We prefer files in
			 * the archive over ones in pg_wal, so try the next file again
			 * from the archive first.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>InArchiveRecovery</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>currentSource</name> <operator>=</operator> <name>XLOG_FROM_ARCHIVE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>currentSource</name> <operator>!=</operator> <name>oldSource</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"switched WAL source from %s to %s after %s"</literal></expr></argument>,
				 <argument><expr><name><name>xlogSourceNames</name><index>[<expr><name>oldSource</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>xlogSourceNames</name><index>[<expr><name>currentSource</name></expr>]</index></name></expr></argument>,
				 <argument><expr><ternary><condition><expr><name>lastSourceFailed</name></expr> ?</condition><then> <expr><literal type="string">"failure"</literal></expr> </then><else>: <expr><literal type="string">"success"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We've now handled possible failure. Try to read from the chosen
		 * source.
		 */</comment>
		<expr_stmt><expr><name>lastSourceFailed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name>currentSource</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>XLOG_FROM_ARCHIVE</name></expr>:</case>
			<case>case <expr><name>XLOG_FROM_PG_WAL</name></expr>:</case>
				<comment type="block">/* Close any old file we might have open. */</comment>
				<if_stmt><if>if <condition>(<expr><name>readFile</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>readFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>readFile</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* Reset curFileTLI if random fetch. */</comment>
				<if_stmt><if>if <condition>(<expr><name>randAccess</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>curFileTLI</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Try to restore the file from archive, or read an existing
				 * file from pg_wal.
				 */</comment>
				<expr_stmt><expr><name>readFile</name> <operator>=</operator> <call><name>XLogFileReadAnyTLI</name><argument_list>(<argument><expr><name>readSegNo</name></expr></argument>, <argument><expr><name>DEBUG2</name></expr></argument>,
											  <argument><expr><ternary><condition><expr><name>currentSource</name> <operator>==</operator> <name>XLOG_FROM_ARCHIVE</name></expr> ?</condition><then> <expr><name>XLOG_FROM_ANY</name></expr> </then><else>:
											  <expr><name>currentSource</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>readFile</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* success! */</comment>

				<comment type="block">/*
				 * Nope, not found in archive or pg_wal.
				 */</comment>
				<expr_stmt><expr><name>lastSourceFailed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>XLOG_FROM_STREAM</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>bool</name></type>		<name>havedata</name></decl>;</decl_stmt>

					<comment type="block">/*
					 * Check if WAL receiver is still active.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>WalRcvStreaming</name><argument_list>()</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>lastSourceFailed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * Walreceiver is active, so see if new data has arrived.
					 *
					 * We only advance XLogReceiptTime when we obtain fresh
					 * WAL from walreceiver and observe that we had already
					 * processed everything before the most recent "chunk"
					 * that it flushed to disk.  In steady state where we are
					 * keeping up with the incoming data, XLogReceiptTime will
					 * be updated on each cycle. When we are behind,
					 * XLogReceiptTime will not advance, so the grace time
					 * allotted to conflicting queries will decrease.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>RecPtr</name> <operator>&lt;</operator> <name>receivedUpto</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>havedata</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
					<else>else
					<block>{<block_content>
						<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>latestChunkStart</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>receivedUpto</name> <operator>=</operator> <call><name>GetWalRcvWriteRecPtr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>latestChunkStart</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>receiveTLI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>RecPtr</name> <operator>&lt;</operator> <name>receivedUpto</name> <operator>&amp;&amp;</operator> <name>receiveTLI</name> <operator>==</operator> <name>curFileTLI</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>havedata</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name>latestChunkStart</name> <operator>&lt;=</operator> <name>RecPtr</name></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><name>XLogReceiptTime</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>SetCurrentChunkStartTime</name><argument_list>(<argument><expr><name>XLogReceiptTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name>havedata</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
					</block_content>}</block></else></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>havedata</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * Great, streamed far enough.  Open the file if it's
						 * not open already.  Also read the timeline history
						 * file if we haven't initialized timeline history
						 * yet; it should be streamed over and present in
						 * pg_wal by now.  Use XLOG_FROM_STREAM so that source
						 * info is set correctly and XLogReceiptTime isn't
						 * changed.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name>readFile</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><operator>!</operator><name>expectedTLEs</name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name>expectedTLEs</name> <operator>=</operator> <call><name>readTimeLineHistory</name><argument_list>(<argument><expr><name>receiveTLI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<expr_stmt><expr><name>readFile</name> <operator>=</operator> <call><name>XLogFileRead</name><argument_list>(<argument><expr><name>readSegNo</name></expr></argument>, <argument><expr><name>PANIC</name></expr></argument>,
													<argument><expr><name>receiveTLI</name></expr></argument>,
													<argument><expr><name>XLOG_FROM_STREAM</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>readFile</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if>
						<else>else
						<block>{<block_content>
							<comment type="block">/* just make sure source info is correct... */</comment>
							<expr_stmt><expr><name>readSource</name> <operator>=</operator> <name>XLOG_FROM_STREAM</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>XLogReceiptSource</name> <operator>=</operator> <name>XLOG_FROM_STREAM</name></expr>;</expr_stmt>
							<return>return <expr><name>true</name></expr>;</return>
						</block_content>}</block></else></if_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * Data not here yet. Check for trigger, then wait for
					 * walreceiver to wake us up when new WAL arrives.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>CheckForStandbyTrigger</name><argument_list>()</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * Note that we don't "return false" immediately here.
						 * After being triggered, we still want to replay all
						 * the WAL that was already streamed. It's in pg_wal
						 * now, so we just treat this as a failure, and the
						 * state machine will move on to replay the streamed
						 * WAL from pg_wal, and then recheck the trigger and
						 * exit replay.
						 */</comment>
						<expr_stmt><expr><name>lastSourceFailed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * Since we have replayed everything we have received so
					 * far and are about to start waiting for more WAL, let's
					 * tell the upstream server our replay location now so
					 * that pg_stat_replication doesn't show stale
					 * information.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>streaming_reply_sent</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>WalRcvForceReply</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>streaming_reply_sent</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * Wait for more WAL to arrive. Time out after 5 seconds
					 * to react to a trigger file promptly.
					 */</comment>
					<expr_stmt><expr><call><name>WaitLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>recoveryWakeupLatch</name></name></expr></argument>,
							  <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_TIMEOUT</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name></expr></argument>,
							  <argument><expr><literal type="number">5000L</literal></expr></argument>, <argument><expr><name>WAIT_EVENT_RECOVERY_WAL_ALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>recoveryWakeupLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected WAL source %d"</literal></expr></argument>, <argument><expr><name>currentSource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>

		<comment type="block">/*
		 * This possibly-long loop needs to handle interrupts of startup
		 * process.
		 */</comment>
		<expr_stmt><expr><call><name>HandleStartupProcInterrupts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>false</name></expr>;</return>				<comment type="block">/* not reached */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Determine what log level should be used to report a corrupt WAL record
 * in the current WAL page, previously read by XLogPageRead().
 *
 * 'emode' is the error mode that would be used to report a file-not-found
 * or legitimate end-of-WAL situation.   Generally, we use it as-is, but if
 * we're retrying the exact same record that we've tried previously, only
 * complain the first time to keep the noise down.  However, we only do when
 * reading from pg_wal, because we don't expect any invalid records in archive
 * or in records streamed from master. Files in the archive should be complete,
 * and we should never hit the end of WAL because we stop and wait for more WAL
 * to arrive before replaying it.
 *
 * NOTE: This function remembers the RecPtr value it was last called with,
 * to suppress repeated messages about the same record. Only call this when
 * you are about to ereport(), or you might cause a later message to be
 * erroneously suppressed.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>emode_for_corrupt_record</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>emode</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>RecPtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>lastComplaint</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>readSource</name> <operator>==</operator> <name>XLOG_FROM_PG_WAL</name> <operator>&amp;&amp;</operator> <name>emode</name> <operator>==</operator> <name>LOG</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>RecPtr</name> <operator>==</operator> <name>lastComplaint</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>emode</name> <operator>=</operator> <name>DEBUG1</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>lastComplaint</name> <operator>=</operator> <name>RecPtr</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>emode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check to see whether the user-specified trigger file exists and whether a
 * promote request has arrived.  If either condition holds, return true.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CheckForStandbyTrigger</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>triggered</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>triggered</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsPromoteTriggered</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * In 9.1 and 9.2 the postmaster unlinked the promote file inside the
		 * signal handler. It now leaves the file in place and lets the
		 * Startup process do the unlink. This allows Startup to know whether
		 * it should create a full checkpoint before starting up (fallback
		 * mode). Fast promotion takes precedence.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>PROMOTE_SIGNAL_FILE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>PROMOTE_SIGNAL_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>FALLBACK_PROMOTE_SIGNAL_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>fast_promote</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>FALLBACK_PROMOTE_SIGNAL_FILE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>FALLBACK_PROMOTE_SIGNAL_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>fast_promote</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"received promote request"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ResetPromoteTriggered</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>triggered</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>TriggerFile</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>TriggerFile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"trigger file found: %s"</literal></expr></argument>, <argument><expr><name>TriggerFile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>TriggerFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>triggered</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>fast_promote</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not stat trigger file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>TriggerFile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Remove the files signaling a standby promotion request.
 */</comment>
<function><type><name>void</name></type>
<name>RemovePromoteSignalFiles</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>PROMOTE_SIGNAL_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>FALLBACK_PROMOTE_SIGNAL_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check to see if a promote request has arrived. Should be
 * called by postmaster after receiving SIGUSR1.
 */</comment>
<function><type><name>bool</name></type>
<name>CheckPromoteSignal</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>PROMOTE_SIGNAL_FILE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>stat</name><argument_list>(<argument><expr><name>FALLBACK_PROMOTE_SIGNAL_FILE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Wake up startup process to replay newly arrived WAL, or to notice that
 * failover has been requested.
 */</comment>
<function><type><name>void</name></type>
<name>WakeupRecovery</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>recoveryWakeupLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Update the WalWriterSleeping flag.
 */</comment>
<function><type><name>void</name></type>
<name>SetWalWriterSleeping</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>sleeping</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>XLogCtl</name><operator>-&gt;</operator><name>WalWriterSleeping</name></name> <operator>=</operator> <name>sleeping</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>XLogCtl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Schedule a walreceiver wakeup in the main recovery loop.
 */</comment>
<function><type><name>void</name></type>
<name>XLogRequestWalReceiverReply</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>doRequestWalReceiverReply</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
