<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/access/transam/generic_xlog.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * generic_xlog.c
 *	 Implementation of generic xlog records.
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * src/backend/access/transam/generic_xlog.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/bufmask.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/generic_xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>

<comment type="block">/*-------------------------------------------------------------------------
 * Internally, a delta between pages consists of a set of fragments.  Each
 * fragment represents changes made in a given region of a page.  A fragment
 * is made up as follows:
 *
 * - offset of page region (OffsetNumber)
 * - length of page region (OffsetNumber)
 * - data - the data to place into the region ('length' number of bytes)
 *
 * Unchanged regions of a page are not represented in its delta.  As a result,
 * a delta can be more compact than the full page image.  But having an
 * unchanged region between two fragments that is smaller than the fragment
 * header (offset+length) does not pay off in terms of the overall size of
 * the delta.  For this reason, we merge adjacent fragments if the unchanged
 * region between them is &lt;= MATCH_THRESHOLD bytes.
 *
 * We do not bother to merge fragments across the "lower" and "upper" parts
 * of a page; it's very seldom the case that pd_lower and pd_upper are within
 * MATCH_THRESHOLD bytes of each other, and handling that infrequent case
 * would complicate and slow down the delta-computation code unduly.
 * Therefore, the worst-case delta size includes two fragment headers plus
 * a full page's worth of data.
 *-------------------------------------------------------------------------
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FRAGMENT_HEADER_SIZE</name></cpp:macro>	<cpp:value>(2 * sizeof(OffsetNumber))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MATCH_THRESHOLD</name></cpp:macro>			<cpp:value>FRAGMENT_HEADER_SIZE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_DELTA_SIZE</name></cpp:macro>			<cpp:value>(BLCKSZ + 2 * FRAGMENT_HEADER_SIZE)</cpp:value></cpp:define>

<comment type="block">/* Struct of generic xlog data for single page */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>			<comment type="block">/* registered buffer */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>flags</name></decl>;</decl_stmt>			<comment type="block">/* flags for this buffer */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>deltaLen</name></decl>;</decl_stmt>		<comment type="block">/* space consumed in delta field */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>image</name></decl>;</decl_stmt>			<comment type="block">/* copy of page image for modification, do not
								 * do it in-place to have aligned memory chunk */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>delta</name><index>[<expr><name>MAX_DELTA_SIZE</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* delta between page images */</comment>
}</block></struct></type> <name>PageData</name>;</typedef>

<comment type="block">/* State of generic xlog record construction */</comment>
<struct>struct <name>GenericXLogState</name>
<block>{
	<comment type="block">/* Info about each page, see above */</comment>
	<decl_stmt><decl><type><name>PageData</name></type>	<name><name>pages</name><index>[<expr><name>MAX_GENERIC_XLOG_PAGES</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isLogged</name></decl>;</decl_stmt>
	<comment type="block">/* Page images (properly aligned) */</comment>
	<decl_stmt><decl><type><name>PGAlignedBlock</name></type> <name><name>images</name><index>[<expr><name>MAX_GENERIC_XLOG_PAGES</name></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>writeFragment</name><parameter_list>(<parameter><decl><type><name>PageData</name> <modifier>*</modifier></type><name>pageData</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>offset</name></decl></parameter>,
			  <parameter><decl><type><name>OffsetNumber</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>computeRegionDelta</name><parameter_list>(<parameter><decl><type><name>PageData</name> <modifier>*</modifier></type><name>pageData</name></decl></parameter>,
				   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>curpage</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetpage</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>targetStart</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targetEnd</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>validStart</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>validEnd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>computeDelta</name><parameter_list>(<parameter><decl><type><name>PageData</name> <modifier>*</modifier></type><name>pageData</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>curpage</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>targetpage</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>applyPageRedo</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>delta</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>deltaSize</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Write next fragment into pageData's delta.
 *
 * The fragment has the given offset and length, and data points to the
 * actual data (of length length).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>writeFragment</name><parameter_list>(<parameter><decl><type><name>PageData</name> <modifier>*</modifier></type><name>pageData</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>length</name></decl></parameter>,
			  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name><name>pageData</name><operator>-&gt;</operator><name>delta</name></name> <operator>+</operator> <name><name>pageData</name><operator>-&gt;</operator><name>deltaLen</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Verify we have enough space */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pageData</name><operator>-&gt;</operator><name>deltaLen</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
		   <sizeof>sizeof<argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>length</name> <operator>&lt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>pageData</name><operator>-&gt;</operator><name>delta</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Write fragment data */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>length</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pageData</name><operator>-&gt;</operator><name>deltaLen</name></name> <operator>=</operator> <name>ptr</name> <operator>-</operator> <name><name>pageData</name><operator>-&gt;</operator><name>delta</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Compute the XLOG fragments needed to transform a region of curpage into the
 * corresponding region of targetpage, and append them to pageData's delta
 * field.  The region to transform runs from targetStart to targetEnd-1.
 * Bytes in curpage outside the range validStart to validEnd-1 should be
 * considered invalid, and always overwritten with target data.
 *
 * This function is a hot spot, so it's worth being as tense as possible
 * about the data-matching loops.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>computeRegionDelta</name><parameter_list>(<parameter><decl><type><name>PageData</name> <modifier>*</modifier></type><name>pageData</name></decl></parameter>,
				   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>curpage</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetpage</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>targetStart</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targetEnd</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>validStart</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>validEnd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>loopEnd</name></decl>,
				<decl><type ref="prev"/><name>fragmentBegin</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>fragmentEnd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Deal with any invalid start region by including it in first fragment */</comment>
	<if_stmt><if>if <condition>(<expr><name>validStart</name> <operator>&gt;</operator> <name>targetStart</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>fragmentBegin</name> <operator>=</operator> <name>targetStart</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>targetStart</name> <operator>=</operator> <name>validStart</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We'll deal with any invalid end region after the main loop */</comment>
	<expr_stmt><expr><name>loopEnd</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>targetEnd</name></expr></argument>, <argument><expr><name>validEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Examine all the potentially matchable bytes */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <name>targetStart</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>loopEnd</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>curpage</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>targetpage</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* On unmatched byte, start new fragment if not already in one */</comment>
			<if_stmt><if>if <condition>(<expr><name>fragmentBegin</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>fragmentBegin</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* Mark unmatched-data endpoint as uncertain */</comment>
			<expr_stmt><expr><name>fragmentEnd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<comment type="block">/* Extend the fragment as far as possible in a tight loop */</comment>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
			<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>loopEnd</name> <operator>&amp;&amp;</operator> <name><name>curpage</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>targetpage</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>loopEnd</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Found a matched byte, so remember end of unmatched fragment */</comment>
		<expr_stmt><expr><name>fragmentEnd</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Extend the match as far as possible in a tight loop.  (On typical
		 * workloads, this inner loop is the bulk of this function's runtime.)
		 */</comment>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>loopEnd</name> <operator>&amp;&amp;</operator> <name><name>curpage</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name><name>targetpage</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

		<comment type="block">/*
		 * There are several possible cases at this point:
		 *
		 * 1. We have no unwritten fragment (fragmentBegin &lt; 0).  There's
		 * nothing to write; and it doesn't matter what fragmentEnd is.
		 *
		 * 2. We found more than MATCH_THRESHOLD consecutive matching bytes.
		 * Dump out the unwritten fragment, stopping at fragmentEnd.
		 *
		 * 3. The match extends to loopEnd.  We'll do nothing here, exit the
		 * loop, and then dump the unwritten fragment, after merging it with
		 * the invalid end region if any.  If we don't so merge, fragmentEnd
		 * establishes how much the final writeFragment call needs to write.
		 *
		 * 4. We found an unmatched byte before loopEnd.  The loop will repeat
		 * and will enter the unmatched-byte stanza above.  So in this case
		 * also, it doesn't matter what fragmentEnd is.  The matched bytes
		 * will get merged into the continuing unmatched fragment.
		 *
		 * Only in case 3 do we reach the bottom of the loop with a meaningful
		 * fragmentEnd value, which is why it's OK that we unconditionally
		 * assign "fragmentEnd = i" above.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>fragmentBegin</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>-</operator> <name>fragmentEnd</name> <operator>&gt;</operator> <name>MATCH_THRESHOLD</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>writeFragment</name><argument_list>(<argument><expr><name>pageData</name></expr></argument>, <argument><expr><name>fragmentBegin</name></expr></argument>,
						  <argument><expr><name>fragmentEnd</name> <operator>-</operator> <name>fragmentBegin</name></expr></argument>,
						  <argument><expr><name>targetpage</name> <operator>+</operator> <name>fragmentBegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>fragmentBegin</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>fragmentEnd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* not really necessary */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Deal with any invalid end region by including it in final fragment */</comment>
	<if_stmt><if>if <condition>(<expr><name>loopEnd</name> <operator>&lt;</operator> <name>targetEnd</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>fragmentBegin</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>fragmentBegin</name> <operator>=</operator> <name>loopEnd</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>fragmentEnd</name> <operator>=</operator> <name>targetEnd</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Write final fragment if any */</comment>
	<if_stmt><if>if <condition>(<expr><name>fragmentBegin</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>fragmentEnd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>fragmentEnd</name> <operator>=</operator> <name>targetEnd</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>writeFragment</name><argument_list>(<argument><expr><name>pageData</name></expr></argument>, <argument><expr><name>fragmentBegin</name></expr></argument>,
					  <argument><expr><name>fragmentEnd</name> <operator>-</operator> <name>fragmentBegin</name></expr></argument>,
					  <argument><expr><name>targetpage</name> <operator>+</operator> <name>fragmentBegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Compute the XLOG delta record needed to transform curpage into targetpage,
 * and store it in pageData's delta field.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>computeDelta</name><parameter_list>(<parameter><decl><type><name>PageData</name> <modifier>*</modifier></type><name>pageData</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>curpage</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>targetpage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>targetLower</name> <init>= <expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>targetpage</name><operator>)</operator><operator>-&gt;</operator><name>pd_lower</name></expr></init></decl>,
				<decl><type ref="prev"/><name>targetUpper</name> <init>= <expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>targetpage</name><operator>)</operator><operator>-&gt;</operator><name>pd_upper</name></expr></init></decl>,
				<decl><type ref="prev"/><name>curLower</name> <init>= <expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>curpage</name><operator>)</operator><operator>-&gt;</operator><name>pd_lower</name></expr></init></decl>,
				<decl><type ref="prev"/><name>curUpper</name> <init>= <expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>curpage</name><operator>)</operator><operator>-&gt;</operator><name>pd_upper</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pageData</name><operator>-&gt;</operator><name>deltaLen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Compute delta records for lower part of page ... */</comment>
	<expr_stmt><expr><call><name>computeRegionDelta</name><argument_list>(<argument><expr><name>pageData</name></expr></argument>, <argument><expr><name>curpage</name></expr></argument>, <argument><expr><name>targetpage</name></expr></argument>,
					   <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>targetLower</name></expr></argument>,
					   <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>curLower</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* ... and for upper part, ignoring what's between */</comment>
	<expr_stmt><expr><call><name>computeRegionDelta</name><argument_list>(<argument><expr><name>pageData</name></expr></argument>, <argument><expr><name>curpage</name></expr></argument>, <argument><expr><name>targetpage</name></expr></argument>,
					   <argument><expr><name>targetUpper</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>,
					   <argument><expr><name>curUpper</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If xlog debug is enabled, then check produced delta.  Result of delta
	 * application to curpage should be equivalent to targetpage.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WAL_DEBUG</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>XLOG_DEBUG</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGAlignedBlock</name></type> <name>tmp</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>curpage</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>applyPageRedo</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>pageData</name><operator>-&gt;</operator><name>delta</name></name></expr></argument>, <argument><expr><name><name>pageData</name><operator>-&gt;</operator><name>deltaLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>targetpage</name></expr></argument>, <argument><expr><name>targetLower</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>memcmp</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>data</name></name> <operator>+</operator> <name>targetUpper</name></expr></argument>, <argument><expr><name>targetpage</name> <operator>+</operator> <name>targetUpper</name></expr></argument>,
				   <argument><expr><name>BLCKSZ</name> <operator>-</operator> <name>targetUpper</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"result of generic xlog apply does not match"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Start new generic xlog record for modifications to specified relation.
 */</comment>
<function><type><name>GenericXLogState</name> <modifier>*</modifier></type>
<name>GenericXLogStart</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GenericXLogState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>GenericXLogState</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GenericXLogState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>isLogged</name></name> <operator>=</operator> <call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_GENERIC_XLOG_PAGES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>pages</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>image</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>images</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>data</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>pages</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>buffer</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Register new buffer for generic xlog record.
 *
 * Returns pointer to the page's image in the GenericXLogState, which
 * is what the caller should modify.
 *
 * If the buffer is already registered, just return its existing entry.
 * (It's not very clear what to do with the flags in such a case, but
 * for now we stay with the original flags.)
 */</comment>
<function><type><name>Page</name></type>
<name>GenericXLogRegisterBuffer</name><parameter_list>(<parameter><decl><type><name>GenericXLogState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>block_id</name></decl>;</decl_stmt>

	<comment type="block">/* Search array for existing entry or first unused slot */</comment>
	<for>for <control>(<init><expr><name>block_id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>block_id</name> <operator>&lt;</operator> <name>MAX_GENERIC_XLOG_PAGES</name></expr>;</condition> <incr><expr><name>block_id</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PageData</name>   <modifier>*</modifier></type><name>page</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>pages</name><index>[<expr><name>block_id</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BufferIsInvalid</name><argument_list>(<argument><expr><name><name>page</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Empty slot, so use it (there cannot be a match later) */</comment>
			<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>page</name><operator>-&gt;</operator><name>image</name></name></expr></argument>, <argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Page</name><operator>)</operator> <name><name>page</name><operator>-&gt;</operator><name>image</name></name></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>page</name><operator>-&gt;</operator><name>buffer</name></name> <operator>==</operator> <name>buffer</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Buffer is already registered.  Just return the image, which is
			 * already prepared.
			 */</comment>
			<return>return <expr><operator>(</operator><name>Page</name><operator>)</operator> <name><name>page</name><operator>-&gt;</operator><name>image</name></name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"maximum number %d of generic xlog buffers is exceeded"</literal></expr></argument>,
		 <argument><expr><name>MAX_GENERIC_XLOG_PAGES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* keep compiler quiet */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Apply changes represented by GenericXLogState to the actual buffers,
 * and emit a generic xlog record.
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>GenericXLogFinish</name><parameter_list>(<parameter><decl><type><name>GenericXLogState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>isLogged</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Logged relation: make xlog record in critical section. */</comment>
		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_GENERIC_XLOG_PAGES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PageData</name>   <modifier>*</modifier></type><name>pageData</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>pages</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PageHeader</name></type>	<name>pageHeader</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>BufferIsInvalid</name><argument_list>(<argument><expr><name><name>pageData</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>pageData</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pageHeader</name> <operator>=</operator> <operator>(</operator><name>PageHeader</name><operator>)</operator> <name><name>pageData</name><operator>-&gt;</operator><name>image</name></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>pageData</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GENERIC_XLOG_FULL_IMAGE</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * A full-page image does not require us to supply any xlog
				 * data.  Just apply the image, being careful to zero the
				 * "hole" between pd_lower and pd_upper in order to avoid
				 * divergence between actual page state and what replay would
				 * produce.
				 */</comment>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>pageData</name><operator>-&gt;</operator><name>image</name></name></expr></argument>, <argument><expr><name><name>pageHeader</name><operator>-&gt;</operator><name>pd_lower</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>page</name> <operator>+</operator> <name><name>pageHeader</name><operator>-&gt;</operator><name>pd_lower</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					   <argument><expr><name><name>pageHeader</name><operator>-&gt;</operator><name>pd_upper</name></name> <operator>-</operator> <name><name>pageHeader</name><operator>-&gt;</operator><name>pd_lower</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>page</name> <operator>+</operator> <name><name>pageHeader</name><operator>-&gt;</operator><name>pd_upper</name></name></expr></argument>,
					   <argument><expr><name><name>pageData</name><operator>-&gt;</operator><name>image</name></name> <operator>+</operator> <name><name>pageHeader</name><operator>-&gt;</operator><name>pd_upper</name></name></expr></argument>,
					   <argument><expr><name>BLCKSZ</name> <operator>-</operator> <name><name>pageHeader</name><operator>-&gt;</operator><name>pd_upper</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>pageData</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>,
								   <argument><expr><name>REGBUF_FORCE_IMAGE</name> <operator>|</operator> <name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * In normal mode, calculate delta and write it as xlog data
				 * associated with this page.
				 */</comment>
				<expr_stmt><expr><call><name>computeDelta</name><argument_list>(<argument><expr><name>pageData</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Page</name><operator>)</operator> <name><name>pageData</name><operator>-&gt;</operator><name>image</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Apply the image, with zeroed "hole" as above */</comment>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>pageData</name><operator>-&gt;</operator><name>image</name></name></expr></argument>, <argument><expr><name><name>pageHeader</name><operator>-&gt;</operator><name>pd_lower</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>page</name> <operator>+</operator> <name><name>pageHeader</name><operator>-&gt;</operator><name>pd_lower</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					   <argument><expr><name><name>pageHeader</name><operator>-&gt;</operator><name>pd_upper</name></name> <operator>-</operator> <name><name>pageHeader</name><operator>-&gt;</operator><name>pd_lower</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>page</name> <operator>+</operator> <name><name>pageHeader</name><operator>-&gt;</operator><name>pd_upper</name></name></expr></argument>,
					   <argument><expr><name><name>pageData</name><operator>-&gt;</operator><name>image</name></name> <operator>+</operator> <name><name>pageHeader</name><operator>-&gt;</operator><name>pd_upper</name></name></expr></argument>,
					   <argument><expr><name>BLCKSZ</name> <operator>-</operator> <name><name>pageHeader</name><operator>-&gt;</operator><name>pd_upper</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>pageData</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>pageData</name><operator>-&gt;</operator><name>delta</name></name></expr></argument>, <argument><expr><name><name>pageData</name><operator>-&gt;</operator><name>deltaLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Insert xlog record */</comment>
		<expr_stmt><expr><name>lsn</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_GENERIC_ID</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Set LSN and mark buffers dirty */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_GENERIC_XLOG_PAGES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PageData</name>   <modifier>*</modifier></type><name>pageData</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>pages</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>BufferIsInvalid</name><argument_list>(<argument><expr><name><name>pageData</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>pageData</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name><name>pageData</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Unlogged relation: skip xlog-related stuff */</comment>
		<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_GENERIC_XLOG_PAGES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PageData</name>   <modifier>*</modifier></type><name>pageData</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>pages</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>BufferIsInvalid</name><argument_list>(<argument><expr><name><name>pageData</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>pageData</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><name><name>pageData</name><operator>-&gt;</operator><name>image</name></name></expr></argument>,
				   <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* We don't worry about zeroing the "hole" in this case */</comment>
			<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name><name>pageData</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* We don't have a LSN to return, in this case */</comment>
		<expr_stmt><expr><name>lsn</name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>lsn</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Abort generic xlog record construction.  No changes are applied to buffers.
 *
 * Note: caller is responsible for releasing locks/pins on buffers, if needed.
 */</comment>
<function><type><name>void</name></type>
<name>GenericXLogAbort</name><parameter_list>(<parameter><decl><type><name>GenericXLogState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Apply delta to given page image.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>applyPageRedo</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>delta</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>deltaSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>delta</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><name>delta</name> <operator>+</operator> <name>deltaSize</name></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>ptr</name> <operator>&lt;</operator> <name>end</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offset</name></decl>,
					<decl><type ref="prev"/><name>length</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>page</name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Redo function for generic xlog record.
 */</comment>
<function><type><name>void</name></type>
<name>generic_redo</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name><name>buffers</name><index>[<expr><name>MAX_GENERIC_XLOG_PAGES</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>block_id</name></decl>;</decl_stmt>

	<comment type="block">/* Protect limited size of buffers[] array */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>max_block_id</name></name> <operator>&lt;</operator> <name>MAX_GENERIC_XLOG_PAGES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Iterate over blocks */</comment>
	<for>for <control>(<init><expr><name>block_id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>block_id</name> <operator>&lt;=</operator> <name><name>record</name><operator>-&gt;</operator><name>max_block_id</name></name></expr>;</condition> <incr><expr><name>block_id</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>block_id</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>buffers</name><index>[<expr><name>block_id</name></expr>]</index></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>block_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>buffers</name><index>[<expr><name>block_id</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Apply redo to given block if needed */</comment>
		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PageHeader</name></type>	<name>pageHeader</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>blockDelta</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Size</name></type>		<name>blockDeltaSize</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>buffers</name><index>[<expr><name>block_id</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>blockDelta</name> <operator>=</operator> <call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>block_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blockDeltaSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>applyPageRedo</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>blockDelta</name></expr></argument>, <argument><expr><name>blockDeltaSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Since the delta contains no information about what's in the
			 * "hole" between pd_lower and pd_upper, set that to zero to
			 * ensure we produce the same page state that application of the
			 * logged action by GenericXLogFinish did.
			 */</comment>
			<expr_stmt><expr><name>pageHeader</name> <operator>=</operator> <operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>page</name> <operator>+</operator> <name><name>pageHeader</name><operator>-&gt;</operator><name>pd_lower</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
				   <argument><expr><name><name>pageHeader</name><operator>-&gt;</operator><name>pd_upper</name></name> <operator>-</operator> <name><name>pageHeader</name><operator>-&gt;</operator><name>pd_lower</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name><name>buffers</name><index>[<expr><name>block_id</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Changes are done: unlock and release all buffers */</comment>
	<for>for <control>(<init><expr><name>block_id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>block_id</name> <operator>&lt;=</operator> <name><name>record</name><operator>-&gt;</operator><name>max_block_id</name></name></expr>;</condition> <incr><expr><name>block_id</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>buffers</name><index>[<expr><name>block_id</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name><name>buffers</name><index>[<expr><name>block_id</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Mask a generic page before performing consistency checks on it.
 */</comment>
<function><type><name>void</name></type>
<name>generic_mask</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>page</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>mask_page_lsn_and_checksum</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>mask_unused_space</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
