<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/access/gist/gistbuildbuffers.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * gistbuildbuffers.c
 *	  node buffer management functions for GiST buffering build algorithm.
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/access/gist/gistbuildbuffers.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gist_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/buffile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>GISTNodeBufferPage</name> <modifier>*</modifier></type><name>gistAllocateNewPageBuffer</name><parameter_list>(<parameter><decl><type><name>GISTBuildBuffers</name> <modifier>*</modifier></type><name>gfbb</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gistAddLoadedBuffer</name><parameter_list>(<parameter><decl><type><name>GISTBuildBuffers</name> <modifier>*</modifier></type><name>gfbb</name></decl></parameter>,
					<parameter><decl><type><name>GISTNodeBuffer</name> <modifier>*</modifier></type><name>nodeBuffer</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gistLoadNodeBuffer</name><parameter_list>(<parameter><decl><type><name>GISTBuildBuffers</name> <modifier>*</modifier></type><name>gfbb</name></decl></parameter>,
				   <parameter><decl><type><name>GISTNodeBuffer</name> <modifier>*</modifier></type><name>nodeBuffer</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gistUnloadNodeBuffer</name><parameter_list>(<parameter><decl><type><name>GISTBuildBuffers</name> <modifier>*</modifier></type><name>gfbb</name></decl></parameter>,
					 <parameter><decl><type><name>GISTNodeBuffer</name> <modifier>*</modifier></type><name>nodeBuffer</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gistPlaceItupToPage</name><parameter_list>(<parameter><decl><type><name>GISTNodeBufferPage</name> <modifier>*</modifier></type><name>pageBuffer</name></decl></parameter>,
					<parameter><decl><type><name>IndexTuple</name></type> <name>item</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gistGetItupFromPage</name><parameter_list>(<parameter><decl><type><name>GISTNodeBufferPage</name> <modifier>*</modifier></type><name>pageBuffer</name></decl></parameter>,
					<parameter><decl><type><name>IndexTuple</name> <modifier>*</modifier></type><name>item</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>long</name></type> <name>gistBuffersGetFreeBlock</name><parameter_list>(<parameter><decl><type><name>GISTBuildBuffers</name> <modifier>*</modifier></type><name>gfbb</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gistBuffersReleaseBlock</name><parameter_list>(<parameter><decl><type><name>GISTBuildBuffers</name> <modifier>*</modifier></type><name>gfbb</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>blocknum</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReadTempFileBlock</name><parameter_list>(<parameter><decl><type><name>BufFile</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>blknum</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WriteTempFileBlock</name><parameter_list>(<parameter><decl><type><name>BufFile</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>blknum</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Initialize GiST build buffers.
 */</comment>
<function><type><name>GISTBuildBuffers</name> <modifier>*</modifier></type>
<name>gistInitBuildBuffers</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pagesPerBuffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>levelStep</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GISTBuildBuffers</name> <modifier>*</modifier></type><name>gfbb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>hashCtl</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>gfbb</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GISTBuildBuffers</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gfbb</name><operator>-&gt;</operator><name>pagesPerBuffer</name></name> <operator>=</operator> <name>pagesPerBuffer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gfbb</name><operator>-&gt;</operator><name>levelStep</name></name> <operator>=</operator> <name>levelStep</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create a temporary file to hold buffer pages that are swapped out of
	 * memory.
	 */</comment>
	<expr_stmt><expr><name><name>gfbb</name><operator>-&gt;</operator><name>pfile</name></name> <operator>=</operator> <call><name>BufFileCreateTemp</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gfbb</name><operator>-&gt;</operator><name>nFileBlocks</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Initialize free page management. */</comment>
	<expr_stmt><expr><name><name>gfbb</name><operator>-&gt;</operator><name>nFreeBlocks</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gfbb</name><operator>-&gt;</operator><name>freeBlocksLen</name></name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gfbb</name><operator>-&gt;</operator><name>freeBlocks</name></name> <operator>=</operator> <operator>(</operator><name>long</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>gfbb</name><operator>-&gt;</operator><name>freeBlocksLen</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Current memory context will be used for all in-memory data structures
	 * of buffers which are persistent during buffering build.
	 */</comment>
	<expr_stmt><expr><name><name>gfbb</name><operator>-&gt;</operator><name>context</name></name> <operator>=</operator> <call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * nodeBuffersTab hash is association between index blocks and it's
	 * buffers.
	 */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hashCtl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hashCtl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashCtl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BlockNumber</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashCtl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GISTNodeBuffer</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashCtl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gfbb</name><operator>-&gt;</operator><name>nodeBuffersTab</name></name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"gistbuildbuffers"</literal></expr></argument>,
									   <argument><expr><literal type="number">1024</literal></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>hashCtl</name></expr></argument>,
									   <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>gfbb</name><operator>-&gt;</operator><name>bufferEmptyingQueue</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Per-level node buffers lists for final buffers emptying process. Node
	 * buffers are inserted here when they are created.
	 */</comment>
	<expr_stmt><expr><name><name>gfbb</name><operator>-&gt;</operator><name>buffersOnLevelsLen</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gfbb</name><operator>-&gt;</operator><name>buffersOnLevels</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator>
											 <name><name>gfbb</name><operator>-&gt;</operator><name>buffersOnLevelsLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gfbb</name><operator>-&gt;</operator><name>buffersOnLevels</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Block numbers of node buffers which last pages are currently loaded
	 * into main memory.
	 */</comment>
	<expr_stmt><expr><name><name>gfbb</name><operator>-&gt;</operator><name>loadedBuffersLen</name></name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gfbb</name><operator>-&gt;</operator><name>loadedBuffers</name></name> <operator>=</operator> <operator>(</operator><name>GISTNodeBuffer</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>gfbb</name><operator>-&gt;</operator><name>loadedBuffersLen</name></name> <operator>*</operator>
													 <sizeof>sizeof<argument_list>(<argument><expr><name>GISTNodeBuffer</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gfbb</name><operator>-&gt;</operator><name>loadedBuffersCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>gfbb</name><operator>-&gt;</operator><name>rootlevel</name></name> <operator>=</operator> <name>maxLevel</name></expr>;</expr_stmt>

	<return>return <expr><name>gfbb</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns a node buffer for given block. The buffer is created if it
 * doesn't exist yet.
 */</comment>
<function><type><name>GISTNodeBuffer</name> <modifier>*</modifier></type>
<name>gistGetNodeBuffer</name><parameter_list>(<parameter><decl><type><name>GISTBuildBuffers</name> <modifier>*</modifier></type><name>gfbb</name></decl></parameter>, <parameter><decl><type><name>GISTSTATE</name> <modifier>*</modifier></type><name>giststate</name></decl></parameter>,
				  <parameter><decl><type><name>BlockNumber</name></type> <name>nodeBlocknum</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GISTNodeBuffer</name> <modifier>*</modifier></type><name>nodeBuffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<comment type="block">/* Find node buffer in hash table */</comment>
	<expr_stmt><expr><name>nodeBuffer</name> <operator>=</operator> <operator>(</operator><name>GISTNodeBuffer</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>gfbb</name><operator>-&gt;</operator><name>nodeBuffersTab</name></name></expr></argument>,
												<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>nodeBlocknum</name></expr></argument>,
												<argument><expr><name>HASH_ENTER</name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Node buffer wasn't found. Initialize the new buffer as empty.
		 */</comment>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>gfbb</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* nodeBuffer-&gt;nodeBlocknum is the hash key and was filled in already */</comment>
		<expr_stmt><expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>blocksCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>pageBlocknum</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>pageBuffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>queuedForEmptying</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>level</name></name> <operator>=</operator> <name>level</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Add this buffer to the list of buffers on this level. Enlarge
		 * buffersOnLevels array if needed.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>level</name> <operator>&gt;=</operator> <name><name>gfbb</name><operator>-&gt;</operator><name>buffersOnLevelsLen</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>gfbb</name><operator>-&gt;</operator><name>buffersOnLevels</name></name> <operator>=</operator>
				<operator>(</operator><name>List</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>gfbb</name><operator>-&gt;</operator><name>buffersOnLevels</name></name></expr></argument>,
								   <argument><expr><operator>(</operator><name>level</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* initialize the enlarged portion */</comment>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>gfbb</name><operator>-&gt;</operator><name>buffersOnLevelsLen</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>level</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>gfbb</name><operator>-&gt;</operator><name>buffersOnLevels</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></for>
			<expr_stmt><expr><name><name>gfbb</name><operator>-&gt;</operator><name>buffersOnLevelsLen</name></name> <operator>=</operator> <name>level</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Prepend the new buffer to the list of buffers on this level. It's
		 * not arbitrary that the new buffer is put to the beginning of the
		 * list: in the final emptying phase we loop through all buffers at
		 * each level, and flush them. If a page is split during the emptying,
		 * it's more efficient to flush the new splitted pages first, before
		 * moving on to pre-existing pages on the level. The buffers just
		 * created during the page split are likely still in cache, so
		 * flushing them immediately is more efficient than putting them to
		 * the end of the queue.
		 */</comment>
		<expr_stmt><expr><name><name>gfbb</name><operator>-&gt;</operator><name>buffersOnLevels</name><index>[<expr><name>level</name></expr>]</index></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>nodeBuffer</name></expr></argument>,
											 <argument><expr><name><name>gfbb</name><operator>-&gt;</operator><name>buffersOnLevels</name><index>[<expr><name>level</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>nodeBuffer</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Allocate memory for a buffer page.
 */</comment>
<function><type><specifier>static</specifier> <name>GISTNodeBufferPage</name> <modifier>*</modifier></type>
<name>gistAllocateNewPageBuffer</name><parameter_list>(<parameter><decl><type><name>GISTBuildBuffers</name> <modifier>*</modifier></type><name>gfbb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GISTNodeBufferPage</name> <modifier>*</modifier></type><name>pageBuffer</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pageBuffer</name> <operator>=</operator> <operator>(</operator><name>GISTNodeBufferPage</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>gfbb</name><operator>-&gt;</operator><name>context</name></name></expr></argument>,
														   <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pageBuffer</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>

	<comment type="block">/* Set page free space */</comment>
	<expr_stmt><expr><call><name>PAGE_FREE_SPACE</name><argument_list>(<argument><expr><name>pageBuffer</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>BLCKSZ</name> <operator>-</operator> <name>BUFFER_PAGE_DATA_OFFSET</name></expr>;</expr_stmt>
	<return>return <expr><name>pageBuffer</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add specified buffer into loadedBuffers array.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gistAddLoadedBuffer</name><parameter_list>(<parameter><decl><type><name>GISTBuildBuffers</name> <modifier>*</modifier></type><name>gfbb</name></decl></parameter>, <parameter><decl><type><name>GISTNodeBuffer</name> <modifier>*</modifier></type><name>nodeBuffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Never add a temporary buffer to the array */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>isTemp</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Enlarge the array if needed */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>gfbb</name><operator>-&gt;</operator><name>loadedBuffersCount</name></name> <operator>&gt;=</operator> <name><name>gfbb</name><operator>-&gt;</operator><name>loadedBuffersLen</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>gfbb</name><operator>-&gt;</operator><name>loadedBuffersLen</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>gfbb</name><operator>-&gt;</operator><name>loadedBuffers</name></name> <operator>=</operator> <operator>(</operator><name>GISTNodeBuffer</name> <operator>*</operator><operator>*</operator><operator>)</operator>
			<call><name>repalloc</name><argument_list>(<argument><expr><name><name>gfbb</name><operator>-&gt;</operator><name>loadedBuffers</name></name></expr></argument>,
					 <argument><expr><name><name>gfbb</name><operator>-&gt;</operator><name>loadedBuffersLen</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GISTNodeBuffer</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>gfbb</name><operator>-&gt;</operator><name>loadedBuffers</name><index>[<expr><name><name>gfbb</name><operator>-&gt;</operator><name>loadedBuffersCount</name></name></expr>]</index></name> <operator>=</operator> <name>nodeBuffer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gfbb</name><operator>-&gt;</operator><name>loadedBuffersCount</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Load last page of node buffer into main memory.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gistLoadNodeBuffer</name><parameter_list>(<parameter><decl><type><name>GISTBuildBuffers</name> <modifier>*</modifier></type><name>gfbb</name></decl></parameter>, <parameter><decl><type><name>GISTNodeBuffer</name> <modifier>*</modifier></type><name>nodeBuffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Check if we really should load something */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nodeBuffer</name><operator>-&gt;</operator><name>pageBuffer</name></name> <operator>&amp;&amp;</operator> <name><name>nodeBuffer</name><operator>-&gt;</operator><name>blocksCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Allocate memory for page */</comment>
		<expr_stmt><expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>pageBuffer</name></name> <operator>=</operator> <call><name>gistAllocateNewPageBuffer</name><argument_list>(<argument><expr><name>gfbb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Read block from temporary file */</comment>
		<expr_stmt><expr><call><name>ReadTempFileBlock</name><argument_list>(<argument><expr><name><name>gfbb</name><operator>-&gt;</operator><name>pfile</name></name></expr></argument>, <argument><expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>pageBlocknum</name></name></expr></argument>,
						  <argument><expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>pageBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Mark file block as free */</comment>
		<expr_stmt><expr><call><name>gistBuffersReleaseBlock</name><argument_list>(<argument><expr><name>gfbb</name></expr></argument>, <argument><expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>pageBlocknum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Mark node buffer as loaded */</comment>
		<expr_stmt><expr><call><name>gistAddLoadedBuffer</name><argument_list>(<argument><expr><name>gfbb</name></expr></argument>, <argument><expr><name>nodeBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>pageBlocknum</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Write last page of node buffer to the disk.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gistUnloadNodeBuffer</name><parameter_list>(<parameter><decl><type><name>GISTBuildBuffers</name> <modifier>*</modifier></type><name>gfbb</name></decl></parameter>, <parameter><decl><type><name>GISTNodeBuffer</name> <modifier>*</modifier></type><name>nodeBuffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Check if we have something to write */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>pageBuffer</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>

		<comment type="block">/* Get free file block */</comment>
		<expr_stmt><expr><name>blkno</name> <operator>=</operator> <call><name>gistBuffersGetFreeBlock</name><argument_list>(<argument><expr><name>gfbb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Write block to the temporary file */</comment>
		<expr_stmt><expr><call><name>WriteTempFileBlock</name><argument_list>(<argument><expr><name><name>gfbb</name><operator>-&gt;</operator><name>pfile</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>pageBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Free memory of that page */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>pageBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>pageBuffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/* Save block number */</comment>
		<expr_stmt><expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>pageBlocknum</name></name> <operator>=</operator> <name>blkno</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Write last pages of all node buffers to the disk.
 */</comment>
<function><type><name>void</name></type>
<name>gistUnloadNodeBuffers</name><parameter_list>(<parameter><decl><type><name>GISTBuildBuffers</name> <modifier>*</modifier></type><name>gfbb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Unload all the buffers that have a page loaded in memory. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>gfbb</name><operator>-&gt;</operator><name>loadedBuffersCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>gistUnloadNodeBuffer</name><argument_list>(<argument><expr><name>gfbb</name></expr></argument>, <argument><expr><name><name>gfbb</name><operator>-&gt;</operator><name>loadedBuffers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* Now there are no node buffers with loaded last page */</comment>
	<expr_stmt><expr><name><name>gfbb</name><operator>-&gt;</operator><name>loadedBuffersCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add index tuple to buffer page.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gistPlaceItupToPage</name><parameter_list>(<parameter><decl><type><name>GISTNodeBufferPage</name> <modifier>*</modifier></type><name>pageBuffer</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>itupsz</name> <init>= <expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

	<comment type="block">/* There should be enough of space. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PAGE_FREE_SPACE</name><argument_list>(<argument><expr><name>pageBuffer</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>itupsz</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reduce free space value of page to reserve a spot for the tuple. */</comment>
	<expr_stmt><expr><call><name>PAGE_FREE_SPACE</name><argument_list>(<argument><expr><name>pageBuffer</name></expr></argument>)</argument_list></call> <operator>-=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>itupsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get pointer to the spot we reserved (ie. end of free space). */</comment>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>pageBuffer</name> <operator>+</operator> <name>BUFFER_PAGE_DATA_OFFSET</name>
		<operator>+</operator> <call><name>PAGE_FREE_SPACE</name><argument_list>(<argument><expr><name>pageBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy the index tuple there. */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><name>itupsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get last item from buffer page and remove it from page.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gistGetItupFromPage</name><parameter_list>(<parameter><decl><type><name>GISTNodeBufferPage</name> <modifier>*</modifier></type><name>pageBuffer</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name> <modifier>*</modifier></type><name>itup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>itupsz</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>PAGE_IS_EMPTY</name><argument_list>(<argument><expr><name>pageBuffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Page shouldn't be empty */</comment>

	<comment type="block">/* Get pointer to last index tuple */</comment>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>pageBuffer</name>
						<operator>+</operator> <name>BUFFER_PAGE_DATA_OFFSET</name>
						<operator>+</operator> <call><name>PAGE_FREE_SPACE</name><argument_list>(<argument><expr><name>pageBuffer</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>itupsz</name> <operator>=</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make a copy of the tuple */</comment>
	<expr_stmt><expr><operator>*</operator><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>itupsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>itup</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>itupsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark the space used by the tuple as free */</comment>
	<expr_stmt><expr><call><name>PAGE_FREE_SPACE</name><argument_list>(<argument><expr><name>pageBuffer</name></expr></argument>)</argument_list></call> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>itupsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Push an index tuple to node buffer.
 */</comment>
<function><type><name>void</name></type>
<name>gistPushItupToNodeBuffer</name><parameter_list>(<parameter><decl><type><name>GISTBuildBuffers</name> <modifier>*</modifier></type><name>gfbb</name></decl></parameter>, <parameter><decl><type><name>GISTNodeBuffer</name> <modifier>*</modifier></type><name>nodeBuffer</name></decl></parameter>,
						 <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Most part of memory operations will be in buffering build persistent
	 * context. So, let's switch to it.
	 */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>gfbb</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the buffer is currently empty, create the first page.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>blocksCount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>pageBuffer</name></name> <operator>=</operator> <call><name>gistAllocateNewPageBuffer</name><argument_list>(<argument><expr><name>gfbb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>blocksCount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>gistAddLoadedBuffer</name><argument_list>(<argument><expr><name>gfbb</name></expr></argument>, <argument><expr><name>nodeBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Load last page of node buffer if it wasn't in memory already */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nodeBuffer</name><operator>-&gt;</operator><name>pageBuffer</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>gistLoadNodeBuffer</name><argument_list>(<argument><expr><name>gfbb</name></expr></argument>, <argument><expr><name>nodeBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check if there is enough space on the last page for the tuple.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PAGE_NO_SPACE</name><argument_list>(<argument><expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>pageBuffer</name></name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Nope. Swap previous block to disk and allocate a new one.
		 */</comment>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>

		<comment type="block">/* Write filled page to the disk */</comment>
		<expr_stmt><expr><name>blkno</name> <operator>=</operator> <call><name>gistBuffersGetFreeBlock</name><argument_list>(<argument><expr><name>gfbb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WriteTempFileBlock</name><argument_list>(<argument><expr><name><name>gfbb</name><operator>-&gt;</operator><name>pfile</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>pageBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Reset the in-memory page as empty, and link the previous block to
		 * the new page by storing its block number in the prev-link.
		 */</comment>
		<expr_stmt><expr><call><name>PAGE_FREE_SPACE</name><argument_list>(<argument><expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>pageBuffer</name></name></expr></argument>)</argument_list></call> <operator>=</operator>
			<name>BLCKSZ</name> <operator>-</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>GISTNodeBufferPage</name></expr></argument>, <argument><expr><name>tupledata</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>pageBuffer</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>blkno</name></expr>;</expr_stmt>

		<comment type="block">/* We've just added one more page */</comment>
		<expr_stmt><expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>blocksCount</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>gistPlaceItupToPage</name><argument_list>(<argument><expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>pageBuffer</name></name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the buffer just overflowed, add it to the emptying queue.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>BUFFER_HALF_FILLED</name><argument_list>(<argument><expr><name>nodeBuffer</name></expr></argument>, <argument><expr><name>gfbb</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>nodeBuffer</name><operator>-&gt;</operator><name>queuedForEmptying</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>gfbb</name><operator>-&gt;</operator><name>bufferEmptyingQueue</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>nodeBuffer</name></expr></argument>,
										  <argument><expr><name><name>gfbb</name><operator>-&gt;</operator><name>bufferEmptyingQueue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>queuedForEmptying</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Restore memory context */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Removes one index tuple from node buffer. Returns true if success and false
 * if node buffer is empty.
 */</comment>
<function><type><name>bool</name></type>
<name>gistPopItupFromNodeBuffer</name><parameter_list>(<parameter><decl><type><name>GISTBuildBuffers</name> <modifier>*</modifier></type><name>gfbb</name></decl></parameter>, <parameter><decl><type><name>GISTNodeBuffer</name> <modifier>*</modifier></type><name>nodeBuffer</name></decl></parameter>,
						  <parameter><decl><type><name>IndexTuple</name> <modifier>*</modifier></type><name>itup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If node buffer is empty then return false.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>blocksCount</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Load last page of node buffer if needed */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nodeBuffer</name><operator>-&gt;</operator><name>pageBuffer</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>gistLoadNodeBuffer</name><argument_list>(<argument><expr><name>gfbb</name></expr></argument>, <argument><expr><name>nodeBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Get index tuple from last non-empty page.
	 */</comment>
	<expr_stmt><expr><call><name>gistGetItupFromPage</name><argument_list>(<argument><expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>pageBuffer</name></name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we just removed the last tuple from the page, fetch previous page on
	 * this node buffer (if any).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PAGE_IS_EMPTY</name><argument_list>(<argument><expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>pageBuffer</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>prevblkno</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * blocksCount includes the page in pageBuffer, so decrease it now.
		 */</comment>
		<expr_stmt><expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>blocksCount</name></name><operator>--</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * If there's more pages, fetch previous one.
		 */</comment>
		<expr_stmt><expr><name>prevblkno</name> <operator>=</operator> <name><name>nodeBuffer</name><operator>-&gt;</operator><name>pageBuffer</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>prevblkno</name> <operator>!=</operator> <name>InvalidBlockNumber</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* There is a previous page. Fetch it. */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>blocksCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReadTempFileBlock</name><argument_list>(<argument><expr><name><name>gfbb</name><operator>-&gt;</operator><name>pfile</name></name></expr></argument>, <argument><expr><name>prevblkno</name></expr></argument>, <argument><expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>pageBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Now that we've read the block in memory, we can release its
			 * on-disk block for reuse.
			 */</comment>
			<expr_stmt><expr><call><name>gistBuffersReleaseBlock</name><argument_list>(<argument><expr><name>gfbb</name></expr></argument>, <argument><expr><name>prevblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* No more pages. Free memory. */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>blocksCount</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>pageBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>pageBuffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Select a currently unused block for writing to.
 */</comment>
<function><type><specifier>static</specifier> <name>long</name></type>
<name>gistBuffersGetFreeBlock</name><parameter_list>(<parameter><decl><type><name>GISTBuildBuffers</name> <modifier>*</modifier></type><name>gfbb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If there are multiple free blocks, we select the one appearing last in
	 * freeBlocks[].  If there are none, assign the next block at the end of
	 * the file (causing the file to be extended).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>gfbb</name><operator>-&gt;</operator><name>nFreeBlocks</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>gfbb</name><operator>-&gt;</operator><name>freeBlocks</name><index>[<expr><operator>--</operator><name><name>gfbb</name><operator>-&gt;</operator><name>nFreeBlocks</name></name></expr>]</index></name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name><name>gfbb</name><operator>-&gt;</operator><name>nFileBlocks</name></name><operator>++</operator></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return a block# to the freelist.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gistBuffersReleaseBlock</name><parameter_list>(<parameter><decl><type><name>GISTBuildBuffers</name> <modifier>*</modifier></type><name>gfbb</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>blocknum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndx</name></decl>;</decl_stmt>

	<comment type="block">/* Enlarge freeBlocks array if full. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>gfbb</name><operator>-&gt;</operator><name>nFreeBlocks</name></name> <operator>&gt;=</operator> <name><name>gfbb</name><operator>-&gt;</operator><name>freeBlocksLen</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>gfbb</name><operator>-&gt;</operator><name>freeBlocksLen</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>gfbb</name><operator>-&gt;</operator><name>freeBlocks</name></name> <operator>=</operator> <operator>(</operator><name>long</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>gfbb</name><operator>-&gt;</operator><name>freeBlocks</name></name></expr></argument>,
											 <argument><expr><name><name>gfbb</name><operator>-&gt;</operator><name>freeBlocksLen</name></name> <operator>*</operator>
											 <sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Add blocknum to array */</comment>
	<expr_stmt><expr><name>ndx</name> <operator>=</operator> <name><name>gfbb</name><operator>-&gt;</operator><name>nFreeBlocks</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gfbb</name><operator>-&gt;</operator><name>freeBlocks</name><index>[<expr><name>ndx</name></expr>]</index></name> <operator>=</operator> <name>blocknum</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Free buffering build data structure.
 */</comment>
<function><type><name>void</name></type>
<name>gistFreeBuildBuffers</name><parameter_list>(<parameter><decl><type><name>GISTBuildBuffers</name> <modifier>*</modifier></type><name>gfbb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Close buffers file. */</comment>
	<expr_stmt><expr><call><name>BufFileClose</name><argument_list>(<argument><expr><name><name>gfbb</name><operator>-&gt;</operator><name>pfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* All other things will be freed on memory context release */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Data structure representing information about node buffer for index tuples
 * relocation from splitted node buffer.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>GISTENTRY</name></type>	<name><name>entry</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>isnull</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GISTPageSplitInfo</name> <modifier>*</modifier></type><name>splitinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GISTNodeBuffer</name> <modifier>*</modifier></type><name>nodeBuffer</name></decl>;</decl_stmt>
}</block></struct></type> <name>RelocationBufferInfo</name>;</typedef>

<comment type="block">/*
 * At page split, distribute tuples from the buffer of the split page to
 * new buffers for the created page halves. This also adjusts the downlinks
 * in 'splitinfo' to include the tuples in the buffers.
 */</comment>
<function><type><name>void</name></type>
<name>gistRelocateBuildBuffersOnSplit</name><parameter_list>(<parameter><decl><type><name>GISTBuildBuffers</name> <modifier>*</modifier></type><name>gfbb</name></decl></parameter>, <parameter><decl><type><name>GISTSTATE</name> <modifier>*</modifier></type><name>giststate</name></decl></parameter>,
								<parameter><decl><type><name>Relation</name></type> <name>r</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>,
								<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>splitinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelocationBufferInfo</name> <modifier>*</modifier></type><name>relocationBuffersInfos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GISTNodeBuffer</name> <modifier>*</modifier></type><name>nodeBuffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>splitPagesCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GISTENTRY</name></type>	<name><name>entry</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>isnull</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GISTNodeBuffer</name></type> <name>oldBuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* If the splitted page doesn't have buffers, we have nothing to do. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>LEVEL_HAS_BUFFERS</name><argument_list>(<argument><expr><name>level</name></expr></argument>, <argument><expr><name>gfbb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Get the node buffer of the splitted page.
	 */</comment>
	<expr_stmt><expr><name>blocknum</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nodeBuffer</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>gfbb</name><operator>-&gt;</operator><name>nodeBuffersTab</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blocknum</name></expr></argument>,
							 <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* The page has no buffer, so we have nothing to do. */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Make a copy of the old buffer, as we're going reuse it as the buffer
	 * for the new left page, which is on the same block as the old page.
	 * That's not true for the root page, but that's fine because we never
	 * have a buffer on the root page anyway. The original algorithm as
	 * described by Arge et al did, but it's of no use, as you might as well
	 * read the tuples straight from the heap instead of the root buffer.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>blocknum</name> <operator>!=</operator> <name>GIST_ROOT_BLKNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oldBuf</name></expr></argument>, <argument><expr><name>nodeBuffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GISTNodeBuffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>oldBuf</name><operator>.</operator><name>isTemp</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Reset the old buffer, used for the new left page from now on */</comment>
	<expr_stmt><expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>blocksCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>pageBuffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>pageBlocknum</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate memory for information about relocation buffers.
	 */</comment>
	<expr_stmt><expr><name>splitPagesCount</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>splitinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>relocationBuffersInfos</name> <operator>=</operator>
		<operator>(</operator><name>RelocationBufferInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelocationBufferInfo</name></expr></argument>)</argument_list></sizeof> <operator>*</operator>
										<name>splitPagesCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fill relocation buffers information for node buffers of pages produced
	 * by split.
	 */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>splitinfo</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GISTPageSplitInfo</name> <modifier>*</modifier></type><name>si</name> <init>= <expr><operator>(</operator><name>GISTPageSplitInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GISTNodeBuffer</name> <modifier>*</modifier></type><name>newNodeBuffer</name></decl>;</decl_stmt>

		<comment type="block">/* Decompress parent index tuple of node buffer page. */</comment>
		<expr_stmt><expr><call><name>gistDeCompressAtt</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>r</name></expr></argument>,
						  <argument><expr><name><name>si</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>OffsetNumber</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
						  <argument><expr><name><name>relocationBuffersInfos</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>entry</name></expr></argument>,
						  <argument><expr><name><name>relocationBuffersInfos</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Create a node buffer for the page. The leftmost half is on the same
		 * block as the old page before split, so for the leftmost half this
		 * will return the original buffer. The tuples on the original buffer
		 * were relinked to the temporary buffer, so the original one is now
		 * empty.
		 */</comment>
		<expr_stmt><expr><name>newNodeBuffer</name> <operator>=</operator> <call><name>gistGetNodeBuffer</name><argument_list>(<argument><expr><name>gfbb</name></expr></argument>, <argument><expr><name>giststate</name></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>relocationBuffersInfos</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nodeBuffer</name> <operator>=</operator> <name>newNodeBuffer</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relocationBuffersInfos</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>splitinfo</name> <operator>=</operator> <name>si</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Loop through all index tuples in the buffer of the page being split,
	 * moving them to buffers for the new pages.  We try to move each tuple to
	 * the page that will result in the lowest penalty for the leading column
	 * or, in the case of a tie, the lowest penalty for the earliest column
	 * that is not tied.
	 *
	 * The page searching logic is very similar to gistchoose().
	 */</comment>
	<while>while <condition>(<expr><call><name>gistPopItupFromNodeBuffer</name><argument_list>(<argument><expr><name>gfbb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldBuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>itup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>float</name></type>		<name><name>best_penalty</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
					<decl><type ref="prev"/><name>which</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>newtup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelocationBufferInfo</name> <modifier>*</modifier></type><name>targetBufferInfo</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>gistDeCompressAtt</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>r</name></expr></argument>,
						  <argument><expr><name>itup</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>OffsetNumber</name><operator>)</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* default to using first page (shouldn't matter) */</comment>
		<expr_stmt><expr><name>which</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * best_penalty[j] is the best penalty we have seen so far for column
		 * j, or -1 when we haven't yet examined column j.  Array entries to
		 * the right of the first -1 are undefined.
		 */</comment>
		<expr_stmt><expr><name><name>best_penalty</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Loop over possible target pages, looking for one to move this tuple
		 * to.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>splitPagesCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RelocationBufferInfo</name> <modifier>*</modifier></type><name>splitPageInfo</name> <init>= <expr><operator>&amp;</operator><name><name>relocationBuffersInfos</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>zero_penalty</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>zero_penalty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<comment type="block">/* Loop over index attributes. */</comment>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>r</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>float</name></type>		<name>usize</name></decl>;</decl_stmt>

				<comment type="block">/* Compute penalty for this column. */</comment>
				<expr_stmt><expr><name>usize</name> <operator>=</operator> <call><name>gistpenalty</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>j</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>splitPageInfo</name><operator>-&gt;</operator><name>entry</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
									<argument><expr><name><name>splitPageInfo</name><operator>-&gt;</operator><name>isnull</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>entry</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>isnull</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>usize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>zero_penalty</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>best_penalty</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>usize</name> <operator>&lt;</operator> <name><name>best_penalty</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * New best penalty for column.  Tentatively select this
					 * page as the target, and record the best penalty.  Then
					 * reset the next column's penalty to "unknown" (and
					 * indirectly, the same for all the ones to its right).
					 * This will force us to adopt this page's penalty values
					 * as the best for all the remaining columns during
					 * subsequent loop iterations.
					 */</comment>
					<expr_stmt><expr><name>which</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>best_penalty</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>usize</name></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <name><name>r</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>best_penalty</name><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>best_penalty</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>usize</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * The current page is exactly as good for this column as
					 * the best page seen so far.  The next iteration of this
					 * loop will compare the next column.
					 */</comment>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * The current page is worse for this column than the best
					 * page seen so far.  Skip the remaining columns and move
					 * on to the next page, if any.
					 */</comment>
					<expr_stmt><expr><name>zero_penalty</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* so outer loop won't exit */</comment>
					<break>break;</break>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></for>

			<comment type="block">/*
			 * If we find a page with zero penalty for all columns, there's no
			 * need to examine remaining pages; just break out of the loop and
			 * return it.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>zero_penalty</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* OK, "which" is the page index to push the tuple to */</comment>
		<expr_stmt><expr><name>targetBufferInfo</name> <operator>=</operator> <operator>&amp;</operator><name><name>relocationBuffersInfos</name><index>[<expr><name>which</name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/* Push item to selected node buffer */</comment>
		<expr_stmt><expr><call><name>gistPushItupToNodeBuffer</name><argument_list>(<argument><expr><name>gfbb</name></expr></argument>, <argument><expr><name><name>targetBufferInfo</name><operator>-&gt;</operator><name>nodeBuffer</name></name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Adjust the downlink for this page, if needed. */</comment>
		<expr_stmt><expr><name>newtup</name> <operator>=</operator> <call><name>gistgetadjusted</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>targetBufferInfo</name><operator>-&gt;</operator><name>splitinfo</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>,
								 <argument><expr><name>itup</name></expr></argument>, <argument><expr><name>giststate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newtup</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>gistDeCompressAtt</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>r</name></expr></argument>,
							  <argument><expr><name>newtup</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>OffsetNumber</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
							  <argument><expr><name><name>targetBufferInfo</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>,
							  <argument><expr><name><name>targetBufferInfo</name><operator>-&gt;</operator><name>isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>targetBufferInfo</name><operator>-&gt;</operator><name>splitinfo</name><operator>-&gt;</operator><name>downlink</name></name> <operator>=</operator> <name>newtup</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>relocationBuffersInfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Wrappers around BufFile operations. The main difference is that these
 * wrappers report errors with ereport(), so that the callers don't need
 * to check the return code.
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReadTempFileBlock</name><parameter_list>(<parameter><decl><type><name>BufFile</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>blknum</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>BufFileSeekBlock</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>blknum</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not seek temporary file: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufFileRead</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>BLCKSZ</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not read temporary file: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>WriteTempFileBlock</name><parameter_list>(<parameter><decl><type><name>BufFile</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>blknum</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>BufFileSeekBlock</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>blknum</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not seek temporary file: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufFileWrite</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>BLCKSZ</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * the other errors in Read/WriteTempFileBlock shouldn't happen, but
		 * an error at write can easily happen if you run out of disk space.
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write block %ld of temporary file: %m"</literal></expr></argument>,
						<argument><expr><name>blknum</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
</unit>
