<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/access/transam/xloginsert.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * xloginsert.c
 *		Functions for constructing WAL records
 *
 * Constructing a WAL record begins with a call to XLogBeginInsert,
 * followed by a number of XLogRegister* calls. The registered data is
 * collected in private working memory, and finally assembled into a chain
 * of XLogRecData structs by a call to XLogRecordAssemble(). See
 * access/transam/README for details.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * src/backend/access/transam/xloginsert.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xloginsert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_control.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/pg_lzcompress.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/origin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_trace.h"</cpp:file></cpp:include>

<comment type="block">/* Buffer size required to store a compressed version of backup block image */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PGLZ_MAX_BLCKSZ</name></cpp:macro> <cpp:value>PGLZ_MAX_OUTPUT(BLCKSZ)</cpp:value></cpp:define>

<comment type="block">/*
 * For each block reference registered with XLogRegisterBuffer, we fill in
 * a registered_buffer struct.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>bool</name></type>		<name>in_use</name></decl>;</decl_stmt>			<comment type="block">/* is this slot in use? */</comment>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>flags</name></decl>;</decl_stmt>			<comment type="block">/* REGBUF_* flags */</comment>
	<decl_stmt><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl>;</decl_stmt>			<comment type="block">/* identifies the relation and block */</comment>
	<decl_stmt><decl><type><name>ForkNumber</name></type>	<name>forkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>block</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>			<comment type="block">/* page content */</comment>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>rdata_len</name></decl>;</decl_stmt>		<comment type="block">/* total length of data in rdata chain */</comment>
	<decl_stmt><decl><type><name>XLogRecData</name> <modifier>*</modifier></type><name>rdata_head</name></decl>;</decl_stmt>	<comment type="block">/* head of the chain of data registered with
								 * this block */</comment>
	<decl_stmt><decl><type><name>XLogRecData</name> <modifier>*</modifier></type><name>rdata_tail</name></decl>;</decl_stmt>	<comment type="block">/* last entry in the chain, or &amp;rdata_head if
								 * empty */</comment>

	<decl_stmt><decl><type><name>XLogRecData</name></type> <name><name>bkp_rdatas</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* temporary rdatas used to hold references to
								 * backup block data in XLogRecordAssemble() */</comment>

	<comment type="block">/* buffer to store a compressed version of backup block image */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>compressed_page</name><index>[<expr><name>PGLZ_MAX_BLCKSZ</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>registered_buffer</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>registered_buffer</name> <modifier>*</modifier></type><name>registered_buffers</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>max_registered_buffers</name></decl>;</decl_stmt> <comment type="block">/* allocated size */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>max_registered_block_id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* highest block_id + 1 currently
											 * registered */</comment>

<comment type="block">/*
 * A chain of XLogRecDatas to hold the "main data" of a WAL record, registered
 * with XLogRegisterData(...).
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecData</name> <modifier>*</modifier></type><name>mainrdata_head</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecData</name> <modifier>*</modifier></type><name>mainrdata_last</name> <init>= <expr><operator>(</operator><name>XLogRecData</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>mainrdata_head</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32</name></type> <name>mainrdata_len</name></decl>;</decl_stmt>	<comment type="block">/* total # of bytes in chain */</comment>

<comment type="block">/* flags for the in-progress insertion */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint8</name></type> <name>curinsert_flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * These are used to hold the record header while constructing a record.
 * 'hdr_scratch' is not a plain variable, but is palloc'd at initialization,
 * because we want it to be MAXALIGNed and padding bytes zeroed.
 *
 * For simplicity, it's allocated large enough to hold the headers for any
 * WAL record.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecData</name></type> <name>hdr_rdt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>hdr_scratch</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SizeOfXlogOrigin</name></cpp:macro>	<cpp:value>(sizeof(RepOriginId) + sizeof(char))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEADER_SCRATCH_SIZE</name></cpp:macro> \
	<cpp:value>(SizeOfXLogRecord + \
	 MaxSizeOfXLogRecordBlockHeader * (XLR_MAX_BLOCK_ID + 1) + \
	 SizeOfXLogRecordDataHeaderLong + SizeOfXlogOrigin)</cpp:value></cpp:define>

<comment type="block">/*
 * An array of XLogRecData structs, to hold registered data.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecData</name> <modifier>*</modifier></type><name>rdatas</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>num_rdatas</name></decl>;</decl_stmt>			<comment type="block">/* entries currently used */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>max_rdatas</name></decl>;</decl_stmt>			<comment type="block">/* allocated size */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>begininsert_called</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Memory context to hold the registered buffer and data references. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>xloginsert_cxt</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>XLogRecData</name> <modifier>*</modifier></type><name>XLogRecordAssemble</name><parameter_list>(<parameter><decl><type><name>RmgrId</name></type> <name>rmid</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>info</name></decl></parameter>,
				   <parameter><decl><type><name>XLogRecPtr</name></type> <name>RedoRecPtr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>doPageWrites</name></decl></parameter>,
				   <parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>fpw_lsn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>XLogCompressBackupBlock</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>page</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>hole_offset</name></decl></parameter>,
						<parameter><decl><type><name>uint16</name></type> <name>hole_length</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>uint16</name> <modifier>*</modifier></type><name>dlen</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Begin constructing a WAL record. This must be called before the
 * XLogRegister* functions and XLogInsert().
 */</comment>
<function><type><name>void</name></type>
<name>XLogBeginInsert</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>max_registered_block_id</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>mainrdata_last</name> <operator>==</operator> <operator>(</operator><name>XLogRecData</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>mainrdata_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>mainrdata_len</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* cross-check on whether we should be here or not */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogInsertAllowed</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot make new WAL entries during recovery"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>begininsert_called</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"XLogBeginInsert was already called"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>begininsert_called</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Ensure that there are enough buffer and data slots in the working area,
 * for subsequent XLogRegisterBuffer, XLogRegisterData and XLogRegisterBufData
 * calls.
 *
 * There is always space for a small number of buffers and data chunks, enough
 * for most record types. This function is for the exceptional cases that need
 * more.
 */</comment>
<function><type><name>void</name></type>
<name>XLogEnsureRecordSpace</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>max_block_id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ndatas</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbuffers</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * This must be called before entering a critical section, because
	 * allocating memory inside a critical section can fail. repalloc() will
	 * check the same, but better to check it here too so that we fail
	 * consistently even if the arrays happen to be large enough already.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CritSectionCount</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* the minimum values can't be decreased */</comment>
	<if_stmt><if>if <condition>(<expr><name>max_block_id</name> <operator>&lt;</operator> <name>XLR_NORMAL_MAX_BLOCK_ID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>max_block_id</name> <operator>=</operator> <name>XLR_NORMAL_MAX_BLOCK_ID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>ndatas</name> <operator>&lt;</operator> <name>XLR_NORMAL_RDATAS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ndatas</name> <operator>=</operator> <name>XLR_NORMAL_RDATAS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>max_block_id</name> <operator>&gt;</operator> <name>XLR_MAX_BLOCK_ID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"maximum number of WAL record block references exceeded"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>nbuffers</name> <operator>=</operator> <name>max_block_id</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nbuffers</name> <operator>&gt;</operator> <name>max_registered_buffers</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>registered_buffers</name> <operator>=</operator> <operator>(</operator><name>registered_buffer</name> <operator>*</operator><operator>)</operator>
			<call><name>repalloc</name><argument_list>(<argument><expr><name>registered_buffers</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>registered_buffer</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nbuffers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * At least the padding bytes in the structs must be zeroed, because
		 * they are included in WAL data, but initialize it all for tidiness.
		 */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>registered_buffers</name><index>[<expr><name>max_registered_buffers</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
			   <argument><expr><operator>(</operator><name>nbuffers</name> <operator>-</operator> <name>max_registered_buffers</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>registered_buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>max_registered_buffers</name> <operator>=</operator> <name>nbuffers</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ndatas</name> <operator>&gt;</operator> <name>max_rdatas</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>rdatas</name> <operator>=</operator> <operator>(</operator><name>XLogRecData</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>rdatas</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndatas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>max_rdatas</name> <operator>=</operator> <name>ndatas</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Reset WAL record construction buffers.
 */</comment>
<function><type><name>void</name></type>
<name>XLogResetInsertion</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_registered_block_id</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>registered_buffers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>in_use</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><name>num_rdatas</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>max_registered_block_id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>mainrdata_len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>mainrdata_last</name> <operator>=</operator> <operator>(</operator><name>XLogRecData</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>mainrdata_head</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>curinsert_flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>begininsert_called</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Register a reference to a buffer with the WAL record being constructed.
 * This must be called for every page that the WAL-logged operation modifies.
 */</comment>
<function><type><name>void</name></type>
<name>XLogRegisterBuffer</name><parameter_list>(<parameter><decl><type><name>uint8</name></type> <name>block_id</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>registered_buffer</name> <modifier>*</modifier></type><name>regbuf</name></decl>;</decl_stmt>

	<comment type="block">/* NO_IMAGE doesn't make sense with FORCE_IMAGE */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>REGBUF_FORCE_IMAGE</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>REGBUF_NO_IMAGE</name><operator>)</operator><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>begininsert_called</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>block_id</name> <operator>&gt;=</operator> <name>max_registered_block_id</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>block_id</name> <operator>&gt;=</operator> <name>max_registered_buffers</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too many registered buffers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>max_registered_block_id</name> <operator>=</operator> <name>block_id</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>regbuf</name> <operator>=</operator> <operator>&amp;</operator><name><name>registered_buffers</name><index>[<expr><name>block_id</name></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>BufferGetTag</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>regbuf</name><operator>-&gt;</operator><name>rnode</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>regbuf</name><operator>-&gt;</operator><name>forkno</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>regbuf</name><operator>-&gt;</operator><name>block</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>regbuf</name><operator>-&gt;</operator><name>page</name></name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>regbuf</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>regbuf</name><operator>-&gt;</operator><name>rdata_tail</name></name> <operator>=</operator> <operator>(</operator><name>XLogRecData</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>regbuf</name><operator>-&gt;</operator><name>rdata_head</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>regbuf</name><operator>-&gt;</operator><name>rdata_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check that this page hasn't already been registered with some other
	 * block_id.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_registered_block_id</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>registered_buffer</name> <modifier>*</modifier></type><name>regbuf_old</name> <init>= <expr><operator>&amp;</operator><name><name>registered_buffers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>block_id</name> <operator>||</operator> <operator>!</operator><name><name>regbuf_old</name><operator>-&gt;</operator><name>in_use</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>RelFileNodeEquals</name><argument_list>(<argument><expr><name><name>regbuf_old</name><operator>-&gt;</operator><name>rnode</name></name></expr></argument>, <argument><expr><name><name>regbuf</name><operator>-&gt;</operator><name>rnode</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
				   <name><name>regbuf_old</name><operator>-&gt;</operator><name>forkno</name></name> <operator>!=</operator> <name><name>regbuf</name><operator>-&gt;</operator><name>forkno</name></name> <operator>||</operator>
				   <name><name>regbuf_old</name><operator>-&gt;</operator><name>block</name></name> <operator>!=</operator> <name><name>regbuf</name><operator>-&gt;</operator><name>block</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name><name>regbuf</name><operator>-&gt;</operator><name>in_use</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Like XLogRegisterBuffer, but for registering a block that's not in the
 * shared buffer pool (i.e. when you don't have a Buffer for it).
 */</comment>
<function><type><name>void</name></type>
<name>XLogRegisterBlock</name><parameter_list>(<parameter><decl><type><name>uint8</name></type> <name>block_id</name></decl></parameter>, <parameter><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>rnode</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
				  <parameter><decl><type><name>BlockNumber</name></type> <name>blknum</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>registered_buffer</name> <modifier>*</modifier></type><name>regbuf</name></decl>;</decl_stmt>

	<comment type="block">/* This is currently only used to WAL-log a full-page image of a page */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>flags</name> <operator>&amp;</operator> <name>REGBUF_FORCE_IMAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>begininsert_called</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>block_id</name> <operator>&gt;=</operator> <name>max_registered_block_id</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>max_registered_block_id</name> <operator>=</operator> <name>block_id</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>block_id</name> <operator>&gt;=</operator> <name>max_registered_buffers</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too many registered buffers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>regbuf</name> <operator>=</operator> <operator>&amp;</operator><name><name>registered_buffers</name><index>[<expr><name>block_id</name></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>regbuf</name><operator>-&gt;</operator><name>rnode</name></name> <operator>=</operator> <operator>*</operator><name>rnode</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>regbuf</name><operator>-&gt;</operator><name>forkno</name></name> <operator>=</operator> <name>forknum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>regbuf</name><operator>-&gt;</operator><name>block</name></name> <operator>=</operator> <name>blknum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>regbuf</name><operator>-&gt;</operator><name>page</name></name> <operator>=</operator> <name>page</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>regbuf</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>regbuf</name><operator>-&gt;</operator><name>rdata_tail</name></name> <operator>=</operator> <operator>(</operator><name>XLogRecData</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>regbuf</name><operator>-&gt;</operator><name>rdata_head</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>regbuf</name><operator>-&gt;</operator><name>rdata_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check that this page hasn't already been registered with some other
	 * block_id.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_registered_block_id</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>registered_buffer</name> <modifier>*</modifier></type><name>regbuf_old</name> <init>= <expr><operator>&amp;</operator><name><name>registered_buffers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>block_id</name> <operator>||</operator> <operator>!</operator><name><name>regbuf_old</name><operator>-&gt;</operator><name>in_use</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>RelFileNodeEquals</name><argument_list>(<argument><expr><name><name>regbuf_old</name><operator>-&gt;</operator><name>rnode</name></name></expr></argument>, <argument><expr><name><name>regbuf</name><operator>-&gt;</operator><name>rnode</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
				   <name><name>regbuf_old</name><operator>-&gt;</operator><name>forkno</name></name> <operator>!=</operator> <name><name>regbuf</name><operator>-&gt;</operator><name>forkno</name></name> <operator>||</operator>
				   <name><name>regbuf_old</name><operator>-&gt;</operator><name>block</name></name> <operator>!=</operator> <name><name>regbuf</name><operator>-&gt;</operator><name>block</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name><name>regbuf</name><operator>-&gt;</operator><name>in_use</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add data to the WAL record that's being constructed.
 *
 * The data is appended to the "main chunk", available at replay with
 * XLogRecGetData().
 */</comment>
<function><type><name>void</name></type>
<name>XLogRegisterData</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecData</name> <modifier>*</modifier></type><name>rdata</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>begininsert_called</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>num_rdatas</name> <operator>&gt;=</operator> <name>max_rdatas</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too much WAL data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>rdata</name> <operator>=</operator> <operator>&amp;</operator><name><name>rdatas</name><index>[<expr><name>num_rdatas</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rdata</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rdata</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * we use the mainrdata_last pointer to track the end of the chain, so no
	 * need to clear 'next' here.
	 */</comment>

	<expr_stmt><expr><name><name>mainrdata_last</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>rdata</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>mainrdata_last</name> <operator>=</operator> <name>rdata</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>mainrdata_len</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add buffer-specific data to the WAL record that's being constructed.
 *
 * Block_id must reference a block previously registered with
 * XLogRegisterBuffer(). If this is called more than once for the same
 * block_id, the data is appended.
 *
 * The maximum amount of data that can be registered per block is 65535
 * bytes. That should be plenty; if you need more than BLCKSZ bytes to
 * reconstruct the changes to the page, you might as well just log a full
 * copy of it. (the "main data" that's not associated with a block is not
 * limited)
 */</comment>
<function><type><name>void</name></type>
<name>XLogRegisterBufData</name><parameter_list>(<parameter><decl><type><name>uint8</name></type> <name>block_id</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>registered_buffer</name> <modifier>*</modifier></type><name>regbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecData</name> <modifier>*</modifier></type><name>rdata</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>begininsert_called</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* find the registered buffer struct */</comment>
	<expr_stmt><expr><name>regbuf</name> <operator>=</operator> <operator>&amp;</operator><name><name>registered_buffers</name><index>[<expr><name>block_id</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>regbuf</name><operator>-&gt;</operator><name>in_use</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no block with id %d registered with WAL insertion"</literal></expr></argument>,
			 <argument><expr><name>block_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>num_rdatas</name> <operator>&gt;=</operator> <name>max_rdatas</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too much WAL data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>rdata</name> <operator>=</operator> <operator>&amp;</operator><name><name>rdatas</name><index>[<expr><name>num_rdatas</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rdata</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rdata</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>regbuf</name><operator>-&gt;</operator><name>rdata_tail</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>rdata</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>regbuf</name><operator>-&gt;</operator><name>rdata_tail</name></name> <operator>=</operator> <name>rdata</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>regbuf</name><operator>-&gt;</operator><name>rdata_len</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Set insert status flags for the upcoming WAL record.
 *
 * The flags that can be used here are:
 * - XLOG_INCLUDE_ORIGIN, to determine if the replication origin should be
 *	 included in the record.
 * - XLOG_MARK_UNIMPORTANT, to signal that the record is not important for
 *	 durability, which allows to avoid triggering WAL archiving and other
 *	 background activity.
 */</comment>
<function><type><name>void</name></type>
<name>XLogSetRecordFlags</name><parameter_list>(<parameter><decl><type><name>uint8</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>begininsert_called</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>curinsert_flags</name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Insert an XLOG record having the specified RMID and info bytes, with the
 * body of the record being the data and buffer references registered earlier
 * with XLogRegister* calls.
 *
 * Returns XLOG pointer to end of record (beginning of next record).
 * This can be used as LSN for data pages affected by the logged action.
 * (LSN is the XLOG point up to which the XLOG must be flushed to disk
 * before the data page can be written out.  This implements the basic
 * WAL rule "write the log before the data".)
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>XLogInsert</name><parameter_list>(<parameter><decl><type><name>RmgrId</name></type> <name>rmid</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>EndPos</name></decl>;</decl_stmt>

	<comment type="block">/* XLogBeginInsert() must have been called. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>begininsert_called</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"XLogBeginInsert was not called"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The caller can set rmgr bits, XLR_SPECIAL_REL_UPDATE and
	 * XLR_CHECK_CONSISTENCY; the rest are reserved for use by me.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>info</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>XLR_RMGR_INFO_MASK</name> <operator>|</operator>
				  <name>XLR_SPECIAL_REL_UPDATE</name> <operator>|</operator>
				  <name>XLR_CHECK_CONSISTENCY</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"invalid xlog info mask %02X"</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_WAL_INSERT</name><argument_list>(<argument><expr><name>rmid</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In bootstrap mode, we don't actually log anything but XLOG resources;
	 * return a phony record pointer.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>rmid</name> <operator>!=</operator> <name>RM_XLOG_ID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>XLogResetInsertion</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>EndPos</name> <operator>=</operator> <name>SizeOfXLogLongPHD</name></expr>;</expr_stmt> <comment type="block">/* start of 1st chkpt record */</comment>
		<return>return <expr><name>EndPos</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>RedoRecPtr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>doPageWrites</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>fpw_lsn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecData</name> <modifier>*</modifier></type><name>rdt</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Get values needed to decide whether to do full-page writes. Since
		 * we don't yet have an insertion lock, these could change under us,
		 * but XLogInsertRecord will recheck them once it has a lock.
		 */</comment>
		<expr_stmt><expr><call><name>GetFullPageWriteInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>RedoRecPtr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>doPageWrites</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>rdt</name> <operator>=</operator> <call><name>XLogRecordAssemble</name><argument_list>(<argument><expr><name>rmid</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><name>RedoRecPtr</name></expr></argument>, <argument><expr><name>doPageWrites</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>fpw_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>EndPos</name> <operator>=</operator> <call><name>XLogInsertRecord</name><argument_list>(<argument><expr><name>rdt</name></expr></argument>, <argument><expr><name>fpw_lsn</name></expr></argument>, <argument><expr><name>curinsert_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>EndPos</name> <operator>==</operator> <name>InvalidXLogRecPtr</name></expr>)</condition>;</do>

	<expr_stmt><expr><call><name>XLogResetInsertion</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>EndPos</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Assemble a WAL record from the registered data and buffers into an
 * XLogRecData chain, ready for insertion with XLogInsertRecord().
 *
 * The record header fields are filled in, except for the xl_prev field. The
 * calculated CRC does not include the record header yet.
 *
 * If there are any registered buffers, and a full-page image was not taken
 * of all of them, *fpw_lsn is set to the lowest LSN among such pages. This
 * signals that the assembled record is only good for insertion on the
 * assumption that the RedoRecPtr and doPageWrites values were up-to-date.
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRecData</name> <modifier>*</modifier></type>
<name>XLogRecordAssemble</name><parameter_list>(<parameter><decl><type><name>RmgrId</name></type> <name>rmid</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>info</name></decl></parameter>,
				   <parameter><decl><type><name>XLogRecPtr</name></type> <name>RedoRecPtr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>doPageWrites</name></decl></parameter>,
				   <parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>fpw_lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecData</name> <modifier>*</modifier></type><name>rdt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>total_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>block_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_crc32c</name></type>	<name>rdata_crc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>registered_buffer</name> <modifier>*</modifier></type><name>prev_regbuf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecData</name> <modifier>*</modifier></type><name>rdt_datas_last</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>rechdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>scratch</name> <init>= <expr><name>hdr_scratch</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Note: this function can be called multiple times for the same record.
	 * All the modifications we do to the rdata chains below must handle that.
	 */</comment>

	<comment type="block">/* The record begins with the fixed-size header */</comment>
	<expr_stmt><expr><name>rechdr</name> <operator>=</operator> <operator>(</operator><name>XLogRecord</name> <operator>*</operator><operator>)</operator> <name>scratch</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>scratch</name> <operator>+=</operator> <name>SizeOfXLogRecord</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>hdr_rdt</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rdt_datas_last</name> <operator>=</operator> <operator>&amp;</operator><name>hdr_rdt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hdr_rdt</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name>hdr_scratch</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Enforce consistency checks for this record if user is looking for it.
	 * Do this before at the beginning of this routine to give the possibility
	 * for callers of XLogInsert() to pass XLR_CHECK_CONSISTENCY directly for
	 * a record.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>wal_consistency_checking</name><index>[<expr><name>rmid</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>info</name> <operator>|=</operator> <name>XLR_CHECK_CONSISTENCY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Make an rdata chain containing all the data portions of all block
	 * references. This includes the data for full-page images. Also append
	 * the headers for the block references in the scratch buffer.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>fpw_lsn</name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>block_id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>block_id</name> <operator>&lt;</operator> <name>max_registered_block_id</name></expr>;</condition> <incr><expr><name>block_id</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>registered_buffer</name> <modifier>*</modifier></type><name>regbuf</name> <init>= <expr><operator>&amp;</operator><name><name>registered_buffers</name><index>[<expr><name>block_id</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>needs_backup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>needs_data</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecordBlockHeader</name></type> <name>bkpb</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecordBlockImageHeader</name></type> <name>bimg</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecordBlockCompressHeader</name></type> <name>cbimg</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>samerel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>is_compressed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>include_image</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>regbuf</name><operator>-&gt;</operator><name>in_use</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Determine if this block needs to be backed up */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>regbuf</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REGBUF_FORCE_IMAGE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>needs_backup</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>regbuf</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REGBUF_NO_IMAGE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>needs_backup</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name>doPageWrites</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>needs_backup</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * We assume page LSN is first data on *every* page that can be
			 * passed to XLogInsert, whether it has the standard page layout
			 * or not.
			 */</comment>
			<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>page_lsn</name> <init>= <expr><call><name>PageGetLSN</name><argument_list>(<argument><expr><name><name>regbuf</name><operator>-&gt;</operator><name>page</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>needs_backup</name> <operator>=</operator> <operator>(</operator><name>page_lsn</name> <operator>&lt;=</operator> <name>RedoRecPtr</name><operator>)</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>needs_backup</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>fpw_lsn</name> <operator>==</operator> <name>InvalidXLogRecPtr</name> <operator>||</operator> <name>page_lsn</name> <operator>&lt;</operator> <operator>*</operator><name>fpw_lsn</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>fpw_lsn</name> <operator>=</operator> <name>page_lsn</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Determine if the buffer data needs to included */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>regbuf</name><operator>-&gt;</operator><name>rdata_len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>needs_data</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>regbuf</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REGBUF_KEEP_DATA</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>needs_data</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>needs_data</name> <operator>=</operator> <operator>!</operator><name>needs_backup</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>bkpb</name><operator>.</operator><name>id</name></name> <operator>=</operator> <name>block_id</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bkpb</name><operator>.</operator><name>fork_flags</name></name> <operator>=</operator> <name><name>regbuf</name><operator>-&gt;</operator><name>forkno</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bkpb</name><operator>.</operator><name>data_length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>regbuf</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REGBUF_WILL_INIT</name><operator>)</operator> <operator>==</operator> <name>REGBUF_WILL_INIT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>bkpb</name><operator>.</operator><name>fork_flags</name></name> <operator>|=</operator> <name>BKPBLOCK_WILL_INIT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If needs_backup is true or WAL checking is enabled for current
		 * resource manager, log a full-page write for the current block.
		 */</comment>
		<expr_stmt><expr><name>include_image</name> <operator>=</operator> <name>needs_backup</name> <operator>||</operator> <operator>(</operator><name>info</name> <operator>&amp;</operator> <name>XLR_CHECK_CONSISTENCY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>include_image</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><name><name>regbuf</name><operator>-&gt;</operator><name>page</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint16</name></type>		<name>compressed_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * The page needs to be backed up, so calculate its hole length
			 * and offset.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>regbuf</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>REGBUF_STANDARD</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Assume we can omit data between pd_lower and pd_upper */</comment>
				<decl_stmt><decl><type><name>uint16</name></type>		<name>lower</name> <init>= <expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name><operator>)</operator><operator>-&gt;</operator><name>pd_lower</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>uint16</name></type>		<name>upper</name> <init>= <expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name><operator>)</operator><operator>-&gt;</operator><name>pd_upper</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>lower</name> <operator>&gt;=</operator> <name>SizeOfPageHeaderData</name> <operator>&amp;&amp;</operator>
					<name>upper</name> <operator>&gt;</operator> <name>lower</name> <operator>&amp;&amp;</operator>
					<name>upper</name> <operator>&lt;=</operator> <name>BLCKSZ</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>bimg</name><operator>.</operator><name>hole_offset</name></name> <operator>=</operator> <name>lower</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cbimg</name><operator>.</operator><name>hole_length</name></name> <operator>=</operator> <name>upper</name> <operator>-</operator> <name>lower</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* No "hole" to compress out */</comment>
					<expr_stmt><expr><name><name>bimg</name><operator>.</operator><name>hole_offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cbimg</name><operator>.</operator><name>hole_length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Not a standard page header, don't try to eliminate "hole" */</comment>
				<expr_stmt><expr><name><name>bimg</name><operator>.</operator><name>hole_offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>cbimg</name><operator>.</operator><name>hole_length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * Try to compress a block image if wal_compression is enabled
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>wal_compression</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>is_compressed</name> <operator>=</operator>
					<call><name>XLogCompressBackupBlock</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>bimg</name><operator>.</operator><name>hole_offset</name></name></expr></argument>,
											<argument><expr><name><name>cbimg</name><operator>.</operator><name>hole_length</name></name></expr></argument>,
											<argument><expr><name><name>regbuf</name><operator>-&gt;</operator><name>compressed_page</name></name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>compressed_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Fill in the remaining fields in the XLogRecordBlockHeader
			 * struct
			 */</comment>
			<expr_stmt><expr><name><name>bkpb</name><operator>.</operator><name>fork_flags</name></name> <operator>|=</operator> <name>BKPBLOCK_HAS_IMAGE</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Construct XLogRecData entries for the page content.
			 */</comment>
			<expr_stmt><expr><name><name>rdt_datas_last</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>regbuf</name><operator>-&gt;</operator><name>bkp_rdatas</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>rdt_datas_last</name> <operator>=</operator> <name><name>rdt_datas_last</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>bimg</name><operator>.</operator><name>bimg_info</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>cbimg</name><operator>.</operator><name>hole_length</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>BKPIMAGE_HAS_HOLE</name></expr></else></ternary></expr>;</expr_stmt>

			<comment type="block">/*
			 * If WAL consistency checking is enabled for the resource manager
			 * of this WAL record, a full-page image is included in the record
			 * for the block modified. During redo, the full-page is replayed
			 * only if BKPIMAGE_APPLY is set.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>needs_backup</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>bimg</name><operator>.</operator><name>bimg_info</name></name> <operator>|=</operator> <name>BKPIMAGE_APPLY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>is_compressed</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>bimg</name><operator>.</operator><name>length</name></name> <operator>=</operator> <name>compressed_len</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>bimg</name><operator>.</operator><name>bimg_info</name></name> <operator>|=</operator> <name>BKPIMAGE_IS_COMPRESSED</name></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>rdt_datas_last</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name><name>regbuf</name><operator>-&gt;</operator><name>compressed_page</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rdt_datas_last</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>compressed_len</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>bimg</name><operator>.</operator><name>length</name></name> <operator>=</operator> <name>BLCKSZ</name> <operator>-</operator> <name><name>cbimg</name><operator>.</operator><name>hole_length</name></name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>cbimg</name><operator>.</operator><name>hole_length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>rdt_datas_last</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>page</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>rdt_datas_last</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>BLCKSZ</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* must skip the hole */</comment>
					<expr_stmt><expr><name><name>rdt_datas_last</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>page</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>rdt_datas_last</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name><name>bimg</name><operator>.</operator><name>hole_offset</name></name></expr>;</expr_stmt>

					<expr_stmt><expr><name><name>rdt_datas_last</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>regbuf</name><operator>-&gt;</operator><name>bkp_rdatas</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>rdt_datas_last</name> <operator>=</operator> <name><name>rdt_datas_last</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

					<expr_stmt><expr><name><name>rdt_datas_last</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator>
						<name>page</name> <operator>+</operator> <operator>(</operator><name><name>bimg</name><operator>.</operator><name>hole_offset</name></name> <operator>+</operator> <name><name>cbimg</name><operator>.</operator><name>hole_length</name></name><operator>)</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>rdt_datas_last</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator>
						<name>BLCKSZ</name> <operator>-</operator> <operator>(</operator><name><name>bimg</name><operator>.</operator><name>hole_offset</name></name> <operator>+</operator> <name><name>cbimg</name><operator>.</operator><name>hole_length</name></name><operator>)</operator></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>total_len</name> <operator>+=</operator> <name><name>bimg</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>needs_data</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Link the caller-supplied rdata chain for this buffer to the
			 * overall list.
			 */</comment>
			<expr_stmt><expr><name><name>bkpb</name><operator>.</operator><name>fork_flags</name></name> <operator>|=</operator> <name>BKPBLOCK_HAS_DATA</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>bkpb</name><operator>.</operator><name>data_length</name></name> <operator>=</operator> <name><name>regbuf</name><operator>-&gt;</operator><name>rdata_len</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>total_len</name> <operator>+=</operator> <name><name>regbuf</name><operator>-&gt;</operator><name>rdata_len</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>rdt_datas_last</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>regbuf</name><operator>-&gt;</operator><name>rdata_head</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>rdt_datas_last</name> <operator>=</operator> <name><name>regbuf</name><operator>-&gt;</operator><name>rdata_tail</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>prev_regbuf</name> <operator>&amp;&amp;</operator> <call><name>RelFileNodeEquals</name><argument_list>(<argument><expr><name><name>regbuf</name><operator>-&gt;</operator><name>rnode</name></name></expr></argument>, <argument><expr><name><name>prev_regbuf</name><operator>-&gt;</operator><name>rnode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>samerel</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>bkpb</name><operator>.</operator><name>fork_flags</name></name> <operator>|=</operator> <name>BKPBLOCK_SAME_REL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>samerel</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>prev_regbuf</name> <operator>=</operator> <name>regbuf</name></expr>;</expr_stmt>

		<comment type="block">/* Ok, copy the header to the scratch buffer */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>scratch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bkpb</name></expr></argument>, <argument><expr><name>SizeOfXLogRecordBlockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>scratch</name> <operator>+=</operator> <name>SizeOfXLogRecordBlockHeader</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>include_image</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>scratch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bimg</name></expr></argument>, <argument><expr><name>SizeOfXLogRecordBlockImageHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>scratch</name> <operator>+=</operator> <name>SizeOfXLogRecordBlockImageHeader</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>cbimg</name><operator>.</operator><name>hole_length</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>is_compressed</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>scratch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cbimg</name></expr></argument>,
					   <argument><expr><name>SizeOfXLogRecordBlockCompressHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>scratch</name> <operator>+=</operator> <name>SizeOfXLogRecordBlockCompressHeader</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>samerel</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>scratch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>regbuf</name><operator>-&gt;</operator><name>rnode</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>scratch</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>scratch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>regbuf</name><operator>-&gt;</operator><name>block</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BlockNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>scratch</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BlockNumber</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* followed by the record's origin, if any */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>curinsert_flags</name> <operator>&amp;</operator> <name>XLOG_INCLUDE_ORIGIN</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<name>replorigin_session_origin</name> <operator>!=</operator> <name>InvalidRepOriginId</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><operator>(</operator><name>scratch</name><operator>++</operator><operator>)</operator> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator> <name>XLR_BLOCK_ID_ORIGIN</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>scratch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>replorigin_session_origin</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>replorigin_session_origin</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>scratch</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>replorigin_session_origin</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* followed by main data, if any */</comment>
	<if_stmt><if>if <condition>(<expr><name>mainrdata_len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>mainrdata_len</name> <operator>&gt;</operator> <literal type="number">255</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name>scratch</name><operator>++</operator><operator>)</operator> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator> <name>XLR_BLOCK_ID_DATA_LONG</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>scratch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mainrdata_len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>scratch</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name>scratch</name><operator>++</operator><operator>)</operator> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator> <name>XLR_BLOCK_ID_DATA_SHORT</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name>scratch</name><operator>++</operator><operator>)</operator> <operator>=</operator> <operator>(</operator><name>uint8</name><operator>)</operator> <name>mainrdata_len</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>rdt_datas_last</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>mainrdata_head</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rdt_datas_last</name> <operator>=</operator> <name>mainrdata_last</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>total_len</name> <operator>+=</operator> <name>mainrdata_len</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>rdt_datas_last</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>hdr_rdt</name><operator>.</operator><name>len</name></name> <operator>=</operator> <operator>(</operator><name>scratch</name> <operator>-</operator> <name>hdr_scratch</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>total_len</name> <operator>+=</operator> <name><name>hdr_rdt</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Calculate CRC of the data
	 *
	 * Note that the record header isn't added into the CRC initially since we
	 * don't know the prev-link yet.  Thus, the CRC will represent the CRC of
	 * the whole record in the order: rdata, then backup blocks, then record
	 * header.
	 */</comment>
	<expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name>rdata_crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>rdata_crc</name></expr></argument>, <argument><expr><name>hdr_scratch</name> <operator>+</operator> <name>SizeOfXLogRecord</name></expr></argument>, <argument><expr><name><name>hdr_rdt</name><operator>.</operator><name>len</name></name> <operator>-</operator> <name>SizeOfXLogRecord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>rdt</name> <operator>=</operator> <name><name>hdr_rdt</name><operator>.</operator><name>next</name></name></expr>;</init> <condition><expr><name>rdt</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>rdt</name> <operator>=</operator> <name><name>rdt</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>rdata_crc</name></expr></argument>, <argument><expr><name><name>rdt</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>rdt</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/*
	 * Fill in the fields in the record header. Prev-link is filled in later,
	 * once we know where in the WAL the record will be inserted. The CRC does
	 * not include the record header yet.
	 */</comment>
	<expr_stmt><expr><name><name>rechdr</name><operator>-&gt;</operator><name>xl_xid</name></name> <operator>=</operator> <call><name>GetCurrentTransactionIdIfAny</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rechdr</name><operator>-&gt;</operator><name>xl_tot_len</name></name> <operator>=</operator> <name>total_len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rechdr</name><operator>-&gt;</operator><name>xl_info</name></name> <operator>=</operator> <name>info</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rechdr</name><operator>-&gt;</operator><name>xl_rmid</name></name> <operator>=</operator> <name>rmid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rechdr</name><operator>-&gt;</operator><name>xl_prev</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rechdr</name><operator>-&gt;</operator><name>xl_crc</name></name> <operator>=</operator> <name>rdata_crc</name></expr>;</expr_stmt>

	<return>return <expr><operator>&amp;</operator><name>hdr_rdt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create a compressed version of a backup block image.
 *
 * Returns false if compression fails (i.e., compressed result is actually
 * bigger than original). Otherwise, returns true and sets 'dlen' to
 * the length of compressed block image.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>XLogCompressBackupBlock</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>page</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>hole_offset</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>hole_length</name></decl></parameter>,
						<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>uint16</name> <modifier>*</modifier></type><name>dlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>orig_len</name> <init>= <expr><name>BLCKSZ</name> <operator>-</operator> <name>hole_length</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>extra_bytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>source</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGAlignedBlock</name></type> <name>tmp</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>hole_length</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* must skip the hole */</comment>
		<expr_stmt><expr><name>source</name> <operator>=</operator> <name><name>tmp</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>hole_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>source</name> <operator>+</operator> <name>hole_offset</name></expr></argument>,
			   <argument><expr><name>page</name> <operator>+</operator> <operator>(</operator><name>hole_offset</name> <operator>+</operator> <name>hole_length</name><operator>)</operator></expr></argument>,
			   <argument><expr><name>BLCKSZ</name> <operator>-</operator> <operator>(</operator><name>hole_length</name> <operator>+</operator> <name>hole_offset</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Extra data needs to be stored in WAL record for the compressed
		 * version of block image if the hole exists.
		 */</comment>
		<expr_stmt><expr><name>extra_bytes</name> <operator>=</operator> <name>SizeOfXLogRecordBlockCompressHeader</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>source</name> <operator>=</operator> <name>page</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * We recheck the actual size even if pglz_compress() reports success and
	 * see if the number of bytes saved by compression is larger than the
	 * length of extra data needed for the compressed version of block image.
	 */</comment>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>pglz_compress</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>orig_len</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>PGLZ_strategy_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name>len</name> <operator>+</operator> <name>extra_bytes</name> <operator>&lt;</operator> <name>orig_len</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>dlen</name> <operator>=</operator> <operator>(</operator><name>uint16</name><operator>)</operator> <name>len</name></expr>;</expr_stmt>	<comment type="block">/* successful compression */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Determine whether the buffer referenced has to be backed up.
 *
 * Since we don't yet have the insert lock, fullPageWrites and forcePageWrites
 * could change later, so the result should be used for optimization purposes
 * only.
 */</comment>
<function><type><name>bool</name></type>
<name>XLogCheckBufferNeedsBackup</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>RedoRecPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>doPageWrites</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>GetFullPageWriteInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>RedoRecPtr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>doPageWrites</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>doPageWrites</name> <operator>&amp;&amp;</operator> <call><name>PageGetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>RedoRecPtr</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* buffer requires backup */</comment>

	<return>return <expr><name>false</name></expr>;</return>				<comment type="block">/* buffer does not need to be backed up */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Write a backup block if needed when we are setting a hint. Note that
 * this may be called for a variety of page types, not just heaps.
 *
 * Callable while holding just share lock on the buffer content.
 *
 * We can't use the plain backup block mechanism since that relies on the
 * Buffer being exclusively locked. Since some modifications (setting LSN, hint
 * bits) are allowed in a sharelocked buffer that can lead to wal checksum
 * failures. So instead we copy the page and insert the copied data as normal
 * record data.
 *
 * We only need to do something if page has not yet been full page written in
 * this checkpoint round. The LSN of the inserted wal record is returned if we
 * had to write, InvalidXLogRecPtr otherwise.
 *
 * It is possible that multiple concurrent backends could attempt to write WAL
 * records. In that case, multiple copies of the same block would be recorded
 * in separate WAL records by different backends, though that is still OK from
 * a correctness perspective.
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>XLogSaveBufferForHint</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>buffer_std</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>RedoRecPtr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Ensure no checkpoint can change our view of RedoRecPtr.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>delayChkpt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update RedoRecPtr so that we can make the right decision
	 */</comment>
	<expr_stmt><expr><name>RedoRecPtr</name> <operator>=</operator> <call><name>GetRedoRecPtr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We assume page LSN is first data on *every* page that can be passed to
	 * XLogInsert, whether it has the standard page layout or not. Since we're
	 * only holding a share-lock on the page, we must take the buffer header
	 * lock when we look at the LSN.
	 */</comment>
	<expr_stmt><expr><name>lsn</name> <operator>=</operator> <call><name>BufferGetLSNAtomic</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>lsn</name> <operator>&lt;=</operator> <name>RedoRecPtr</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>flags</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGAlignedBlock</name></type> <name>copied_buffer</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>origdata</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>BufferGetBlock</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ForkNumber</name></type>	<name>forkno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Copy buffer so we don't have to worry about concurrent hint bit or
		 * lsn updates. We assume pd_lower/upper cannot be changed without an
		 * exclusive lock, so the contents bkp are not racy.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>buffer_std</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Assume we can omit data between pd_lower and pd_upper */</comment>
			<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint16</name></type>		<name>lower</name> <init>= <expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name><operator>)</operator><operator>-&gt;</operator><name>pd_lower</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint16</name></type>		<name>upper</name> <init>= <expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name><operator>)</operator><operator>-&gt;</operator><name>pd_upper</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>copied_buffer</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>origdata</name></expr></argument>, <argument><expr><name>lower</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>copied_buffer</name><operator>.</operator><name>data</name></name> <operator>+</operator> <name>upper</name></expr></argument>, <argument><expr><name>origdata</name> <operator>+</operator> <name>upper</name></expr></argument>, <argument><expr><name>BLCKSZ</name> <operator>-</operator> <name>upper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>copied_buffer</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>origdata</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>REGBUF_FORCE_IMAGE</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>buffer_std</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>REGBUF_STANDARD</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>BufferGetTag</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>forkno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterBlock</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>, <argument><expr><name>forkno</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name><name>copied_buffer</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_XLOG_ID</name></expr></argument>, <argument><expr><name>XLOG_FPI_FOR_HINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>recptr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Write a WAL record containing a full image of a page. Caller is responsible
 * for writing the page to disk after calling this routine.
 *
 * Note: If you're using this function, you should be building pages in private
 * memory and writing them directly to smgr.  If you're using buffers, call
 * log_newpage_buffer instead.
 *
 * If the page follows the standard page layout, with a PageHeader and unused
 * space between pd_lower and pd_upper, set 'page_std' to true. That allows
 * the unused space to be left out from the WAL record, making it smaller.
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>log_newpage</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>rnode</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkNum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>,
			<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>page_std</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>REGBUF_FORCE_IMAGE</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>page_std</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>REGBUF_STANDARD</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogRegisterBlock</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_XLOG_ID</name></expr></argument>, <argument><expr><name>XLOG_FPI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The page may be uninitialized. If so, we can't set the LSN because that
	 * would corrupt the page.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PageIsNew</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>recptr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Write a WAL record containing a full image of a page.
 *
 * Caller should initialize the buffer and mark it dirty before calling this
 * function.  This function will set the page LSN.
 *
 * If the page follows the standard page layout, with a PageHeader and unused
 * space between pd_lower and pd_upper, set 'page_std' to true. That allows
 * the unused space to be left out from the WAL record, making it smaller.
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>log_newpage_buffer</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>page_std</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForkNumber</name></type>	<name>forkNum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>

	<comment type="block">/* Shared buffers should be modified in a critical section. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CritSectionCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>BufferGetTag</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>forkNum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>log_newpage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>page_std</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Allocate working buffers needed for WAL record construction.
 */</comment>
<function><type><name>void</name></type>
<name>InitXLogInsert</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Initialize the working areas */</comment>
	<if_stmt><if>if <condition>(<expr><name>xloginsert_cxt</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>xloginsert_cxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
											   <argument><expr><literal type="string">"WAL record construction"</literal></expr></argument>,
											   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>registered_buffers</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>registered_buffers</name> <operator>=</operator> <operator>(</operator><name>registered_buffer</name> <operator>*</operator><operator>)</operator>
			<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>xloginsert_cxt</name></expr></argument>,
								   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>registered_buffer</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>XLR_NORMAL_MAX_BLOCK_ID</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>max_registered_buffers</name> <operator>=</operator> <name>XLR_NORMAL_MAX_BLOCK_ID</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>rdatas</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>rdatas</name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>xloginsert_cxt</name></expr></argument>,
									<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>XLR_NORMAL_RDATAS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>max_rdatas</name> <operator>=</operator> <name>XLR_NORMAL_RDATAS</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Allocate a buffer to hold the header information for a WAL record.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>hdr_scratch</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>hdr_scratch</name> <operator>=</operator> <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>xloginsert_cxt</name></expr></argument>,
											 <argument><expr><name>HEADER_SCRATCH_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
</unit>
