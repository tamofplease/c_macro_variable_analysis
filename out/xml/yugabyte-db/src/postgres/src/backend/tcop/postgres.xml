<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/tcop/postgres.c"> <comment type="block">/*-------------------------------------------------------------------------
 *
 * postgres.c
 *	  POSTGRES C Backend Interface
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/tcop/postgres.c
 *
 * NOTES
 *	  this is the "main" module of the postgres backend and
 *	  hence the main module of the "traffic cop".
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_SELECT_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/select.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_RESOURCE_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/resource.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_GETRUSAGE</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rusagestub.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/parallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/printtup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/yb_catalog_version.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/async.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/portalcmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/prepare.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jit/jit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/print.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_trace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/analyze.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_getopt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/autovacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/logicallauncher.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/logicalworker.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/slot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walsender.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteHandler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/sinval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/fastpath.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/pquery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/catcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timeout.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_yb_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/yb_pqcomm_extensions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>

<comment type="block">/* ----------------
 *		global variables
 * ----------------
 */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>debug_query_string</name></decl>;</decl_stmt> <comment type="block">/* client-supplied query string */</comment>

<comment type="block">/* Note: whereToSendOutput is initialized for the bootstrap/standalone case */</comment>
<decl_stmt><decl><type><name>CommandDest</name></type> <name>whereToSendOutput</name> <init>= <expr><name>DestDebug</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* flag for logging end of session */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>Log_disconnections</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type>			<name>log_statement</name> <init>= <expr><name>LOGSTMT_NONE</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* GUC variable for maximum stack depth (measured in kilobytes) */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>max_stack_depth</name> <init>= <expr><literal type="number">100</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* wait N seconds to allow attach from a debugger */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>PostAuthDelay</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* ----------------
 *		private variables
 * ----------------
 */</comment>

<comment type="block">/* max_stack_depth converted to bytes for speed of checking */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>max_stack_depth_bytes</name> <init>= <expr><literal type="number">100</literal> <operator>*</operator> <literal type="number">1024L</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Stack base pointer -- initialized by PostmasterMain and inherited by
 * subprocesses. This is not static because old versions of PL/Java modify
 * it directly. Newer versions use set_stack_base(), but we want to stay
 * binary-compatible for the time being.
 */</comment>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>stack_base_ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * On IA64 we also have to remember the register stack base.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ia64__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__ia64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>register_stack_base_ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Flag to keep track of whether we have started a transaction.
 * For extended query protocol this has to be remembered across messages.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>xact_started</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Flag to indicate that we are doing the outer loop's read-from-client,
 * as opposed to any random read from client that might happen within
 * commands like COPY FROM STDIN.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>DoingCommandRead</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Flags to implement skip-till-Sync-after-error behavior for messages of
 * the extended query protocol.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>doing_extended_query_message</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>ignore_till_sync</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Flag to keep track of whether statement timeout timer is active.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>stmt_timeout_active</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * If an unnamed prepared statement exists, it's stored here.
 * We keep it separate from the hashtable kept by commands/prepare.c
 * in order to reduce overhead for short-lived queries.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>CachedPlanSource</name> <modifier>*</modifier></type><name>unnamed_stmt_psrc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* assorted command-line switches */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>userDoption</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* -D switch */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>EchoQuery</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* -E switch */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>UseSemiNewlineNewline</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* -j switch */</comment>

<comment type="block">/* whether or not, and why, we were canceled by conflict with recovery */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>RecoveryConflictPending</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>RecoveryConflictRetryable</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ProcSignalReason</name></type> <name>RecoveryConflictReason</name></decl>;</decl_stmt>

<comment type="block">/* reused buffer to pass to SendRowDescriptionMessage() */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>row_description_context</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>StringInfoData</name></type> <name>row_description_buf</name></decl>;</decl_stmt>

<comment type="block">/* Flag to mark cache as invalid if discovered within a txn block. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>yb_need_cache_refresh</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * String constants used for redacting text after the password token in
 * CREATE/ALTER ROLE commands.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOKEN_PASSWORD</name></cpp:macro> <cpp:value>"password"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOKEN_REDACTED</name></cpp:macro> <cpp:value>"&lt;REDACTED&gt;"</cpp:value></cpp:define>

<comment type="block">/* ----------------------------------------------------------------
 *		decls for routines only used in this file
 * ----------------------------------------------------------------
 */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>InteractiveBackend</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>inBuf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>interactive_getc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>SocketBackend</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>inBuf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>ReadCommand</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>inBuf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>forbidden_in_wal_sender</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>firstchar</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>pg_rewrite_query</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_log_statement</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>stmt_list</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>errdetail_execute</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>raw_parsetree_list</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>errdetail_params</name><parameter_list>(<parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>errdetail_abort</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>errdetail_recovery_conflict</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>start_xact_command</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>finish_xact_command</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsTransactionExitStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsTransactionExitStmtList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pstmts</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsTransactionStmtList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pstmts</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>drop_unnamed_stmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>log_disconnections</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>enable_statement_timeout</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>disable_statement_timeout</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* ----------------------------------------------------------------
 *		routines to obtain user input
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/* ----------------
 *	InteractiveBackend() is called for user interactive connections
 *
 *	the string entered by the user is placed in its parameter inBuf,
 *	and we act like a Q message was received.
 *
 *	EOF is returned if end-of-file input is seen; time to shut down.
 * ----------------
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>InteractiveBackend</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>inBuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>c</name></decl>;</decl_stmt>				<comment type="block">/* character read from getc() */</comment>

	<comment type="block">/*
	 * display a prompt and obtain input from the user
	 */</comment>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"backend&gt; "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name>inBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Read characters until EOF or the appropriate delimiter is seen.
	 */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>interactive_getc</name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <name>EOF</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>UseSemiNewlineNewline</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * In -j mode, semicolon followed by two newlines ends the
				 * command; otherwise treat newline as regular character.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>inBuf</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
					<name><name>inBuf</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>inBuf</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator>
					<name><name>inBuf</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>inBuf</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">';'</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* might as well drop the second newline */</comment>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * In plain mode, newline ends the command unless preceded by
				 * backslash.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>inBuf</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
					<name><name>inBuf</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>inBuf</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* discard backslash from inBuf */</comment>
					<expr_stmt><expr><name><name>inBuf</name><operator>-&gt;</operator><name>data</name><index>[<expr><operator>--</operator><name><name>inBuf</name><operator>-&gt;</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
					<comment type="block">/* discard newline too */</comment>
					<continue>continue;</continue>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* keep the newline character, but end the command */</comment>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>inBuf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Not newline, or newline treated as regular character */</comment>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>inBuf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* No input before EOF signal means time to quit. */</comment>
	<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>EOF</name> <operator>&amp;&amp;</operator> <name><name>inBuf</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * otherwise we have a user query so process it.
	 */</comment>

	<comment type="block">/* Add '\0' to make it look the same as message case. */</comment>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>inBuf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>)</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * if the query echo flag was given, print the query..
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>EchoQuery</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"statement: %s\n"</literal></expr></argument>, <argument><expr><name><name>inBuf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="char">'Q'</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * interactive_getc -- collect one character from stdin
 *
 * Even though we are not reading from a "client" process, we still want to
 * respond to signals, particularly SIGTERM/SIGQUIT.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>interactive_getc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>c</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * This will not process catchup interrupts or notifications while
	 * reading. But those can't really be relevant for a standalone backend
	 * anyway. To properly handle SIGTERM there's a hack in die() that
	 * directly processes interrupts at this stage...
	 */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ProcessClientReadInterrupt</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *	SocketBackend()		Is called for frontend-backend connections
 *
 *	Returns the message type code, and loads message body data into inBuf.
 *
 *	EOF is returned if the connection is lost.
 * ----------------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>SocketBackend</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>inBuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>qtype</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get message type code from the frontend.
	 */</comment>
	<expr_stmt><expr><call><name>HOLD_CANCEL_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_startmsgread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>qtype</name> <operator>=</operator> <call><name>pq_getbyte</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>qtype</name> <operator>==</operator> <name>EOF</name></expr>)</condition>			<comment type="block">/* frontend disconnected */</comment>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>COMMERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF on client connection with an open transaction"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Can't send DEBUG log messages to client at this point. Since
			 * we're disconnecting right away, we don't need to restore
			 * whereToSendOutput.
			 */</comment>
			<expr_stmt><expr><name>whereToSendOutput</name> <operator>=</operator> <name>DestNone</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_DOES_NOT_EXIST</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF on client connection"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<return>return <expr><name>qtype</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Validate message type code before trying to read body; if we have lost
	 * sync, better to say "command unknown" than to run out of memory because
	 * we used garbage as a length word.
	 *
	 * This also gives us a place to set the doing_extended_query_message flag
	 * as soon as possible.
	 */</comment>
	<switch>switch <condition>(<expr><name>qtype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="char">'Q'</literal></expr>:</case>				<comment type="block">/* simple query */</comment>
			<expr_stmt><expr><name>doing_extended_query_message</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* old style without length word; convert */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>pq_getstring</name><argument_list>(<argument><expr><name>inBuf</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>COMMERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF on client connection with an open transaction"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/*
						 * Can't send DEBUG log messages to client at this
						 * point. Since we're disconnecting right away, we
						 * don't need to restore whereToSendOutput.
						 */</comment>
						<expr_stmt><expr><name>whereToSendOutput</name> <operator>=</operator> <name>DestNone</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_DOES_NOT_EXIST</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF on client connection"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<return>return <expr><name>EOF</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><literal type="char">'F'</literal></expr>:</case>				<comment type="block">/* fastpath function call */</comment>
			<expr_stmt><expr><name>doing_extended_query_message</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>GetOldFunctionMessage</name><argument_list>(<argument><expr><name>inBuf</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>COMMERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF on client connection with an open transaction"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/*
						 * Can't send DEBUG log messages to client at this
						 * point. Since we're disconnecting right away, we
						 * don't need to restore whereToSendOutput.
						 */</comment>
						<expr_stmt><expr><name>whereToSendOutput</name> <operator>=</operator> <name>DestNone</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_DOES_NOT_EXIST</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF on client connection"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<return>return <expr><name>EOF</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><literal type="char">'X'</literal></expr>:</case>				<comment type="block">/* terminate */</comment>
			<expr_stmt><expr><name>doing_extended_query_message</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ignore_till_sync</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><literal type="char">'B'</literal></expr>:</case>				<comment type="block">/* bind */</comment>
		<case>case <expr><literal type="char">'C'</literal></expr>:</case>				<comment type="block">/* close */</comment>
		<case>case <expr><literal type="char">'D'</literal></expr>:</case>				<comment type="block">/* describe */</comment>
		<case>case <expr><literal type="char">'E'</literal></expr>:</case>				<comment type="block">/* execute */</comment>
		<case>case <expr><literal type="char">'H'</literal></expr>:</case>				<comment type="block">/* flush */</comment>
		<case>case <expr><literal type="char">'P'</literal></expr>:</case>				<comment type="block">/* parse */</comment>
			<expr_stmt><expr><name>doing_extended_query_message</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<comment type="block">/* these are only legal in protocol 3 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid frontend message type %d"</literal></expr></argument>, <argument><expr><name>qtype</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><literal type="char">'S'</literal></expr>:</case>				<comment type="block">/* sync */</comment>
			<comment type="block">/* stop any active skip-till-Sync */</comment>
			<expr_stmt><expr><name>ignore_till_sync</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<comment type="block">/* mark not-extended, so that a new error doesn't begin skip */</comment>
			<expr_stmt><expr><name>doing_extended_query_message</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<comment type="block">/* only legal in protocol 3 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid frontend message type %d"</literal></expr></argument>, <argument><expr><name>qtype</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><literal type="char">'d'</literal></expr>:</case>				<comment type="block">/* copy data */</comment>
		<case>case <expr><literal type="char">'c'</literal></expr>:</case>				<comment type="block">/* copy done */</comment>
		<case>case <expr><literal type="char">'f'</literal></expr>:</case>				<comment type="block">/* copy fail */</comment>
			<expr_stmt><expr><name>doing_extended_query_message</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<comment type="block">/* these are only legal in protocol 3 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid frontend message type %d"</literal></expr></argument>, <argument><expr><name>qtype</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<default>default:</default>

			<comment type="block">/*
			 * Otherwise we got garbage from the frontend.  We treat this as
			 * fatal because we have probably lost message boundary sync, and
			 * there's no good way to recover.
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid frontend message type %d"</literal></expr></argument>, <argument><expr><name>qtype</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * In protocol version 3, all frontend messages have a length word next
	 * after the type code; we can read the message contents independently of
	 * the type.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pq_getmessage</name><argument_list>(<argument><expr><name>inBuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* suitable message already logged */</comment>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pq_endmsgread</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>RESUME_CANCEL_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>qtype</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		ReadCommand reads a command from either the frontend or
 *		standard input, places it in inBuf, and returns the
 *		message type code (first byte of the message).
 *		EOF is returned if end of file.
 * ----------------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ReadCommand</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>inBuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>SocketBackend</name><argument_list>(<argument><expr><name>inBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>InteractiveBackend</name><argument_list>(<argument><expr><name>inBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ProcessClientReadInterrupt() - Process interrupts specific to client reads
 *
 * This is called just before and after low-level reads.
 * 'blocked' is true if no data was available to read and we plan to retry,
 * false if about to read or done reading.
 *
 * Must preserve errno!
 */</comment>
<function><type><name>void</name></type>
<name>ProcessClientReadInterrupt</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>blocked</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>DoingCommandRead</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Check for general interrupts that arrived before/while reading */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Process sinval catchup interrupts, if any */</comment>
		<if_stmt><if>if <condition>(<expr><name>catchupInterruptPending</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ProcessCatchupInterrupt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Process notify interrupts, if any */</comment>
		<if_stmt><if>if <condition>(<expr><name>notifyInterruptPending</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ProcessNotifyInterrupt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>ProcDiePending</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We're dying.  If there is no data available to read, then it's safe
		 * (and sane) to handle that now.  If we haven't tried to read yet,
		 * make sure the process latch is set, so that if there is no data
		 * then we'll come back here and die.  If we're done reading, also
		 * make sure the process latch is set, as we might've undesirably
		 * cleared it while reading.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>blocked</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ProcessClientWriteInterrupt() - Process interrupts specific to client writes
 *
 * This is called just before and after low-level writes.
 * 'blocked' is true if no data could be written and we plan to retry,
 * false if about to write or done writing.
 *
 * Must preserve errno!
 */</comment>
<function><type><name>void</name></type>
<name>ProcessClientWriteInterrupt</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>blocked</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>ProcDiePending</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We're dying.  If it's not possible to write, then we should handle
		 * that immediately, else a stuck client could indefinitely delay our
		 * response to the signal.  If we haven't tried to write yet, make
		 * sure the process latch is set, so that if the write would block
		 * then we'll come back here and die.  If we're done writing, also
		 * make sure the process latch is set, as we might've undesirably
		 * cleared it while writing.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>blocked</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Don't mess with whereToSendOutput if ProcessInterrupts wouldn't
			 * do anything.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>InterruptHoldoffCount</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>CritSectionCount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We don't want to send the client the error message, as a)
				 * that would possibly block again, and b) it would likely
				 * lead to loss of protocol sync because we may have already
				 * sent a partial protocol message.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>whereToSendOutput</name> <operator>=</operator> <name>DestNone</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Do raw parsing (only).
 *
 * A list of parsetrees (RawStmt nodes) is returned, since there might be
 * multiple commands in the given string.
 *
 * NOTE: for interactive queries, it is important to keep this routine
 * separate from the analysis &amp; rewrite stages.  Analysis and rewriting
 * cannot be done in an aborted transaction, since they require access to
 * database tables.  So, we rely on the raw parser to determine whether
 * we've seen a COMMIT or ABORT command; when we are in abort state, other
 * commands are not processed any further than the raw parse stage.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>pg_parse_query</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>raw_parsetree_list</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_PARSE_START</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>log_parser_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>raw_parsetree_list</name> <operator>=</operator> <call><name>raw_parser</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>log_parser_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"PARSER STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>COPY_PARSE_PLAN_TREES</name></cpp:ifdef>
	<comment type="block">/* Optional debugging check: pass raw parsetrees through copyObject() */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_list</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>raw_parsetree_list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* This checks both copyObject() and the equal() routines... */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name>new_list</name></expr></argument>, <argument><expr><name>raw_parsetree_list</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"copyObject() failed to produce an equal raw parse tree"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>raw_parsetree_list</name> <operator>=</operator> <name>new_list</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_PARSE_DONE</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>raw_parsetree_list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given a raw parsetree (gram.y output), and optionally information about
 * types of parameter symbols ($n), perform parse analysis and rule rewriting.
 *
 * A list of Query nodes is returned, since either the analyzer or the
 * rewriter might expand one query to several.
 *
 * NOTE: for reasons mentioned above, this must be separate from raw parsing.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>pg_analyze_and_rewrite</name><parameter_list>(<parameter><decl><type><name>RawStmt</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl></parameter>,
					   <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>paramTypes</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numParams</name></decl></parameter>,
					   <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>querytree_list</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_REWRITE_START</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * (1) Perform parse analysis.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>log_parser_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>parse_analyze</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>query_string</name></expr></argument>, <argument><expr><name>paramTypes</name></expr></argument>, <argument><expr><name>numParams</name></expr></argument>,
						  <argument><expr><name>queryEnv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>log_parser_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"PARSE ANALYSIS STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * (2) Rewrite the queries, as necessary
	 */</comment>
	<expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <call><name>pg_rewrite_query</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_REWRITE_DONE</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>querytree_list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Do parse analysis and rewriting.  This is the same as pg_analyze_and_rewrite
 * except that external-parameter resolution is determined by parser callback
 * hooks instead of a fixed list of parameter datatypes.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>pg_analyze_and_rewrite_params</name><parameter_list>(<parameter><decl><type><name>RawStmt</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>,
							  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl></parameter>,
							  <parameter><decl><type><name>ParserSetupHook</name></type> <name>parserSetup</name></decl></parameter>,
							  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>parserSetupArg</name></decl></parameter>,
							  <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>querytree_list</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>query_string</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* required as of 8.4 */</comment>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_REWRITE_START</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * (1) Perform parse analysis.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>log_parser_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>query_string</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_queryEnv</name></name> <operator>=</operator> <name>queryEnv</name></expr>;</expr_stmt>
	<expr_stmt><expr><call>(<modifier>*</modifier><name>parserSetup</name>) <argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>parserSetupArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>transformTopLevelStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name></name> <operator>&amp;&amp;</operator>
		<name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name>
		<operator>&amp;&amp;</operator> <call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SetTxnWithPGRel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>post_parse_analyze_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>post_parse_analyze_hook</name>) <argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>log_parser_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"PARSE ANALYSIS STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * (2) Rewrite the queries, as necessary
	 */</comment>
	<expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <call><name>pg_rewrite_query</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_REWRITE_DONE</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>querytree_list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Perform rewriting of a query produced by parse analysis.
 *
 * Note: query must just have come from the parser, because we do not do
 * AcquireRewriteLocks() on it.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>pg_rewrite_query</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>querytree_list</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>Debug_print_parse</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog_node_display</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"parse tree"</literal></expr></argument>, <argument><expr><name>query</name></expr></argument>,
						  <argument><expr><name>Debug_pretty_print</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>log_parser_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* don't rewrite utilities, just dump 'em into result list */</comment>
		<expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* rewrite regular queries */</comment>
		<expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <call><name>QueryRewrite</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>log_parser_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"REWRITER STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>COPY_PARSE_PLAN_TREES</name></cpp:ifdef>
	<comment type="block">/* Optional debugging check: pass querytree output through copyObject() */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_list</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>new_list</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>querytree_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* This checks both copyObject() and the equal() routines... */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name>new_list</name></expr></argument>, <argument><expr><name>querytree_list</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"copyObject() failed to produce equal parse tree"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <name>new_list</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name>Debug_print_rewritten</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog_node_display</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"rewritten parse tree"</literal></expr></argument>, <argument><expr><name>querytree_list</name></expr></argument>,
						  <argument><expr><name>Debug_pretty_print</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>querytree_list</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Generate a plan for a single already-rewritten query.
 * This is a thin wrapper around planner() and takes the same parameters.
 */</comment>
<function><type><name>PlannedStmt</name> <modifier>*</modifier></type>
<name>pg_plan_query</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>querytree</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cursorOptions</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>

	<comment type="block">/* Utility commands have no plans. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>querytree</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Planner must have a snapshot in case it calls user-defined functions. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ActiveSnapshotSet</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_PLAN_START</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>log_planner_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* call the optimizer */</comment>
	<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>planner</name><argument_list>(<argument><expr><name>querytree</name></expr></argument>, <argument><expr><name>cursorOptions</name></expr></argument>, <argument><expr><name>boundParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>log_planner_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"PLANNER STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>COPY_PARSE_PLAN_TREES</name></cpp:ifdef>
	<comment type="block">/* Optional debugging check: pass plan output through copyObject() */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>new_plan</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * equal() currently does not have routines to compare Plan nodes, so
		 * don't try to test equality here.  Perhaps fix someday?
		 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
		<comment type="block">/* This checks both copyObject() and the equal() routines... */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name>new_plan</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"copyObject() failed to produce an equal plan tree"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <name>new_plan</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Print plan if debugging.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Debug_print_plan</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog_node_display</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"plan"</literal></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Debug_pretty_print</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_PLAN_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate plans for a list of already-rewritten queries.
 *
 * For normal optimizable statements, invoke the planner.  For utility
 * statements, just make a wrapper PlannedStmt node.
 *
 * The result is a list of PlannedStmt nodes.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>pg_plan_queries</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>querytrees</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cursorOptions</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>stmt_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>query_list</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>query_list</argument>, <argument>querytrees</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name>query_list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Utility commands require no planning. */</comment>
			<expr_stmt><expr><name>stmt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_UTILITY</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>canSetTag</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>stmt_location</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>stmt_location</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>stmt_len</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>stmt_len</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>stmt</name> <operator>=</operator> <call><name>pg_plan_query</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>cursorOptions</name></expr></argument>, <argument><expr><name>boundParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>stmt_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>stmt_list</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>stmt_list</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * exec_simple_query
 *
 * Execute a "simple Query" protocol message.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_simple_query</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CommandDest</name></type> <name>dest</name> <init>= <expr><name>whereToSendOutput</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>parsetree_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>parsetree_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>save_log_statement_stats</name> <init>= <expr><name>log_statement_stats</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>was_logged</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>use_implicit_block</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>msec_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>redacted_query_string</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Report query to various monitoring facilities.
	 */</comment>
	<expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name>query_string</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>redacted_query_string</name> <operator>=</operator> <call><name>RedactPasswordIfExists</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_RUNNING</name></expr></argument>, <argument><expr><name>redacted_query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_START</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We use save_log_statement_stats so ShowUsage doesn't report incorrect
	 * results because ResetUsage wasn't called.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>save_log_statement_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Start up a transaction command.  All queries generated by the
	 * query_string will be in this same command block, *unless* we find a
	 * BEGIN/COMMIT/ABORT statement; we have to force a new xact command after
	 * one of those, else bad things will happen in xact.c. (Note that this
	 * will normally change current memory context.)
	 */</comment>
	<expr_stmt><expr><call><name>start_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Zap any pre-existing unnamed statement.  (While not strictly necessary,
	 * it seems best to define simple-Query mode as if it used the unnamed
	 * statement and portal; this ensures we recover any storage used by prior
	 * unnamed operations.)
	 */</comment>
	<expr_stmt><expr><call><name>drop_unnamed_stmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Switch to appropriate context for constructing parsetrees.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do basic parsing of the query or queries (this should be safe even if
	 * we are in aborted transaction state!)
	 */</comment>
	<expr_stmt><expr><name>parsetree_list</name> <operator>=</operator> <call><name>pg_parse_query</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Log the redacted query immediately if dictated by log_statement */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>check_log_statement</name><argument_list>(<argument><expr><name>parsetree_list</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"statement: %s"</literal></expr></argument>, <argument><expr><name>redacted_query_string</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_execute</name><argument_list>(<argument><expr><name>parsetree_list</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>was_logged</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Switch back to transaction context to enter the loop.
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For historical reasons, if multiple SQL statements are given in a
	 * single "simple Query" message, we execute them as a single transaction,
	 * unless explicit transaction control commands are included to make
	 * portions of the list be separate transactions.  To represent this
	 * behavior properly in the transaction machinery, we use an "implicit"
	 * transaction block.
	 */</comment>
	<expr_stmt><expr><name>use_implicit_block</name> <operator>=</operator> <operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name>parsetree_list</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Run through the raw parsetree(s) and process each one.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>parsetree_item</argument>, <argument>parsetree_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RawStmt</name>    <modifier>*</modifier></type><name>parsetree</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RawStmt</name></expr></argument>, <argument><expr><name>parsetree_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>snapshot_set</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>commandTag</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>completionTag</name><index>[<expr><name>COMPLETION_TAG_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>querytree_list</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>plantree_list</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Portal</name></type>		<name>portal</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>receiver</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type>		<name>format</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Get the command name for use in status display (it also becomes the
		 * default completion tag, down inside PortalRun).  Set ps_status and
		 * do any special start-of-SQL-command processing needed by the
		 * destination.
		 */</comment>
		<expr_stmt><expr><name>commandTag</name> <operator>=</operator> <call><name>CreateCommandTag</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><name>commandTag</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>BeginCommand</name><argument_list>(<argument><expr><name>commandTag</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we are in an aborted transaction, reject all commands except
		 * COMMIT/ABORT.  It is important that this test occur before we try
		 * to do parse analysis, rewrite, or planning, since all those phases
		 * try to do database accesses, which may fail in abort state. (It
		 * might be safe to allow some additional utility commands in this
		 * state, but not many...)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>IsTransactionExitStmt</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_IN_FAILED_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"current transaction is aborted, "</literal>
							<literal type="string">"commands ignored until end of transaction block"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_abort</name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Make sure we are in a transaction command */</comment>
		<expr_stmt><expr><call><name>start_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If using an implicit transaction block, and we're not already in a
		 * transaction block, start an implicit block to force this statement
		 * to be grouped together with any following ones.  (We must do this
		 * each time through the loop; otherwise, a COMMIT/ROLLBACK in the
		 * list would cause later statements to not be grouped.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>use_implicit_block</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>BeginImplicitTransactionBlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* If we got a cancel signal in parsing or prior command, quit */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Set up a snapshot if parse analysis/planning will need one.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>analyze_requires_snapshot</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>snapshot_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * OK to analyze, rewrite, and plan this query.
		 *
		 * Switch to appropriate context for constructing querytrees (again,
		 * these must outlive the execution context).
		 */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <call><name>pg_analyze_and_rewrite</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>query_string</name></expr></argument>,
												<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>plantree_list</name> <operator>=</operator> <call><name>pg_plan_queries</name><argument_list>(<argument><expr><name>querytree_list</name></expr></argument>,
										<argument><expr><name>CURSOR_OPT_PARALLEL_OK</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Done with the snapshot used for parsing/planning */</comment>
		<if_stmt><if>if <condition>(<expr><name>snapshot_set</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* If we got a cancel signal in analysis or planning, quit */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Create unnamed portal to run the query or queries in. If there
		 * already is one, silently drop it.
		 */</comment>
		<expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>CreatePortal</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Don't display the portal in pg_cursors */</comment>
		<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>visible</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * We don't have to copy anything into the portal, because everything
		 * we are passing here is in MessageContext, which will outlive the
		 * portal anyway.
		 */</comment>
		<expr_stmt><expr><call><name>PortalDefineQuery</name><argument_list>(<argument><expr><name>portal</name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><name>query_string</name></expr></argument>,
						  <argument><expr><name>commandTag</name></expr></argument>,
						  <argument><expr><name>plantree_list</name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Start the portal.  No parameters here.
		 */</comment>
		<expr_stmt><expr><call><name>PortalStart</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>InvalidSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Select the appropriate output format: text unless we are doing a
		 * FETCH from a binary cursor.  (Pretty grotty to have to do this here
		 * --- but it avoids grottiness in other places.  Ah, the joys of
		 * backward compatibility...)
		 */</comment>
		<expr_stmt><expr><name>format</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>				<comment type="block">/* TEXT is default */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>, <argument><expr><name>FetchStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FetchStmt</name>  <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>FetchStmt</name> <operator>*</operator><operator>)</operator> <name><name>parsetree</name><operator>-&gt;</operator><name>stmt</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>ismove</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Portal</name></type>		<name>fportal</name> <init>= <expr><call><name>GetPortalByName</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>portalname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>PortalIsValid</name><argument_list>(<argument><expr><name>fportal</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<operator>(</operator><name><name>fportal</name><operator>-&gt;</operator><name>cursorOptions</name></name> <operator>&amp;</operator> <name>CURSOR_OPT_BINARY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>format</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* BINARY */</comment>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>PortalSetResultFormat</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now we can create the destination receiver object.
		 */</comment>
		<expr_stmt><expr><name>receiver</name> <operator>=</operator> <call><name>CreateDestReceiver</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>dest</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SetRemoteDestReceiverParams</name><argument_list>(<argument><expr><name>receiver</name></expr></argument>, <argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Switch back to transaction context for execution.
		 */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Run the portal to completion, and then drop it (and the receiver).
		 */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>PortalRun</name><argument_list>(<argument><expr><name>portal</name></expr></argument>,
						 <argument><expr><name>FETCH_ALL</name></expr></argument>,
						 <argument><expr><name>true</name></expr></argument>,	<comment type="block">/* always top level */</comment>
						 <argument><expr><name>true</name></expr></argument>,
						 <argument><expr><name>receiver</name></expr></argument>,
						 <argument><expr><name>receiver</name></expr></argument>,
						 <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name><name>receiver</name><operator>-&gt;</operator><name>rDestroy</name></name><argument_list>(<argument><expr><name>receiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PortalDrop</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>lnext</name><argument_list>(<argument><expr><name>parsetree_item</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If this is the last parsetree of the query string, close down
			 * transaction statement before reporting command-complete.  This
			 * is so that any end-of-transaction errors are reported before
			 * the command-complete message is issued, to avoid confusing
			 * clients who will expect either a command-complete message or an
			 * error, not one and then the other.  Also, if we're using an
			 * implicit transaction block, we must close that out first.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>use_implicit_block</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>EndImplicitTransactionBlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>finish_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>, <argument><expr><name>TransactionStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If this was a transaction control statement, commit it. We will
			 * start a new xact command for the next command.
			 */</comment>
			<expr_stmt><expr><call><name>finish_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * We need a CommandCounterIncrement after every query, except
			 * those that start or end a transaction block.
			 */</comment>
			<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Tell client that we're done with this query.  Note we emit exactly
		 * one EndCommand report for each raw parsetree, thus one for each SQL
		 * command the client sent, regardless of rewriting. (But a command
		 * aborted by error will not send an EndCommand report at all.)
		 */</comment>
		<expr_stmt><expr><call><name>EndCommand</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>							<comment type="block">/* end loop over parsetrees */</comment>

	<comment type="block">/*
	 * Close down transaction statement, if one is open.  (This will only do
	 * something if the parsetree list was empty; otherwise the last loop
	 * iteration already did it.)
	 */</comment>
	<expr_stmt><expr><call><name>finish_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there were no parsetrees, return EmptyQueryResponse message.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>parsetree_list</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>NullCommand</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Emit duration logging if appropriate.
	 */</comment>
	<switch>switch <condition>(<expr><call><name>check_log_duration</name><argument_list>(<argument><expr><name>msec_str</name></expr></argument>, <argument><expr><name>was_logged</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">1</literal></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration: %s ms"</literal></expr></argument>, <argument><expr><name>msec_str</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="number">2</literal></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration: %s ms  statement: %s"</literal></expr></argument>,
							<argument><expr><name>msec_str</name></expr></argument>, <argument><expr><name>redacted_query_string</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_execute</name><argument_list>(<argument><expr><name>parsetree_list</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name>save_log_statement_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"QUERY STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_DONE</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * exec_parse_message
 *
 * Execute a "Parse" protocol message.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_parse_message</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl></parameter>,	<comment type="block">/* string to execute */</comment>
				   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmt_name</name></decl></parameter>,	<comment type="block">/* name for prepared stmt */</comment>
				   <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>paramTypes</name></decl></parameter>, <comment type="block">/* parameter types */</comment>
				   <parameter><decl><type><name>int</name></type> <name>numParams</name></decl></parameter>, <comment type="block">/* number of parameters */</comment>
				   <parameter><decl><type><name>CommandDest</name></type> <name>output_dest</name></decl></parameter>)</parameter_list> <comment type="block">/* where to send output */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>unnamed_stmt_context</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>parsetree_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RawStmt</name>    <modifier>*</modifier></type><name>raw_parse_tree</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>commandTag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>querytree_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>psrc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_named</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>save_log_statement_stats</name> <init>= <expr><name>log_statement_stats</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>msec_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>redacted_query_string</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Report query to various monitoring facilities.
	 */</comment>
	<expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name>query_string</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>redacted_query_string</name> <operator>=</operator> <call><name>RedactPasswordIfExists</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_RUNNING</name></expr></argument>, <argument><expr><name>redacted_query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><literal type="string">"PARSE"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>save_log_statement_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parse %s: %s"</literal></expr></argument>,
					<argument><expr><ternary><condition><expr><operator>*</operator><name>stmt_name</name></expr> ?</condition><then> <expr><name>stmt_name</name></expr> </then><else>: <expr><literal type="string">"&lt;unnamed&gt;"</literal></expr></else></ternary></expr></argument>,
					<argument><expr><name>redacted_query_string</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Start up a transaction command so we can run parse analysis etc. (Note
	 * that this will normally change current memory context.) Nothing happens
	 * if we are already in one.  This also arms the statement timeout if
	 * necessary.
	 */</comment>
	<expr_stmt><expr><call><name>start_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Switch to appropriate context for constructing parsetrees.
	 *
	 * We have two strategies depending on whether the prepared statement is
	 * named or not.  For a named prepared statement, we do parsing in
	 * MessageContext and copy the finished trees into the prepared
	 * statement's plancache entry; then the reset of MessageContext releases
	 * temporary space used by parsing and rewriting. For an unnamed prepared
	 * statement, we assume the statement isn't going to hang around long, so
	 * getting rid of temp space quickly is probably not worth the costs of
	 * copying parse trees.  So in this case, we create the plancache entry's
	 * query_context here, and do all the parsing work therein.
	 */</comment>
	<expr_stmt><expr><name>is_named</name> <operator>=</operator> <operator>(</operator><name><name>stmt_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>is_named</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Named prepared statement --- parse in MessageContext */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Unnamed prepared statement --- release any prior unnamed stmt */</comment>
		<expr_stmt><expr><call><name>drop_unnamed_stmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Create context for parsing */</comment>
		<expr_stmt><expr><name>unnamed_stmt_context</name> <operator>=</operator>
			<call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>,
								  <argument><expr><literal type="string">"unnamed prepared statement"</literal></expr></argument>,
								  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>unnamed_stmt_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Do basic parsing of the query or queries (this should be safe even if
	 * we are in aborted transaction state!)
	 */</comment>
	<expr_stmt><expr><name>parsetree_list</name> <operator>=</operator> <call><name>pg_parse_query</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We only allow a single user statement in a prepared statement. This is
	 * mainly to keep the protocol simple --- otherwise we'd need to worry
	 * about multiple result tupdescs and things like that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>parsetree_list</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot insert multiple commands into a prepared statement"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>parsetree_list</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>snapshot_set</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>raw_parse_tree</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>RawStmt</name></expr></argument>, <argument><expr><name>parsetree_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Get the command name for possible use in status display.
		 */</comment>
		<expr_stmt><expr><name>commandTag</name> <operator>=</operator> <call><name>CreateCommandTag</name><argument_list>(<argument><expr><name><name>raw_parse_tree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we are in an aborted transaction, reject all commands except
		 * COMMIT/ROLLBACK.  It is important that this test occur before we
		 * try to do parse analysis, rewrite, or planning, since all those
		 * phases try to do database accesses, which may fail in abort state.
		 * (It might be safe to allow some additional utility commands in this
		 * state, but not many...)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>IsTransactionExitStmt</name><argument_list>(<argument><expr><name><name>raw_parse_tree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_IN_FAILED_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"current transaction is aborted, "</literal>
							<literal type="string">"commands ignored until end of transaction block"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_abort</name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Create the CachedPlanSource before we do parse analysis, since it
		 * needs to see the unmodified raw parse tree.
		 */</comment>
		<expr_stmt><expr><name>psrc</name> <operator>=</operator> <call><name>CreateCachedPlan</name><argument_list>(<argument><expr><name>raw_parse_tree</name></expr></argument>, <argument><expr><name>query_string</name></expr></argument>, <argument><expr><name>commandTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Set up a snapshot if parse analysis will need one.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>analyze_requires_snapshot</name><argument_list>(<argument><expr><name>raw_parse_tree</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>snapshot_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Analyze and rewrite the query.  Note that the originally specified
		 * parameter set is not required to be complete, so we have to use
		 * parse_analyze_varparams().
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>log_parser_stats</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>parse_analyze_varparams</name><argument_list>(<argument><expr><name>raw_parse_tree</name></expr></argument>,
										<argument><expr><name>query_string</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>paramTypes</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>numParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check all parameter types got determined.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numParams</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>ptype</name> <init>= <expr><name><name>paramTypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>ptype</name> <operator>==</operator> <name>InvalidOid</name> <operator>||</operator> <name>ptype</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDETERMINATE_DATATYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine data type of parameter $%d"</literal></expr></argument>,
								<argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>log_parser_stats</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"PARSE ANALYSIS STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <call><name>pg_rewrite_query</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Done with the snapshot used for parsing */</comment>
		<if_stmt><if>if <condition>(<expr><name>snapshot_set</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Empty input string.  This is legal. */</comment>
		<expr_stmt><expr><name>raw_parse_tree</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>commandTag</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>psrc</name> <operator>=</operator> <call><name>CreateCachedPlan</name><argument_list>(<argument><expr><name>raw_parse_tree</name></expr></argument>, <argument><expr><name>query_string</name></expr></argument>, <argument><expr><name>commandTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * CachedPlanSource must be a direct child of MessageContext before we
	 * reparent unnamed_stmt_context under it, else we have a disconnected
	 * circular subgraph.  Klugy, but less so than flipping contexts even more
	 * above.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>unnamed_stmt_context</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextSetParent</name><argument_list>(<argument><expr><name><name>psrc</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Finish filling in the CachedPlanSource */</comment>
	<expr_stmt><expr><call><name>CompleteCachedPlan</name><argument_list>(<argument><expr><name>psrc</name></expr></argument>,
					   <argument><expr><name>querytree_list</name></expr></argument>,
					   <argument><expr><name>unnamed_stmt_context</name></expr></argument>,
					   <argument><expr><name>paramTypes</name></expr></argument>,
					   <argument><expr><name>numParams</name></expr></argument>,
					   <argument><expr><name>NULL</name></expr></argument>,
					   <argument><expr><name>NULL</name></expr></argument>,
					   <argument><expr><name>CURSOR_OPT_PARALLEL_OK</name></expr></argument>,	<comment type="block">/* allow parallel mode */</comment>
					   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* fixed result */</comment>

	<comment type="block">/* If we got a cancel signal during analysis, quit */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_named</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Store the query as a prepared statement.
		 */</comment>
		<expr_stmt><expr><call><name>StorePreparedStatement</name><argument_list>(<argument><expr><name>stmt_name</name></expr></argument>, <argument><expr><name>psrc</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We just save the CachedPlanSource into unnamed_stmt_psrc.
		 */</comment>
		<expr_stmt><expr><call><name>SaveCachedPlan</name><argument_list>(<argument><expr><name>psrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>unnamed_stmt_psrc</name> <operator>=</operator> <name>psrc</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We do NOT close the open transaction command here; that only happens
	 * when the client sends Sync.  Instead, do CommandCounterIncrement just
	 * in case something happened during parse/plan.
	 */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Send ParseComplete.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>output_dest</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pq_putemptymessage</name><argument_list>(<argument><expr><literal type="char">'1'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Emit duration logging if appropriate.
	 */</comment>
	<switch>switch <condition>(<expr><call><name>check_log_duration</name><argument_list>(<argument><expr><name>msec_str</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">1</literal></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration: %s ms"</literal></expr></argument>, <argument><expr><name>msec_str</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="number">2</literal></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration: %s ms  parse %s: %s"</literal></expr></argument>,
							<argument><expr><name>msec_str</name></expr></argument>,
							<argument><expr><ternary><condition><expr><operator>*</operator><name>stmt_name</name></expr> ?</condition><then> <expr><name>stmt_name</name></expr> </then><else>: <expr><literal type="string">"&lt;unnamed&gt;"</literal></expr></else></ternary></expr></argument>,
							<argument><expr><name>redacted_query_string</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name>save_log_statement_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"PARSE MESSAGE STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * exec_bind_message
 *
 * Process a "Bind" message to create a portal from a prepared statement
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_bind_message</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>input_message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>portal_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmt_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numPFormats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name>	   <modifier>*</modifier></type><name>pformats</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numParams</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numRFormats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name>	   <modifier>*</modifier></type><name>rformats</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>psrc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CachedPlan</name> <modifier>*</modifier></type><name>cplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Portal</name></type>		<name>portal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>query_string</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>redacted_query_string</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>saved_stmt_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>params</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>save_log_statement_stats</name> <init>= <expr><name>log_statement_stats</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>snapshot_set</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>msec_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* Get the fixed part of the message */</comment>
	<expr_stmt><expr><name>portal_name</name> <operator>=</operator> <call><name>pq_getmsgstring</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>stmt_name</name> <operator>=</operator> <call><name>pq_getmsgstring</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"bind %s to %s"</literal></expr></argument>,
					<argument><expr><ternary><condition><expr><operator>*</operator><name>portal_name</name></expr> ?</condition><then> <expr><name>portal_name</name></expr> </then><else>: <expr><literal type="string">"&lt;unnamed&gt;"</literal></expr></else></ternary></expr></argument>,
					<argument><expr><ternary><condition><expr><operator>*</operator><name>stmt_name</name></expr> ?</condition><then> <expr><name>stmt_name</name></expr> </then><else>: <expr><literal type="string">"&lt;unnamed&gt;"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Find prepared statement */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PreparedStatement</name> <modifier>*</modifier></type><name>pstmt</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>pstmt</name> <operator>=</operator> <call><name>FetchPreparedStatement</name><argument_list>(<argument><expr><name>stmt_name</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>psrc</name> <operator>=</operator> <name><name>pstmt</name><operator>-&gt;</operator><name>plansource</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* special-case the unnamed statement */</comment>
		<expr_stmt><expr><name>psrc</name> <operator>=</operator> <name>unnamed_stmt_psrc</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>psrc</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_PSTATEMENT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unnamed prepared statement does not exist"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Report query to various monitoring facilities.
	 */</comment>
	<expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name><name>psrc</name><operator>-&gt;</operator><name>query_string</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>redacted_query_string</name> <operator>=</operator> <call><name>RedactPasswordIfExists</name><argument_list>(<argument><expr><name><name>psrc</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_RUNNING</name></expr></argument>, <argument><expr><name>redacted_query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><literal type="string">"BIND"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>save_log_statement_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Start up a transaction command so we can call functions etc. (Note that
	 * this will normally change current memory context.) Nothing happens if
	 * we are already in one.  This also arms the statement timeout if
	 * necessary.
	 */</comment>
	<expr_stmt><expr><call><name>start_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Switch back to message context */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get the parameter format codes */</comment>
	<expr_stmt><expr><name>numPFormats</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>numPFormats</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>pformats</name> <operator>=</operator> <operator>(</operator><name>int16</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numPFormats</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numPFormats</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pformats</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Get the parameter value count */</comment>
	<expr_stmt><expr><name>numParams</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>numPFormats</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>numPFormats</name> <operator>!=</operator> <name>numParams</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"bind message has %d parameter formats but %d parameters"</literal></expr></argument>,
						<argument><expr><name>numPFormats</name></expr></argument>, <argument><expr><name>numParams</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>numParams</name> <operator>!=</operator> <name><name>psrc</name><operator>-&gt;</operator><name>num_params</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"bind message supplies %d parameters, but prepared statement \"%s\" requires %d"</literal></expr></argument>,
						<argument><expr><name>numParams</name></expr></argument>, <argument><expr><name>stmt_name</name></expr></argument>, <argument><expr><name><name>psrc</name><operator>-&gt;</operator><name>num_params</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we are in aborted transaction state, the only portals we can
	 * actually run are those containing COMMIT or ROLLBACK commands. We
	 * disallow binding anything else to avoid problems with infrastructure
	 * that expects to run inside a valid transaction.  We also disallow
	 * binding any parameters, since we can't risk calling user-defined I/O
	 * functions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>!</operator><operator>(</operator><name><name>psrc</name><operator>-&gt;</operator><name>raw_parse_tree</name></name> <operator>&amp;&amp;</operator>
		   <call><name>IsTransactionExitStmt</name><argument_list>(<argument><expr><name><name>psrc</name><operator>-&gt;</operator><name>raw_parse_tree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
		 <name>numParams</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_IN_FAILED_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"current transaction is aborted, "</literal>
						<literal type="string">"commands ignored until end of transaction block"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_abort</name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Create the portal.  Allow silent replacement of an existing portal only
	 * if the unnamed portal is specified.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>portal_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>CreatePortal</name><argument_list>(<argument><expr><name>portal_name</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>CreatePortal</name><argument_list>(<argument><expr><name>portal_name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Prepare to copy stuff into the portal's memory context.  We do all this
	 * copying first, because it could possibly fail (out-of-memory) and we
	 * don't want a failure to occur between GetCachedPlan and
	 * PortalDefineQuery; that would result in leaking our plancache refcount.
	 */</comment>
	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>portalContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy the plan's query string into the portal */</comment>
	<expr_stmt><expr><name>query_string</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>psrc</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Likewise make a copy of the statement name, unless it's unnamed */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>saved_stmt_name</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>stmt_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>saved_stmt_name</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Set a snapshot if we have parameters to fetch (since the input
	 * functions might need it) or the query isn't a utility command (and
	 * hence could require redoing parse analysis and planning).  We keep the
	 * snapshot active till we're done, so that plancache.c doesn't have to
	 * take new ones.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numParams</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<operator>(</operator><name><name>psrc</name><operator>-&gt;</operator><name>raw_parse_tree</name></name> <operator>&amp;&amp;</operator>
		 <call><name>analyze_requires_snapshot</name><argument_list>(<argument><expr><name><name>psrc</name><operator>-&gt;</operator><name>raw_parse_tree</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>snapshot_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Fetch parameters, if any, and store in the portal's memory context.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numParams</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>paramno</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>params</name> <operator>=</operator> <operator>(</operator><name>ParamListInfo</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ParamListInfoData</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call> <operator>+</operator>
										<name>numParams</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ParamExternData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* we have static list of params, so no hooks needed */</comment>
		<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>paramFetch</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>paramFetchArg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>paramCompile</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>paramCompileArg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>parserSetup</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>parserSetupArg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>numParams</name></name> <operator>=</operator> <name>numParams</name></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>paramno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>paramno</name> <operator>&lt;</operator> <name>numParams</name></expr>;</condition> <incr><expr><name>paramno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>ptype</name> <init>= <expr><name><name>psrc</name><operator>-&gt;</operator><name>param_types</name><index>[<expr><name>paramno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>plength</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>pval</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>StringInfoData</name></type> <name>pbuf</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type>		<name>csave</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int16</name></type>		<name>pformat</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>plength</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>isNull</name> <operator>=</operator> <operator>(</operator><name>plength</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pvalue</name> <init>= <expr><call><name>pq_getmsgbytes</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>, <argument><expr><name>plength</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Rather than copying data around, we just set up a phony
				 * StringInfo pointing to the correct portion of the message
				 * buffer.  We assume we can scribble on the message buffer so
				 * as to maintain the convention that StringInfos have a
				 * trailing null.  This is grotty but is a big win when
				 * dealing with very large parameter strings.
				 */</comment>
				<expr_stmt><expr><name><name>pbuf</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>pvalue</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pbuf</name><operator>.</operator><name>maxlen</name></name> <operator>=</operator> <name>plength</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pbuf</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>plength</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pbuf</name><operator>.</operator><name>cursor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

				<expr_stmt><expr><name>csave</name> <operator>=</operator> <name><name>pbuf</name><operator>.</operator><name>data</name><index>[<expr><name>plength</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pbuf</name><operator>.</operator><name>data</name><index>[<expr><name>plength</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>pbuf</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
				<expr_stmt><expr><name>csave</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>numPFormats</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>pformat</name> <operator>=</operator> <name><name>pformats</name><index>[<expr><name>paramno</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>numPFormats</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>pformat</name> <operator>=</operator> <name><name>pformats</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>pformat</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* default = text */</comment>

			<if_stmt><if>if <condition>(<expr><name>pformat</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>	<comment type="block">/* text mode */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>typinput</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>typioparam</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pstring</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>getTypeInputInfo</name><argument_list>(<argument><expr><name>ptype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typinput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typioparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * We have to do encoding conversion before calling the
				 * typinput routine.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>pstring</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>pstring</name> <operator>=</operator> <call><name>pg_client_to_server</name><argument_list>(<argument><expr><name><name>pbuf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>plength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><name>pval</name> <operator>=</operator> <call><name>OidInputFunctionCall</name><argument_list>(<argument><expr><name>typinput</name></expr></argument>, <argument><expr><name>pstring</name></expr></argument>, <argument><expr><name>typioparam</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Free result of encoding conversion, if any */</comment>
				<if_stmt><if>if <condition>(<expr><name>pstring</name> <operator>&amp;&amp;</operator> <name>pstring</name> <operator>!=</operator> <name><name>pbuf</name><operator>.</operator><name>data</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>pformat</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>	<comment type="block">/* binary mode */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>typreceive</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>typioparam</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>StringInfo</name></type>	<name>bufptr</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Call the parameter type's binary input converter
				 */</comment>
				<expr_stmt><expr><call><name>getTypeBinaryInputInfo</name><argument_list>(<argument><expr><name>ptype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typreceive</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typioparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>bufptr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>bufptr</name> <operator>=</operator> <operator>&amp;</operator><name>pbuf</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><name>pval</name> <operator>=</operator> <call><name>OidReceiveFunctionCall</name><argument_list>(<argument><expr><name>typreceive</name></expr></argument>, <argument><expr><name>bufptr</name></expr></argument>, <argument><expr><name>typioparam</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Trouble if it didn't eat the whole buffer */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name> <operator>&amp;&amp;</operator> <name><name>pbuf</name><operator>.</operator><name>cursor</name></name> <operator>!=</operator> <name><name>pbuf</name><operator>.</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_BINARY_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"incorrect binary data format in bind parameter %d"</literal></expr></argument>,
									<argument><expr><name>paramno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported format code: %d"</literal></expr></argument>,
								<argument><expr><name>pformat</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>pval</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>		<comment type="block">/* keep compiler quiet */</comment>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* Restore message buffer contents */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>pbuf</name><operator>.</operator><name>data</name><index>[<expr><name>plength</name></expr>]</index></name> <operator>=</operator> <name>csave</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>paramno</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>pval</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>paramno</name></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>isNull</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * We mark the params as CONST.  This ensures that any custom plan
			 * makes full use of the parameter values.
			 */</comment>
			<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>paramno</name></expr>]</index></name><operator>.</operator><name>pflags</name> <operator>=</operator> <name>PARAM_FLAG_CONST</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>paramno</name></expr>]</index></name><operator>.</operator><name>ptype</name> <operator>=</operator> <name>ptype</name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>params</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Done storing stuff in portal's context */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get the result format codes */</comment>
	<expr_stmt><expr><name>numRFormats</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>numRFormats</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rformats</name> <operator>=</operator> <operator>(</operator><name>int16</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numRFormats</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numRFormats</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>rformats</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Obtain a plan from the CachedPlanSource.  Any cruft from (re)planning
	 * will be generated in MessageContext.  The plan refcount will be
	 * assigned to the Portal, so it will be released at portal destruction.
	 */</comment>
	<expr_stmt><expr><name>cplan</name> <operator>=</operator> <call><name>GetCachedPlan</name><argument_list>(<argument><expr><name>psrc</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now we can define the portal.
	 *
	 * DO NOT put any code that could possibly throw an error between the
	 * above GetCachedPlan call and here.
	 */</comment>
	<expr_stmt><expr><call><name>PortalDefineQuery</name><argument_list>(<argument><expr><name>portal</name></expr></argument>,
					  <argument><expr><name>saved_stmt_name</name></expr></argument>,
					  <argument><expr><name>query_string</name></expr></argument>,
					  <argument><expr><name><name>psrc</name><operator>-&gt;</operator><name>commandTag</name></name></expr></argument>,
					  <argument><expr><name><name>cplan</name><operator>-&gt;</operator><name>stmt_list</name></name></expr></argument>,
					  <argument><expr><name>cplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Done with the snapshot used for parameter I/O and parsing/planning */</comment>
	<if_stmt><if>if <condition>(<expr><name>snapshot_set</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * And we're ready to start portal execution.
	 */</comment>
	<expr_stmt><expr><call><name>PortalStart</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>InvalidSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Apply the result format requests to the portal.
	 */</comment>
	<expr_stmt><expr><call><name>PortalSetResultFormat</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>numRFormats</name></expr></argument>, <argument><expr><name>rformats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Send BindComplete.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pq_putemptymessage</name><argument_list>(<argument><expr><literal type="char">'2'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Emit duration logging if appropriate.
	 */</comment>
	<switch>switch <condition>(<expr><call><name>check_log_duration</name><argument_list>(<argument><expr><name>msec_str</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">1</literal></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration: %s ms"</literal></expr></argument>, <argument><expr><name>msec_str</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="number">2</literal></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration: %s ms  bind %s%s%s: %s"</literal></expr></argument>,
							<argument><expr><name>msec_str</name></expr></argument>,
							<argument><expr><ternary><condition><expr><operator>*</operator><name>stmt_name</name></expr> ?</condition><then> <expr><name>stmt_name</name></expr> </then><else>: <expr><literal type="string">"&lt;unnamed&gt;"</literal></expr></else></ternary></expr></argument>,
							<argument><expr><ternary><condition><expr><operator>*</operator><name>portal_name</name></expr> ?</condition><then> <expr><literal type="string">"/"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
							<argument><expr><ternary><condition><expr><operator>*</operator><name>portal_name</name></expr> ?</condition><then> <expr><name>portal_name</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
							<argument><expr><name>redacted_query_string</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_params</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name>save_log_statement_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"BIND MESSAGE STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * exec_execute_message
 *
 * Process an "Execute" message for a portal
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_execute_message</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>portal_name</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>max_rows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CommandDest</name></type> <name>dest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>receiver</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Portal</name></type>		<name>portal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>completed</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>completionTag</name><index>[<expr><name>COMPLETION_TAG_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sourceText</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prepStmtName</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>portalParams</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>save_log_statement_stats</name> <init>= <expr><name>log_statement_stats</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_xact_command</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>execute_is_fetch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>was_logged</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>msec_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* Adjust destination to tell printtup.c what to do */</comment>
	<expr_stmt><expr><name>dest</name> <operator>=</operator> <name>whereToSendOutput</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dest</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dest</name> <operator>=</operator> <name>DestRemoteExecute</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>GetPortalByName</name><argument_list>(<argument><expr><name>portal_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PortalIsValid</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_CURSOR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"portal \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>portal_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the original query was a null string, just return
	 * EmptyQueryResponse.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>commandTag</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>stmts</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NullCommand</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Does the portal contain a transaction command? */</comment>
	<expr_stmt><expr><name>is_xact_command</name> <operator>=</operator> <call><name>IsTransactionStmtList</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>stmts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We must copy the sourceText and prepStmtName into MessageContext in
	 * case the portal is destroyed during finish_xact_command. Can avoid the
	 * copy if it's not an xact command, though.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_xact_command</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>sourceText</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>sourceText</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>prepStmtName</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>prepStmtName</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>prepStmtName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>prepStmtName</name> <operator>=</operator> <literal type="string">"&lt;unnamed&gt;"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * An xact command shouldn't have any parameters, which is a good
		 * thing because they wouldn't be around after finish_xact_command.
		 */</comment>
		<expr_stmt><expr><name>portalParams</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>sourceText</name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>sourceText</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>prepStmtName</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>prepStmtName</name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>prepStmtName</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>prepStmtName</name> <operator>=</operator> <literal type="string">"&lt;unnamed&gt;"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>portalParams</name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>portalParams</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Report query to various monitoring facilities.
	 */</comment>
	<expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name>sourceText</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_RUNNING</name></expr></argument>, <argument><expr><name>sourceText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>commandTag</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>save_log_statement_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>BeginCommand</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>commandTag</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create dest receiver in MessageContext (we don't want it in transaction
	 * context, because that may get deleted if portal contains VACUUM).
	 */</comment>
	<expr_stmt><expr><name>receiver</name> <operator>=</operator> <call><name>CreateDestReceiver</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dest</name> <operator>==</operator> <name>DestRemoteExecute</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetRemoteDestReceiverParams</name><argument_list>(<argument><expr><name>receiver</name></expr></argument>, <argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Ensure we are in a transaction command (this should normally be the
	 * case already due to prior BIND).
	 */</comment>
	<expr_stmt><expr><call><name>start_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we re-issue an Execute protocol request against an existing portal,
	 * then we are only fetching more rows rather than completely re-executing
	 * the query from the start. atStart is never reset for a v3 portal, so we
	 * are safe to use this check.
	 */</comment>
	<expr_stmt><expr><name>execute_is_fetch</name> <operator>=</operator> <operator>!</operator><name><name>portal</name><operator>-&gt;</operator><name>atStart</name></name></expr>;</expr_stmt>

	<comment type="block">/* Log immediately if dictated by log_statement */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>check_log_statement</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>stmts</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s %s%s%s: %s"</literal></expr></argument>,
						<argument><expr><ternary><condition><expr><name>execute_is_fetch</name></expr> ?</condition><then>
						<expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"execute fetch from"</literal></expr></argument>)</argument_list></call></expr> </then><else>:
						<expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"execute"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>,
						<argument><expr><name>prepStmtName</name></expr></argument>,
						<argument><expr><ternary><condition><expr><operator>*</operator><name>portal_name</name></expr> ?</condition><then> <expr><literal type="string">"/"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
						<argument><expr><ternary><condition><expr><operator>*</operator><name>portal_name</name></expr> ?</condition><then> <expr><name>portal_name</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
						<argument><expr><name>sourceText</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_params</name><argument_list>(<argument><expr><name>portalParams</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>was_logged</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we are in aborted transaction state, the only portals we can
	 * actually run are those containing COMMIT or ROLLBACK commands.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>IsTransactionExitStmtList</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>stmts</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_IN_FAILED_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"current transaction is aborted, "</literal>
						<literal type="string">"commands ignored until end of transaction block"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_abort</name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Check for cancel signal before we start execution */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Okay to run the portal.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>max_rows</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>max_rows</name> <operator>=</operator> <name>FETCH_ALL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>completed</name> <operator>=</operator> <call><name>PortalRun</name><argument_list>(<argument><expr><name>portal</name></expr></argument>,
						  <argument><expr><name>max_rows</name></expr></argument>,
						  <argument><expr><name>true</name></expr></argument>, <comment type="block">/* always top level */</comment>
						  <argument><expr><operator>!</operator><name>execute_is_fetch</name> <operator>&amp;&amp;</operator> <name>max_rows</name> <operator>==</operator> <name>FETCH_ALL</name></expr></argument>,
						  <argument><expr><name>receiver</name></expr></argument>,
						  <argument><expr><name>receiver</name></expr></argument>,
						  <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name><name>receiver</name><operator>-&gt;</operator><name>rDestroy</name></name><argument_list>(<argument><expr><name>receiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>completed</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>is_xact_command</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If this was a transaction control statement, commit it.  We
			 * will start a new xact command for the next command (if any).
			 */</comment>
			<expr_stmt><expr><call><name>finish_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * We need a CommandCounterIncrement after every query, except
			 * those that start or end a transaction block.
			 */</comment>
			<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* full command has been executed, reset timeout */</comment>
			<expr_stmt><expr><call><name>disable_statement_timeout</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Send appropriate CommandComplete to client */</comment>
		<expr_stmt><expr><call><name>EndCommand</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Portal run not complete, so send PortalSuspended */</comment>
		<if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pq_putemptymessage</name><argument_list>(<argument><expr><literal type="char">'s'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Emit duration logging if appropriate.
	 */</comment>
	<switch>switch <condition>(<expr><call><name>check_log_duration</name><argument_list>(<argument><expr><name>msec_str</name></expr></argument>, <argument><expr><name>was_logged</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">1</literal></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration: %s ms"</literal></expr></argument>, <argument><expr><name>msec_str</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="number">2</literal></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration: %s ms  %s %s%s%s: %s"</literal></expr></argument>,
							<argument><expr><name>msec_str</name></expr></argument>,
							<argument><expr><ternary><condition><expr><name>execute_is_fetch</name></expr> ?</condition><then>
							<expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"execute fetch from"</literal></expr></argument>)</argument_list></call></expr> </then><else>:
							<expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"execute"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>,
							<argument><expr><name>prepStmtName</name></expr></argument>,
							<argument><expr><ternary><condition><expr><operator>*</operator><name>portal_name</name></expr> ?</condition><then> <expr><literal type="string">"/"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
							<argument><expr><ternary><condition><expr><operator>*</operator><name>portal_name</name></expr> ?</condition><then> <expr><name>portal_name</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
							<argument><expr><name>sourceText</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_params</name><argument_list>(<argument><expr><name>portalParams</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name>save_log_statement_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"EXECUTE MESSAGE STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * check_log_statement
 *		Determine whether command should be logged because of log_statement
 *
 * stmt_list can be either raw grammar output or a list of planned
 * statements
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_log_statement</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>stmt_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>stmt_item</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>log_statement</name> <operator>==</operator> <name>LOGSTMT_NONE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>log_statement</name> <operator>==</operator> <name>LOGSTMT_ALL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Else we have to inspect the statement(s) to see whether to log */</comment>
	<macro><name>foreach</name><argument_list>(<argument>stmt_item</argument>, <argument>stmt_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>stmt_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>GetCommandLogLevel</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>log_statement</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * check_log_duration
 *		Determine whether current command's duration should be logged
 *
 * Returns:
 *		0 if no logging is needed
 *		1 if just the duration should be logged
 *		2 if duration and query details should be logged
 *
 * If logging is needed, the duration in msec is formatted into msec_str[],
 * which must be a 32-byte buffer.
 *
 * was_logged should be true if caller already logged query details (this
 * essentially prevents 2 from being returned).
 */</comment>
<function><type><name>int</name></type>
<name>check_log_duration</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>msec_str</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>was_logged</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>log_duration</name> <operator>||</operator> <name>log_min_duration_statement</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>long</name></type>		<name>secs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>usecs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>msecs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>exceeded</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>TimestampDifference</name><argument_list>(<argument><expr><call><name>GetCurrentStatementStartTimestamp</name><argument_list>()</argument_list></call></expr></argument>,
							<argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>secs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>usecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>msecs</name> <operator>=</operator> <name>usecs</name> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * This odd-looking test for log_min_duration_statement being exceeded
		 * is designed to avoid integer overflow with very long durations:
		 * don't compute secs * 1000 until we've verified it will fit in int.
		 */</comment>
		<expr_stmt><expr><name>exceeded</name> <operator>=</operator> <operator>(</operator><name>log_min_duration_statement</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					<operator>(</operator><name>log_min_duration_statement</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
					 <operator>(</operator><name>secs</name> <operator>&gt;</operator> <name>log_min_duration_statement</name> <operator>/</operator> <literal type="number">1000</literal> <operator>||</operator>
					  <name>secs</name> <operator>*</operator> <literal type="number">1000</literal> <operator>+</operator> <name>msecs</name> <operator>&gt;=</operator> <name>log_min_duration_statement</name><operator>)</operator><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>exceeded</name> <operator>||</operator> <name>log_duration</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>msec_str</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="string">"%ld.%03d"</literal></expr></argument>,
					 <argument><expr><name>secs</name> <operator>*</operator> <literal type="number">1000</literal> <operator>+</operator> <name>msecs</name></expr></argument>, <argument><expr><name>usecs</name> <operator>%</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>exceeded</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>was_logged</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * errdetail_execute
 *
 * Add an errdetail() line showing the query referenced by an EXECUTE, if any.
 * The argument is the raw parsetree list.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>errdetail_execute</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>raw_parsetree_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>parsetree_item</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>parsetree_item</argument>, <argument>raw_parsetree_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RawStmt</name>    <modifier>*</modifier></type><name>parsetree</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RawStmt</name></expr></argument>, <argument><expr><name>parsetree_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>, <argument><expr><name>ExecuteStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ExecuteStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>ExecuteStmt</name> <operator>*</operator><operator>)</operator> <name><name>parsetree</name><operator>-&gt;</operator><name>stmt</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PreparedStatement</name> <modifier>*</modifier></type><name>pstmt</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>pstmt</name> <operator>=</operator> <call><name>FetchPreparedStatement</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>pstmt</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"prepare: %s"</literal></expr></argument>, <argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>plansource</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><literal type="number">0</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * errdetail_params
 *
 * Add an errdetail() line showing bind-parameter data, if available.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>errdetail_params</name><parameter_list>(<parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* We mustn't call user-defined I/O functions when in an aborted xact */</comment>
	<if_stmt><if>if <condition>(<expr><name>params</name> <operator>&amp;&amp;</operator> <name><name>params</name><operator>-&gt;</operator><name>numParams</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>param_str</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>paramno</name></decl>;</decl_stmt>

		<comment type="block">/* This code doesn't support dynamic param lists */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>paramFetch</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Make sure any trash is generated in MessageContext */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>param_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>paramno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>paramno</name> <operator>&lt;</operator> <name><name>params</name><operator>-&gt;</operator><name>numParams</name></name></expr>;</condition> <incr><expr><name>paramno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ParamExternData</name> <modifier>*</modifier></type><name>prm</name> <init>= <expr><operator>&amp;</operator><name><name>params</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>paramno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>typoutput</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>typisvarlena</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pstring</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>param_str</name></expr></argument>, <argument><expr><literal type="string">"%s$%d = "</literal></expr></argument>,
							 <argument><expr><ternary><condition><expr><name>paramno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">", "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
							 <argument><expr><name>paramno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name> <operator>||</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>param_str</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typoutput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typisvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>pstring</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typoutput</name></expr></argument>, <argument><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>param_str</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>pstring</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* double single quotes */</comment>
					<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>param_str</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>param_str</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>param_str</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"parameters: %s"</literal></expr></argument>, <argument><expr><name><name>param_str</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>param_str</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * errdetail_abort
 *
 * Add an errdetail() line showing abort reason, if any.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>errdetail_abort</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>MyProc</name><operator>-&gt;</operator><name>recoveryConflictPending</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"abort reason: recovery conflict"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * errdetail_recovery_conflict
 *
 * Add an errdetail() line showing conflict source.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>errdetail_recovery_conflict</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>RecoveryConflictReason</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_BUFFERPIN</name></expr>:</case>
			<expr_stmt><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"User was holding shared buffer pin for too long."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_LOCK</name></expr>:</case>
			<expr_stmt><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"User was holding a relation lock for too long."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_TABLESPACE</name></expr>:</case>
			<expr_stmt><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"User was or might have been using tablespace that must be dropped."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_SNAPSHOT</name></expr>:</case>
			<expr_stmt><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"User query might have needed to see row versions that must be removed."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_STARTUP_DEADLOCK</name></expr>:</case>
			<expr_stmt><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"User transaction caused buffer deadlock with recovery."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_DATABASE</name></expr>:</case>
			<expr_stmt><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"User was connected to a database that must be dropped."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
			<comment type="block">/* no errdetail */</comment>
	</block_content>}</block></switch>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * exec_describe_statement_message
 *
 * Process a "Describe" message for a prepared statement
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_describe_statement_message</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmt_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>psrc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Start up a transaction command. (Note that this will normally change
	 * current memory context.) Nothing happens if we are already in one.
	 */</comment>
	<expr_stmt><expr><call><name>start_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Switch back to message context */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Find prepared statement */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PreparedStatement</name> <modifier>*</modifier></type><name>pstmt</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>pstmt</name> <operator>=</operator> <call><name>FetchPreparedStatement</name><argument_list>(<argument><expr><name>stmt_name</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>psrc</name> <operator>=</operator> <name><name>pstmt</name><operator>-&gt;</operator><name>plansource</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* special-case the unnamed statement */</comment>
		<expr_stmt><expr><name>psrc</name> <operator>=</operator> <name>unnamed_stmt_psrc</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>psrc</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_PSTATEMENT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unnamed prepared statement does not exist"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Prepared statements shouldn't have changeable result descs */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>psrc</name><operator>-&gt;</operator><name>fixed_result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we are in aborted transaction state, we can't run
	 * SendRowDescriptionMessage(), because that needs catalog accesses.
	 * Hence, refuse to Describe statements that return data.  (We shouldn't
	 * just refuse all Describes, since that might break the ability of some
	 * clients to issue COMMIT or ROLLBACK commands, if they use code that
	 * blindly Describes whatever it does.)  We can Describe parameters
	 * without doing anything dangerous, so we don't restrict that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
		<name><name>psrc</name><operator>-&gt;</operator><name>resultDesc</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_IN_FAILED_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"current transaction is aborted, "</literal>
						<literal type="string">"commands ignored until end of transaction block"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_abort</name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>!=</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* can't actually do anything... */</comment>

	<comment type="block">/*
	 * First describe the parameters...
	 */</comment>
	<expr_stmt><expr><call><name>pq_beginmessage_reuse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>row_description_buf</name></expr></argument>, <argument><expr><literal type="char">'t'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* parameter description
														 * message type */</comment>
	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>row_description_buf</name></expr></argument>, <argument><expr><name><name>psrc</name><operator>-&gt;</operator><name>num_params</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>psrc</name><operator>-&gt;</operator><name>num_params</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>ptype</name> <init>= <expr><name><name>psrc</name><operator>-&gt;</operator><name>param_types</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>row_description_buf</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>ptype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>pq_endmessage_reuse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>row_description_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Next send RowDescription or NoData to describe the result...
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>psrc</name><operator>-&gt;</operator><name>resultDesc</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>

		<comment type="block">/* Get the plan's primary targetlist */</comment>
		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>CachedPlanGetTargetList</name><argument_list>(<argument><expr><name>psrc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SendRowDescriptionMessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>row_description_buf</name></expr></argument>,
								  <argument><expr><name><name>psrc</name><operator>-&gt;</operator><name>resultDesc</name></name></expr></argument>,
								  <argument><expr><name>tlist</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pq_putemptymessage</name><argument_list>(<argument><expr><literal type="char">'n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* NoData */</comment>

</block_content>}</block></function>

<comment type="block">/*
 * exec_describe_portal_message
 *
 * Process a "Describe" message for a portal
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_describe_portal_message</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>portal_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Portal</name></type>		<name>portal</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Start up a transaction command. (Note that this will normally change
	 * current memory context.) Nothing happens if we are already in one.
	 */</comment>
	<expr_stmt><expr><call><name>start_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Switch back to message context */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>GetPortalByName</name><argument_list>(<argument><expr><name>portal_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PortalIsValid</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_CURSOR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"portal \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>portal_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we are in aborted transaction state, we can't run
	 * SendRowDescriptionMessage(), because that needs catalog accesses.
	 * Hence, refuse to Describe portals that return data.  (We shouldn't just
	 * refuse all Describes, since that might break the ability of some
	 * clients to issue COMMIT or ROLLBACK commands, if they use code that
	 * blindly Describes whatever it does.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
		<name><name>portal</name><operator>-&gt;</operator><name>tupDesc</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_IN_FAILED_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"current transaction is aborted, "</literal>
						<literal type="string">"commands ignored until end of transaction block"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_abort</name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>!=</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* can't actually do anything... */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>tupDesc</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SendRowDescriptionMessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>row_description_buf</name></expr></argument>,
								  <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></argument>,
								  <argument><expr><call><name>FetchPortalTargetList</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>formats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pq_putemptymessage</name><argument_list>(<argument><expr><literal type="char">'n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* NoData */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * Convenience routines for starting/committing a single command.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>start_xact_command</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>xact_started</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>xact_started</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Start statement timeout if necessary.  Note that this'll intentionally
	 * not reset the clock on an already started timeout, to avoid the timing
	 * overhead when start_xact_command() is invoked repeatedly, without an
	 * interceding finish_xact_command() (e.g. parse/bind/execute).  If that's
	 * not desired, the timeout has to be disabled explicitly.
	 */</comment>
	<expr_stmt><expr><call><name>enable_statement_timeout</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>finish_xact_command</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* cancel active statement timeout after each command */</comment>
	<expr_stmt><expr><call><name>disable_statement_timeout</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>xact_started</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MEMORY_CONTEXT_CHECKING</name></cpp:ifdef>
		<comment type="block">/* Check all memory contexts that weren't freed during commit */</comment>
		<comment type="block">/* (those that were, were checked before being deleted) */</comment>
		<expr_stmt><expr><call><name>MemoryContextCheck</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SHOW_MEMORY_STATS</name></cpp:ifdef>
		<comment type="block">/* Print mem stats after each commit for leak tracking */</comment>
		<expr_stmt><expr><call><name>MemoryContextStats</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr_stmt><expr><name>xact_started</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Convenience routines for checking whether a statement is one of the
 * ones that we allow in transaction-aborted state.
 */</comment>

<comment type="block">/* Test a bare parsetree */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsTransactionExitStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>parsetree</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>TransactionStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TransactionStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>TransactionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>TRANS_STMT_COMMIT</name> <operator>||</operator>
			<name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>TRANS_STMT_PREPARE</name> <operator>||</operator>
			<name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>TRANS_STMT_ROLLBACK</name> <operator>||</operator>
			<name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>TRANS_STMT_ROLLBACK_TO</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Test a list that contains PlannedStmt nodes */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsTransactionExitStmtList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pstmts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>pstmts</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name> <init>= <expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>, <argument><expr><name>pstmts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name> <operator>&amp;&amp;</operator>
			<call><name>IsTransactionExitStmt</name><argument_list>(<argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Test a list that contains PlannedStmt nodes */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsTransactionStmtList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pstmts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>pstmts</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name> <init>= <expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>, <argument><expr><name>pstmts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name> <operator>&amp;&amp;</operator>
			<call><name>IsA</name><argument_list>(<argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>, <argument><expr><name>TransactionStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Release any existing unnamed prepared statement */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>drop_unnamed_stmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* paranoia to avoid a dangling pointer in case of error */</comment>
	<if_stmt><if>if <condition>(<expr><name>unnamed_stmt_psrc</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>psrc</name> <init>= <expr><name>unnamed_stmt_psrc</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>unnamed_stmt_psrc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DropCachedPlan</name><argument_list>(<argument><expr><name>psrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* --------------------------------
 *		signal handler routines used in PostgresMain()
 * --------------------------------
 */</comment>

<comment type="block">/*
 * quickdie() occurs when signalled SIGQUIT by the postmaster.
 *
 * Some backend has bought the farm,
 * so we need to stop what we're doing and exit.
 */</comment>
<function><type><name>void</name></type>
<name>quickdie</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>sigaddset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>, <argument><expr><name>SIGQUIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* prevent nested calls */</comment>
	<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prevent interrupts while exiting; though we just blocked signals that
	 * would queue new interrupts, one may have been pending.  We don't want a
	 * quickdie() downgraded to a mere query cancel.
	 */</comment>
	<expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we're aborting out of client auth, don't risk trying to send
	 * anything to the client; we will likely violate the protocol, not to
	 * mention that we may have interrupted the guts of OpenSSL or some
	 * authentication library.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ClientAuthInProgress</name> <operator>&amp;&amp;</operator> <name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>whereToSendOutput</name> <operator>=</operator> <name>DestNone</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Notify the client before exiting, to give a clue on what happened.
	 *
	 * It's dubious to call ereport() from a signal handler.  It is certainly
	 * not async-signal safe.  But it seems better to try, than to disconnect
	 * abruptly and leave the client wondering what happened.  It's remotely
	 * possible that we crash or hang while trying to send the message, but
	 * receiving a SIGQUIT is a sign that something has already gone badly
	 * wrong, so there's not much to lose.  Assuming the postmaster is still
	 * running, it will SIGKILL us soon if we get stuck for some reason.
	 *
	 * Ideally this should be ereport(FATAL), but then we'd not get control
	 * back...
	 */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CRASH_SHUTDOWN</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating connection because of crash of another server process"</literal></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The postmaster has commanded this server process to roll back"</literal>
					   <literal type="string">" the current transaction and exit, because another"</literal>
					   <literal type="string">" server process exited abnormally and possibly corrupted"</literal>
					   <literal type="string">" shared memory."</literal></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"In a moment you should be able to reconnect to the"</literal>
					 <literal type="string">" database and repeat your command."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>YBOnPostgresBackendShutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We DO NOT want to run proc_exit() or atexit() callbacks -- we're here
	 * because shared memory may be corrupted, so we don't want to try to
	 * clean up our transaction.  Just nail the windows shut and get out of
	 * town.  The callbacks wouldn't be safe to run from a signal handler,
	 * anyway.
	 *
	 * Note we do _exit(2) not _exit(0).  This is to force the postmaster into
	 * a system reset cycle if someone sends a manual SIGQUIT to a random
	 * backend.  This is necessary precisely because we don't clean up our
	 * shared memory state.  (The "dead man switch" mechanism in pmsignal.c
	 * should ensure the postmaster sees this as a crash, too, but no harm in
	 * being doubly sure.)
	 */</comment>
	<expr_stmt><expr><call><name>_exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Shutdown signal from postmaster: abort transaction and exit
 * at soonest convenient time
 */</comment>
<function><type><name>void</name></type>
<name>die</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Don't joggle the elbow of proc_exit */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>proc_exit_inprogress</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>InterruptPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ProcDiePending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>YBCInterruptPgGate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If we're still here, waken anything waiting on the process latch */</comment>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we're in single user mode, we want to quit immediately - we can't
	 * rely on latches as they wouldn't work when stdin/stdout is a file.
	 * Rather ugly, but it's unlikely to be worthwhile to invest much more
	 * effort just for the benefit of single user mode.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>DoingCommandRead</name> <operator>&amp;&amp;</operator> <name>whereToSendOutput</name> <operator>!=</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ProcessInterrupts</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Query-cancel signal from postmaster: abort current transaction
 * at soonest convenient time
 */</comment>
<function><type><name>void</name></type>
<name>StatementCancelHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Don't joggle the elbow of proc_exit
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>proc_exit_inprogress</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>InterruptPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>QueryCancelPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If we're still here, waken anything waiting on the process latch */</comment>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* signal handler for floating point exception */</comment>
<function><type><name>void</name></type>
<name>FloatExceptionHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* We're not returning, so no need to save errno */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FLOATING_POINT_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"floating-point exception"</literal></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"An invalid floating-point operation was signaled. "</literal>
					   <literal type="string">"This probably means an out-of-range result or an "</literal>
					   <literal type="string">"invalid operation, such as division by zero."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SIGHUP: set flag to re-read config file at next convenient time.
 *
 * Sets the ConfigReloadPending flag, which should be checked at convenient
 * places inside main loops. (Better than doing the reading in the signal
 * handler, ey?)
 */</comment>
<function><type><name>void</name></type>
<name>PostgresSigHupHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>ConfigReloadPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RecoveryConflictInterrupt: out-of-line portion of recovery conflict
 * handling following receipt of SIGUSR1. Designed to be similar to die()
 * and StatementCancelHandler(). Called only by a normal user backend
 * that begins a transaction during recovery.
 */</comment>
<function><type><name>void</name></type>
<name>RecoveryConflictInterrupt</name><parameter_list>(<parameter><decl><type><name>ProcSignalReason</name></type> <name>reason</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Don't joggle the elbow of proc_exit
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>proc_exit_inprogress</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>RecoveryConflictReason</name> <operator>=</operator> <name>reason</name></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name>reason</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_STARTUP_DEADLOCK</name></expr>:</case>

				<comment type="block">/*
				 * If we aren't waiting for a lock we can never deadlock.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsWaitingForLock</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return;</return></block_content></block></if></if_stmt>

				<comment type="block">/* Intentional fall through to check wait for pin */</comment>
				<expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_BUFFERPIN</name></expr>:</case>

				<comment type="block">/*
				 * If we aren't blocking the Startup process there is nothing
				 * more to do.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HoldingBufferPinThatDelaysRecovery</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return;</return></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>recoveryConflictPending</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<comment type="block">/* Intentional fall through to error handling */</comment>
				<expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_LOCK</name></expr>:</case>
			<case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_TABLESPACE</name></expr>:</case>
			<case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_SNAPSHOT</name></expr>:</case>

				<comment type="block">/*
				 * If we aren't in a transaction any longer then ignore.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsTransactionOrTransactionBlock</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return;</return></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * If we can abort just the current subtransaction then we are
				 * OK to throw an ERROR to resolve the conflict. Otherwise
				 * drop through to the FATAL case.
				 *
				 * XXX other times that we can throw just an ERROR *may* be
				 * PROCSIG_RECOVERY_CONFLICT_LOCK if no locks are held in
				 * parent transactions
				 *
				 * PROCSIG_RECOVERY_CONFLICT_SNAPSHOT if no snapshots are held
				 * by parent transactions and the transaction is not
				 * transaction-snapshot mode
				 *
				 * PROCSIG_RECOVERY_CONFLICT_TABLESPACE if no temp files or
				 * cursors open in parent transactions
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsSubTransaction</name><argument_list>()</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * If we already aborted then we no longer need to cancel.
					 * We do this here since we do not wish to ignore aborted
					 * subtransactions, which must cause FATAL, currently.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return;</return></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>RecoveryConflictPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>QueryCancelPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>InterruptPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Intentional fall through to session cancel */</comment>
				<expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_DATABASE</name></expr>:</case>
				<expr_stmt><expr><name>RecoveryConflictPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>ProcDiePending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>InterruptPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"unrecognized conflict mode: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>RecoveryConflictPending</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>QueryCancelPending</name> <operator>||</operator> <name>ProcDiePending</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * All conflicts apart from database cause dynamic errors where the
		 * command or transaction can be retried at a later point with some
		 * potential for success. No need to reset this, since non-retryable
		 * conflict errors are currently FATAL.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>reason</name> <operator>==</operator> <name>PROCSIG_RECOVERY_CONFLICT_DATABASE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>RecoveryConflictRetryable</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Set the process latch. This function essentially emulates signal
	 * handlers like die() and StatementCancelHandler() and it seems prudent
	 * to behave similarly as they do.
	 */</comment>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ProcessInterrupts: out-of-line portion of CHECK_FOR_INTERRUPTS() macro
 *
 * If an interrupt condition is pending, and it's safe to service it,
 * then clear the flag and accept the interrupt.  Called only when
 * InterruptPending is true.
 */</comment>
<function><type><name>void</name></type>
<name>ProcessInterrupts</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* OK to accept any interrupts now? */</comment>
	<if_stmt><if>if <condition>(<expr><name>InterruptHoldoffCount</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>CritSectionCount</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>InterruptPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ProcDiePending</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ProcDiePending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>QueryCancelPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* ProcDie trumps QueryCancel */</comment>
		<expr_stmt><expr><call><name>LockErrorCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* As in quickdie, don't risk sending to client during auth */</comment>
		<if_stmt><if>if <condition>(<expr><name>ClientAuthInProgress</name> <operator>&amp;&amp;</operator> <name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>whereToSendOutput</name> <operator>=</operator> <name>DestNone</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>ClientAuthInProgress</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_QUERY_CANCELED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"canceling authentication due to timeout"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ADMIN_SHUTDOWN</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating autovacuum process due to administrator command"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsLogicalWorker</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ADMIN_SHUTDOWN</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating logical replication worker due to administrator command"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsLogicalLauncher</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"logical replication launcher shutting down"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * The logical replication launcher can be stopped at any time.
			 * Use exit status 1 so the background worker is restarted.
			 */</comment>
			<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>RecoveryConflictPending</name> <operator>&amp;&amp;</operator> <name>RecoveryConflictRetryable</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pgstat_report_recovery_conflict</name><argument_list>(<argument><expr><name>RecoveryConflictReason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating connection due to conflict with recovery"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_recovery_conflict</name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>RecoveryConflictPending</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Currently there is only one non-retryable recovery conflict */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>RecoveryConflictReason</name> <operator>==</operator> <name>PROCSIG_RECOVERY_CONFLICT_DATABASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pgstat_report_recovery_conflict</name><argument_list>(<argument><expr><name>RecoveryConflictReason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATABASE_DROPPED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating connection due to conflict with recovery"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_recovery_conflict</name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ADMIN_SHUTDOWN</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating connection due to administrator command"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>ClientConnectionLost</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>QueryCancelPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* lost connection trumps QueryCancel */</comment>
		<expr_stmt><expr><call><name>LockErrorCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* don't send to client, we already know the connection to be dead. */</comment>
		<expr_stmt><expr><name>whereToSendOutput</name> <operator>=</operator> <name>DestNone</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"connection to client lost"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If a recovery conflict happens while we are waiting for input from the
	 * client, the client is presumably just sitting idle in a transaction,
	 * preventing recovery from making progress.  Terminate the connection to
	 * dislodge it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>RecoveryConflictPending</name> <operator>&amp;&amp;</operator> <name>DoingCommandRead</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>QueryCancelPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* this trumps QueryCancel */</comment>
		<expr_stmt><expr><name>RecoveryConflictPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LockErrorCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_report_recovery_conflict</name><argument_list>(<argument><expr><name>RecoveryConflictReason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating connection due to conflict with recovery"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_recovery_conflict</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"In a moment you should be able to reconnect to the"</literal>
						 <literal type="string">" database and repeat your command."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Don't allow query cancel interrupts while reading input from the
	 * client, because we might lose sync in the FE/BE protocol.  (Die
	 * interrupts are OK, because we won't read any further messages from the
	 * client in that case.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>QueryCancelPending</name> <operator>&amp;&amp;</operator> <name>QueryCancelHoldoffCount</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Re-arm InterruptPending so that we process the cancel request as
		 * soon as we're done reading the message.
		 */</comment>
		<expr_stmt><expr><name>InterruptPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>QueryCancelPending</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>lock_timeout_occurred</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>stmt_timeout_occurred</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>QueryCancelPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If LOCK_TIMEOUT and STATEMENT_TIMEOUT indicators are both set, we
		 * need to clear both, so always fetch both.
		 */</comment>
		<expr_stmt><expr><name>lock_timeout_occurred</name> <operator>=</operator> <call><name>get_timeout_indicator</name><argument_list>(<argument><expr><name>LOCK_TIMEOUT</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>stmt_timeout_occurred</name> <operator>=</operator> <call><name>get_timeout_indicator</name><argument_list>(<argument><expr><name>STATEMENT_TIMEOUT</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If both were set, we want to report whichever timeout completed
		 * earlier; this ensures consistent behavior if the machine is slow
		 * enough that the second timeout triggers before we get here.  A tie
		 * is arbitrarily broken in favor of reporting a lock timeout.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>lock_timeout_occurred</name> <operator>&amp;&amp;</operator> <name>stmt_timeout_occurred</name> <operator>&amp;&amp;</operator>
			<call><name>get_timeout_finish_time</name><argument_list>(<argument><expr><name>STATEMENT_TIMEOUT</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>get_timeout_finish_time</name><argument_list>(<argument><expr><name>LOCK_TIMEOUT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lock_timeout_occurred</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* report stmt timeout */</comment>

		<if_stmt><if>if <condition>(<expr><name>lock_timeout_occurred</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LockErrorCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_LOCK_NOT_AVAILABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"canceling statement due to lock timeout"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>stmt_timeout_occurred</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LockErrorCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_QUERY_CANCELED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"canceling statement due to statement timeout"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LockErrorCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_QUERY_CANCELED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"canceling autovacuum task"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>RecoveryConflictPending</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>RecoveryConflictPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LockErrorCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pgstat_report_recovery_conflict</name><argument_list>(<argument><expr><name>RecoveryConflictReason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"canceling statement due to conflict with recovery"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_recovery_conflict</name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If we are reading a command from the client, just ignore the cancel
		 * request --- sending an extra error message won't accomplish
		 * anything.  Otherwise, go ahead and throw the error.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>DoingCommandRead</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LockErrorCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_QUERY_CANCELED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"canceling statement due to user request"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>IdleInTransactionSessionTimeoutPending</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Has the timeout setting changed since last we looked? */</comment>
		<if_stmt><if>if <condition>(<expr><name>IdleInTransactionSessionTimeout</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_IDLE_IN_TRANSACTION_SESSION_TIMEOUT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating connection due to idle-in-transaction timeout"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>IdleInTransactionSessionTimeoutPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ParallelMessagePending</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>HandleParallelMessages</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * IA64-specific code to fetch the AR.BSP register for stack depth checks.
 *
 * We currently support gcc, icc, and HP-UX's native compiler here.
 *
 * Note: while icc accepts gcc asm blocks on x86[_64], this is not true on
 * ia64 (at least not in icc versions before 12.x).  So we have to carry a
 * separate implementation for it.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ia64__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__ia64</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__hpux</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__INTEL_COMPILER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* Assume it's HP-UX native compiler */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ia64/sys/inline.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ia64_get_bsp</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>((char *) (_Asm_mov_from_ar(_AREG_BSP, _NO_FENCE)))</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__INTEL_COMPILER</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<comment type="block">/* icc */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;asm/ia64regs.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ia64_get_bsp</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>((char *) __getReg(_IA64_REG_AR_BSP))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<comment type="block">/* gcc */</comment>
<function><type><specifier>static</specifier> <name>__inline__</name> <name>char</name> <modifier>*</modifier></type>
<name>ia64_get_bsp</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

	<comment type="block">/* the ;; is a "stop", seems to be required before fetching BSP */</comment>
	<asm>__asm__ <specifier>__volatile__</specifier>(
						 ";;\n"
						 "	mov	%0=ar.bsp	\n"
:						 "=r"(ret));</asm>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* IA64 */</comment>


<comment type="block">/*
 * set_stack_base: set up reference point for stack depth checking
 *
 * Returns the old reference point, if any.
 */</comment>
<function><type><name>pg_stack_base_t</name></type>
<name>set_stack_base</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name>stack_base</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_stack_base_t</name></type> <name>old</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ia64__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__ia64</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><name><name>old</name><operator>.</operator><name>stack_base_ptr</name></name> <operator>=</operator> <name>stack_base_ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>old</name><operator>.</operator><name>register_stack_base_ptr</name></name> <operator>=</operator> <name>register_stack_base_ptr</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>old</name> <operator>=</operator> <name>stack_base_ptr</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Set up reference point for stack depth checking */</comment>
	<expr_stmt><expr><name>stack_base_ptr</name> <operator>=</operator> <operator>&amp;</operator><name>stack_base</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ia64__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__ia64</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><name>register_stack_base_ptr</name> <operator>=</operator> <call><name>ia64_get_bsp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>old</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * restore_stack_base: restore reference point for stack depth checking
 *
 * This can be used after set_stack_base() to restore the old value. This
 * is currently only used in PL/Java. When PL/Java calls a backend function
 * from different thread, the thread's stack is at a different location than
 * the main thread's stack, so it sets the base pointer before the call, and
 * restores it afterwards.
 */</comment>
<function><type><name>void</name></type>
<name>restore_stack_base</name><parameter_list>(<parameter><decl><type><name>pg_stack_base_t</name></type> <name>base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ia64__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__ia64</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><name>stack_base_ptr</name> <operator>=</operator> <name><name>base</name><operator>.</operator><name>stack_base_ptr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>register_stack_base_ptr</name> <operator>=</operator> <name><name>base</name><operator>.</operator><name>register_stack_base_ptr</name></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>stack_base_ptr</name> <operator>=</operator> <name>base</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * check_stack_depth/stack_is_too_deep: check for excessively deep recursion
 *
 * This should be called someplace in any recursive routine that might possibly
 * recurse deep enough to overflow the stack.  Most Unixen treat stack
 * overflow as an unrecoverable SIGSEGV, so we want to error out ourselves
 * before hitting the hardware limit.
 *
 * check_stack_depth() just throws an error summarily.  stack_is_too_deep()
 * can be used by code that wants to handle the error condition itself.
 */</comment>
<function><type><name>void</name></type>
<name>check_stack_depth</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>stack_is_too_deep</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_STATEMENT_TOO_COMPLEX</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"stack depth limit exceeded"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Increase the configuration parameter \"max_stack_depth\" (currently %dkB), "</literal>
						 <literal type="string">"after ensuring the platform's stack depth limit is adequate."</literal></expr></argument>,
						 <argument><expr><name>max_stack_depth</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>stack_is_too_deep</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name>stack_top_loc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>stack_depth</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Compute distance from reference point to my local variables
	 */</comment>
	<expr_stmt><expr><name>stack_depth</name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name>stack_base_ptr</name> <operator>-</operator> <operator>&amp;</operator><name>stack_top_loc</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Take abs value, since stacks grow up on some machines, down on others
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>stack_depth</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>stack_depth</name> <operator>=</operator> <operator>-</operator><name>stack_depth</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Trouble?
	 *
	 * The test on stack_base_ptr prevents us from erroring out if called
	 * during process setup or in a non-backend process.  Logically it should
	 * be done first, but putting it here avoids wasting cycles during normal
	 * cases.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>stack_depth</name> <operator>&gt;</operator> <name>max_stack_depth_bytes</name> <operator>&amp;&amp;</operator>
		<name>stack_base_ptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * On IA64 there is a separate "register" stack that requires its own
	 * independent check.  For this, we have to measure the change in the
	 * "BSP" pointer from PostgresMain to here.  Logic is just as above,
	 * except that we know IA64's register stack grows up.
	 *
	 * Note we assume that the same max_stack_depth applies to both stacks.
	 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ia64__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__ia64</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><name>stack_depth</name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><call><name>ia64_get_bsp</name><argument_list>()</argument_list></call> <operator>-</operator> <name>register_stack_base_ptr</name><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>stack_depth</name> <operator>&gt;</operator> <name>max_stack_depth_bytes</name> <operator>&amp;&amp;</operator>
		<name>register_stack_base_ptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* IA64 */</comment>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* GUC check hook for max_stack_depth */</comment>
<function><type><name>bool</name></type>
<name>check_max_stack_depth</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>long</name></type>		<name>newval_bytes</name> <init>= <expr><operator>*</operator><name>newval</name> <operator>*</operator> <literal type="number">1024L</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>stack_rlimit</name> <init>= <expr><call><name>get_stack_depth_rlimit</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>stack_rlimit</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>newval_bytes</name> <operator>&gt;</operator> <name>stack_rlimit</name> <operator>-</operator> <name>STACK_DEPTH_SLOP</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>GUC_check_errdetail</name><argument_list>(<argument><expr><literal type="string">"\"max_stack_depth\" must not exceed %ldkB."</literal></expr></argument>,
							<argument><expr><operator>(</operator><name>stack_rlimit</name> <operator>-</operator> <name>STACK_DEPTH_SLOP</name><operator>)</operator> <operator>/</operator> <literal type="number">1024L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>GUC_check_errhint</name><argument_list>(<argument><expr><literal type="string">"Increase the platform's stack depth limit via \"ulimit -s\" or local equivalent."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* GUC assign hook for max_stack_depth */</comment>
<function><type><name>void</name></type>
<name>assign_max_stack_depth</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>long</name></type>		<name>newval_bytes</name> <init>= <expr><name>newval</name> <operator>*</operator> <literal type="number">1024L</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>max_stack_depth_bytes</name> <operator>=</operator> <name>newval_bytes</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * set_debug_options --- apply "-d N" command line option
 *
 * -d is not quite the same as setting log_min_messages because it enables
 * other output options.
 */</comment>
<function><type><name>void</name></type>
<name>set_debug_options</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>debug_flag</name></decl></parameter>, <parameter><decl><type><name>GucContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>debug_flag</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>debugstr</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>debugstr</name></expr></argument>, <argument><expr><literal type="string">"debug%d"</literal></expr></argument>, <argument><expr><name>debug_flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"log_min_messages"</literal></expr></argument>, <argument><expr><name>debugstr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"log_min_messages"</literal></expr></argument>, <argument><expr><literal type="string">"notice"</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>debug_flag</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>context</name> <operator>==</operator> <name>PGC_POSTMASTER</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"log_connections"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"log_disconnections"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>debug_flag</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"log_statement"</literal></expr></argument>, <argument><expr><literal type="string">"all"</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>debug_flag</name> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"debug_print_parse"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>debug_flag</name> <operator>&gt;=</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"debug_print_plan"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>debug_flag</name> <operator>&gt;=</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"debug_print_rewritten"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>bool</name></type>
<name>set_plan_disabling_options</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>GucContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="char">'s'</literal></expr>:</case>				<comment type="block">/* seqscan */</comment>
			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="string">"enable_seqscan"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'i'</literal></expr>:</case>				<comment type="block">/* indexscan */</comment>
			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="string">"enable_indexscan"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'o'</literal></expr>:</case>				<comment type="block">/* indexonlyscan */</comment>
			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="string">"enable_indexonlyscan"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'b'</literal></expr>:</case>				<comment type="block">/* bitmapscan */</comment>
			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="string">"enable_bitmapscan"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'t'</literal></expr>:</case>				<comment type="block">/* tidscan */</comment>
			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="string">"enable_tidscan"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'n'</literal></expr>:</case>				<comment type="block">/* nestloop */</comment>
			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="string">"enable_nestloop"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'m'</literal></expr>:</case>				<comment type="block">/* mergejoin */</comment>
			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="string">"enable_mergejoin"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'h'</literal></expr>:</case>				<comment type="block">/* hashjoin */</comment>
			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="string">"enable_hashjoin"</literal></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<if_stmt><if>if <condition>(<expr><name>tmp</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_stats_option_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="char">'p'</literal></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>optarg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'a'</literal></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* "parser" */</comment>
				<return>return <expr><literal type="string">"log_parser_stats"</literal></expr>;</return></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>optarg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'l'</literal></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* "planner" */</comment>
				<return>return <expr><literal type="string">"log_planner_stats"</literal></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><literal type="char">'e'</literal></expr>:</case>				<comment type="block">/* "executor" */</comment>
			<return>return <expr><literal type="string">"log_executor_stats"</literal></expr>;</return>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 * process_postgres_switches
 *	   Parse command line arguments for PostgresMain
 *
 * This is called twice, once for the "secure" options coming from the
 * postmaster or command line, and once for the "insecure" options coming
 * from the client's startup packet.  The latter have the same syntax but
 * may be restricted in what they can do.
 *
 * argv[0] is ignored in either case (it's assumed to be the program name).
 *
 * ctx is PGC_POSTMASTER for secure options, PGC_BACKEND for insecure options
 * coming from the client, or PGC_SU_BACKEND for insecure options coming from
 * a superuser client.
 *
 * If a database name is present in the command line arguments, it's
 * returned into *dbname (this is allowed only if *dbname is initially NULL).
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>process_postgres_switches</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>GucContext</name></type> <name>ctx</name></decl></parameter>,
						  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>dbname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>secure</name> <init>= <expr><operator>(</operator><name>ctx</name> <operator>==</operator> <name>PGC_POSTMASTER</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>errs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GucSource</name></type>	<name>gucsource</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>flag</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>secure</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>gucsource</name> <operator>=</operator> <name>PGC_S_ARGV</name></expr>;</expr_stmt> <comment type="block">/* switches came from command line */</comment>

		<comment type="block">/* Ignore the initial --single argument, if present */</comment>
		<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--single"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>argv</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>argc</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>gucsource</name> <operator>=</operator> <name>PGC_S_CLIENT</name></expr>;</expr_stmt>	<comment type="block">/* switches came from client */</comment>
	</block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT_OPTERR</name></cpp:ifdef>

	<comment type="block">/*
	 * Turn this off because it's either printed to stderr and not the log
	 * where we'd want it, or argv[0] is now "--single", which would make for
	 * a weird error message.  We print our own error message below.
	 */</comment>
	<expr_stmt><expr><name>opterr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Parse command-line options.  CAUTION: keep this in sync with
	 * postmaster/postmaster.c (the option sets should not conflict) and with
	 * the common help() function in main/main.c.
	 */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>flag</name> <operator>=</operator> <call><name>getopt</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"B:bc:C:D:d:EeFf:h:ijk:lN:nOo:Pp:r:S:sTt:v:W:-:"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>flag</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'B'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"shared_buffers"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'b'</literal></expr>:</case>
				<comment type="block">/* Undocumented flag used for binary upgrades */</comment>
				<if_stmt><if>if <condition>(<expr><name>secure</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>IsBinaryUpgrade</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'C'</literal></expr>:</case>
				<comment type="block">/* ignored for consistency with the postmaster */</comment>
				<break>break;</break>

			<case>case <expr><literal type="char">'D'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>secure</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>userDoption</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'d'</literal></expr>:</case>
				<expr_stmt><expr><call><name>set_debug_options</name><argument_list>(<argument><expr><call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'E'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>secure</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>EchoQuery</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'e'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"datestyle"</literal></expr></argument>, <argument><expr><literal type="string">"euro"</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'F'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"fsync"</literal></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'f'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>set_plan_disabling_options</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>errs</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'h'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"listen_addresses"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'i'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"listen_addresses"</literal></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'j'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>secure</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>UseSemiNewlineNewline</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'k'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"unix_socket_directories"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'l'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"ssl"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'N'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"max_connections"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'n'</literal></expr>:</case>
				<comment type="block">/* ignored for consistency with postmaster */</comment>
				<break>break;</break>

			<case>case <expr><literal type="char">'O'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"allow_system_table_mods"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'o'</literal></expr>:</case>
				<expr_stmt><expr><name>errs</name><operator>++</operator></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'P'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"ignore_system_indexes"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'p'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"port"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'r'</literal></expr>:</case>
				<comment type="block">/* send output (stdout and stderr) to the given file */</comment>
				<if_stmt><if>if <condition>(<expr><name>secure</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>OutputFileName</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'S'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"work_mem"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'s'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"log_statement_stats"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'T'</literal></expr>:</case>
				<comment type="block">/* ignored for consistency with the postmaster */</comment>
				<break>break;</break>

			<case>case <expr><literal type="char">'t'</literal></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>get_stats_option_name</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>tmp</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>errs</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<break>break;</break>
				</block_content>}</block>

			<case>case <expr><literal type="char">'v'</literal></expr>:</case>

				<comment type="block">/*
				 * -v is no longer used in normal operation, since
				 * FrontendProtocol is already set before we get here. We keep
				 * the switch only for possible use in standalone operation,
				 * in case we ever support using normal FE/BE protocol with a
				 * standalone backend.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>secure</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>FrontendProtocol</name> <operator>=</operator> <operator>(</operator><name>ProtocolVersion</name><operator>)</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'W'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"post_auth_delay"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'c'</literal></expr>:</case>
			<case>case <expr><literal type="char">'-'</literal></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name></decl>,
							   <decl><type ref="prev"><modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>ParseLongOption</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>value</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>flag</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"--%s requires a value"</literal></expr></argument>,
											<argument><expr><name>optarg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"-c %s requires a value"</literal></expr></argument>,
											<argument><expr><name>optarg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				</block_content>}</block>

			<default>default:</default>
				<expr_stmt><expr><name>errs</name><operator>++</operator></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><name>errs</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Optional database name should be there only if *dbname is NULL.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>errs</name> <operator>&amp;&amp;</operator> <name>dbname</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>dbname</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>argc</name> <operator>-</operator> <name>optind</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>dbname</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>optind</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>errs</name> <operator>||</operator> <name>argc</name> <operator>!=</operator> <name>optind</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errs</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>optind</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>			<comment type="block">/* complain about the previous argument */</comment>

		<comment type="block">/* spell the error message a bit differently depending on context */</comment>
		<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid command-line argument for server process: %s"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information."</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s: invalid command-line argument: %s"</literal></expr></argument>,
							<argument><expr><name>progname</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information."</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Reset getopt(3) library so that it will work correctly in subprocesses
	 * or when this function is called a second time with another array.
	 */</comment>
	<expr_stmt><expr><name>optind</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT_OPTRESET</name></cpp:ifdef>
	<expr_stmt><expr><name>optreset</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>				<comment type="block">/* some systems need this too */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>YbPreloadRelCacheHelper</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>catalog_master_version</name> <init>=
		<expr><call><name>YbGetCatalogCacheVersionForTablePrefetching</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>YBCPgResetCatalogReadTime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>YBCStartSysTablePrefetching</name><argument_list>(<argument><expr><name>catalog_master_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>YBPreloadRelCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>YBCStopSysTablePrefetching</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>YBCStopSysTablePrefetching</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Reload the postgres caches and update the cache version.
 * Note: if catalog changes sneaked in since getting the
 * version it is unfortunate but ok. The master version will have
 * changed too (making our version number obsolete) so we will just end
 * up needing to do another cache refresh later.
 * See the comment for yb_catalog_cache_version in 'pg_yb_utils.c' for
 * more details.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>YBRefreshCache</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check that we are not already inside a transaction or we might end up
	 * leaking cache references for any open relations (i.e. relations in-use by
	 * the current transaction).
	 *
	 * Caller(s) should have already ensured that this is the case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>xact_started</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
		        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Cannot refresh cache within a transaction"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>yb_debug_log_catcache_events</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Refreshing catalog cache."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Get the latest syscatalog version from the master.
	 * Reset the cached version type if needed to force reading catalog version
	 * from the catalog table first.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>yb_catalog_version_type</name> <operator>!=</operator> <name>CATALOG_VERSION_CATALOG_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>yb_catalog_version_type</name> <operator>=</operator> <name>CATALOG_VERSION_UNSET</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Need to execute some (read) queries internally so start a local txn. */</comment>
	<expr_stmt><expr><call><name>start_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clear and reload system catalog caches, including all callbacks. */</comment>
	<expr_stmt><expr><call><name>ResetCatalogCaches</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CallSystemCacheCallbacks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>YbPreloadRelCacheHelper</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Also invalidate the pggate cache. */</comment>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgInvalidateCache</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>yb_need_cache_refresh</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>finish_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>YBTableSchemaVersionMismatchError</name><parameter_list>(<parameter><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>table_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>table_cache_refresh_search_str</name> <init>= <expr><literal type="string">"schema version mismatch for table "</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>table_to_refresh</name> <init>= <expr><call><name>strstr</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>, <argument><expr><name>table_cache_refresh_search_str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>table_to_refresh</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>table_to_refresh</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>table_cache_refresh_search_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>size_of_uuid</name> <init>= <expr><literal type="number">16</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* boost::uuids::uuid::static_size() */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>size_of_hex_uuid</name> <init>= <expr><name>size_of_uuid</name> <operator>*</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>table_to_refresh</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>size_of_hex_uuid</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>table_id</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>table_id</name> <operator>=</operator> <call><name>pnstrdup</name><argument_list>(<argument><expr><name>table_to_refresh</name></expr></argument>, <argument><expr><name>size_of_hex_uuid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>YBPrepareCacheRefreshIfNeeded</name><parameter_list>(<parameter><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>consider_retry</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>need_retry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>need_retry</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * A retry is only required if the transaction is handled by YugaByte.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>table_to_refresh</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>need_table_cache_refresh</name> <init>=
	    <expr><call><name>YBTableSchemaVersionMismatchError</name><argument_list>(<argument><expr><name>edata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>table_to_refresh</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get the latest syscatalog version from the master to check if we need
	 * to refresh the cache.
	 */</comment>
	<expr_stmt><expr><call><name>YBCPgResetCatalogReadTime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>catalog_master_version</name> <init>= <expr><call><name>YbGetMasterCatalogVersion</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>need_global_cache_refresh</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>YbGetCatalogCacheVersion</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>catalog_master_version</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>need_global_cache_refresh</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>YbUpdateLastKnownCatalogCacheVersion</name><argument_list>(<argument><expr><name>catalog_master_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><call><name>YBCGetGFlags</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>log_ysql_catalog_versions</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>elevel</name> <init>= <expr><ternary><condition><expr><name>need_global_cache_refresh</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>DEBUG1</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s: got master catalog version: %"</literal> <name>PRIu64</name></expr></argument>,
						<argument><expr><name>__func__</name></expr></argument>, <argument><expr><name>catalog_master_version</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>need_global_cache_refresh</name> <operator>||</operator> <name>need_table_cache_refresh</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Reset catalog version so that the cache gets marked as invalid and
	 * will be refreshed after the txn ends.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>need_global_cache_refresh</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>yb_need_cache_refresh</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>need_table_cache_refresh</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalidating table cache entry %s"</literal></expr></argument>,
						<argument><expr><name>table_to_refresh</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgInvalidateTableCacheByTableId</name><argument_list>(<argument><expr><name>table_to_refresh</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Prepare to retry the query if possible.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>YBNeedRetryAfterCacheRefresh</name><argument_list>(<argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For single-query transactions we abort the current
		 * transaction to undo any already-applied operations
		 * and retry the query.
		 *
		 * For transaction blocks we would have to re-apply
		 * all previous queries and also continue the
		 * transaction for future queries (before commit).
		 * So we just re-throw the error in that case.
		 *
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>consider_retry</name> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>IsTransactionBlock</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>YBCGetDisableTransparentCacheRefreshRetry</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Clear error state */</comment>
			<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Make sure debug_query_string gets reset before we possibly clobber
			 * the storage it points at.
			 */</comment>
			<expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

			<comment type="block">/* Abort the transaction and clean up. */</comment>
			<expr_stmt><expr><call><name>AbortCurrentTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>am_walsender</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>WalSndErrorCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>MyReplicationSlot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ReplicationSlotRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>ReplicationSlotCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>doing_extended_query_message</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ignore_till_sync</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>xact_started</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<comment type="block">/* Refresh cache now so that the retry uses latest version. */</comment>
			<if_stmt><if>if <condition>(<expr><name>need_global_cache_refresh</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>YBRefreshCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><operator>*</operator><name>need_retry</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>need_global_cache_refresh</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type> <name>error_code</name> <init>= <expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * TODO: This error occurs in tablet service when snapshot is outdated.
				 * We should eventually translate this type of error as a retryable error
				 * in the upper layer such as in YBCStatusPgsqlError().
				 */</comment>
				<decl_stmt><decl><type><name>bool</name></type> <name>isInvalidCatalogSnapshotError</name> <init>= <expr><call><name>strstr</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>,
						<argument><expr><literal type="string">"catalog snapshot used for this transaction has been invalidated"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * If we got a schema-version-mismatch error while a DDL happened,
				 * this is likely caused by a conflict between the current
				 * transaction and the DDL transaction.
				 * So we map it to the retryable serialization failure error code.
				 * TODO: consider if we should
				 * 1. map this case to a different (retryable) error code
				 * 2. always map schema-version-mismatch to a retryable error.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>need_table_cache_refresh</name> <operator>||</operator> <name>isInvalidCatalogSnapshotError</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>error_code</name> <operator>=</operator> <name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Report the original error, but add a context mentioning that a
				 * possibly-conflicting, concurrent DDL transaction happened.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>detail</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>edata</name><operator>-&gt;</operator><name>hint</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>yb_txn_errcode</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>yb_txn_errcode</name></name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errcode</name><argument_list>(<argument><expr><name>error_code</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"Catalog Version Mismatch: A DDL occurred "</literal>
										<literal type="string">"while processing this query. Try again."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>yb_txn_errcode</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>yb_txn_errcode</name></name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errcode</name><argument_list>(<argument><expr><name>error_code</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>detail</name></name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>hint</name></name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"Catalog Version Mismatch: A DDL occurred "</literal>
										<literal type="string">"while processing this query. Try again."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>need_table_cache_refresh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Clear error state */</comment>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Parse query tree via pg_parse_query, suppressing log messages below ERROR level.
 * This is useful e.g. for avoiding "not supported yet and will be ignored" warnings.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name><modifier>*</modifier></type> <name>yb_parse_query_silently</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name><modifier>*</modifier></type> <name>parsetree_list</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>prev_log_min_messages</name>    <init>= <expr><name>log_min_messages</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>prev_client_min_messages</name> <init>= <expr><name>client_min_messages</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>log_min_messages</name>    <operator>=</operator> <name>ERROR</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>client_min_messages</name> <operator>=</operator> <name>ERROR</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>parsetree_list</name>      <operator>=</operator> <call><name>pg_parse_query</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>log_min_messages</name>    <operator>=</operator> <name>prev_log_min_messages</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>client_min_messages</name> <operator>=</operator> <name>prev_client_min_messages</name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>log_min_messages</name>    <operator>=</operator> <name>prev_log_min_messages</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>client_min_messages</name> <operator>=</operator> <name>prev_client_min_messages</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>parsetree_list</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>yb_parse_command_tag</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name><modifier>*</modifier></type> <name>parsetree_list</name> <init>= <expr><call><name>yb_parse_query_silently</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>parsetree_list</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>RawStmt</name><modifier>*</modifier></type> <name>raw_parse_tree</name> <init>= <expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>RawStmt</name></expr></argument>, <argument><expr><name>parsetree_list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<return>return <expr><call><name>CreateCommandTag</name><argument_list>(<argument><expr><name><name>raw_parse_tree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>yb_is_begin_transaction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command_tag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>command_tag</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><operator>(</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>command_tag</name></expr></argument>, <argument><expr><literal type="string">"BEGIN"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
	        <call><name>strncmp</name><argument_list>(<argument><expr><name>command_tag</name></expr></argument>, <argument><expr><literal type="string">"START TRANSACTION"</literal></expr></argument>, <argument><expr><literal type="number">17</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Only retry SELECT, INSERT, UPDATE and DELETE commands.
 * Do the minimum parsing to find out what the command is
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>yb_check_retry_allowed</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>query_string</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>command_tag</name> <init>= <expr><call><name>yb_parse_command_tag</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>command_tag</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><operator>(</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>command_tag</name></expr></argument>, <argument><expr><literal type="string">"DELETE"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
	        <call><name>strncmp</name><argument_list>(<argument><expr><name>command_tag</name></expr></argument>, <argument><expr><literal type="string">"INSERT"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
	        <call><name>strncmp</name><argument_list>(<argument><expr><name>command_tag</name></expr></argument>, <argument><expr><literal type="string">"SELECT"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
	        <call><name>strncmp</name><argument_list>(<argument><expr><name>command_tag</name></expr></argument>, <argument><expr><literal type="string">"UPDATE"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>YBCheckSharedCatalogCacheVersion</name><parameter_list>()</parameter_list> <block>{<block_content>
	<comment type="block">/*
	 * We cannot refresh the cache if we are already inside a transaction, so don't
	 * bother checking shared memory.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsTransactionOrTransactionBlock</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Don't check shared memory if we are in initdb. E.g. during initial system
	 * catalog snapshot creation, tablet servers may not be running.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>YBCIsInitDbModeEnvVarSet</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>shared_catalog_version</name> <init>= <expr><call><name>YbGetSharedCatalogVersion</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>need_global_cache_refresh</name> <init>=
		<expr><call><name>YbGetCatalogCacheVersion</name><argument_list>()</argument_list></call> <operator>&lt;</operator> <name>shared_catalog_version</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><call><name>YBCGetGFlags</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>log_ysql_catalog_versions</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>elevel</name> <init>= <expr><ternary><condition><expr><name>need_global_cache_refresh</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>DEBUG1</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s: got tserver catalog version: %"</literal> <name>PRIu64</name></expr></argument>,
						<argument><expr><name>__func__</name></expr></argument>, <argument><expr><name>shared_catalog_version</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>need_global_cache_refresh</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>YbUpdateLastKnownCatalogCacheVersion</name><argument_list>(<argument><expr><name>shared_catalog_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>YBRefreshCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Data needed to restart a query (plaintext or portal) after its execution failed.
 *
 * Note that in case of a portal query, it refers to values from portal's memory context,
 * so it's only valid as long as the portal exists.
 */</comment>
<typedef>typedef <type><struct>struct <name>YBQueryRestartData</name>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type>	<name>portal_name</name></decl>;</decl_stmt>	<comment type="block">/* '\0' for unnamed portal, NULL if not a portal */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type>	<name>query_string</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type>	<name>command_tag</name></decl>;</decl_stmt>
}</block></struct></type> <name>YBQueryRestartData</name>;</typedef>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>YBIsDmlCommandTag</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command_tag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>command_tag</name></expr></argument>, <argument><expr><literal type="string">"UPDATE"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
	       <call><name>strncmp</name><argument_list>(<argument><expr><name>command_tag</name></expr></argument>, <argument><expr><literal type="string">"INSERT"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
	       <call><name>strncmp</name><argument_list>(<argument><expr><name>command_tag</name></expr></argument>, <argument><expr><literal type="string">"DELETE"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Whether we are allowed to restart current query/txn. */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>yb_is_restart_possible</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ErrorData</name><modifier>*</modifier></type> <name>edata</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>attempt</name></decl></parameter>,
					   <parameter><decl><type><specifier>const</specifier> <name>YBQueryRestartData</name><modifier>*</modifier></type> <name>restart_data</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name><modifier>*</modifier></type> <name>retries_exhausted</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name><modifier>*</modifier></type> <name>rc_ignoring_ddl_statement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>yb_debug_log_internal_restarts</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Restart isn't possible, YB is not enabled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Error details: edata-&gt;message=%s edata-&gt;filename=%s edata-&gt;lineno=%d"</literal></expr></argument>,
			 <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_read_restart_error</name> <init>= <expr><call><name>YBCIsRestartReadError</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>yb_txn_errcode</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_conflict_error</name>     <init>= <expr><call><name>YBCIsTxnConflictError</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>yb_txn_errcode</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_read_restart_error</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_conflict_error</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>yb_debug_log_internal_restarts</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Restart isn't possible, code %d isn't a read restart/conflict error"</literal></expr></argument>,
			          <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>yb_txn_errcode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * In case of READ COMMITTED, retries for kConflict are performed indefinitely until statement
	 * timeout is hit.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsYBReadCommitted</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>is_conflict_error</name> <operator>&amp;&amp;</operator> <name>attempt</name> <operator>&gt;=</operator> <operator>*</operator><call><name>YBCGetGFlags</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>ysql_max_write_restart_attempts</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>yb_debug_log_internal_restarts</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Restart isn't possible, we're out of write restart attempts (%d)"</literal></expr></argument>,
			          <argument><expr><name>attempt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>retries_exhausted</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Retries for kReadRestart are performed indefinitely in case the true READ COMMITTED isolation
	 * level implementation is used.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsYBReadCommitted</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>is_read_restart_error</name> <operator>&amp;&amp;</operator> <name>attempt</name> <operator>&gt;=</operator> <operator>*</operator><call><name>YBCGetGFlags</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>ysql_max_read_restart_attempts</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>yb_debug_log_internal_restarts</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Restart isn't possible, we're out of read restart attempts (%d)"</literal></expr></argument>,
			          <argument><expr><name>attempt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>retries_exhausted</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// We can perform kReadRestart retries in READ COMMITTED isolation level even if data has been</comment>
	<comment type="line">// sent as part of the txn, but not as part of the current query. This is because we just have to</comment>
	<comment type="line">// retry the query and not the whole transaction.</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><call><name>IsYBReadCommitted</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>YBIsDataSent</name><argument_list>()</argument_list></call><operator>)</operator> <operator>||</operator>
			<operator>(</operator><call><name>IsYBReadCommitted</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>YBIsDataSentForCurrQuery</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>yb_debug_log_internal_restarts</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Restart isn't possible, data was already sent. Txn error code=%d"</literal></expr></argument>,
								<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>yb_txn_errcode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>restart_data</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>yb_debug_log_internal_restarts</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Restart isn't possible, restart data is missing"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* can only restart SELECT queries */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>restart_data</name><operator>-&gt;</operator><name>query_string</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>yb_debug_log_internal_restarts</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Restart isn't possible, query string is missing"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsSubTransaction</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsYBReadCommitted</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>yb_debug_log_internal_restarts</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Restart isn't possible, savepoints have been used"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>command_tag</name> <init>= <expr><name><name>restart_data</name><operator>-&gt;</operator><name>command_tag</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we're executing a prepared statement, we're interested in the command
	 * tag of the underlying statement.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>command_tag</name></expr></argument>, <argument><expr><literal type="string">"EXECUTE"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name><modifier>*</modifier></type> <name>parsetree_list</name> <init>=
			<expr><call><name>yb_parse_query_silently</name><argument_list>(<argument><expr><name><name>restart_data</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>parsetree_list</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<decl_stmt><decl><type><name>ExecuteStmt</name><modifier>*</modifier></type> <name>execute_stmt</name> <init>=
			<expr><operator>(</operator><name>ExecuteStmt</name><operator>*</operator><operator>)</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>RawStmt</name></expr></argument>, <argument><expr><name>parsetree_list</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>stmt</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PreparedStatement</name><modifier>*</modifier></type> <name>prepared_stmt</name> <init>=
			<expr><call><name>FetchPreparedStatement</name><argument_list>(<argument><expr><name><name>execute_stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* throwError */</comment>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>prepared_stmt</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>command_tag</name> <operator>=</operator> <name><name>prepared_stmt</name><operator>-&gt;</operator><name>plansource</name><operator>-&gt;</operator><name>commandTag</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>is_read</name> <init>= <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>command_tag</name></expr></argument>, <argument><expr><literal type="string">"SELECT"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_dml</name>  <init>= <expr><call><name>YBIsDmlCommandTag</name><argument_list>(<argument><expr><name>command_tag</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsYBReadCommitted</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>YBGetDdlNestingLevel</name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>yb_debug_log_internal_restarts</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"READ COMMITTED retry semantics don't support DDLs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><operator>*</operator><name>rc_ignoring_ddl_statement</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name>is_read</name> <operator>||</operator> <name>is_dml</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// if !read committed, we only support retries with SELECT/UPDATE/INSERT/DELETE. There are other</comment>
		<comment type="line">// statements that might result in a kReadRestart/kConflict like CREATE INDEX. We don't retry</comment>
		<comment type="line">// those as of now.</comment>
		<if_stmt><if>if <condition>(<expr><name>yb_debug_log_internal_restarts</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					 <argument><expr><literal type="string">"Restart isn't possible because statement isn't one of SELECT/UPDATE/INSERT/DELETE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>yb_debug_log_internal_restarts</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Restart is possible"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Collect data necessary for yb_attempt_to_restart_on_error invocation.
 */</comment>
<function><type><specifier>static</specifier> <name>YBQueryRestartData</name><modifier>*</modifier></type>
<name>yb_collect_portal_restart_data</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>portal_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Portal</name></type> <name>portal</name> <init>= <expr><call><name>GetPortalByName</name><argument_list>(<argument><expr><name>portal_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>YBQueryRestartData</name><modifier>*</modifier></type> <name>result</name> <init>= <expr><operator>(</operator><name>YBQueryRestartData</name><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>YBQueryRestartData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>portal_name</name></name>  <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>query_string</name></name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>sourceText</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>command_tag</name></name>  <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>commandTag</name></name></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Restart a portal, preparing it for re-execution.
 *
 * This allows us to reuse portal's MemoryContext, which contains, among other things,
 * bound variables.
 * Some of them might be pointers to a memory within the same context (e.g. arrays),
 * so it's important to preserve the context as-is instead of e.g. copying it into a fresh portal.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>yb_restart_portal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>portal_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Portal</name></type> <name>portal</name> <init>= <expr><call><name>GetPortalByName</name><argument_list>(<argument><expr><name>portal_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>PORTAL_FAILED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Here our goal is to emulate what would PortalDrop + CreatePortal do, but instead of actually
	 * destroying/creating a portal, we're going to reuse an existing one.
	 *
	 * The following code is a selective copy-paste from PortalDrop routine.
	 * Original comments are preserved, even though some of the described use cases
	 * are not applicable here.
	 */</comment>

	<comment type="block">/*
	 * Allow portalcmds.c to clean up the state it knows about, in particular
	 * shutting down the executor if still active.  This step potentially runs
	 * user-defined code so failure has to be expected.  It's the cleanup
	 * hook's responsibility to not try to do that more than once, in the case
	 * that failure occurs and then we come back to drop the portal again
	 * during transaction abort.
	 *
	 * Note: in most paths of control, this will have been done already in
	 * MarkPortalDone or MarkPortalFailed.  We're just making sure.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>cleanup</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name><name>portal</name><operator>-&gt;</operator><name>cleanup</name></name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>cleanup</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If portal has a snapshot protecting its data, release that.  This needs
	 * a little care since the registration will be attached to the portal's
	 * resowner; if the portal failed, we will already have released the
	 * resowner (and the snapshot) during transaction abort.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>holdSnapshot</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>resowner</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UnregisterSnapshotFromOwner</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>holdSnapshot</name></name></expr></argument>,
										<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>resowner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>holdSnapshot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Release any resources still attached to the portal.  There are several
	 * cases being covered here:
	 *
	 * Top transaction commit (indicated by isTopCommit): normally we should
	 * do nothing here and let the regular end-of-transaction resource
	 * releasing mechanism handle these resources too.  However, if we have a
	 * FAILED portal (eg, a cursor that got an error), we'd better clean up
	 * its resources to avoid resource-leakage warning messages.
	 *
	 * Sub transaction commit: never comes here at all, since we don't kill
	 * any portals in AtSubCommit_Portals().
	 *
	 * Main or sub transaction abort: we will do nothing here because
	 * portal-&gt;resowner was already set NULL; the resources were already
	 * cleaned up in transaction abort.
	 *
	 * Ordinary portal drop: must release resources.  However, if the portal
	 * is not FAILED then we do not release its locks.  The locks become the
	 * responsibility of the transaction's ResourceOwner (since it is the
	 * parent of the portal's owner) and will be released when the transaction
	 * eventually ends.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>resowner</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isCommit</name> <init>= <expr><operator>(</operator><name><name>portal</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>PORTAL_FAILED</name><operator>)</operator></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ResourceOwnerRelease</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>resowner</name></name></expr></argument>,
							 <argument><expr><name>RESOURCE_RELEASE_BEFORE_LOCKS</name></expr></argument>,
							 <argument><expr><name>isCommit</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ResourceOwnerRelease</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>resowner</name></name></expr></argument>,
							 <argument><expr><name>RESOURCE_RELEASE_LOCKS</name></expr></argument>,
							 <argument><expr><name>isCommit</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ResourceOwnerRelease</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>resowner</name></name></expr></argument>,
							 <argument><expr><name>RESOURCE_RELEASE_AFTER_LOCKS</name></expr></argument>,
							 <argument><expr><name>isCommit</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ResourceOwnerDelete</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>resowner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>resowner</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Delete tuplestore if present.  We should do this even under error
	 * conditions; since the tuplestore would have been using cross-
	 * transaction storage, its temp files need to be explicitly deleted.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>holdStore</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>holdContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>tuplestore_end</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>holdStore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>holdStore</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* delete tuplestore storage, if any */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>holdContext</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>holdContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


	<comment type="block">/* -------------------------------------------------------------------------
	 * YB NOTE:
	 *
	 * The following code is a selective copy-paste from CreatePortal routine.
	 */</comment>

	<comment type="block">/* create a resource owner for the portal */</comment>
	<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>resowner</name></name> <operator>=</operator> <call><name>ResourceOwnerCreate</name><argument_list>(<argument><expr><name>CurTransactionResourceOwner</name></expr></argument>,
										   <argument><expr><literal type="string">"Portal"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* initialize portal fields that don't start off zero */</comment>
	<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>PORTAL_NEW</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>cleanup</name></name> <operator>=</operator> <name>PortalCleanup</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>createSubid</name></name> <operator>=</operator> <call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>activeSubid</name></name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>createSubid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name>PORTAL_MULTI_QUERY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>cursorOptions</name></name> <operator>=</operator> <name>CURSOR_OPT_NO_SCROLL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>atStart</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>atEnd</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>		<comment type="block">/* disallow fetches until query is set */</comment>
	<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>visible</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>creation_time</name></name> <operator>=</operator> <call><name>GetCurrentStatementStartTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* -------------------------------------------------------------------------
	 * YB NOTE:
	 *
	 * Now that our portal looks like a fresh one, time to prepare and start it.
	 */</comment>

	<comment type="block">/*
	 * No need for GetCachedPlan + PortalDefineQuery routine, everything is in
	 * place already.
	 */</comment>
	<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>PORTAL_DEFINED</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PortalStart</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>portalParams</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* eflags */</comment>, <argument><expr><name>InvalidSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* no need to call PortalSetResultFormat either - formats array is already set */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type>
<name>yb_get_sleep_usecs_on_txn_conflict</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>attempt</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="block">/* Use exponential backoff to calculate the sleep duration. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><call><name>YBCGetGFlags</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>ysql_sleep_before_retry_on_txn_conflict</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * While the guc variables are being changed, RetryMaxBackoffMsecs can be
	 * smaller than RetryMinBackoffMsecs. Return RetryMaxBackoffMsecs in this
	 * case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>RetryMaxBackoffMsecs</name> <operator>&lt;=</operator> <name>RetryMinBackoffMsecs</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>RetryMaxBackoffMsecs</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>RetryMaxBackoffMsecs</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>RetryMinBackoffMsecs</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><call><name>PowerWithUpperLimit</name><argument_list>(<argument><expr><name>RetryBackoffMultiplier</name></expr></argument>, <argument><expr><name>attempt</name></expr></argument>,
				<argument><expr><literal type="number">1.0</literal> <operator>*</operator> <name>RetryMaxBackoffMsecs</name> <operator>/</operator> <name>RetryMinBackoffMsecs</name></expr></argument>)</argument_list></call> <operator>*</operator>
			<name>RetryMinBackoffMsecs</name> <operator>*</operator> <literal type="number">1000</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>yb_maybe_sleep_on_txn_conflict</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>attempt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>YBIsWaitQueueEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If transactions are leveraging the wait queue based infrastructure for
		 * blocking semantics on conflicts, they need not sleep with exponential
		 * backoff between retries. The wait queues ensure that the transaction's
		 * read/ write rpc which faced a kConflict error is unblocked only when all
		 * conflicting transactions have ended (either committed or aborted).
		 */</comment>
		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><call><name>yb_get_sleep_usecs_on_txn_conflict</name><argument_list>(<argument><expr><name>attempt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Process an error that happened during execution with expected read restart
 * errors. Prepares the re-execution if an error is restartable, otherwise -
 * rethrows the error.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>yb_attempt_to_restart_on_error</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>attempt</name></decl></parameter>,
                               <parameter><decl><type><name>YBQueryRestartData</name><modifier>*</modifier></type> <name>restart_data</name></decl></parameter>,
                               <parameter><decl><type><name>MemoryContext</name></type> <name>exec_context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Switch the context back to the original one when server started
	 * processing user request.
	 */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>error_context</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>exec_context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorData</name><modifier>*</modifier></type>    <name>edata</name>         <init>= <expr><call><name>CopyErrorData</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>					<name>retries_exhausted</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>					<name>rc_ignoring_ddl_statement</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>yb_is_restart_possible</name><argument_list>(
					<argument><expr><name>edata</name></expr></argument>, <argument><expr><name>attempt</name></expr></argument>, <argument><expr><name>restart_data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>retries_exhausted</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc_ignoring_ddl_statement</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>yb_debug_log_internal_restarts</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Restarting statement due to kReadRestart/kConflict error:"</literal>
			                <literal type="string">"\nQuery: %s\nError: %s\nAttempt No: %d"</literal></expr></argument>,
			                <argument><expr><name><name>restart_data</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>,
			                <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>,
			                <argument><expr><name>attempt</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/*
		 * Cleanup the error and restart portal.
		 */</comment>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>restart_data</name><operator>-&gt;</operator><name>portal_name</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Restarting portal %s for retry"</literal></expr></argument>, <argument><expr><name><name>restart_data</name><operator>-&gt;</operator><name>portal_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>yb_restart_portal</name><argument_list>(<argument><expr><name><name>restart_data</name><operator>-&gt;</operator><name>portal_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>YBRestoreOutputBufferPosition</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsYBReadCommitted</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsInTransactionBlock</name><argument_list>(<argument><expr><name>true</name></expr></argument> <comment type="block">/* isTopLevel */</comment>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * In this case the txn is not restarted, just the statement is restarted after rolling back
			 * to the internal savepoint registered at start of the statement.
			 */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Rolling back statement"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Presence of triggers pushes additional snapshots. Pop all of them.
			 */</comment>
			<expr_stmt><expr><call><name>PopAllActiveSnapshots</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="line">// TODO(Piyush): Perform pg_session_-&gt;InvalidateForeignKeyReferenceCache() and create tests</comment>
			<comment type="line">// that would fail without this.</comment>

			<comment type="block">/*
			 * Rollback to the savepoint that was started in StartTransactionCommand() for READ COMMITTED
			 * isolation.
			 */</comment>

			<if_stmt><if>if <condition>(<expr><name><name>restart_data</name><operator>-&gt;</operator><name>portal_name</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Portal</name></type> <name>portal</name> <init>= <expr><call><name>GetPortalByName</name><argument_list>(<argument><expr><name><name>restart_data</name><operator>-&gt;</operator><name>portal_name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Set the createSubid to the next internal sub txn that we are going to create after
				 * RollbackAndReleaseCurrentSubTransaction(). This is ensure
				 * RollbackAndReleaseCurrentSubTransaction() doesn't clean up the portal we had just
				 * restarted using yb_restart_portal().
				 */</comment>
				<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>createSubid</name></name> <operator>=</operator> <call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>activeSubid</name></name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>createSubid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ResourceOwnerNewParent</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>resowner</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="line">// TODO(read committed): remove this once the feature is GA</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>GetCurrentTransactionName</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>YB_READ_COMMITTED_INTERNAL_SUB_TXN_NAME</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>RollbackAndReleaseCurrentSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>BeginInternalSubTransactionForReadCommittedStatement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>restart_data</name><operator>-&gt;</operator><name>portal_name</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Portal</name></type> <name>portal</name> <init>= <expr><call><name>GetPortalByName</name><argument_list>(<argument><expr><name><name>restart_data</name><operator>-&gt;</operator><name>portal_name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ResourceOwnerNewParent</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>resowner</name></name></expr></argument>, <argument><expr><name>CurTransactionResourceOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>YBCIsRestartReadError</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>yb_txn_errcode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgRestartReadPoint</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>YBCIsTxnConflictError</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>yb_txn_errcode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgResetTransactionReadPoint</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>yb_maybe_sleep_on_txn_conflict</name><argument_list>(<argument><expr><name>attempt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * We shouldn't really be able to reach here. If yb_is_restart_possible()
				 * was true, the error should have been either of kReadRestart/kConflict
				 */</comment>
				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>error_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * In this case the txn is restarted, which can be done since we haven't executed even the
			 * first statement fully and no data has been sent to the client.
			 */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Restarting txn"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * The txn might or might not have performed writes. Reset the state in
			 * either case to avoid checking/tracking if a write could have been
			 * performed.
			 */</comment>
			<expr_stmt><expr><call><name>YBCRestartWriteTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>YBCIsRestartReadError</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>yb_txn_errcode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>YBCRestartTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>YBCIsTxnConflictError</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>yb_txn_errcode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Recreate the YB state for the transaction. This call preserves the
				 * priority of the current YB transaction so that when we retry, we re-use
				 * the same priority.
				 */</comment>
				<expr_stmt><expr><call><name>YBCRecreateTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>yb_maybe_sleep_on_txn_conflict</name><argument_list>(<argument><expr><name>attempt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * We shouldn't really be able to reach here. If yb_is_restart_possible()
				 * was true, the error should have been either of kReadRestart/kConflict
				 */</comment>
				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>error_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="block">/* if we shouldn't restart - propagate the error */</comment>

		<if_stmt><if>if <condition>(<expr><name>rc_ignoring_ddl_statement</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name> <operator>=</operator> <call><name>psprintf</name><argument_list>(
				<argument><expr><literal type="string">"Read Committed txn cannot proceed because of error in DDL. %s"</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReThrowError</name><argument_list>(<argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>retries_exhausted</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s. %s"</literal></expr></argument>, <argument><expr><literal type="string">"All transparent retries exhausted"</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReThrowError</name><argument_list>(<argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>error_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<typedef>typedef <function_decl><type><name>void</name></type>(<modifier>*</modifier><name>YBFunctor</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl></typedef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>yb_exec_query_wrapper_one_attempt</name><parameter_list>(
	<parameter><decl><type><name>MemoryContext</name></type> <name>exec_context</name></decl></parameter>,
	<parameter><decl><type><name>YBQueryRestartData</name><modifier>*</modifier></type> <name>restart_data</name></decl></parameter>,
	<parameter><decl><type><name>YBFunctor</name></type> <name>functor</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>functor_context</name></decl></parameter>,
	<parameter><decl><type><name>int</name></type> <name>attempt</name></decl></parameter>,
	<parameter><decl><type><name>bool</name><modifier>*</modifier></type> <name>retry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"yb_exec_query_wrapper attempt %d for %s"</literal></expr></argument>, <argument><expr><name>attempt</name></expr></argument>, <argument><expr><name><name>restart_data</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>YBSaveOutputBufferPosition</name><argument_list>(
		<argument><expr><operator>!</operator><call><name>yb_is_begin_transaction</name><argument_list>(<argument><expr><name><name>restart_data</name><operator>-&gt;</operator><name>command_tag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>functor</name>)<argument_list>(<argument><expr><name>functor_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
			* Stop retrying if successful. Note, break or return could not be
			* used here, they would prevent PG_END_TRY();
			*/</comment>
		<expr_stmt><expr><operator>*</operator><name>retry</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>YBResetOperationsBuffering</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>yb_attempt_to_restart_on_error</name><argument_list>(<argument><expr><name>attempt</name></expr></argument>, <argument><expr><name>restart_data</name></expr></argument>, <argument><expr><name>exec_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>yb_exec_query_wrapper</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>exec_context</name></decl></parameter>,
					  <parameter><decl><type><name>YBQueryRestartData</name><modifier>*</modifier></type> <name>restart_data</name></decl></parameter>,
					  <parameter><decl><type><name>YBFunctor</name></type> <name>functor</name></decl></parameter>,
					  <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>functor_context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>retry</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>attempt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>retry</name></expr>;</condition> <incr><expr><operator>++</operator><name>attempt</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>yb_exec_query_wrapper_one_attempt</name><argument_list>(
			<argument><expr><name>exec_context</name></expr></argument>, <argument><expr><name>restart_data</name></expr></argument>, <argument><expr><name>functor</name></expr></argument>, <argument><expr><name>functor_context</name></expr></argument>, <argument><expr><name>attempt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>retry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>yb_exec_simple_query_impl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>query_string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>exec_simple_query</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Wraps exec_simple_query, attempting to transparently do restarts when possible.
 * Accepts execution memory context to revert to in case of an error.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>yb_exec_simple_query</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>query_string</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>exec_context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>YBQueryRestartData</name></type> <name>restart_data</name>  <init>= <expr><block>{
		<expr><operator>.</operator><name>portal_name</name>  <operator>=</operator> <name>NULL</name></expr>,
		<expr><operator>.</operator><name>query_string</name> <operator>=</operator> <name>query_string</name></expr>,
		<expr><operator>.</operator><name>command_tag</name>  <operator>=</operator> <macro><name>yb_parse_command_tag</name><argument_list>(<argument>query_string</argument>)</argument_list></macro></expr>
	}</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>yb_exec_query_wrapper</name><argument_list>(<argument><expr><name>exec_context</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>restart_data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yb_exec_simple_query_impl</name></expr></argument>, <argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>YBExecuteMessageFunctorContext</name>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>portal_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>max_rows</name></decl>;</decl_stmt>
}</block></struct></type> <name>YBExecuteMessageFunctorContext</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>yb_exec_execute_message_impl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>raw_ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>YBExecuteMessageFunctorContext</name><modifier>*</modifier></type> <name>ctx</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>YBExecuteMessageFunctorContext</name><operator>*</operator><operator>)</operator><operator>(</operator><name>raw_ctx</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>exec_execute_message</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>portal_name</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>max_rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Wraps exec_execute_message, attempting to transparently do restarts when possible.
 * Accepts execution memory context to revert to in case of an error.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>yb_exec_execute_message</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>portal_name</name></decl></parameter>,
                        <parameter><decl><type><name>long</name></type> <name>max_rows</name></decl></parameter>,
                        <parameter><decl><type><name>YBQueryRestartData</name><modifier>*</modifier></type> <name>restart_data</name></decl></parameter>,
                        <parameter><decl><type><name>MemoryContext</name></type> <name>exec_context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>YBExecuteMessageFunctorContext</name></type> <name>ctx</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>portal_name</name> <operator>=</operator> <name>portal_name</name></expr>,
		<expr><operator>.</operator><name>max_rows</name> <operator>=</operator> <name>max_rows</name></expr>
	}</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>yb_exec_query_wrapper</name><argument_list>(<argument><expr><name>exec_context</name></expr></argument>, <argument><expr><name>restart_data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yb_exec_execute_message_impl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>yb_report_cache_version_restart</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>query</name></decl></parameter>, <parameter><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
	        <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Restarting statement due to catalog version mismatch:"</literal>
	                <literal type="string">"\nQuery: %s\nError: %s"</literal></expr></argument>,
	                <argument><expr><name>query</name></expr></argument>,
	                <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 * PostgresMain
 *	   postgres main loop -- all backends, interactive or otherwise start here
 *
 * argc/argv are the command line arguments to be used.  (When being forked
 * by the postmaster, these are not the original argv array of the process.)
 * dbname is the name of the database to connect to, or NULL if the database
 * name should be extracted from the command line arguments or defaulted.
 * username is the PostgreSQL user name to be used for the session.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>PostgresMain</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>,
			 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbname</name></decl></parameter>,
			 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>username</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>firstchar</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>input_message</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sigjmp_buf</name></type>	<name>local_sigjmp_buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>bool</name></type> <name>send_ready_for_query</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>disable_idle_in_transaction_timeout</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Initialize startup process environment if necessary. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InitStandaloneProcess</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SetProcessingMode</name><argument_list>(<argument><expr><name>InitProcessing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set default values for command-line options.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InitializeGUCOptions</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Parse command-line options.
	 */</comment>
	<expr_stmt><expr><call><name>process_postgres_switches</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Must have gotten a database name, or have a default (the username) */</comment>
	<if_stmt><if>if <condition>(<expr><name>dbname</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>dbname</name> <operator>=</operator> <name>username</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>dbname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s: no database nor user name specified"</literal></expr></argument>,
							<argument><expr><name>progname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// TODO(neil) Once we have our system DB, remove the following code.</comment>
	<comment type="line">// It is a hack to help us getting by for now.</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>, <argument><expr><literal type="string">"template0"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>, <argument><expr><literal type="string">"template1"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>YbSetConnectedToTemplateDb</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Acquire configuration parameters, unless inherited from postmaster */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SelectConfigFiles</name><argument_list>(<argument><expr><name>userDoption</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Set up signal handlers and masks.
	 *
	 * Note that postmaster blocked all signals before forking child process,
	 * so there is no race condition whereby we might receive a signal before
	 * we have set up the handler.
	 *
	 * Also note: it's best not to use any signals that are SIG_IGNored in the
	 * postmaster.  If such a signal arrives before we are able to change the
	 * handler to non-SIG_IGN, it'll get dropped.  Instead, make a dummy
	 * handler in the postmaster to reserve the signal. (Of course, this isn't
	 * an issue for signals that are locally generated, such as SIGALRM and
	 * SIGPIPE.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>am_walsender</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>WalSndSignals</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>PostgresSigHupHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* set flag to read config
													 * file */</comment>
		<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>StatementCancelHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* cancel current query */</comment>
		<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>die</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* cancel current query and exit */</comment>

		<comment type="block">/*
		 * In a standalone backend, SIGQUIT can be generated from the keyboard
		 * easily, while SIGTERM cannot, so we make both signals do die()
		 * rather than quickdie().
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><name>quickdie</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* hard crash time */</comment>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><name>die</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt> <comment type="block">/* cancel current query and exit */</comment>
		<expr_stmt><expr><call><name>InitializeTimeouts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* establishes SIGALRM handler */</comment>

		<comment type="block">/*
		 * Ignore failure to write to frontend. Note: if frontend closes
		 * connection, we will notice it and exit cleanly when control next
		 * returns to outer loop.  This seems safer than forcing exit in the
		 * midst of output during who-knows-what operation...
		 */</comment>
		<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><name>procsignal_sigusr1_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR2</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGFPE</name></expr></argument>, <argument><expr><name>FloatExceptionHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Reset some signals that are accepted by postmaster but not by
		 * backend
		 */</comment>
		<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* system() requires this on some
									 * platforms */</comment>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>pqinitmask</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We allow SIGQUIT (quickdie) at all times */</comment>
		<expr_stmt><expr><call><name>sigdelset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>, <argument><expr><name>SIGQUIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* block everything except SIGQUIT */</comment>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Validate we have been given a reasonable-looking DataDir (if under
		 * postmaster, assume postmaster did this already).
		 */</comment>
		<expr_stmt><expr><call><name>checkDataDir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Change into DataDir (if under postmaster, was done already) */</comment>
		<expr_stmt><expr><call><name>ChangeToDataDir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Create lockfile for data directory.
		 */</comment>
		<expr_stmt><expr><call><name>CreateDataDirLockFile</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* read control file (error checking and contains config ) */</comment>
		<expr_stmt><expr><call><name>LocalProcessControlFile</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Initialize MaxBackends (if under postmaster, was done already) */</comment>
		<expr_stmt><expr><call><name>InitializeMaxBackends</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Early initialization */</comment>
	<expr_stmt><expr><call><name>BaseInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create a per-backend PGPROC struct in shared memory, except in the
	 * EXEC_BACKEND case where this was done in SubPostmasterMain. We must do
	 * this before we can use LWLocks (and in the EXEC_BACKEND case we already
	 * had to do some stuff with LWLocks).
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InitProcess</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>InitProcess</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* We need to allow SIGINT, etc during the initial transaction */</comment>
	<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UnBlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * General initialization.
	 *
	 * NOTE: if you are tempted to add code in this vicinity, consider putting
	 * it inside InitPostgres() instead.  In particular, anything that
	 * involves database access should be there, not here.
	 */</comment>
	<expr_stmt><expr><call><name>InitPostgres</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>username</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the PostmasterContext is still around, recycle the space; we don't
	 * need it anymore after InitPostgres completes.  Note this does not trash
	 * *MyProcPort, because ConnCreate() allocated that space with malloc()
	 * ... else we'd need to copy the Port data first.  Also, subsidiary data
	 * such as the username isn't lost either; see ProcessStartupPacket().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>PostmasterContext</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>PostmasterContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>PostmasterContext</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>SetProcessingMode</name><argument_list>(<argument><expr><name>NormalProcessing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now all GUC states are fully set up.  Report them to client if
	 * appropriate.
	 */</comment>
	<expr_stmt><expr><call><name>BeginReportingGUCOptions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Also set up handler to log session end; we have to wait till now to be
	 * sure Log_disconnections has its final value.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator> <name>Log_disconnections</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>on_proc_exit</name><argument_list>(<argument><expr><name>log_disconnections</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Perform initialization specific to a WAL sender process. */</comment>
	<if_stmt><if>if <condition>(<expr><name>am_walsender</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InitWalSender</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * process any libraries that should be preloaded at backend start (this
	 * likewise can't be done until GUC settings are complete)
	 */</comment>
	<expr_stmt><expr><call><name>process_session_preload_libraries</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Send this backend's cancellation info to the frontend.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'K'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>int32</name><operator>)</operator> <name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>int32</name><operator>)</operator> <name>MyCancelKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Need not flush since ReadyForQuery will do it. */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Welcome banner for standalone case */</comment>
	<if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestDebug</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nPostgreSQL stand-alone backend %s\n"</literal></expr></argument>, <argument><expr><name>PG_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Create the memory context we will use in the main loop.
	 *
	 * MessageContext is reset once per iteration of the main loop, ie, upon
	 * completion of processing of each command message from the client.
	 */</comment>
	<expr_stmt><expr><name>MessageContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
										   <argument><expr><literal type="string">"MessageContext"</literal></expr></argument>,
										   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create memory context and buffer used for RowDescription messages. As
	 * SendRowDescriptionMessage(), via exec_describe_statement_message(), is
	 * frequently executed for ever single statement, we don't want to
	 * allocate a separate buffer every time.
	 */</comment>
	<expr_stmt><expr><name>row_description_context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
													<argument><expr><literal type="string">"RowDescriptionContext"</literal></expr></argument>,
													<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>row_description_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>row_description_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Remember stand-alone backend startup time
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>PgStartTime</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * POSTGRES main processing loop begins here
	 *
	 * If an exception is encountered, processing resumes here so we abort the
	 * current transaction and start a new one.
	 *
	 * You might wonder why this isn't coded as an infinite loop around a
	 * PG_TRY construct.  The reason is that this is the bottom of the
	 * exception stack, and so with PG_TRY there would be no exception handler
	 * in force at all during the CATCH part.  By leaving the outermost setjmp
	 * always active, we have at least some chance of recovering from an error
	 * during error recovery.  (If we get into an infinite loop thereby, it
	 * will soon be stopped by overflow of elog.c's internal state stack.)
	 *
	 * Note that we use sigsetjmp(..., 1), so that this function's signal mask
	 * (to wit, UnBlockSig) will be restored when longjmp'ing to here.  This
	 * is essential in case we longjmp'd out of a signal handler on a platform
	 * where that leaves the signal blocked.  It's not redundant with the
	 * unblock in AbortTransaction() because the latter is only called if we
	 * were inside a transaction.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>sigsetjmp</name><argument_list>(<argument><expr><name>local_sigjmp_buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * NOTE: if you are tempted to add more code in this if-block,
		 * consider the high probability that it should be in
		 * AbortTransaction() instead.  The only stuff done directly here
		 * should be stuff that is guaranteed to apply *only* for outer-level
		 * error recovery, such as adjusting the FE/BE protocol status.
		 */</comment>

		<comment type="block">/* Since not using PG_TRY, must reset error stack by hand */</comment>
		<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/* Prevent interrupts while cleaning up */</comment>
		<expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Forget any pending QueryCancel request, since we're returning to
		 * the idle loop anyway, and cancel any active timeout requests.  (In
		 * future we might want to allow some timeout requests to survive, but
		 * at minimum it'd be necessary to do reschedule_timeouts(), in case
		 * we got here because of a query cancel interrupting the SIGALRM
		 * interrupt handler.)	Note in particular that we must clear the
		 * statement and lock timeout indicators, to prevent any future plain
		 * query cancels from being misreported as timeouts in case we're
		 * forgetting a timeout cancel.
		 */</comment>
		<expr_stmt><expr><call><name>disable_all_timeouts</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>QueryCancelPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* second to avoid race condition */</comment>
		<expr_stmt><expr><name>stmt_timeout_active</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* Not reading from the client anymore. */</comment>
		<expr_stmt><expr><name>DoingCommandRead</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* Make sure libpq is in a good state */</comment>
		<expr_stmt><expr><call><name>pq_comm_reset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Report the error to the client and/or server log */</comment>
		<expr_stmt><expr><call><name>EmitErrorReport</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Make sure debug_query_string gets reset before we possibly clobber
		 * the storage it points at.
		 */</comment>
		<expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Abort the current transaction in order to recover.
		 */</comment>
		<expr_stmt><expr><call><name>AbortCurrentTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>am_walsender</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>WalSndErrorCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>PortalErrorCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SPICleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We can't release replication slots inside AbortTransaction() as we
		 * need to be able to start and abort transactions while having a slot
		 * acquired. But we never need to hold them across top level errors,
		 * so releasing here is fine. There's another cleanup in ProcKill()
		 * ensuring we'll correctly cleanup on FATAL errors as well.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>MyReplicationSlot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ReplicationSlotRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* We also want to cleanup temporary slots on error. */</comment>
		<expr_stmt><expr><call><name>ReplicationSlotCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>jit_reset_after_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now return to normal top-level context and clear ErrorContext for
		 * next time.
		 */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we were handling an extended-query-protocol message, initiate
		 * skip till next Sync.  This also causes us not to issue
		 * ReadyForQuery (until we get Sync).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>doing_extended_query_message</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ignore_till_sync</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* We don't have a transaction command open anymore */</comment>
		<expr_stmt><expr><name>xact_started</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If an error occurred while we were reading a message from the
		 * client, we have potentially lost track of where the previous
		 * message ends and the next one begins.  Even though we have
		 * otherwise recovered from the error, we cannot safely read any more
		 * messages from the client, so there isn't much we can do with the
		 * connection anymore.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pq_is_reading_msg</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating connection because protocol synchronization was lost"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Now we can allow interrupts again */</comment>
		<expr_stmt><expr><call><name>RESUME_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We can now handle ereport(ERROR) */</comment>
	<expr_stmt><expr><name>PG_exception_stack</name> <operator>=</operator> <operator>&amp;</operator><name>local_sigjmp_buf</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ignore_till_sync</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>send_ready_for_query</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* initially, or after error */</comment>

	<comment type="block">/*
	 * Non-error queries loop here.
	 */</comment>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * At top of loop, reset extended-query-message flag, so that any
		 * errors encountered in "idle" state don't provoke skip.
		 */</comment>
		<expr_stmt><expr><name>doing_extended_query_message</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Release storage left over from prior query cycle, and create a new
		 * query input buffer in the cleared MessageContext.
		 */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Also consider releasing our catalog snapshot if any, so that it's
		 * not preventing advance of global xmin while we wait for the client.
		 */</comment>
		<expr_stmt><expr><call><name>InvalidateCatalogSnapshotConditionally</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * (1) If we've reached idle state, tell the frontend we're ready for
		 * a new query.
		 *
		 * Note: this includes fflush()'ing the last of the prior output.
		 *
		 * This is also a good time to send collected statistics to the
		 * collector, and to update the PS stats display.  We avoid doing
		 * those every time through the message loop because it'd slow down
		 * processing of batched messages, and because we don't want to report
		 * uncommitted updates (that confuses autovacuum).  The notification
		 * processor wants a call too, if we are not in a transaction block.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>send_ready_for_query</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><literal type="string">"idle in transaction (aborted)"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_IDLEINTRANSACTION_ABORTED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Start the idle-in-transaction timer */</comment>
				<if_stmt><if>if <condition>(<expr><name>IdleInTransactionSessionTimeout</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>disable_idle_in_transaction_timeout</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>enable_timeout_after</name><argument_list>(<argument><expr><name>IDLE_IN_TRANSACTION_SESSION_TIMEOUT</name></expr></argument>,
										 <argument><expr><name>IdleInTransactionSessionTimeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>IsTransactionOrTransactionBlock</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><literal type="string">"idle in transaction"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_IDLEINTRANSACTION</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Start the idle-in-transaction timer */</comment>
				<if_stmt><if>if <condition>(<expr><name>IdleInTransactionSessionTimeout</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>disable_idle_in_transaction_timeout</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>enable_timeout_after</name><argument_list>(<argument><expr><name>IDLE_IN_TRANSACTION_SESSION_TIMEOUT</name></expr></argument>,
										 <argument><expr><name>IdleInTransactionSessionTimeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>yb_need_cache_refresh</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>YBRefreshCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>ProcessCompletedNotifies</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pgstat_report_stat</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><literal type="string">"idle"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_IDLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>ReadyForQuery</name><argument_list>(<argument><expr><name>whereToSendOutput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>send_ready_for_query</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * (2) Allow asynchronous signals to be executed immediately if they
		 * come in while we are waiting for client input. (This must be
		 * conditional since we don't want, say, reads on behalf of COPY FROM
		 * STDIN doing the same thing.)
		 */</comment>
		<expr_stmt><expr><name>DoingCommandRead</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * (3) read a command (loop blocks here)
		 */</comment>
		<expr_stmt><expr><name>firstchar</name> <operator>=</operator> <call><name>ReadCommand</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * (4) disable async signal conditions again.
		 *
		 * Query cancel is supposed to be a no-op when there is no query in
		 * progress, so if a query cancel arrived while we were idle, just
		 * reset QueryCancelPending. ProcessInterrupts() has that effect when
		 * it's called when DoingCommandRead is set, so check for interrupts
		 * before resetting DoingCommandRead.
		 */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>DoingCommandRead</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * (5) turn off the idle-in-transaction timeout
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>disable_idle_in_transaction_timeout</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>disable_timeout</name><argument_list>(<argument><expr><name>IDLE_IN_TRANSACTION_SESSION_TIMEOUT</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>disable_idle_in_transaction_timeout</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * (6) check for any other interesting events that happened while we
		 * slept.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>ConfigReloadPending</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ConfigReloadPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * (7) process the command.  But ignore it if we're skipping till
		 * Sync.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>ignore_till_sync</name> <operator>&amp;&amp;</operator> <name>firstchar</name> <operator>!=</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>YBCPgResetCatalogReadTime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>YBCheckSharedCatalogCacheVersion</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<switch>switch <condition>(<expr><name>firstchar</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'Q'</literal></expr>:</case>			<comment type="block">/* simple query */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl>;</decl_stmt>

				<comment type="block">/* Set statement_timestamp() */</comment>
				<expr_stmt><expr><call><name>SetCurrentStatementStartTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>query_string</name> <operator>=</operator> <call><name>pq_getmsgstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>am_walsender</name> <operator>||</operator> <operator>!</operator><call><name>exec_replication_command</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                      <expr_stmt><expr><call><name>yb_exec_simple_query</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>, <argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block>
				<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<block>{<block_content>
					<comment type="block">/* Get error data */</comment>
					<decl_stmt><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>MemoryContext</name></type> <name>errorcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name>edata</name> <operator>=</operator> <call><name>CopyErrorData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

					<decl_stmt><decl><type><name>bool</name></type> <name>need_retry</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>YBPrepareCacheRefreshIfNeeded</name><argument_list>(<argument><expr><name>edata</name></expr></argument>,
                                                  <argument><expr><call><name>yb_check_retry_allowed</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr></argument>,
                                                  <argument><expr><operator>&amp;</operator><name>need_retry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>need_retry</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>am_walsender</name> <operator>||</operator> <operator>!</operator><call><name>exec_replication_command</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><name>yb_debug_log_internal_restarts</name></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>yb_report_cache_version_restart</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>, <argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
							<comment type="block">/*
							 * Free edata before restarting, in other branches
							 * the memory context will get reset after anyway.
							 */</comment>
							<expr_stmt><expr><call><name>FreeErrorData</name><argument_list>(<argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>yb_exec_simple_query</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>, <argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>errorcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block>
				<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>send_ready_for_query</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

			<case>case <expr><literal type="char">'P'</literal></expr>:</case>			<comment type="block">/* parse */</comment>
				<block>{<block_content>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmt_name</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>numParams</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>paramTypes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>forbidden_in_wal_sender</name><argument_list>(<argument><expr><name>firstchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Set statement_timestamp() */</comment>
					<expr_stmt><expr><call><name>SetCurrentStatementStartTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>stmt_name</name> <operator>=</operator> <call><name>pq_getmsgstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>query_string</name> <operator>=</operator> <call><name>pq_getmsgstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>numParams</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>numParams</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>paramTypes</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numParams</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numParams</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>paramTypes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<block>{<block_content>
						<expr_stmt><expr><call><name>exec_parse_message</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>,
						                   <argument><expr><name>stmt_name</name></expr></argument>,
						                   <argument><expr><name>paramTypes</name></expr></argument>,
						                   <argument><expr><name>numParams</name></expr></argument>,
						                   <argument><expr><name>whereToSendOutput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block>
					<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<block>{<block_content>
						<comment type="block">/* Get error data */</comment>
						<decl_stmt><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>MemoryContext</name></type> <name>errorcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<expr_stmt><expr><name>edata</name> <operator>=</operator> <call><name>CopyErrorData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/*
						 * TODO Cannot retry parse statements yet (without
						 * aborting the followup bind/execute.
						 */</comment>
						<decl_stmt><decl><type><name>bool</name></type> <name>need_retry</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
						<expr_stmt><expr><call><name>YBPrepareCacheRefreshIfNeeded</name><argument_list>(<argument><expr><name>edata</name></expr></argument>,
						                              <argument><expr><name>false</name></expr></argument> <comment type="block">/* consider_retry */</comment>,
						                              <argument><expr><operator>&amp;</operator><name>need_retry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>errorcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

					</block_content>}</block>
					<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><literal type="char">'B'</literal></expr>:</case>			<comment type="block">/* bind */</comment>
				<expr_stmt><expr><call><name>forbidden_in_wal_sender</name><argument_list>(<argument><expr><name>firstchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Set statement_timestamp() */</comment>
				<expr_stmt><expr><call><name>SetCurrentStatementStartTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * this message is complex enough that it seems best to put
				 * the field extraction out-of-line
				 */</comment>
				<expr_stmt><expr><call><name>exec_bind_message</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'E'</literal></expr>:</case>			<comment type="block">/* execute */</comment>
				<block>{<block_content>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>portal_name</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>max_rows</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>forbidden_in_wal_sender</name><argument_list>(<argument><expr><name>firstchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Set statement_timestamp() */</comment>
					<expr_stmt><expr><call><name>SetCurrentStatementStartTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>portal_name</name> <operator>=</operator> <call><name>pq_getmsgstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>max_rows</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>YBQueryRestartData</name><modifier>*</modifier></type> <name>restart_data</name> <init>=
						<expr><call><name>yb_collect_portal_restart_data</name><argument_list>(<argument><expr><name>portal_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<block>{<block_content>
						<expr_stmt><expr><call><name>yb_exec_execute_message</name><argument_list>(<argument><expr><name>portal_name</name></expr></argument>,
												<argument><expr><name>max_rows</name></expr></argument>,
												<argument><expr><name>restart_data</name></expr></argument>,
												<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block>
					<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<block>{<block_content>
						<comment type="block">/*
						 * Get error data. Original error will be thrown in 2 cases:
						 * - query can't be restarted transparently
						 * - original error is "schema version mismatch for table"
						 *   and restarting will raise an error (workaround for #6982)
						 */</comment>
						<decl_stmt><decl><type><name>MemoryContext</name></type> <name>errorcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name> <init>= <expr><call><name>CopyErrorData</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

						<comment type="block">/*
						 * The portal recreation logic is restored to the pre-#2216 state
						 * (it was reworked in #4254).
						 */</comment>
						<decl_stmt><decl><type><name>Portal</name></type> <name>old_portal</name> <init>= <expr><call><name>GetPortalByName</name><argument_list>(<argument><expr><name>portal_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<comment type="block">/*
						 * TODO Do not support retrying for prepared statements
						 * yet. (i.e. if portal is named or has params).
						 */</comment>
						<decl_stmt><decl><type><name>bool</name></type> <name>can_retry</name> <init>=
						    <expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
						    <name>old_portal</name> <operator>&amp;&amp;</operator>
						    <name><name>portal_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator>
						    <operator>!</operator><name><name>old_portal</name><operator>-&gt;</operator><name>portalParams</name></name> <operator>&amp;&amp;</operator>
						    <call><name>yb_check_retry_allowed</name><argument_list>(<argument><expr><name><name>restart_data</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


						<comment type="block">/* Stuff we might need for retrying below */</comment>
						<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>query_string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>int</name></type>   <name>nformats</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>int16</name> <modifier>*</modifier></type><name>formats</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name>can_retry</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/*
							 * Copy the data needed to retry before transaction
							 * abort cleans it up.
							 */</comment>
							<expr_stmt><expr><name>query_string</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>restart_data</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<if_stmt><if>if <condition>(<expr><name><name>old_portal</name><operator>-&gt;</operator><name>formats</name></name></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><name>nformats</name> <operator>=</operator> <name><name>old_portal</name><operator>-&gt;</operator><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
								<expr_stmt><expr><name>formats</name>  <operator>=</operator> <operator>(</operator><name>int16</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nformats</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>formats</name></expr></argument>,
								       <argument><expr><name><name>old_portal</name><operator>-&gt;</operator><name>formats</name></name></expr></argument>,
								       <argument><expr><name>nformats</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block></if></if_stmt>

						<decl_stmt><decl><type><name>bool</name></type> <name>need_retry</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

						<comment type="block">/*
						 * Execute may have been partially applied so need to
						 * cleanup (and restart) the transaction.
						 */</comment>
						<expr_stmt><expr><call><name>YBPrepareCacheRefreshIfNeeded</name><argument_list>(<argument><expr><name>edata</name></expr></argument>, <argument><expr><name>can_retry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>need_retry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><name>need_retry</name> <operator>&amp;&amp;</operator> <name>can_retry</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
							<block>{<block_content>
								<if_stmt><if>if <condition>(<expr><name>yb_debug_log_internal_restarts</name></expr>)</condition>
								<block>{<block_content>
									<expr_stmt><expr><call><name>yb_report_cache_version_restart</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>, <argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								</block_content>}</block></if></if_stmt>

								<comment type="block">/* 1. Redo Parse: Create Cached stmt (no output) */</comment>
								<expr_stmt><expr><call><name>exec_parse_message</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>,
								                   <argument><expr><name>portal_name</name></expr></argument>,
								                   <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* param_types*/</comment>,
								                   <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* num_params */</comment>,
								                   <argument><expr><name>DestNone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

								<comment type="block">/* 2. Redo the Bind step */</comment>
								<decl_stmt><decl><type><name>Portal</name></type> <name>portal</name></decl>;</decl_stmt>
								<comment type="block">/* Create portal */</comment>
								<expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>CreatePortal</name><argument_list>(<argument><expr><name>portal_name</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

								<comment type="block">/* Set portal data */</comment>
								<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(
										<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>portalContext</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
								<decl_stmt><decl><type><name>char</name>          <modifier>*</modifier></type><name>stmt_name</name></decl>;</decl_stmt>
								<if_stmt><if>if <condition>(<expr><name><name>portal_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><name>stmt_name</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>portal_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
								<else>else<block type="pseudo"><block_content>
									<expr_stmt><expr><name>stmt_name</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
								<expr_stmt><expr><name>query_string</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

								<comment type="block">/* TODO params are none for now (see above) */</comment>
								<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>params</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

								<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

								<decl_stmt><decl><type><name>CachedPlan</name> <modifier>*</modifier></type><name>cplan</name> <init>= <expr><call><name>GetCachedPlan</name><argument_list>(<argument><expr><name>unnamed_stmt_psrc</name></expr></argument>,
								                                  <argument><expr><name>params</name></expr></argument>,
								                                  <argument><expr><name>false</name></expr></argument>,
								                                  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

								<expr_stmt><expr><call><name>PortalDefineQuery</name><argument_list>(<argument><expr><name>portal</name></expr></argument>,
								                  <argument><expr><name>stmt_name</name></expr></argument>,
								                  <argument><expr><name>query_string</name></expr></argument>,
								                  <argument><expr><name><name>unnamed_stmt_psrc</name><operator>-&gt;</operator><name>commandTag</name></name></expr></argument>,
								                  <argument><expr><name><name>cplan</name><operator>-&gt;</operator><name>stmt_list</name></name></expr></argument>,
								                  <argument><expr><name>cplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

								<comment type="block">/* Start portal */</comment>
								<expr_stmt><expr><call><name>PortalStart</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>InvalidSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<comment type="block">/* Set the output format */</comment>
								<expr_stmt><expr><call><name>PortalSetResultFormat</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>nformats</name></expr></argument>, <argument><expr><name>formats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

								<comment type="block">/* Now ready to retry the execute step. */</comment>
								<expr_stmt><expr><call><name>yb_exec_execute_message</name><argument_list>(<argument><expr><name>portal_name</name></expr></argument>,
														<argument><expr><name>max_rows</name></expr></argument>,
														<argument><expr><name>restart_data</name></expr></argument>,
														<argument><expr><call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block>
							<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
							<block>{<block_content>
								<if_stmt><if>if <condition>(<expr><call><name>YBTableSchemaVersionMismatchError</name><argument_list>(<argument><expr><name>edata</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* table_id */</comment>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><call><name>ReThrowError</name><argument_list>(<argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
								<else>else<block type="pseudo"><block_content>
									<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
							</block_content>}</block>
							<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if>
						<else>else
						<block>{<block_content>
							<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>errorcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></else></if_stmt>

					</block_content>}</block>
					<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><literal type="char">'F'</literal></expr>:</case>			<comment type="block">/* fastpath function call */</comment>
				<expr_stmt><expr><call><name>forbidden_in_wal_sender</name><argument_list>(<argument><expr><name>firstchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Set statement_timestamp() */</comment>
				<expr_stmt><expr><call><name>SetCurrentStatementStartTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Report query to various monitoring facilities. */</comment>
				<expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_FASTPATH</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><literal type="string">"&lt;FASTPATH&gt;"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* start an xact for this function invocation */</comment>
				<expr_stmt><expr><call><name>start_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Note: we may at this point be inside an aborted
				 * transaction.  We can't throw error for that until we've
				 * finished reading the function-call message, so
				 * HandleFunctionRequest() must check for it after doing so.
				 * Be careful not to do anything that assumes we're inside a
				 * valid transaction here.
				 */</comment>

				<comment type="block">/* switch back to message context */</comment>
				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>HandleFunctionRequest</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* commit the function-invocation transaction */</comment>
				<expr_stmt><expr><call><name>finish_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>send_ready_for_query</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'C'</literal></expr>:</case>			<comment type="block">/* close */</comment>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>close_type</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>close_target</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>forbidden_in_wal_sender</name><argument_list>(<argument><expr><name>firstchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>close_type</name> <operator>=</operator> <call><name>pq_getmsgbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>close_target</name> <operator>=</operator> <call><name>pq_getmsgstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<switch>switch <condition>(<expr><name>close_type</name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><literal type="char">'S'</literal></expr>:</case>
							<if_stmt><if>if <condition>(<expr><name><name>close_target</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>DropPreparedStatement</name><argument_list>(<argument><expr><name>close_target</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
							<else>else
							<block>{<block_content>
								<comment type="block">/* special-case the unnamed statement */</comment>
								<expr_stmt><expr><call><name>drop_unnamed_stmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></else></if_stmt>
							<break>break;</break>
						<case>case <expr><literal type="char">'P'</literal></expr>:</case>
							<block>{<block_content>
								<decl_stmt><decl><type><name>Portal</name></type>		<name>portal</name></decl>;</decl_stmt>

								<expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>GetPortalByName</name><argument_list>(<argument><expr><name>close_target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<if_stmt><if>if <condition>(<expr><call><name>PortalIsValid</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><call><name>PortalDrop</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							</block_content>}</block>
							<break>break;</break>
						<default>default:</default>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid CLOSE message subtype %d"</literal></expr></argument>,
											<argument><expr><name>close_type</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
					</block_content>}</block></switch>

					<if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>pq_putemptymessage</name><argument_list>(<argument><expr><literal type="char">'3'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* CloseComplete */</comment>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><literal type="char">'D'</literal></expr>:</case>			<comment type="block">/* describe */</comment>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>describe_type</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>describe_target</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>forbidden_in_wal_sender</name><argument_list>(<argument><expr><name>firstchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Set statement_timestamp() (needed for xact) */</comment>
					<expr_stmt><expr><call><name>SetCurrentStatementStartTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>describe_type</name> <operator>=</operator> <call><name>pq_getmsgbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>describe_target</name> <operator>=</operator> <call><name>pq_getmsgstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<switch>switch <condition>(<expr><name>describe_type</name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><literal type="char">'S'</literal></expr>:</case>
							<expr_stmt><expr><call><name>exec_describe_statement_message</name><argument_list>(<argument><expr><name>describe_target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><literal type="char">'P'</literal></expr>:</case>
							<expr_stmt><expr><call><name>exec_describe_portal_message</name><argument_list>(<argument><expr><name>describe_target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<default>default:</default>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid DESCRIBE message subtype %d"</literal></expr></argument>,
											<argument><expr><name>describe_type</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
					</block_content>}</block></switch>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><literal type="char">'H'</literal></expr>:</case>			<comment type="block">/* flush */</comment>
				<expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pq_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'S'</literal></expr>:</case>			<comment type="block">/* sync */</comment>
				<expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>finish_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>send_ready_for_query</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * 'X' means that the frontend is closing down the socket. EOF
				 * means unexpected loss of frontend connection. Either way,
				 * perform normal shutdown.
				 */</comment>
			<case>case <expr><literal type="char">'X'</literal></expr>:</case>
			<case>case <expr><name>EOF</name></expr>:</case>

				<comment type="block">/*
				 * Reset whereToSendOutput to prevent ereport from attempting
				 * to send any more messages to client.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>whereToSendOutput</name> <operator>=</operator> <name>DestNone</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * NOTE: if you are tempted to add more code here, DON'T!
				 * Whatever you had in mind to do should be set up as an
				 * on_proc_exit or on_shmem_exit callback, instead. Otherwise
				 * it will fail to be called during other backend-shutdown
				 * scenarios.
				 */</comment>
				<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<case>case <expr><literal type="char">'d'</literal></expr>:</case>			<comment type="block">/* copy data */</comment>
			<case>case <expr><literal type="char">'c'</literal></expr>:</case>			<comment type="block">/* copy done */</comment>
			<case>case <expr><literal type="char">'f'</literal></expr>:</case>			<comment type="block">/* copy fail */</comment>

				<comment type="block">/*
				 * Accept but ignore these messages, per protocol spec; we
				 * probably got here because a COPY failed, and the frontend
				 * is still sending data.
				 */</comment>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid frontend message type %d"</literal></expr></argument>,
								<argument><expr><name>firstchar</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block></for>							<comment type="block">/* end of input-reading loop */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Throw an error if we're a WAL sender process.
 *
 * This is used to forbid anything else than simple query protocol messages
 * in a WAL sender process.  'firstchar' specifies what kind of a forbidden
 * message was received, and is used to construct the error message.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>forbidden_in_wal_sender</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>firstchar</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>am_walsender</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>firstchar</name> <operator>==</operator> <literal type="char">'F'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fastpath function calls not supported in a replication connection"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"extended query protocol not supported in a replication connection"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Obtain platform stack depth limit (in bytes)
 *
 * Return -1 if unknown
 */</comment>
<function><type><name>long</name></type>
<name>get_stack_depth_rlimit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETRLIMIT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>RLIMIT_STACK</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>val</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* This won't change after process launch, so check just once */</comment>
	<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>rlimit</name></name></type> <name>rlim</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>getrlimit</name><argument_list>(<argument><expr><name>RLIMIT_STACK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rlim</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rlim</name><operator>.</operator><name>rlim_cur</name></name> <operator>==</operator> <name>RLIM_INFINITY</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <name>LONG_MAX</name></expr>;</expr_stmt></block_content></block></if>
		<comment type="block">/* rlim_cur is probably of an unsigned type, so check for overflow */</comment>
		<if type="elseif">else if <condition>(<expr><name><name>rlim</name><operator>.</operator><name>rlim_cur</name></name> <operator>&gt;=</operator> <name>LONG_MAX</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <name>LONG_MAX</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <name><name>rlim</name><operator>.</operator><name>rlim_cur</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>val</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* no getrlimit */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<comment type="block">/* On Windows we set the backend stack size in src/backend/Makefile */</comment>
	<return>return <expr><name>WIN32_STACK_RLIMIT</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* not windows ... give up */</comment>
	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>rusage</name></name></type> <name>Save_r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>timeval</name></name></type> <name>Save_t</name></decl>;</decl_stmt>

<function><type><name>void</name></type>
<name>ResetUsage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>getrusage</name><argument_list>(<argument><expr><name>RUSAGE_SELF</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Save_r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Save_t</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ShowUsage</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>title</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>user</name></decl>,
				<decl><type ref="prev"/><name>sys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>elapse_t</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>rusage</name></name></type> <name>r</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>getrusage</name><argument_list>(<argument><expr><name>RUSAGE_SELF</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>elapse_t</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>user</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>r</name><operator>.</operator><name>ru_utime</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>user</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>sys</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>r</name><operator>.</operator><name>ru_stime</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sys</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>elapse_t</name><operator>.</operator><name>tv_usec</name></name> <operator>&lt;</operator> <name><name>Save_t</name><operator>.</operator><name>tv_usec</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>elapse_t</name><operator>.</operator><name>tv_sec</name></name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>elapse_t</name><operator>.</operator><name>tv_usec</name></name> <operator>+=</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>.</operator><name>ru_utime</name><operator>.</operator><name>tv_usec</name></name> <operator>&lt;</operator> <name><name>Save_r</name><operator>.</operator><name>ru_utime</name><operator>.</operator><name>tv_usec</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>r</name><operator>.</operator><name>ru_utime</name><operator>.</operator><name>tv_sec</name></name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name><operator>.</operator><name>ru_utime</name><operator>.</operator><name>tv_usec</name></name> <operator>+=</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>.</operator><name>ru_stime</name><operator>.</operator><name>tv_usec</name></name> <operator>&lt;</operator> <name><name>Save_r</name><operator>.</operator><name>ru_stime</name><operator>.</operator><name>tv_usec</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>r</name><operator>.</operator><name>ru_stime</name><operator>.</operator><name>tv_sec</name></name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name><operator>.</operator><name>ru_stime</name><operator>.</operator><name>tv_usec</name></name> <operator>+=</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The only stats we don't show here are ixrss, idrss, isrss.  It takes
	 * some work to interpret them, and most platforms don't fill them in.
	 */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"! system usage stats:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>,
					 <argument><expr><literal type="string">"!\t%ld.%06ld s user, %ld.%06ld s system, %ld.%06ld s elapsed\n"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name><name>r</name><operator>.</operator><name>ru_utime</name><operator>.</operator><name>tv_sec</name></name> <operator>-</operator> <name><name>Save_r</name><operator>.</operator><name>ru_utime</name><operator>.</operator><name>tv_sec</name></name><operator>)</operator></expr></argument>,
					 <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name><name>r</name><operator>.</operator><name>ru_utime</name><operator>.</operator><name>tv_usec</name></name> <operator>-</operator> <name><name>Save_r</name><operator>.</operator><name>ru_utime</name><operator>.</operator><name>tv_usec</name></name><operator>)</operator></expr></argument>,
					 <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name><name>r</name><operator>.</operator><name>ru_stime</name><operator>.</operator><name>tv_sec</name></name> <operator>-</operator> <name><name>Save_r</name><operator>.</operator><name>ru_stime</name><operator>.</operator><name>tv_sec</name></name><operator>)</operator></expr></argument>,
					 <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name><name>r</name><operator>.</operator><name>ru_stime</name><operator>.</operator><name>tv_usec</name></name> <operator>-</operator> <name><name>Save_r</name><operator>.</operator><name>ru_stime</name><operator>.</operator><name>tv_usec</name></name><operator>)</operator></expr></argument>,
					 <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name><name>elapse_t</name><operator>.</operator><name>tv_sec</name></name> <operator>-</operator> <name><name>Save_t</name><operator>.</operator><name>tv_sec</name></name><operator>)</operator></expr></argument>,
					 <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name><name>elapse_t</name><operator>.</operator><name>tv_usec</name></name> <operator>-</operator> <name><name>Save_t</name><operator>.</operator><name>tv_usec</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>,
					 <argument><expr><literal type="string">"!\t[%ld.%06ld s user, %ld.%06ld s system total]\n"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>user</name><operator>.</operator><name>tv_sec</name></name></expr></argument>,
					 <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>user</name><operator>.</operator><name>tv_usec</name></name></expr></argument>,
					 <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>sys</name><operator>.</operator><name>tv_sec</name></name></expr></argument>,
					 <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>sys</name><operator>.</operator><name>tv_usec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETRUSAGE</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>,
					 <argument><expr><literal type="string">"!\t%ld kB max resident size\n"</literal></expr></argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__darwin__</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<comment type="block">/* in bytes on macOS */</comment>
					 <argument><expr><name><name>r</name><operator>.</operator><name>ru_maxrss</name></name> <operator>/</operator> <literal type="number">1024</literal>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<comment type="block">/* in kilobytes on most other platforms */</comment>
					 <name><name>r</name><operator>.</operator><name>ru_maxrss</name></name></expr></argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>,
					 <argument><expr><literal type="string">"!\t%ld/%ld [%ld/%ld] filesystem blocks in/out\n"</literal></expr></argument>,
					 <argument><expr><name><name>r</name><operator>.</operator><name>ru_inblock</name></name> <operator>-</operator> <name><name>Save_r</name><operator>.</operator><name>ru_inblock</name></name></expr></argument>,
	<comment type="block">/* they only drink coffee at dec */</comment>
					 <argument><expr><name><name>r</name><operator>.</operator><name>ru_oublock</name></name> <operator>-</operator> <name><name>Save_r</name><operator>.</operator><name>ru_oublock</name></name></expr></argument>,
					 <argument><expr><name><name>r</name><operator>.</operator><name>ru_inblock</name></name></expr></argument>, <argument><expr><name><name>r</name><operator>.</operator><name>ru_oublock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>,
					 <argument><expr><literal type="string">"!\t%ld/%ld [%ld/%ld] page faults/reclaims, %ld [%ld] swaps\n"</literal></expr></argument>,
					 <argument><expr><name><name>r</name><operator>.</operator><name>ru_majflt</name></name> <operator>-</operator> <name><name>Save_r</name><operator>.</operator><name>ru_majflt</name></name></expr></argument>,
					 <argument><expr><name><name>r</name><operator>.</operator><name>ru_minflt</name></name> <operator>-</operator> <name><name>Save_r</name><operator>.</operator><name>ru_minflt</name></name></expr></argument>,
					 <argument><expr><name><name>r</name><operator>.</operator><name>ru_majflt</name></name></expr></argument>, <argument><expr><name><name>r</name><operator>.</operator><name>ru_minflt</name></name></expr></argument>,
					 <argument><expr><name><name>r</name><operator>.</operator><name>ru_nswap</name></name> <operator>-</operator> <name><name>Save_r</name><operator>.</operator><name>ru_nswap</name></name></expr></argument>,
					 <argument><expr><name><name>r</name><operator>.</operator><name>ru_nswap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>,
					 <argument><expr><literal type="string">"!\t%ld [%ld] signals rcvd, %ld/%ld [%ld/%ld] messages rcvd/sent\n"</literal></expr></argument>,
					 <argument><expr><name><name>r</name><operator>.</operator><name>ru_nsignals</name></name> <operator>-</operator> <name><name>Save_r</name><operator>.</operator><name>ru_nsignals</name></name></expr></argument>,
					 <argument><expr><name><name>r</name><operator>.</operator><name>ru_nsignals</name></name></expr></argument>,
					 <argument><expr><name><name>r</name><operator>.</operator><name>ru_msgrcv</name></name> <operator>-</operator> <name><name>Save_r</name><operator>.</operator><name>ru_msgrcv</name></name></expr></argument>,
					 <argument><expr><name><name>r</name><operator>.</operator><name>ru_msgsnd</name></name> <operator>-</operator> <name><name>Save_r</name><operator>.</operator><name>ru_msgsnd</name></name></expr></argument>,
					 <argument><expr><name><name>r</name><operator>.</operator><name>ru_msgrcv</name></name></expr></argument>, <argument><expr><name><name>r</name><operator>.</operator><name>ru_msgsnd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>,
					 <argument><expr><literal type="string">"!\t%ld/%ld [%ld/%ld] voluntary/involuntary context switches\n"</literal></expr></argument>,
					 <argument><expr><name><name>r</name><operator>.</operator><name>ru_nvcsw</name></name> <operator>-</operator> <name><name>Save_r</name><operator>.</operator><name>ru_nvcsw</name></name></expr></argument>,
					 <argument><expr><name><name>r</name><operator>.</operator><name>ru_nivcsw</name></name> <operator>-</operator> <name><name>Save_r</name><operator>.</operator><name>ru_nivcsw</name></name></expr></argument>,
					 <argument><expr><name><name>r</name><operator>.</operator><name>ru_nvcsw</name></name></expr></argument>, <argument><expr><name><name>r</name><operator>.</operator><name>ru_nivcsw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* HAVE_GETRUSAGE */</comment>

	<comment type="block">/* remove trailing newline */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>str</name><operator>.</operator><name>data</name><index>[<expr><name><name>str</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>str</name><operator>.</operator><name>data</name><index>[<expr><operator>--</operator><name><name>str</name><operator>.</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>str</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>str</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * on_proc_exit handler to log end of session
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>log_disconnections</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Port</name>	   <modifier>*</modifier></type><name>port</name> <init>= <expr><name>MyProcPort</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>secs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>usecs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>msecs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>hours</name></decl>,
				<decl><type ref="prev"/><name>minutes</name></decl>,
				<decl><type ref="prev"/><name>seconds</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TimestampDifference</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>SessionStartTime</name></name></expr></argument>,
						<argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>secs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>usecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>msecs</name> <operator>=</operator> <name>usecs</name> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>hours</name> <operator>=</operator> <name>secs</name> <operator>/</operator> <name>SECS_PER_HOUR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>secs</name> <operator>%=</operator> <name>SECS_PER_HOUR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>minutes</name> <operator>=</operator> <name>secs</name> <operator>/</operator> <name>SECS_PER_MINUTE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>seconds</name> <operator>=</operator> <name>secs</name> <operator>%</operator> <name>SECS_PER_MINUTE</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"disconnection: session time: %d:%02d:%02d.%03d "</literal>
					<literal type="string">"user=%s database=%s host=%s%s%s"</literal></expr></argument>,
					<argument><expr><name>hours</name></expr></argument>, <argument><expr><name>minutes</name></expr></argument>, <argument><expr><name>seconds</name></expr></argument>, <argument><expr><name>msecs</name></expr></argument>,
					<argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>database_name</name></name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>remote_host</name></name></expr></argument>,
					<argument><expr><ternary><condition><expr><name><name>port</name><operator>-&gt;</operator><name>remote_port</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ?</condition><then> <expr><literal type="string">" port="</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>remote_port</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Start statement timeout timer, if enabled.
 *
 * If there's already a timeout running, don't restart the timer.  That
 * enables compromises between accuracy of timeouts and cost of starting a
 * timeout.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>enable_statement_timeout</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* must be within an xact */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>xact_started</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>StatementTimeout</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>stmt_timeout_active</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>enable_timeout_after</name><argument_list>(<argument><expr><name>STATEMENT_TIMEOUT</name></expr></argument>, <argument><expr><name>StatementTimeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>stmt_timeout_active</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>disable_timeout</name><argument_list>(<argument><expr><name>STATEMENT_TIMEOUT</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Disable statement timeout, if active.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>disable_statement_timeout</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>stmt_timeout_active</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>disable_timeout</name><argument_list>(<argument><expr><name>STATEMENT_TIMEOUT</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>stmt_timeout_active</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Redact password, if exists in the query text.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>RedactPasswordIfExists</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>queryStr</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>redactedStr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>passwordToken</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>passwordPos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>commandTag</name></decl>;</decl_stmt>

	<comment type="block">/*
	* Parse and check the type of the query. We only redact password
	* for the CREATE USER / CREATE ROLE / ALTER USER / ALTER ROLE queries.
	* Use yb_parse_command_tag to suppress error warnings.
	*/</comment>
	<expr_stmt><expr><name>commandTag</name> <operator>=</operator> <call><name>yb_parse_command_tag</name><argument_list>(<argument><expr><name>queryStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>commandTag</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>commandTag</name></expr></argument>, <argument><expr><literal type="string">"CREATE ROLE"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
					<call><name>strcmp</name><argument_list>(<argument><expr><name>commandTag</name></expr></argument>, <argument><expr><literal type="string">"ALTER ROLE"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>queryStr</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Copy the query string and convert to lower case. */</comment>
  	<expr_stmt><expr><name>redactedStr</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>queryStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>redactedStr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    	<expr_stmt><expr><name><name>redactedStr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><call><name>pg_tolower</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>redactedStr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* Find index of password token. */</comment>
	<expr_stmt><expr><name>passwordToken</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>redactedStr</name></expr></argument>, <argument><expr><name>TOKEN_PASSWORD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>passwordToken</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Copy query string up to password token. */</comment>
		<expr_stmt><expr><name>passwordPos</name> <operator>=</operator> <operator>(</operator><name>passwordToken</name> <operator>-</operator> <name>redactedStr</name><operator>)</operator> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>TOKEN_PASSWORD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>redactedStr</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>passwordPos</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>TOKEN_REDACTED</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>redactedStr</name></expr></argument>, <argument><expr><name>queryStr</name></expr></argument>, <argument><expr><name>passwordPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* And append redacted token. */</comment>
		<expr_stmt><expr><name><name>redactedStr</name><index>[<expr><name>passwordPos</name></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>redactedStr</name> <operator>+</operator> <name>passwordPos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>TOKEN_REDACTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>redactedStr</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>queryStr</name></expr>;</return>
</block_content>}</block></function>
</unit>
