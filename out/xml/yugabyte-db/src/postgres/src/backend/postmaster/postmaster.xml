<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/postmaster/postmaster.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * postmaster.c
 *	  This program acts as a clearing house for requests to the
 *	  POSTGRES system.  Frontend programs send a startup message
 *	  to the Postmaster and the postmaster uses the info in the
 *	  message to setup a backend process.
 *
 *	  The postmaster also manages system-wide operations such as
 *	  startup and shutdown. The postmaster itself doesn't do those
 *	  operations, mind you --- it just forks off a subprocess to do them
 *	  at the right times.  It also takes care of resetting the system
 *	  if a backend crashes.
 *
 *	  The postmaster process creates the shared memory and semaphore
 *	  pools during startup, but as a rule does not touch them itself.
 *	  In particular, it is not a member of the PGPROC array of backends
 *	  and so it cannot participate in lock-manager operations.  Keeping
 *	  the postmaster away from shared memory operations makes it simpler
 *	  and more reliable.  The postmaster is almost always able to recover
 *	  from crashes of individual backends by resetting shared memory;
 *	  if it did much with shared memory then it would be prone to crashing
 *	  along with the backends.
 *
 *	  When a request message is received, we now fork() immediately.
 *	  The child process performs authentication of the request, and
 *	  then becomes a backend if successful.  This allows the auth code
 *	  to be written in a simple single-threaded style (as opposed to the
 *	  crufty "poor man's multitasking" code that used to be needed).
 *	  More importantly, it ensures that blockages in non-multithreaded
 *	  libraries like SSL or PAM cannot cause denial of service to other
 *	  clients.
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/postmaster/postmaster.c
 *
 * NOTES
 *
 * Initialization:
 *		The Postmaster sets up shared memory data structures
 *		for the backends.
 *
 * Synchronization:
 *		The Postmaster shares memory with the backends but should avoid
 *		touching shared memory, so as not to become stuck if a crashing
 *		backend screws up locks or shared memory.  Likewise, the Postmaster
 *		should never block on messages from frontend clients.
 *
 * Garbage Collection:
 *		The Postmaster cleans up after backends if they have an emergency
 *		exit and/or core dump.
 *
 * Error Reporting:
 *		Use write_stderr() only for reporting "interactive" errors
 *		(essentially, bogus arguments on the command line).  Once the
 *		postmaster is launched, use ereport().
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/wait.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netdb.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_SELECT_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/select.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_BONJOUR</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dns_sd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SYSTEMD</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;systemd/sd-daemon.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_PTHREAD_IS_THREADED_NP</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bootstrap/bootstrap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_control.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/file_perm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/ip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/ilist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/auth.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_getopt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port/pg_bswap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/autovacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/bgworker_internals.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/fork_process.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/pgarch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/syslogger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/logicallauncher.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walsender.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pg_shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pmsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datetime.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/dynamic_loader.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pidfile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timeout.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/varlena.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/pg_yb_common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_yb_utils.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/spin.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Possible types of a backend. Beyond being the possible bkend_type values in
 * struct bkend, these are OR-able request flag bits for SignalSomeChildren()
 * and CountChildren().
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BACKEND_TYPE_NORMAL</name></cpp:macro>		<cpp:value>0x0001</cpp:value></cpp:define>	<comment type="block">/* normal backend */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BACKEND_TYPE_AUTOVAC</name></cpp:macro>	<cpp:value>0x0002</cpp:value></cpp:define>	<comment type="block">/* autovacuum worker process */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BACKEND_TYPE_WALSND</name></cpp:macro>		<cpp:value>0x0004</cpp:value></cpp:define>	<comment type="block">/* walsender process */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BACKEND_TYPE_BGWORKER</name></cpp:macro>	<cpp:value>0x0008</cpp:value></cpp:define>	<comment type="block">/* bgworker process */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BACKEND_TYPE_ALL</name></cpp:macro>		<cpp:value>0x000F</cpp:value></cpp:define>	<comment type="block">/* OR of all the above */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BACKEND_TYPE_WORKER</name></cpp:macro>		<cpp:value>(BACKEND_TYPE_AUTOVAC | BACKEND_TYPE_BGWORKER)</cpp:value></cpp:define>

<comment type="block">/*
 * List of active backends (or child processes anyway; we don't actually
 * know whether a given child has become a backend or is still in the
 * authorization phase).  This is used mainly to keep track of how many
 * children we have and send them appropriate signals when necessary.
 *
 * "Special" children such as the startup, bgwriter and autovacuum launcher
 * tasks are not in this list.  Autovacuum worker and walsender are in it.
 * Also, "dead_end" children are in it: these are children launched just for
 * the purpose of sending a friendly rejection message to a would-be client.
 * We must track them because they are attached to shared memory, but we know
 * they will never become live backends.  dead_end children are not assigned a
 * PMChildSlot.
 *
 * Background workers are in this list, too.
 */</comment>
<typedef>typedef <type><struct>struct <name>bkend</name>
<block>{
	<decl_stmt><decl><type><name>pid_t</name></type>		<name>pid</name></decl>;</decl_stmt>			<comment type="block">/* process id of backend */</comment>
	<decl_stmt><decl><type><name>int32</name></type>		<name>cancel_key</name></decl>;</decl_stmt>		<comment type="block">/* cancel key for cancels for this backend */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>child_slot</name></decl>;</decl_stmt>		<comment type="block">/* PMChildSlot for this backend, if any */</comment>

	<comment type="block">/*
	 * Flavor of backend or auxiliary process.  Note that BACKEND_TYPE_WALSND
	 * backends initially announce themselves as BACKEND_TYPE_NORMAL, so if
	 * bkend_type is normal, you should check for a recent transition.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>bkend_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>dead_end</name></decl>;</decl_stmt>		<comment type="block">/* is it going to send an error and quit? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>bgworker_notify</name></decl>;</decl_stmt>	<comment type="block">/* gets bgworker start/stop notifications */</comment>
	<decl_stmt><decl><type><name>dlist_node</name></type>	<name>elem</name></decl>;</decl_stmt>			<comment type="block">/* list link in BackendList */</comment>
}</block></struct></type> <name>Backend</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>dlist_head</name></type> <name>BackendList</name> <init>= <expr><call><name>DLIST_STATIC_INIT</name><argument_list>(<argument><expr><name>BackendList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>too_many_conn</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>Backend</name> <modifier>*</modifier></type><name>ShmemBackendArray</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>BackgroundWorker</name> <modifier>*</modifier></type><name>MyBgworkerEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>



<comment type="block">/* The socket number we are listening for connections on */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>PostPortNumber</name></decl>;</decl_stmt>

<comment type="block">/* The directory names for Unix socket(s) */</comment>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>Unix_socket_directories</name></decl>;</decl_stmt>

<comment type="block">/* The TCP listen address(es) */</comment>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ListenAddresses</name></decl>;</decl_stmt>

<comment type="block">/*
 * ReservedBackends is the number of backends reserved for superuser use.
 * This number is taken out of the pool size given by MaxConnections so
 * number of backend slots available to non-superusers is
 * (MaxConnections - ReservedBackends).  Note what this really means is
 * "if there are &lt;= ReservedBackends connections available, only superusers
 * can make new connections" --- pre-existing superuser connections don't
 * count against the limit.
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>ReservedBackends</name></decl>;</decl_stmt>

<comment type="block">/* The socket(s) we're listening to. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXLISTEN</name></cpp:macro>	<cpp:value>64</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>pgsocket</name></type> <name><name>ListenSocket</name><index>[<expr><name>MAXLISTEN</name></expr>]</index></name></decl>;</decl_stmt>

<comment type="block">/*
 * Set by the -o option
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>ExtraOptions</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

<comment type="block">/*
 * These globals control the behavior of the postmaster in case some
 * backend dumps core.  Normally, it kills all peers of the dead backend
 * and reinitializes shared memory.  By specifying -s or -n, we can have
 * the postmaster stop (rather than kill) peers and not reinitialize
 * shared data structures.  (Reinit is currently dead code, though.)
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>Reinit</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>SendStop</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* still more option variables */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>EnableSSL</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type>			<name>PreAuthDelay</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>AuthenticationTimeout</name> <init>= <expr><literal type="number">60</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type>		<name>log_hostname</name></decl>;</decl_stmt>		<comment type="block">/* for ps display and logging */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>Log_connections</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>Db_user_namespace</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type>		<name>enable_bonjour</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>bonjour_name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>restart_after_crash</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* PIDs of special child processes; 0 when not running */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>pid_t</name></type> <name>StartupPID</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
			<decl><type ref="prev"/><name>BgWriterPID</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
			<decl><type ref="prev"/><name>CheckpointerPID</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
			<decl><type ref="prev"/><name>WalWriterPID</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
			<decl><type ref="prev"/><name>WalReceiverPID</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
			<decl><type ref="prev"/><name>AutoVacPID</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
			<decl><type ref="prev"/><name>PgArchPID</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
			<decl><type ref="prev"/><name>PgStatPID</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
			<decl><type ref="prev"/><name>SysLoggerPID</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Startup process's status */</comment>
<typedef>typedef <type><enum>enum
<block>{
	<decl><name>STARTUP_NOT_RUNNING</name></decl>,
	<decl><name>STARTUP_RUNNING</name></decl>,
	<decl><name>STARTUP_SIGNALED</name></decl>,			<comment type="block">/* we sent it a SIGQUIT or SIGKILL */</comment>
	<decl><name>STARTUP_CRASHED</name></decl>
}</block></enum></type> <name>StartupStatusEnum</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>StartupStatusEnum</name></type> <name>StartupStatus</name> <init>= <expr><name>STARTUP_NOT_RUNNING</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Startup/shutdown state */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive>			<cpp:macro><name>NoShutdown</name></cpp:macro>		<cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>			<cpp:macro><name>SmartShutdown</name></cpp:macro>	<cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>			<cpp:macro><name>FastShutdown</name></cpp:macro>	<cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>			<cpp:macro><name>ImmediateShutdown</name></cpp:macro>	<cpp:value>3</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>Shutdown</name> <init>= <expr><name>NoShutdown</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>FatalError</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt> <comment type="block">/* T if recovering from backend crash */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>YbCrashWhileLockIntermediateState</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Crashed before fully acquiring a lock */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__linux__</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>YbBackendOomScoreAdj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * We use a simple state machine to control startup, shutdown, and
 * crash recovery (which is rather like shutdown followed by startup).
 *
 * After doing all the postmaster initialization work, we enter PM_STARTUP
 * state and the startup process is launched. The startup process begins by
 * reading the control file and other preliminary initialization steps.
 * In a normal startup, or after crash recovery, the startup process exits
 * with exit code 0 and we switch to PM_RUN state.  However, archive recovery
 * is handled specially since it takes much longer and we would like to support
 * hot standby during archive recovery.
 *
 * When the startup process is ready to start archive recovery, it signals the
 * postmaster, and we switch to PM_RECOVERY state. The background writer and
 * checkpointer are launched, while the startup process continues applying WAL.
 * If Hot Standby is enabled, then, after reaching a consistent point in WAL
 * redo, startup process signals us again, and we switch to PM_HOT_STANDBY
 * state and begin accepting connections to perform read-only queries.  When
 * archive recovery is finished, the startup process exits with exit code 0
 * and we switch to PM_RUN state.
 *
 * Normal child backends can only be launched when we are in PM_RUN or
 * PM_HOT_STANDBY state.  (We also allow launch of normal
 * child backends in PM_WAIT_BACKUP state, but only for superusers.)
 * In other states we handle connection requests by launching "dead_end"
 * child processes, which will simply send the client an error message and
 * quit.  (We track these in the BackendList so that we can know when they
 * are all gone; this is important because they're still connected to shared
 * memory, and would interfere with an attempt to destroy the shmem segment,
 * possibly leading to SHMALL failure when we try to make a new one.)
 * In PM_WAIT_DEAD_END state we are waiting for all the dead_end children
 * to drain out of the system, and therefore stop accepting connection
 * requests at all until the last existing child has quit (which hopefully
 * will not be very long).
 *
 * Notice that this state variable does not distinguish *why* we entered
 * states later than PM_RUN --- Shutdown and FatalError must be consulted
 * to find that out.  FatalError is never true in PM_RECOVERY_* or PM_RUN
 * states, nor in PM_SHUTDOWN states (because we don't enter those states
 * when trying to recover from a crash).  It can be true in PM_STARTUP state,
 * because we don't clear it until we've successfully started WAL redo.
 */</comment>
<typedef>typedef <type><enum>enum
<block>{
	<decl><name>PM_INIT</name></decl>,					<comment type="block">/* postmaster starting */</comment>
	<decl><name>PM_STARTUP</name></decl>,					<comment type="block">/* waiting for startup subprocess */</comment>
	<decl><name>PM_RECOVERY</name></decl>,				<comment type="block">/* in archive recovery mode */</comment>
	<decl><name>PM_HOT_STANDBY</name></decl>,				<comment type="block">/* in hot standby mode */</comment>
	<decl><name>PM_RUN</name></decl>,						<comment type="block">/* normal "database is alive" state */</comment>
	<decl><name>PM_WAIT_BACKUP</name></decl>,				<comment type="block">/* waiting for online backup mode to end */</comment>
	<decl><name>PM_WAIT_READONLY</name></decl>,			<comment type="block">/* waiting for read only backends to exit */</comment>
	<decl><name>PM_WAIT_BACKENDS</name></decl>,			<comment type="block">/* waiting for live backends to exit */</comment>
	<decl><name>PM_SHUTDOWN</name></decl>,				<comment type="block">/* waiting for checkpointer to do shutdown
								 * ckpt */</comment>
	<decl><name>PM_SHUTDOWN_2</name></decl>,				<comment type="block">/* waiting for archiver and walsenders to
								 * finish */</comment>
	<decl><name>PM_WAIT_DEAD_END</name></decl>,			<comment type="block">/* waiting for dead_end children to exit */</comment>
	<decl><name>PM_NO_CHILDREN</name></decl>				<comment type="block">/* all important children have exited */</comment>
}</block></enum></type> <name>PMState</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>PMState</name></type> <name>pmState</name> <init>= <expr><name>PM_INIT</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Start time of SIGKILL timeout during immediate shutdown or child crash */</comment>
<comment type="block">/* Zero means timeout is not running */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>time_t</name></type> <name>AbortStartTime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Length of said timeout */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIGKILL_CHILDREN_AFTER_SECS</name></cpp:macro>		<cpp:value>5</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>ReachedNormalRunning</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* T if we've reached PM_RUN */</comment>

<decl_stmt><decl><type><name>bool</name></type>		<name>ClientAuthInProgress</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* T during new-client
											 * authentication */</comment>

<decl_stmt><decl><type><name>bool</name></type>		<name>redirection_done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* stderr redirected for syslogger? */</comment>

<comment type="block">/* received START_AUTOVAC_LAUNCHER signal */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>start_autovac_launcher</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* the launcher needs to be signalled to communicate some condition */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>bool</name></type> <name>avlauncher_needs_signal</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* received START_WALRECEIVER signal */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>WalReceiverRequested</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* set when there's a worker that needs to be started up */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>bool</name></type> <name>StartWorkerNeeded</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>bool</name></type> <name>HaveCrashedWorker</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_STRONG_RANDOM</name></cpp:ifndef>
<comment type="block">/*
 * State for assigning cancel keys.
 * Also, the global MyCancelKey passes the cancel key assigned to a given
 * backend from the postmaster to that backend (via fork).
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>random_seed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>timeval</name></name></type> <name>random_start_time</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
<comment type="block">/* Set when and if SSL has been initialized properly */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>LoadedSSL</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_BONJOUR</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>DNSServiceRef</name></type> <name>bonjour_sdref</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * postmaster.c - function prototypes
 */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CloseServerPorts</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>unlink_external_pid_file</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>getInstallationPaths</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>argv0</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>checkControlFile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Port</name> <modifier>*</modifier></type><name>ConnCreate</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>serverFd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ConnFree</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>reset_shared</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>port</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SIGHUP_handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pmdie</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>reaper</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sigusr1_handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>startup_die</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dummy_handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>StartupPacketTimeoutHandler</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CleanupBackend</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>exitstatus</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CleanupBackgroundWorker</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>exitstatus</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>HandleChildCrash</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>exitstatus</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>procname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>LogChildExit</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lev</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>procname</name></decl></parameter>,
			 <parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>exitstatus</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PostmasterStateMachine</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>BackendInitialize</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>BackendRun</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list> pg_attribute_noreturn<parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExitPostmaster</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>)</parameter_list> pg_attribute_noreturn<parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>ServerLoop</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>BackendStartup</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>ProcessStartupPacket</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>SSLdone</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SendNegotiateProtocolVersion</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>unrecognized_protocol_options</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>processCancelRequest</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>initMasks</name><parameter_list>(<parameter><decl><type><name>fd_set</name> <modifier>*</modifier></type><name>rmask</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>report_fork_failure_to_client</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>errnum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CAC_state</name></type> <name>canAcceptConnections</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>backend_type</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>RandomCancelKey</name><parameter_list>(<parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>cancel_key</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>signal_child</name><parameter_list>(<parameter><decl><type><name>pid_t</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>signal</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>SignalSomeChildren</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>signal</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targets</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TerminateChildren</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>signal</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SignalChildren</name><parameter_list>(<parameter><type><name>sig</name></type></parameter>)</parameter_list></cpp:macro>			   <cpp:value>SignalSomeChildren(sig, BACKEND_TYPE_ALL)</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>CountChildren</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>target</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>assign_backendlist_entry</name><parameter_list>(<parameter><decl><type><name>RegisteredBgWorker</name> <modifier>*</modifier></type><name>rw</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>maybe_start_bgworkers</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CreateOptsFile</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fullprogname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>pid_t</name></type> <name>StartChildProcess</name><parameter_list>(<parameter><decl><type><name>AuxProcType</name></type> <name>type</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>StartAutovacuumWorker</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>MaybeStartWalReceiver</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InitPostmasterDeathWatchHandle</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Archiver is allowed to start up at the current postmaster state?
 *
 * If WAL archiving is enabled always, we are allowed to start archiver
 * even during recovery.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PgArchStartupAllowed</name><parameter_list>()</parameter_list></cpp:macro>	\
	<cpp:value>((XLogArchivingActive() &amp;&amp; pmState == PM_RUN) ||	\
	 (XLogArchivingAlways() &amp;&amp;	\
	  (pmState == PM_RECOVERY || pmState == PM_HOT_STANDBY)))</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WNOHANG</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>				<comment type="block">/* ignored, so any integer value will do */</comment>

<function_decl><type><specifier>static</specifier> <name>pid_t</name></type> <name>waitpid</name><parameter_list>(<parameter><decl><type><name>pid_t</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>exitstatus</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <name>WINAPI</name></type> <name>pgwin32_deadchild_callback</name><parameter_list>(<parameter><decl><type><name>PVOID</name></type> <name>lpParameter</name></decl></parameter>, <parameter><decl><type><name>BOOLEAN</name></type> <name>TimerOrWaitFired</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>HANDLE</name></type> <name>win32ChildQueue</name></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>HANDLE</name></type>		<name>waitHandle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HANDLE</name></type>		<name>procHandle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DWORD</name></type>		<name>procId</name></decl>;</decl_stmt>
}</block></struct></type> <name>win32_deadchild_waitinfo</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>

<function_decl><type><specifier>static</specifier> <name>pid_t</name></type> <name>backend_forkexec</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>pid_t</name></type> <name>internal_forkexec</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Type for a socket that can be inherited to a client process */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>SOCKET</name></type>		<name>origsocket</name></decl>;</decl_stmt>		<comment type="block">/* Original socket value, or PGINVALID_SOCKET
								 * if not a socket */</comment>
	<decl_stmt><decl><type><name>WSAPROTOCOL_INFO</name></type> <name>wsainfo</name></decl>;</decl_stmt>
}</block></struct></type> <name>InheritableSocket</name>;</typedef>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<typedef>typedef <type><name>int</name></type> <name>InheritableSocket</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Structure contains all variables passed to exec:ed backends
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>Port</name></type>		<name>port</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>InheritableSocket</name></type> <name>portsocket</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>DataDir</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgsocket</name></type>	<name><name>ListenSocket</name><index>[<expr><name>MAXLISTEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>MyCancelKey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>MyPMChildSlot</name></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>UsedShmemSegID</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>HANDLE</name></type>		<name>UsedShmemSegID</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>UsedShmemSegAddr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>slock_t</name>    <modifier>*</modifier></type><name>ShmemLock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VariableCache</name></type> <name>ShmemVariableCache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Backend</name>    <modifier>*</modifier></type><name>ShmemBackendArray</name></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_SPINLOCKS</name></cpp:ifndef>
	<decl_stmt><decl><type><name>PGSemaphore</name> <modifier>*</modifier></type><name>SpinlockSemaArray</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>int</name></type>			<name>NamedLWLockTrancheRequests</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NamedLWLockTranche</name> <modifier>*</modifier></type><name>NamedLWLockTrancheArray</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLockPadded</name> <modifier>*</modifier></type><name>MainLWLockArray</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>slock_t</name>    <modifier>*</modifier></type><name>ProcStructLock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PROC_HDR</name>   <modifier>*</modifier></type><name>ProcGlobal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>AuxiliaryProcs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>PreparedXactProcs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PMSignalData</name> <modifier>*</modifier></type><name>PMSignalState</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>InheritableSocket</name></type> <name>pgStatSock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pid_t</name></type>		<name>PostmasterPid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>PgStartTime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>PgReloadTime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>first_syslogger_file_time</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>redirection_done</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>IsBinaryUpgrade</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>max_safe_fds</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>MaxBackends</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<decl_stmt><decl><type><name>HANDLE</name></type>		<name>PostmasterHandle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HANDLE</name></type>		<name>initial_signal_pipe</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HANDLE</name></type>		<name><name>syslogPipe</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>postmaster_alive_fds</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>syslogPipe</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>my_exec_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>pkglib_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>ExtraOptions</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>BackendParameters</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>read_backend_variables</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>restore_backend_variables</name><parameter_list>(<parameter><decl><type><name>BackendParameters</name> <modifier>*</modifier></type><name>param</name></decl></parameter>, <parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>save_backend_variables</name><parameter_list>(<parameter><decl><type><name>BackendParameters</name> <modifier>*</modifier></type><name>param</name></decl></parameter>, <parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>save_backend_variables</name><parameter_list>(<parameter><decl><type><name>BackendParameters</name> <modifier>*</modifier></type><name>param</name></decl></parameter>, <parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>,
					   <parameter><decl><type><name>HANDLE</name></type> <name>childProcess</name></decl></parameter>, <parameter><decl><type><name>pid_t</name></type> <name>childPid</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ShmemBackendArrayAdd</name><parameter_list>(<parameter><decl><type><name>Backend</name> <modifier>*</modifier></type><name>bn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ShmemBackendArrayRemove</name><parameter_list>(<parameter><decl><type><name>Backend</name> <modifier>*</modifier></type><name>bn</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* EXEC_BACKEND */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>StartupDataBase</name><parameter_list>()</parameter_list></cpp:macro>		<cpp:value>StartChildProcess(StartupProcess)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>StartBackgroundWriter</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>StartChildProcess(BgWriterProcess)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>StartCheckpointer</name><parameter_list>()</parameter_list></cpp:macro>		<cpp:value>StartChildProcess(CheckpointerProcess)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>StartWalWriter</name><parameter_list>()</parameter_list></cpp:macro>		<cpp:value>StartChildProcess(WalWriterProcess)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>StartWalReceiver</name><parameter_list>()</parameter_list></cpp:macro>		<cpp:value>StartChildProcess(WalReceiverProcess)</cpp:value></cpp:define>

<comment type="block">/* Macros to check exit status of a child process */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXIT_STATUS_0</name><parameter_list>(<parameter><type><name>st</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>((st) == 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXIT_STATUS_1</name><parameter_list>(<parameter><type><name>st</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(WIFEXITED(st) &amp;&amp; WEXITSTATUS(st) == 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXIT_STATUS_3</name><parameter_list>(<parameter><type><name>st</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(WIFEXITED(st) &amp;&amp; WEXITSTATUS(st) == 3)</cpp:value></cpp:define>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<comment type="block">/*
 * File descriptors for pipe used to monitor if postmaster is alive.
 * First is POSTMASTER_FD_WATCH, second is POSTMASTER_FD_OWN.
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name><name>postmaster_alive_fds</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<comment type="block">/* Process handle of postmaster used for the same purpose on Windows */</comment>
<decl_stmt><decl><type><name>HANDLE</name></type>		<name>PostmasterHandle</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Wrap strdup so we can suppress LeakSanitizer (LSAN) warnings here without
 * suppressing them in all occurrences of strdup.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>postmaster_strdup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>in</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>strdup</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Postmaster main entry point
 */</comment>
<function><type><name>void</name></type>
<name>PostmasterMain</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>opt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>userDoption</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>listen_addr_saved</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>output_config_variable</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="line">// This should be done as the first thing after process start.</comment>
	<expr_stmt><expr><call><name>YBSetParentDeathSignal</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>MyProcPid</name> <operator>=</operator> <name>PostmasterPid</name> <operator>=</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>MyStartTime</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>IsPostmasterEnvironment</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>YBIsEnabledInPostgresEnvVar</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>YBCStatementTimeoutPtr</name> <operator>=</operator> <operator>&amp;</operator><name>StatementTimeout</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We should not be creating any files or directories before we check the
	 * data directory (see checkDataDir()), but just in case set the umask to
	 * the most restrictive (owner-only) permissions.
	 *
	 * checkDataDir() will reset the umask based on the data directory
	 * permissions.
	 */</comment>
	<expr_stmt><expr><call><name>umask</name><argument_list>(<argument><expr><name>PG_MODE_MASK_OWNER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize random(3) so we don't get the same values in every run.
	 *
	 * Note: the seed is pretty predictable from externally-visible facts such
	 * as postmaster start time, so avoid using random() for security-critical
	 * random values during postmaster startup.  At the time of first
	 * connection, PostmasterRandom will select a hopefully-more-random seed.
	 */</comment>
	<expr_stmt><expr><call><name>srandom</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <operator>(</operator><name>MyProcPid</name> <operator>^</operator> <name>MyStartTime</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * By default, palloc() requests in the postmaster will be allocated in
	 * the PostmasterContext, which is space that can be recycled by backends.
	 * Allocated data that needs to be available to backends should be
	 * allocated in TopMemoryContext.
	 */</comment>
	<expr_stmt><expr><name>PostmasterContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
											  <argument><expr><literal type="string">"Postmaster"</literal></expr></argument>,
											  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>PostmasterContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize paths to installation files */</comment>
	<expr_stmt><expr><call><name>getInstallationPaths</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up signal handlers for the postmaster process.
	 *
	 * In the postmaster, we want to install non-ignored handlers *without*
	 * SA_RESTART.  This is because they'll be blocked at all times except
	 * when ServerLoop is waiting for something to happen, and during that
	 * window, we want signals to exit the select(2) wait so that ServerLoop
	 * can respond if anything interesting happened.  On some platforms,
	 * signals marked SA_RESTART would not cause the select() wait to end.
	 * Child processes will generally want SA_RESTART, but we expect them to
	 * set up their own handlers before unblocking signals.
	 *
	 * CAUTION: when changing this list, check for side-effects on the signal
	 * handling setup of child processes.  See tcop/postgres.c,
	 * bootstrap/bootstrap.c, postmaster/bgwriter.c, postmaster/walwriter.c,
	 * postmaster/autovacuum.c, postmaster/pgarch.c, postmaster/pgstat.c,
	 * postmaster/syslogger.c, postmaster/bgworker.c and
	 * postmaster/checkpointer.c.
	 */</comment>
	<expr_stmt><expr><call><name>pqinitmask</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pqsignal_no_restart</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>SIGHUP_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* reread config file and
													 * have children do same */</comment>
	<expr_stmt><expr><call><name>pqsignal_no_restart</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>pmdie</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* send SIGTERM and shut down */</comment>
	<expr_stmt><expr><call><name>pqsignal_no_restart</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><name>pmdie</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* send SIGQUIT and die */</comment>
	<expr_stmt><expr><call><name>pqsignal_no_restart</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>pmdie</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* wait for children and shut down */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGALRM</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* ignored */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* ignored */</comment>
	<expr_stmt><expr><call><name>pqsignal_no_restart</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><name>sigusr1_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* message from child
													 * process */</comment>
	<expr_stmt><expr><call><name>pqsignal_no_restart</name><argument_list>(<argument><expr><name>SIGUSR2</name></expr></argument>, <argument><expr><name>dummy_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* unused, reserve for
													 * children */</comment>
	<expr_stmt><expr><call><name>pqsignal_no_restart</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>, <argument><expr><name>reaper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* handle child termination */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTTIN</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* ignored */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTTOU</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* ignored */</comment>
	<comment type="block">/* ignore SIGXFSZ, so that ulimit violations work like disk full */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGXFSZ</name></cpp:ifdef>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGXFSZ</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* ignored */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Options setup
	 */</comment>
	<expr_stmt><expr><call><name>InitializeGUCOptions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>opterr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Parse command-line options.  CAUTION: keep this in sync with
	 * tcop/postgres.c (the option sets should not conflict) and with the
	 * common help() function in main/main.c.
	 */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>opt</name> <operator>=</operator> <call><name>getopt</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"B:bc:C:D:d:EeFf:h:ijk:lN:nOo:Pp:r:S:sTt:W:-:"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>opt</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'B'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"shared_buffers"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_ARGV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'b'</literal></expr>:</case>
				<comment type="block">/* Undocumented flag used for binary upgrades */</comment>
				<expr_stmt><expr><name>IsBinaryUpgrade</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'C'</literal></expr>:</case>
				<expr_stmt><expr><name>output_config_variable</name> <operator>=</operator> <call><name>postmaster_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'D'</literal></expr>:</case>
				<expr_stmt><expr><name>userDoption</name> <operator>=</operator> <call><name>postmaster_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'d'</literal></expr>:</case>
				<expr_stmt><expr><call><name>set_debug_options</name><argument_list>(<argument><expr><call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_ARGV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'E'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"log_statement"</literal></expr></argument>, <argument><expr><literal type="string">"all"</literal></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_ARGV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'e'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"datestyle"</literal></expr></argument>, <argument><expr><literal type="string">"euro"</literal></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_ARGV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'F'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"fsync"</literal></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_ARGV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'f'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>set_plan_disabling_options</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_ARGV</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"%s: invalid argument for option -f: \"%s\"\n"</literal></expr></argument>,
								 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ExitPostmaster</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'h'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"listen_addresses"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_ARGV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'i'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"listen_addresses"</literal></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_ARGV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'j'</literal></expr>:</case>
				<comment type="block">/* only used by interactive backend */</comment>
				<break>break;</break>

			<case>case <expr><literal type="char">'k'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"unix_socket_directories"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_ARGV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'l'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"ssl"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_ARGV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'N'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"max_connections"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_ARGV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'n'</literal></expr>:</case>
				<comment type="block">/* Don't reinit shared mem after abnormal exit */</comment>
				<expr_stmt><expr><name>Reinit</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'O'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"allow_system_table_mods"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_ARGV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'o'</literal></expr>:</case>
				<comment type="block">/* Other options to pass to the backend on the command line */</comment>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>ExtraOptions</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>ExtraOptions</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExtraOptions</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>ExtraOptions</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'P'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"ignore_system_indexes"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_ARGV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'p'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"port"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_ARGV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'r'</literal></expr>:</case>
				<comment type="block">/* only used by single-user backend */</comment>
				<break>break;</break>

			<case>case <expr><literal type="char">'S'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"work_mem"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_ARGV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'s'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"log_statement_stats"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_ARGV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'T'</literal></expr>:</case>

				<comment type="block">/*
				 * In the event that some backend dumps core, send SIGSTOP,
				 * rather than SIGQUIT, to all its peers.  This lets the wily
				 * post_hacker collect core dumps from everyone.
				 */</comment>
				<expr_stmt><expr><name>SendStop</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'t'</literal></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>get_stats_option_name</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>tmp</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_ARGV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"%s: invalid argument for option -t: \"%s\"\n"</literal></expr></argument>,
									 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ExitPostmaster</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<break>break;</break>
				</block_content>}</block>

			<case>case <expr><literal type="char">'W'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"post_auth_delay"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_ARGV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'c'</literal></expr>:</case>
			<case>case <expr><literal type="char">'-'</literal></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name></decl>,
							   <decl><type ref="prev"><modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>ParseLongOption</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>value</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>opt</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"--%s requires a value"</literal></expr></argument>,
											<argument><expr><name>optarg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"-c %s requires a value"</literal></expr></argument>,
											<argument><expr><name>optarg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_ARGV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				</block_content>}</block>

			<default>default:</default>
				<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>,
							 <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExitPostmaster</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Postmaster accepts no non-option switch arguments.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>optind</name> <operator>&lt;</operator> <name>argc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"%s: invalid argument: \"%s\"\n"</literal></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExitPostmaster</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Locate the proper configuration files and data directory, and read
	 * postgresql.conf for the first time.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SelectConfigFiles</name><argument_list>(<argument><expr><name>userDoption</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExitPostmaster</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>output_config_variable</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * "-C guc" was specified, so print GUC's value and exit.  No extra
		 * permission check is needed because the user is reading inside the
		 * data dir.
		 */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>config_val</name> <init>= <expr><call><name>GetConfigOption</name><argument_list>(<argument><expr><name>output_config_variable</name></expr></argument>,
												 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><ternary><condition><expr><name>config_val</name></expr> ?</condition><then> <expr><name>config_val</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExitPostmaster</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Verify that DataDir looks reasonable */</comment>
	<expr_stmt><expr><call><name>checkDataDir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check that pg_control exists */</comment>
	<expr_stmt><expr><call><name>checkControlFile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* And switch working directory into it */</comment>
	<expr_stmt><expr><call><name>ChangeToDataDir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check for invalid combinations of GUC settings.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ReservedBackends</name> <operator>+</operator> <name>max_wal_senders</name> <operator>&gt;=</operator> <name>MaxConnections</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"%s: superuser_reserved_connections (%d) plus max_wal_senders (%d) must be less than max_connections (%d)\n"</literal></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>,
					 <argument><expr><name>ReservedBackends</name></expr></argument>, <argument><expr><name>max_wal_senders</name></expr></argument>, <argument><expr><name>MaxConnections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExitPostmaster</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>XLogArchiveMode</name> <operator>&gt;</operator> <name>ARCHIVE_MODE_OFF</name> <operator>&amp;&amp;</operator> <name>wal_level</name> <operator>==</operator> <name>WAL_LEVEL_MINIMAL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"WAL archival cannot be enabled when wal_level is \"minimal\""</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>max_wal_senders</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>wal_level</name> <operator>==</operator> <name>WAL_LEVEL_MINIMAL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"WAL streaming (max_wal_senders &gt; 0) requires wal_level \"replica\" or \"logical\""</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Other one-time internal sanity checks can go here, if they are fast.
	 * (Put any slow processing further down, after postmaster.pid creation.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckDateTokenTables</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"%s: invalid datetoken tables, please fix\n"</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExitPostmaster</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now that we are done processing the postmaster arguments, reset
	 * getopt(3) library so that it will work correctly in subprocesses.
	 */</comment>
	<expr_stmt><expr><name>optind</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT_OPTRESET</name></cpp:ifdef>
	<expr_stmt><expr><name>optreset</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>				<comment type="block">/* some systems need this too */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* For debugging: display postmaster environment */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>environ</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%s: PostmasterMain: initial environment dump:"</literal></expr></argument>,
								 <argument><expr><name>progname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"-----------------------------------------"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>environ</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"\t%s"</literal></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"-----------------------------------------"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>YBReportIfYugaByteEnabled</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__APPLE__</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><call><name>YBIsEnabledInPostgresEnvVar</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * Resolve local hostname to initialize macOS network libraries. If we
		 * don't do this, there might be a lot of segmentation faults in
		 * PostgreSQL backend processes in tests on macOS (especially debug
		 * mode).
		 *
		 * See https://github.com/yugabyte/yugabyte-db/issues/2509 for details.
		 */</comment>
		<expr_stmt><expr><call><name>YBCResolveHostname</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Create lockfile for data directory.
	 *
	 * We want to do this before we try to grab the input sockets, because the
	 * data directory interlock is more reliable than the socket-file
	 * interlock (thanks to whoever decided to put socket files in /tmp :-().
	 * For the same reason, it's best to grab the TCP socket(s) before the
	 * Unix socket(s).
	 *
	 * Also note that this internally sets up the on_proc_exit function that
	 * is responsible for removing both data directory and socket lockfiles;
	 * so it must happen before opening sockets so that at exit, the socket
	 * lockfiles go away after CloseServerPorts runs.
	 */</comment>
	<expr_stmt><expr><call><name>CreateDataDirLockFile</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Read the control file (for error checking and config info).
	 *
	 * Since we verify the control file's CRC, this has a useful side effect
	 * on machines where we need a run-time test for CRC support instructions.
	 * The postmaster will do the test once at startup, and then its child
	 * processes will inherit the correct function pointer and not need to
	 * repeat the test.
	 */</comment>
	<expr_stmt><expr><call><name>LocalProcessControlFile</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize SSL library, if specified.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>EnableSSL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>secure_initialize</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>LoadedSSL</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Register the apply launcher.  Since it registers a background worker,
	 * it needs to be called before InitializeMaxBackends(), and it's probably
	 * a good idea to call it before any modules had chance to take the
	 * background worker slots.
	 *
	 * Logical replication is not supported in YugaByte mode currently and the
	 * registration is disabled.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>YBIsEnabledInPostgresEnvVar</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ApplyLauncherRegister</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * process any libraries that should be preloaded at postmaster start
	 */</comment>
	<expr_stmt><expr><call><name>process_shared_preload_libraries</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now that loadable modules have had their chance to register background
	 * workers, calculate MaxBackends.
	 */</comment>
	<expr_stmt><expr><call><name>InitializeMaxBackends</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Establish input sockets.
	 *
	 * First, mark them all closed, and set up an on_proc_exit function that's
	 * charged with closing the sockets again at postmaster shutdown.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAXLISTEN</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ListenSocket</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>PGINVALID_SOCKET</name></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>on_proc_exit</name><argument_list>(<argument><expr><name>CloseServerPorts</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ListenAddresses</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rawstring</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>elemlist</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>success</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Need a modifiable copy of ListenAddresses */</comment>
		<expr_stmt><expr><name>rawstring</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>ListenAddresses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Parse string into list of hostnames */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SplitIdentifierString</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>elemlist</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* syntax error in list */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid list syntax in parameter \"%s\""</literal></expr></argument>,
							<argument><expr><literal type="string">"listen_addresses"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>elemlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>curhost</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>curhost</name></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>StreamServerPort</name><argument_list>(<argument><expr><name>AF_UNSPEC</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
										  <argument><expr><operator>(</operator><name>unsigned</name> <name>short</name><operator>)</operator> <name>PostPortNumber</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>,
										  <argument><expr><name>ListenSocket</name></expr></argument>, <argument><expr><name>MAXLISTEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>StreamServerPort</name><argument_list>(<argument><expr><name>AF_UNSPEC</name></expr></argument>, <argument><expr><name>curhost</name></expr></argument>,
										  <argument><expr><operator>(</operator><name>unsigned</name> <name>short</name><operator>)</operator> <name>PostPortNumber</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>,
										  <argument><expr><name>ListenSocket</name></expr></argument>, <argument><expr><name>MAXLISTEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>STATUS_OK</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>success</name><operator>++</operator></expr>;</expr_stmt>
				<comment type="block">/* record the first successful host addr in lockfile */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>listen_addr_saved</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>AddToDataDirLockFile</name><argument_list>(<argument><expr><name>LOCK_FILE_LINE_LISTEN_ADDR</name></expr></argument>, <argument><expr><name>curhost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>listen_addr_saved</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create listen socket for \"%s\""</literal></expr></argument>,
								<argument><expr><name>curhost</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name> <operator>&amp;&amp;</operator> <name>elemlist</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create any TCP/IP sockets"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>elemlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_BONJOUR</name></cpp:ifdef>
	<comment type="block">/* Register for Bonjour only if we opened TCP socket(s) */</comment>
	<if_stmt><if>if <condition>(<expr><name>enable_bonjour</name> <operator>&amp;&amp;</operator> <name><name>ListenSocket</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>PGINVALID_SOCKET</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DNSServiceErrorType</name></type> <name>err</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We pass 0 for interface_index, which will result in registering on
		 * all "applicable" interfaces.  It's not entirely clear from the
		 * DNS-SD docs whether this would be appropriate if we have bound to
		 * just a subset of the available network interfaces.
		 */</comment>
		<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>DNSServiceRegister</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bonjour_sdref</name></expr></argument>,
								 <argument><expr><literal type="number">0</literal></expr></argument>,
								 <argument><expr><literal type="number">0</literal></expr></argument>,
								 <argument><expr><name>bonjour_name</name></expr></argument>,
								 <argument><expr><literal type="string">"_postgresql._tcp."</literal></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><call><name>pg_hton16</name><argument_list>(<argument><expr><name>PostPortNumber</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><literal type="number">0</literal></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <name>kDNSServiceErr_NoError</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"DNSServiceRegister() failed: error code %ld"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We don't bother to read the mDNS daemon's reply, and we expect that
		 * it will automatically terminate our registration when the socket is
		 * closed at postmaster termination.  So there's nothing more to be
		 * done here.  However, the bonjour_sdref is kept around so that
		 * forked children can close their copies of the socket.
		 */</comment>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>Unix_socket_directories</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rawstring</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>elemlist</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>success</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Need a modifiable copy of Unix_socket_directories */</comment>
		<expr_stmt><expr><name>rawstring</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>Unix_socket_directories</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Parse string into list of directories */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SplitDirectoriesString</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>elemlist</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* syntax error in list */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid list syntax in parameter \"%s\""</literal></expr></argument>,
							<argument><expr><literal type="string">"unix_socket_directories"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>elemlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>socketdir</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>StreamServerPort</name><argument_list>(<argument><expr><name>AF_UNIX</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									  <argument><expr><operator>(</operator><name>unsigned</name> <name>short</name><operator>)</operator> <name>PostPortNumber</name></expr></argument>,
									  <argument><expr><name>socketdir</name></expr></argument>,
									  <argument><expr><name>ListenSocket</name></expr></argument>, <argument><expr><name>MAXLISTEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>STATUS_OK</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>success</name><operator>++</operator></expr>;</expr_stmt>
				<comment type="block">/* record the first successful Unix socket in lockfile */</comment>
				<if_stmt><if>if <condition>(<expr><name>success</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>AddToDataDirLockFile</name><argument_list>(<argument><expr><name>LOCK_FILE_LINE_SOCKET_DIR</name></expr></argument>, <argument><expr><name>socketdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create Unix-domain socket in directory \"%s\""</literal></expr></argument>,
								<argument><expr><name>socketdir</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name> <operator>&amp;&amp;</operator> <name>elemlist</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create any Unix-domain sockets"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>elemlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * check that we have some socket to listen on
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ListenSocket</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>PGINVALID_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no socket created for listening"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If no valid TCP ports, write an empty line for listen address,
	 * indicating the Unix socket must be used.  Note that this line is not
	 * added to the lock file until there is a socket backing it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>listen_addr_saved</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AddToDataDirLockFile</name><argument_list>(<argument><expr><name>LOCK_FILE_LINE_LISTEN_ADDR</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Set up shared memory and semaphores.
	 */</comment>
	<expr_stmt><expr><call><name>reset_shared</name><argument_list>(<argument><expr><name>PostPortNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Estimate number of openable files.  This must happen after setting up
	 * semaphores, because on some platforms semaphores count as open files.
	 */</comment>
	<expr_stmt><expr><call><name>set_max_safe_fds</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set reference point for stack-depth checking.
	 */</comment>
	<expr_stmt><expr><call><name>set_stack_base</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize pipe (or process handle on Windows) that allows children to
	 * wake up from sleep on postmaster death.
	 */</comment>
	<expr_stmt><expr><call><name>InitPostmasterDeathWatchHandle</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>

	<comment type="block">/*
	 * Initialize I/O completion port used to deliver list of dead children.
	 */</comment>
	<expr_stmt><expr><name>win32ChildQueue</name> <operator>=</operator> <call><name>CreateIoCompletionPort</name><argument_list>(<argument><expr><name>INVALID_HANDLE_VALUE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>win32ChildQueue</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create I/O completion port for child queue"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Record postmaster options.  We delay this till now to avoid recording
	 * bogus options (eg, NBuffers too high for available memory).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CreateOptsFile</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>my_exec_path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExitPostmaster</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
	<comment type="block">/* Write out nondefault GUC settings for child processes to use */</comment>
	<expr_stmt><expr><call><name>write_nondefault_variables</name><argument_list>(<argument><expr><name>PGC_POSTMASTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Write the external PID file if requested
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>external_pid_file</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>fpidfile</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><name>external_pid_file</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>fpidfile</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fpidfile</name></expr></argument>, <argument><expr><literal type="string">"%d\n"</literal></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fpidfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Make PID file world readable */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>chmod</name><argument_list>(<argument><expr><name>external_pid_file</name></expr></argument>, <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name> <operator>|</operator> <name>S_IRGRP</name> <operator>|</operator> <name>S_IROTH</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"%s: could not change permissions of external PID file \"%s\": %s\n"</literal></expr></argument>,
							 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>external_pid_file</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"%s: could not write external PID file \"%s\": %s\n"</literal></expr></argument>,
						 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>external_pid_file</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>on_proc_exit</name><argument_list>(<argument><expr><name>unlink_external_pid_file</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Remove old temporary files.  At this point there can be no other
	 * Postgres processes running in this directory, so this should be safe.
	 */</comment>
	<expr_stmt><expr><call><name>RemovePgTempFiles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Forcibly remove the files signaling a standby promotion request.
	 * Otherwise, the existence of those files triggers a promotion too early,
	 * whether a user wants that or not.
	 *
	 * This removal of files is usually unnecessary because they can exist
	 * only during a few moments during a standby promotion. However there is
	 * a race condition: if pg_ctl promote is executed and creates the files
	 * during a promotion, the files can stay around even after the server is
	 * brought up to new master. Then, if new standby starts by using the
	 * backup taken from that master, the files can exist at the server
	 * startup and should be removed in order to avoid an unexpected
	 * promotion.
	 *
	 * Note that promotion signal files need to be removed before the startup
	 * process is invoked. Because, after that, they can be used by
	 * postmaster's SIGUSR1 signal handler.
	 */</comment>
	<expr_stmt><expr><call><name>RemovePromoteSignalFiles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Remove any outdated file holding the current log filenames. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>LOG_METAINFO_DATAFILE</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>LOG_METAINFO_DATAFILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If enabled, start up syslogger collection subprocess
	 */</comment>
	<expr_stmt><expr><name>SysLoggerPID</name> <operator>=</operator> <call><name>SysLogger_Start</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reset whereToSendOutput from DestDebug (its starting state) to
	 * DestNone. This stops ereport from sending log messages to stderr unless
	 * Log_destination permits.  We don't do this until the postmaster is
	 * fully launched, since startup failures may as well be reported to
	 * stderr.
	 *
	 * If we are in fact disabling logging to stderr, first emit a log message
	 * saying so, to provide a breadcrumb trail for users who may not remember
	 * that their logging is configured to go somewhere else.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>Log_destination</name> <operator>&amp;</operator> <name>LOG_DESTINATION_STDERR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ending log output to stderr"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Future log output will go to log destination \"%s\"."</literal></expr></argument>,
						 <argument><expr><name>Log_destination_string</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>whereToSendOutput</name> <operator>=</operator> <name>DestNone</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize stats collection subsystem (this does NOT start the
	 * collector process!)
	 */</comment>
	<expr_stmt><expr><call><name>pgstat_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize the autovacuum subsystem (again, no process start yet)
	 */</comment>
	<expr_stmt><expr><call><name>autovac_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Load configuration files for client authentication.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>load_hba</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * It makes no sense to continue if we fail to load the HBA file,
		 * since there is no way to connect to the database in this case.
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not load pg_hba.conf"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>load_ident</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We can start up without the IDENT file, although it means that you
		 * cannot log in using any of the authentication methods that need a
		 * user name mapping. load_ident() already logged the details of error
		 * to the log.
		 */</comment>
	</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_PTHREAD_IS_THREADED_NP</name></cpp:ifdef>

	<comment type="block">/*
	 * On macOS, libintl replaces setlocale() with a version that calls
	 * CFLocaleCopyCurrent() when its second argument is "" and every relevant
	 * environment variable is unset or empty.  CFLocaleCopyCurrent() makes
	 * the process multithreaded.  The postmaster calls sigprocmask() and
	 * calls fork() without an immediate exec(), both of which have undefined
	 * behavior in a multithreaded program.  A multithreaded postmaster is the
	 * normal case on Windows, which offers neither fork() nor sigprocmask().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pthread_is_threaded_np</name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"postmaster became multithreaded during startup"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Set the LC_ALL environment variable to a valid locale."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Remember postmaster startup time
	 */</comment>
	<expr_stmt><expr><name>PgStartTime</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_STRONG_RANDOM</name></cpp:ifndef>
	<comment type="block">/* RandomCancelKey wants its own copy */</comment>
	<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>random_start_time</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Report postmaster status in the postmaster.pid file, to allow pg_ctl to
	 * see what's happening.
	 */</comment>
	<expr_stmt><expr><call><name>AddToDataDirLockFile</name><argument_list>(<argument><expr><name>LOCK_FILE_LINE_PM_STATUS</name></expr></argument>, <argument><expr><name>PM_STATUS_STARTING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We're ready to rock and roll...
	 */</comment>
	<expr_stmt><expr><name>StartupPID</name> <operator>=</operator> <call><name>StartupDataBase</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>StartupPID</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>StartupStatus</name> <operator>=</operator> <name>STARTUP_RUNNING</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pmState</name> <operator>=</operator> <name>PM_STARTUP</name></expr>;</expr_stmt>

	<comment type="block">/* Some workers may be scheduled to start now */</comment>
	<expr_stmt><expr><call><name>maybe_start_bgworkers</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>ServerLoop</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * ServerLoop probably shouldn't ever return, but if it does, close down.
	 */</comment>
	<expr_stmt><expr><call><name>ExitPostmaster</name><argument_list>(<argument><expr><name>status</name> <operator>!=</operator> <name>STATUS_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>					<comment type="block">/* not reached */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * on_proc_exit callback to close server's listen sockets
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CloseServerPorts</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * First, explicitly close all the socket FDs.  We used to just let this
	 * happen implicitly at postmaster exit, but it's better to close them
	 * before we remove the postmaster.pid lockfile; otherwise there's a race
	 * condition if a new postmaster wants to re-use the TCP port number.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAXLISTEN</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>ListenSocket</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>PGINVALID_SOCKET</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>StreamClose</name><argument_list>(<argument><expr><name><name>ListenSocket</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ListenSocket</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>PGINVALID_SOCKET</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Next, remove any filesystem entries for Unix sockets.  To avoid race
	 * conditions against incoming postmasters, this must happen after closing
	 * the sockets and before removing lock files.
	 */</comment>
	<expr_stmt><expr><call><name>RemoveSocketFiles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We don't do anything about socket lock files here; those will be
	 * removed in a later on_proc_exit callback.
	 */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * on_proc_exit callback to delete external_pid_file
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>unlink_external_pid_file</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>external_pid_file</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>external_pid_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Compute and check the directory paths to files that are part of the
 * installation (as deduced from the postgres executable's own location)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>getInstallationPaths</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>argv0</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>pdir</name></decl>;</decl_stmt>

	<comment type="block">/* Locate the postgres executable itself */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>find_my_exec</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>, <argument><expr><name>my_exec_path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"%s: could not locate my own executable path"</literal></expr></argument>, <argument><expr><name>argv0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
	<comment type="block">/* Locate executable backend before we change working directory */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>find_other_exec</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>, <argument><expr><literal type="string">"postgres"</literal></expr></argument>, <argument><expr><name>PG_BACKEND_VERSIONSTR</name></expr></argument>,
						<argument><expr><name>postgres_exec_path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s: could not locate matching postgres executable"</literal></expr></argument>,
						<argument><expr><name>argv0</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Locate the pkglib directory --- this has to be set early in case we try
	 * to load any modules from it in response to postgresql.conf entries.
	 */</comment>
	<expr_stmt><expr><call><name>get_pkglib_path</name><argument_list>(<argument><expr><name>my_exec_path</name></expr></argument>, <argument><expr><name>pkglib_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Verify that there's a readable directory there; otherwise the Postgres
	 * installation is incomplete or corrupt.  (A typical cause of this
	 * failure is that the postgres executable has been moved or hardlinked to
	 * some directory that's not a sibling of the installation lib/
	 * directory.)
	 */</comment>
	<expr_stmt><expr><name>pdir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><name>pkglib_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pdir</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open directory \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>pkglib_path</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"This may indicate an incomplete PostgreSQL installation, or that the file \"%s\" has been moved away from its proper location."</literal></expr></argument>,
						 <argument><expr><name>my_exec_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>pdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * XXX is it worth similarly checking the share/ directory?  If the lib/
	 * directory is there, then share/ probably is too.
	 */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Check that pg_control exists in the correct location in the data directory.
 *
 * No attempt is made to validate the contents of pg_control here.  This is
 * just a sanity check to see if we are looking at a real data directory.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkControlFile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/global/pg_control"</literal></expr></argument>, <argument><expr><name>DataDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>PG_BINARY_R</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fp</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"%s: could not find the database system\n"</literal>
					 <literal type="string">"Expected to find it in the directory \"%s\",\n"</literal>
					 <literal type="string">"but could not open file \"%s\": %s\n"</literal></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>DataDir</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExitPostmaster</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Determine how long should we let ServerLoop sleep.
 *
 * In normal conditions we wait at most one minute, to ensure that the other
 * background tasks handled by ServerLoop get done even when no requests are
 * arriving.  However, if there are background workers waiting to be started,
 * we don't actually sleep so that they are quickly serviced.  Other exception
 * cases are as shown in the code.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DetermineSleepTime</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>timeval</name></name> <modifier>*</modifier></type><name>timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>next_wakeup</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Normal case: either there are no background workers at all, or we're in
	 * a shutdown sequence (during which we ignore bgworkers altogether).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Shutdown</name> <operator>&gt;</operator> <name>NoShutdown</name> <operator>||</operator>
		<operator>(</operator><operator>!</operator><name>StartWorkerNeeded</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>HaveCrashedWorker</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>AbortStartTime</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* time left to abort; clamp to 0 in case it already expired */</comment>
			<expr_stmt><expr><name><name>timeout</name><operator>-&gt;</operator><name>tv_sec</name></name> <operator>=</operator> <name>SIGKILL_CHILDREN_AFTER_SECS</name> <operator>-</operator>
				<operator>(</operator><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>AbortStartTime</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>timeout</name><operator>-&gt;</operator><name>tv_sec</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>timeout</name><operator>-&gt;</operator><name>tv_sec</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>timeout</name><operator>-&gt;</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>timeout</name><operator>-&gt;</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">60</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>timeout</name><operator>-&gt;</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>StartWorkerNeeded</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>timeout</name><operator>-&gt;</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>timeout</name><operator>-&gt;</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>HaveCrashedWorker</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>slist_mutable_iter</name></type> <name>siter</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * When there are crashed bgworkers, we sleep just long enough that
		 * they are restarted when they request to be.  Scan the list to
		 * determine the minimum of all wakeup times according to most recent
		 * crash time and requested restart interval.
		 */</comment>
		<macro><name>slist_foreach_modify</name><argument_list>(<argument>siter</argument>, <argument>&amp;BackgroundWorkerList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RegisteredBgWorker</name> <modifier>*</modifier></type><name>rw</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TimestampTz</name></type> <name>this_wakeup</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>rw</name> <operator>=</operator> <call><name>slist_container</name><argument_list>(<argument><expr><name>RegisteredBgWorker</name></expr></argument>, <argument><expr><name>rw_lnode</name></expr></argument>, <argument><expr><name><name>siter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>rw</name><operator>-&gt;</operator><name>rw_crashed_at</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_restart_time</name></name> <operator>==</operator> <name>BGW_NEVER_RESTART</name>
				<operator>||</operator> <name><name>rw</name><operator>-&gt;</operator><name>rw_terminate</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ForgetBackgroundWorker</name><argument_list>(<argument><expr><operator>&amp;</operator><name>siter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>this_wakeup</name> <operator>=</operator> <call><name>TimestampTzPlusMilliseconds</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_crashed_at</name></name></expr></argument>,
													  <argument><expr><literal type="number">1000L</literal> <operator>*</operator> <name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_restart_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>next_wakeup</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>this_wakeup</name> <operator>&lt;</operator> <name>next_wakeup</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>next_wakeup</name> <operator>=</operator> <name>this_wakeup</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>next_wakeup</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>long</name></type>		<name>secs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>microsecs</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>TimestampDifference</name><argument_list>(<argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>next_wakeup</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>secs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>microsecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>timeout</name><operator>-&gt;</operator><name>tv_sec</name></name> <operator>=</operator> <name>secs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>timeout</name><operator>-&gt;</operator><name>tv_usec</name></name> <operator>=</operator> <name>microsecs</name></expr>;</expr_stmt>

		<comment type="block">/* Ensure we don't exceed one minute */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>timeout</name><operator>-&gt;</operator><name>tv_sec</name></name> <operator>&gt;</operator> <literal type="number">60</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>timeout</name><operator>-&gt;</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">60</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>timeout</name><operator>-&gt;</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>timeout</name><operator>-&gt;</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">60</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>timeout</name><operator>-&gt;</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Main idle loop of postmaster
 *
 * NB: Needs to be called with signals blocked
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ServerLoop</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>fd_set</name></type>		<name>readmask</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nSockets</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>time_t</name></type>		<name>last_lockfile_recheck_time</name></decl>,
				<decl><type ref="prev"/><name>last_touch_time</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>last_lockfile_recheck_time</name> <operator>=</operator> <name>last_touch_time</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nSockets</name> <operator>=</operator> <call><name>initMasks</name><argument_list>(<argument><expr><operator>&amp;</operator><name>readmask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__APPLE__</name></cpp:ifdef>
	<decl_stmt><decl><type><name>bool</name></type> <name>yb_enabled</name> <init>= <expr><call><name>YBIsEnabledInPostgresEnvVar</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__linux__</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"FLAGS_yb_backend_oom_score_adj"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>YbBackendOomScoreAdj</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"FLAGS_yb_backend_oom_score_adj"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>fd_set</name></type>		<name>rmask</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>selres</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>time_t</name></type>		<name>now</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Wait for a connection request to arrive.
		 *
		 * We block all signals except while sleeping. That makes it safe for
		 * signal handlers, which again block all signals while executing, to
		 * do nontrivial work.
		 *
		 * If we are in PM_WAIT_DEAD_END state, then we don't want to accept
		 * any new connections, so we don't call select(), and just sleep.
		 */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>rmask</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>readmask</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fd_set</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>pmState</name> <operator>==</operator> <name>PM_WAIT_DEAD_END</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UnBlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">100000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 100 msec seems reasonable */</comment>
			<expr_stmt><expr><name>selres</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* must set timeout each time; some OSes change it! */</comment>
			<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>timeout</name></decl>;</decl_stmt>

			<comment type="block">/* Needs to run with blocked signals! */</comment>
			<expr_stmt><expr><call><name>DetermineSleepTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UnBlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>selres</name> <operator>=</operator> <call><name>select</name><argument_list>(<argument><expr><name>nSockets</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rmask</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Now check the select() result */</comment>
		<if_stmt><if>if <condition>(<expr><name>selres</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>EINTR</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>EWOULDBLOCK</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_socket_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"select() failed in postmaster: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * New connection pending on any of our sockets? If so, fork a child
		 * process to deal with it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>selres</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__APPLE__</name></cpp:ifdef>
			<comment type="line">// If STDIN is closed, it means that parent did exit</comment>
			<if_stmt><if>if <condition>(<expr><name>yb_enabled</name> <operator>&amp;&amp;</operator> <call><name>FD_ISSET</name><argument_list>(<argument><expr><name>STDIN_FILENO</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rmask</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<return>return <expr><name>STATUS_OK</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAXLISTEN</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>ListenSocket</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>PGINVALID_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>FD_ISSET</name><argument_list>(<argument><expr><name><name>ListenSocket</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rmask</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Port</name>	   <modifier>*</modifier></type><name>port</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>port</name> <operator>=</operator> <call><name>ConnCreate</name><argument_list>(<argument><expr><name><name>ListenSocket</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>port</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>BackendStartup</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/*
						 * We no longer need the open socket or port structure
						 * in this process
						 */</comment>
						<expr_stmt><expr><call><name>StreamClose</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ConnFree</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* If we have lost the log collector, try to start a new one */</comment>
		<if_stmt><if>if <condition>(<expr><name>SysLoggerPID</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>Logging_collector</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>SysLoggerPID</name> <operator>=</operator> <call><name>SysLogger_Start</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If no background writer process is running, and we are not in a
		 * state that prevents it, start one.  It doesn't matter if this
		 * fails, we'll just try again later.  Likewise for the checkpointer.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>pmState</name> <operator>==</operator> <name>PM_RUN</name> <operator>||</operator> <name>pmState</name> <operator>==</operator> <name>PM_RECOVERY</name> <operator>||</operator>
			<name>pmState</name> <operator>==</operator> <name>PM_HOT_STANDBY</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>CheckpointerPID</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>CheckpointerPID</name> <operator>=</operator> <call><name>StartCheckpointer</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>BgWriterPID</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>BgWriterPID</name> <operator>=</operator> <call><name>StartBackgroundWriter</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Likewise, if we have lost the walwriter process, try to start a new
		 * one.  But this is needed only in normal operation (else we cannot
		 * be writing any new WAL).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>WalWriterPID</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pmState</name> <operator>==</operator> <name>PM_RUN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>WalWriterPID</name> <operator>=</operator> <call><name>StartWalWriter</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If we have lost the autovacuum launcher, try to start a new one. We
		 * don't want autovacuum to run in binary upgrade mode because
		 * autovacuum might update relfrozenxid for empty tables before the
		 * physical files are put in place.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsBinaryUpgrade</name> <operator>&amp;&amp;</operator> <name>AutoVacPID</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<operator>(</operator><call><name>AutoVacuumingActive</name><argument_list>()</argument_list></call> <operator>||</operator> <name>start_autovac_launcher</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<name>pmState</name> <operator>==</operator> <name>PM_RUN</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>YBIsEnabledInPostgresEnvVar</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>AutoVacPID</name> <operator>=</operator> <call><name>StartAutoVacLauncher</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>AutoVacPID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>start_autovac_launcher</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* signal processed */</comment>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* If we have lost the stats collector, try to start a new one */</comment>
		<if_stmt><if>if <condition>(<expr><name>PgStatPID</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>pmState</name> <operator>==</operator> <name>PM_RUN</name> <operator>||</operator> <name>pmState</name> <operator>==</operator> <name>PM_HOT_STANDBY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>PgStatPID</name> <operator>=</operator> <call><name>pgstat_start</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* If we have lost the archiver, try to start a new one. */</comment>
		<if_stmt><if>if <condition>(<expr><name>PgArchPID</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>PgArchStartupAllowed</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>PgArchPID</name> <operator>=</operator> <call><name>pgarch_start</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* If we need to signal the autovacuum launcher, do so now */</comment>
		<if_stmt><if>if <condition>(<expr><name>avlauncher_needs_signal</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>avlauncher_needs_signal</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>AutoVacPID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name>AutoVacPID</name></expr></argument>, <argument><expr><name>SIGUSR2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* If we need to start a WAL receiver, try to do that now */</comment>
		<if_stmt><if>if <condition>(<expr><name>WalReceiverRequested</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>MaybeStartWalReceiver</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Get other worker processes running, if needed */</comment>
		<if_stmt><if>if <condition>(<expr><name>StartWorkerNeeded</name> <operator>||</operator> <name>HaveCrashedWorker</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>maybe_start_bgworkers</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_PTHREAD_IS_THREADED_NP</name></cpp:ifdef>

		<comment type="block">/*
		 * With assertions enabled, check regularly for appearance of
		 * additional threads.  All builds check at start and exit.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>pthread_is_threaded_np</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/*
		 * Lastly, check to see if it's time to do some things that we don't
		 * want to do every single time through the loop, because they're a
		 * bit expensive.  Note that there's up to a minute of slop in when
		 * these tasks will be performed, since DetermineSleepTime() will let
		 * us sleep at most that long; except for SIGKILL timeout which has
		 * special-case logic there.
		 */</comment>
		<expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we already sent SIGQUIT to children and they are slow to shut
		 * down, it's time to send them SIGKILL.  This doesn't happen
		 * normally, but under certain conditions backends can get stuck while
		 * shutting down.  This is a last measure to get them unwedged.
		 *
		 * Note we also do this during recovery from a process crash.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Shutdown</name> <operator>&gt;=</operator> <name>ImmediateShutdown</name> <operator>||</operator> <operator>(</operator><name>FatalError</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>SendStop</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
			<name>AbortStartTime</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>now</name> <operator>-</operator> <name>AbortStartTime</name><operator>)</operator> <operator>&gt;=</operator> <name>SIGKILL_CHILDREN_AFTER_SECS</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* We were gentle with them before. Not anymore */</comment>
			<expr_stmt><expr><call><name>TerminateChildren</name><argument_list>(<argument><expr><name>SIGKILL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* reset flag so we don't SIGKILL again */</comment>
			<expr_stmt><expr><name>AbortStartTime</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Once a minute, verify that postmaster.pid hasn't been removed or
		 * overwritten.  If it has, we force a shutdown.  This avoids having
		 * postmasters and child processes hanging around after their database
		 * is gone, and maybe causing problems if a new database cluster is
		 * created in the same place.  It also provides some protection
		 * against a DBA foolishly removing postmaster.pid and manually
		 * starting a new postmaster.  Data corruption is likely to ensue from
		 * that anyway, but we can minimize the damage by aborting ASAP.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>now</name> <operator>-</operator> <name>last_lockfile_recheck_time</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>*</operator> <name>SECS_PER_MINUTE</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RecheckDataDirLockFile</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"performing immediate shutdown because data directory lock file is invalid"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><name>SIGQUIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>last_lockfile_recheck_time</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Touch Unix socket and lock files every 58 minutes, to ensure that
		 * they are not removed by overzealous /tmp-cleaning tasks.  We assume
		 * no one runs cleaners with cutoff times of less than an hour ...
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>now</name> <operator>-</operator> <name>last_touch_time</name> <operator>&gt;=</operator> <literal type="number">58</literal> <operator>*</operator> <name>SECS_PER_MINUTE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>TouchSocketFiles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>TouchSocketLockFiles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>last_touch_time</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Initialise the masks for select() for the ports we are listening on.
 * Return the number of sockets to listen on.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>initMasks</name><parameter_list>(<parameter><decl><type><name>fd_set</name> <modifier>*</modifier></type><name>rmask</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxsock</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><name>rmask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__APPLE__</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><call><name>YBIsEnabledInPostgresEnvVar</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name>STDIN_FILENO</name></expr></argument>, <argument><expr><name>rmask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>maxsock</name> <operator>=</operator> <name>STDIN_FILENO</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAXLISTEN</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>fd</name> <init>= <expr><name><name>ListenSocket</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <name>PGINVALID_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>rmask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;</operator> <name>maxsock</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>maxsock</name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>maxsock</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Read a client's startup packet and do something according to it.
 *
 * Returns STATUS_OK or STATUS_ERROR, or might call ereport(FATAL) and
 * not return at all.
 *
 * (Note that ereport(FATAL) stuff is sent to the client, so only use it
 * if that's what you want.  Return STATUS_ERROR if you don't want to
 * send anything to the client, which would typically be appropriate
 * if we detect a communications failure.)
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ProcessStartupPacket</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>SSLdone</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ProtocolVersion</name></type> <name>proto</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pq_startmsgread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Grab the first byte of the length word separately, so that we can tell
	 * whether we have no data at all or an incomplete packet.  (This might
	 * sound inefficient, but it's not really, because of buffering in
	 * pqcomm.c.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pq_getbytes</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>EOF</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we get no data at all, don't clutter the log with a complaint;
		 * such cases often occur for legitimate reasons.  An example is that
		 * we might be here after responding to NEGOTIATE_SSL_CODE, and if the
		 * client didn't like our response, it'll probably just drop the
		 * connection.  Service-monitoring software also often just opens and
		 * closes a connection without sending anything.  (So do port
		 * scanners, which may be less benign, but it's not really our job to
		 * notice those.)
		 */</comment>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pq_getbytes</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>len</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>EOF</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Got a partial length word, so bleat about that */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>SSLdone</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>COMMERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"incomplete startup packet"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>pg_ntoh32</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <operator>(</operator><name>int32</name><operator>)</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ProtocolVersion</name></expr></argument>)</argument_list></sizeof> <operator>||</operator>
		<name>len</name> <operator>&gt;</operator> <name>MAX_STARTUP_PACKET_LENGTH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>COMMERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid length of startup packet"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Allocate at least the size of an old-style startup packet, plus one
	 * extra byte, and make sure all are zeroes.  This ensures we will have
	 * null termination of all strings, in both fixed- and variable-length
	 * packet layouts.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>StartupPacket</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>StartupPacket</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pq_getbytes</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>EOF</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>COMMERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"incomplete startup packet"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pq_endmsgread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The first field is either a protocol version number or a special
	 * request code.
	 */</comment>
	<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>proto</name></name> <operator>=</operator> <name>proto</name> <operator>=</operator> <call><name>pg_ntoh32</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>ProtocolVersion</name> <operator>*</operator><operator>)</operator> <name>buf</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>proto</name> <operator>==</operator> <name>CANCEL_REQUEST_CODE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>processCancelRequest</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Not really an error, but we don't want to proceed further */</comment>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>proto</name> <operator>==</operator> <name>NEGOTIATE_SSL_CODE</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>SSLdone</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name>SSLok</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
		<comment type="block">/* No SSL when disabled or on Unix sockets */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>LoadedSSL</name> <operator>||</operator> <call><name>IS_AF_UNIX</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>laddr</name><operator>.</operator><name>addr</name><operator>.</operator><name>ss_family</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>SSLok</name> <operator>=</operator> <literal type="char">'N'</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>SSLok</name> <operator>=</operator> <literal type="char">'S'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>		<comment type="block">/* Support for SSL */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>SSLok</name> <operator>=</operator> <literal type="char">'N'</literal></expr>;</expr_stmt>			<comment type="block">/* No support for SSL */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<label><name>retry1</name>:</label>
		<if_stmt><if>if <condition>(<expr><call><name>send</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>SSLok</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>retry1</name>;</goto></block_content></block></if></if_stmt>	<comment type="block">/* if interrupted, just retry */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>COMMERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_socket_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to send SSL negotiation response: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>	<comment type="block">/* close the connection */</comment>
		</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>SSLok</name> <operator>==</operator> <literal type="char">'S'</literal> <operator>&amp;&amp;</operator> <call><name>secure_open_server</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<comment type="block">/* regular startup packet, cancel, etc packet should follow... */</comment>
		<comment type="block">/* but not another SSL negotiation request */</comment>
		<return>return <expr><call><name>ProcessStartupPacket</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Could add additional special packet types here */</comment>

	<comment type="block">/*
	 * Set FrontendProtocol now so that ereport() knows what format to send if
	 * we fail during startup.
	 */</comment>
	<expr_stmt><expr><name>FrontendProtocol</name> <operator>=</operator> <name>proto</name></expr>;</expr_stmt>

	<comment type="block">/* Check that the major protocol version is in range. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>PG_PROTOCOL_EARLIEST</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>PG_PROTOCOL_LATEST</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported frontend protocol %u.%u: server supports %u.0 to %u.%u"</literal></expr></argument>,
						<argument><expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PG_PROTOCOL_MINOR</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>PG_PROTOCOL_EARLIEST</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>PG_PROTOCOL_LATEST</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>PG_PROTOCOL_MINOR</name><argument_list>(<argument><expr><name>PG_PROTOCOL_LATEST</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Now fetch parameters out of startup packet and save them into the Port
	 * structure.  All data structures attached to the Port struct must be
	 * allocated in TopMemoryContext so that they will remain available in a
	 * running backend (even after PostmasterContext is destroyed).  We need
	 * not worry about leaking this storage on failure, since we aren't in the
	 * postmaster process anymore.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type>		<name>offset</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>ProtocolVersion</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>unrecognized_protocol_options</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * At this point we should have no data already buffered.  If we do,
		 * it was received before we performed the SSL handshake, so it wasn't
		 * encrypted and indeed may have been injected by a man-in-the-middle.
		 * We report this case to the client.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pq_buffer_has_data</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"received unencrypted data after SSL request"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"This could be either a client-software bug or evidence of an attempted man-in-the-middle attack."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Scan packet body for name/option pairs.  We can assume any string
		 * beginning within the packet body is null-terminated, thanks to
		 * zeroing extra byte above.
		 */</comment>
		<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>guc_options</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

		<while>while <condition>(<expr><name>offset</name> <operator>&lt;</operator> <name>len</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nameptr</name> <init>= <expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>buf</name><operator>)</operator> <operator>+</operator> <name>offset</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>valoffset</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>valptr</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>nameptr</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* found packet terminator */</comment>
			<expr_stmt><expr><name>valoffset</name> <operator>=</operator> <name>offset</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>nameptr</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>valoffset</name> <operator>&gt;=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* missing value, will complain below */</comment>
			<expr_stmt><expr><name>valptr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>buf</name><operator>)</operator> <operator>+</operator> <name>valoffset</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>nameptr</name></expr></argument>, <argument><expr><literal type="string">"database"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>database_name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>valptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>nameptr</name></expr></argument>, <argument><expr><literal type="string">"user"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>valptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>nameptr</name></expr></argument>, <argument><expr><literal type="string">"options"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>cmdline_options</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>valptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>nameptr</name></expr></argument>, <argument><expr><literal type="string">"replication"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Due to backward compatibility concerns the replication
				 * parameter is a hybrid beast which allows the value to be
				 * either boolean or the string 'database'. The latter
				 * connects to a specific database which is e.g. required for
				 * logical decoding while.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>valptr</name></expr></argument>, <argument><expr><literal type="string">"database"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>am_walsender</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>am_db_walsender</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>parse_bool</name><argument_list>(<argument><expr><name>valptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>am_walsender</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid value for parameter \"%s\": \"%s\""</literal></expr></argument>,
									<argument><expr><literal type="string">"replication"</literal></expr></argument>,
									<argument><expr><name>valptr</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Valid values are: \"false\", 0, \"true\", 1, \"database\"."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>nameptr</name></expr></argument>, <argument><expr><literal type="string">"_pq_."</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Any option beginning with _pq_. is reserved for use as a
				 * protocol-level option, but at present no such options are
				 * defined.
				 */</comment>
				<expr_stmt><expr><name>unrecognized_protocol_options</name> <operator>=</operator>
					<call><name>lappend</name><argument_list>(<argument><expr><name>unrecognized_protocol_options</name></expr></argument>, <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>nameptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Assume it's a generic GUC option */</comment>
				<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>guc_options</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>guc_options</name></name></expr></argument>,
											<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>nameptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>guc_options</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>guc_options</name></name></expr></argument>,
											<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>valptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><name>offset</name> <operator>=</operator> <name>valoffset</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>valptr</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></while>

		<comment type="block">/*
		 * At this point we should have no data already buffered.  If we do,
		 * it was received before we performed the GSS handshake, so it wasn't
		 * encrypted and indeed may have been injected by a man-in-the-middle.
		 * We report this case to the client.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pq_buffer_has_data</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"received unencrypted data after GSSAPI encryption request"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"This could be either a client-software bug or evidence of an attempted man-in-the-middle attack."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If we didn't find a packet terminator exactly at the end of the
		 * given packet length, complain.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>!=</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid startup packet layout: expected terminator as last byte"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If the client requested a newer protocol version or if the client
		 * requested any protocol options we didn't recognize, let them know
		 * the newest minor protocol version we do support and the names of
		 * any unrecognized options.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MINOR</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>PG_PROTOCOL_MINOR</name><argument_list>(<argument><expr><name>PG_PROTOCOL_LATEST</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<name>unrecognized_protocol_options</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SendNegotiateProtocolVersion</name><argument_list>(<argument><expr><name>unrecognized_protocol_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Get the parameters from the old-style, fixed-width-fields startup
		 * packet as C strings.  The packet destination was cleared first so a
		 * short packet has zeros silently added.  We have to be prepared to
		 * truncate the pstrdup result for oversize fields, though.
		 */</comment>
		<decl_stmt><decl><type><name>StartupPacket</name> <modifier>*</modifier></type><name>packet</name> <init>= <expr><operator>(</operator><name>StartupPacket</name> <operator>*</operator><operator>)</operator> <name>buf</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>database_name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>packet</name><operator>-&gt;</operator><name>database</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>database_name</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>packet</name><operator>-&gt;</operator><name>database</name></name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>database_name</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>packet</name><operator>-&gt;</operator><name>database</name></name></expr></argument>)</argument_list></sizeof></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>packet</name><operator>-&gt;</operator><name>user</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>packet</name><operator>-&gt;</operator><name>user</name></name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>packet</name><operator>-&gt;</operator><name>user</name></name></expr></argument>)</argument_list></sizeof></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>cmdline_options</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>packet</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>cmdline_options</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>packet</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>cmdline_options</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>packet</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></sizeof></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>guc_options</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Check a user name was given. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>port</name><operator>-&gt;</operator><name>user_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no PostgreSQL user name specified in startup packet"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* The database defaults to the user name. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>database_name</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>port</name><operator>-&gt;</operator><name>database_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>database_name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>Db_user_namespace</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If user@, it is a global user, remove '@'. We only want to do this
		 * if there is an '@' at the end and no earlier in the user string or
		 * they may fake as a local user of another database attaching to this
		 * database.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>, <argument><expr><literal type="char">'@'</literal></expr></argument>)</argument_list></call> <operator>==</operator>
			<name><name>port</name><operator>-&gt;</operator><name>user_name</name></name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><call><name>strchr</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>, <argument><expr><literal type="char">'@'</literal></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Append '@' and dbname */</comment>
			<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s@%s"</literal></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>database_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Truncate given database and user names to length of a Postgres name.
	 * This avoids lookup failures when overlength names are given.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>database_name</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>NAMEDATALEN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>database_name</name><index>[<expr><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>NAMEDATALEN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name><index>[<expr><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Normal walsender backends, e.g. for streaming replication, are not
	 * connected to a particular database. But walsenders used for logical
	 * replication need to connect to a specific database. We allow streaming
	 * replication commands to be issued even if connected to a database as it
	 * can make sense to first make a basebackup and then stream changes
	 * starting from that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>am_walsender</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>am_db_walsender</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>database_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Done putting stuff in TopMemoryContext.
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we're going to reject the connection due to database state, say so
	 * now instead of wasting cycles on an authentication exchange. (This also
	 * allows a pg_ping utility to be written.)
	 */</comment>
	<switch>switch <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>canAcceptConnections</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CAC_STARTUP</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANNOT_CONNECT_NOW</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"the database system is starting up"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CAC_SHUTDOWN</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANNOT_CONNECT_NOW</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"the database system is shutting down"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CAC_RECOVERY</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANNOT_CONNECT_NOW</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"the database system is in recovery mode"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CAC_TOOMANY</name></expr>:</case>
			<comment type="block">/* increment rejection counter */</comment>
			<expr_stmt><expr><name>too_many_conn</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_CONNECTIONS</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"sorry, too many clients already"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CAC_WAITBACKUP</name></expr>:</case>
			<comment type="block">/* OK for now, will check in InitPostgres */</comment>
			<break>break;</break>
		<case>case <expr><name>CAC_OK</name></expr>:</case>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Send a NegotiateProtocolVersion to the client.  This lets the client know
 * that they have requested a newer minor protocol version than we are able
 * to speak.  We'll speak the highest version we know about; the client can,
 * of course, abandon the connection if that's a problem.
 *
 * We also include in the response a list of protocol options we didn't
 * understand.  This allows clients to include optional parameters that might
 * be present either in newer protocol versions or third-party protocol
 * extensions without fear of having to reconnect if those options are not
 * understood, while at the same time making certain that the client is aware
 * of which options were actually accepted.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SendNegotiateProtocolVersion</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>unrecognized_protocol_options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'v'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* NegotiateProtocolVersion */</comment>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>PG_PROTOCOL_LATEST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>unrecognized_protocol_options</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>unrecognized_protocol_options</argument>)</argument_list></macro>
		<expr_stmt><expr><call><name>pq_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* no need to flush, some other message will follow */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * The client has sent a cancel request packet, not a normal
 * start-a-new-connection packet.  Perform the necessary processing.
 * Nothing is sent back to the client.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>processCancelRequest</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CancelRequestPacket</name> <modifier>*</modifier></type><name>canc</name> <init>= <expr><operator>(</operator><name>CancelRequestPacket</name> <operator>*</operator><operator>)</operator> <name>pkt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>backendPID</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>cancelAuthCode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Backend</name>    <modifier>*</modifier></type><name>bp</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifndef>
	<decl_stmt><decl><type><name>dlist_iter</name></type>	<name>iter</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>backendPID</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>pg_ntoh32</name><argument_list>(<argument><expr><name><name>canc</name><operator>-&gt;</operator><name>backendPID</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cancelAuthCode</name> <operator>=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <call><name>pg_ntoh32</name><argument_list>(<argument><expr><name><name>canc</name><operator>-&gt;</operator><name>cancelAuthCode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * See if we have a matching backend.  In the EXEC_BACKEND case, we can no
	 * longer access the postmaster's own backend list, and must rely on the
	 * duplicate array in shared memory.
	 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifndef>
	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;BackendList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>bp</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>Backend</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <call><name>MaxLivePostmasterChildren</name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>bp</name> <operator>=</operator> <operator>(</operator><name>Backend</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>ShmemBackendArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if_stmt><if>if <condition>(<expr><name><name>bp</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <name>backendPID</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>bp</name><operator>-&gt;</operator><name>cancel_key</name></name> <operator>==</operator> <name>cancelAuthCode</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Found a match; signal that backend to cancel current op */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"processing cancel request: sending SIGINT to process %d"</literal></expr></argument>,
										 <argument><expr><name>backendPID</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name><name>bp</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><name>SIGINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<comment type="block">/* Right PID, wrong key: no way, Jose */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"wrong key in cancel request for process %d"</literal></expr></argument>,
								<argument><expr><name>backendPID</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* No matching backend */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PID %d in cancel request did not match any process"</literal></expr></argument>,
					<argument><expr><name>backendPID</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<comment type="block">/*
 * canAcceptConnections --- check to see if database state allows connections
 * of the specified type.  backend_type can be BACKEND_TYPE_NORMAL,
 * BACKEND_TYPE_AUTOVAC, or BACKEND_TYPE_BGWORKER.  (Note that we don't yet
 * know whether a NORMAL connection might turn into a walsender.)
 */</comment>
<function><type><specifier>static</specifier> <name>CAC_state</name></type>
<name>canAcceptConnections</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>backend_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CAC_state</name></type>	<name>result</name> <init>= <expr><name>CAC_OK</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Can't start backends when in startup/shutdown/inconsistent recovery
	 * state.  We treat autovac workers the same as user backends for this
	 * purpose.  However, bgworkers are excluded from this test; we expect
	 * bgworker_should_start_now() decided whether the DB state allows them.
	 *
	 * In state PM_WAIT_BACKUP only superusers can connect (this must be
	 * allowed so that a superuser can end online backup mode); we return
	 * CAC_WAITBACKUP code to indicate that this must be checked later. Note
	 * that neither CAC_OK nor CAC_WAITBACKUP can safely be returned until we
	 * have checked for too many children.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>pmState</name> <operator>!=</operator> <name>PM_RUN</name> <operator>&amp;&amp;</operator>
		<name>backend_type</name> <operator>!=</operator> <name>BACKEND_TYPE_BGWORKER</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>pmState</name> <operator>==</operator> <name>PM_WAIT_BACKUP</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>CAC_WAITBACKUP</name></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* allow superusers only */</comment>
		<if type="elseif">else if <condition>(<expr><name>Shutdown</name> <operator>&gt;</operator> <name>NoShutdown</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>CAC_SHUTDOWN</name></expr>;</return></block_content></block></if>	<comment type="block">/* shutdown is pending */</comment>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name>FatalError</name> <operator>&amp;&amp;</operator>
				 <operator>(</operator><name>pmState</name> <operator>==</operator> <name>PM_STARTUP</name> <operator>||</operator>
				  <name>pmState</name> <operator>==</operator> <name>PM_RECOVERY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>CAC_STARTUP</name></expr>;</return></block_content></block></if> <comment type="block">/* normal startup */</comment>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name>FatalError</name> <operator>&amp;&amp;</operator>
				 <name>pmState</name> <operator>==</operator> <name>PM_HOT_STANDBY</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>CAC_OK</name></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* connection OK during hot standby */</comment>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>CAC_RECOVERY</name></expr>;</return></block_content></block></else></if_stmt>	<comment type="block">/* else must be crash recovery */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Don't start too many children.
	 *
	 * We allow more connections here than we can have backends because some
	 * might still be authenticating; they might fail auth, or some existing
	 * backend might exit before the auth cycle is completed.  The exact
	 * MaxBackends limit is enforced when a new backend tries to join the
	 * shared-inval backend array.
	 *
	 * The limit here must match the sizes of the per-child-process arrays;
	 * see comments for MaxLivePostmasterChildren().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>CountChildren</name><argument_list>(<argument><expr><name>BACKEND_TYPE_ALL</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <call><name>MaxLivePostmasterChildren</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>CAC_TOOMANY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ConnCreate -- create a local connection data structure
 *
 * Returns NULL on failure, other than out-of-memory which is fatal.
 */</comment>
<function><type><specifier>static</specifier> <name>Port</name> <modifier>*</modifier></type>
<name>ConnCreate</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>serverFd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Port</name>	   <modifier>*</modifier></type><name>port</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>port</name> <operator>=</operator> <operator>(</operator><name>Port</name> <operator>*</operator><operator>)</operator> <call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Port</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExitPostmaster</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>StreamConnection</name><argument_list>(<argument><expr><name>serverFd</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>STATUS_OK</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>sock</name></name> <operator>!=</operator> <name>PGINVALID_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>StreamClose</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ConnFree</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Allocate GSSAPI specific state struct
	 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifndef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_GSS</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_SSPI</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>gss</name></name> <operator>=</operator> <operator>(</operator><name>pg_gssinfo</name> <operator>*</operator><operator>)</operator> <call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pg_gssinfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>port</name><operator>-&gt;</operator><name>gss</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExitPostmaster</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>port</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ConnFree -- free a local connection data structure
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ConnFree</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
	<expr_stmt><expr><call><name>secure_close</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>gss</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>gss</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ClosePostmasterPorts -- close all the postmaster's open sockets
 *
 * This is called during child process startup to release file descriptors
 * that are not needed by that child process.  The postmaster still has
 * them open, of course.
 *
 * Note: we pass am_syslogger as a boolean because we don't want to set
 * the global variable yet when this is called.
 */</comment>
<function><type><name>void</name></type>
<name>ClosePostmasterPorts</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>am_syslogger</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>

	<comment type="block">/*
	 * Close the write end of postmaster death watch pipe. It's important to
	 * do this as early as possible, so that if postmaster dies, others won't
	 * think that it's still running because we're holding the pipe open.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>close</name><argument_list>(<argument><expr><name><name>postmaster_alive_fds</name><index>[<expr><name>POSTMASTER_FD_OWN</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"could not close postmaster death monitoring pipe in child process: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>postmaster_alive_fds</name><index>[<expr><name>POSTMASTER_FD_OWN</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Close the listen sockets */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAXLISTEN</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>ListenSocket</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>PGINVALID_SOCKET</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>StreamClose</name><argument_list>(<argument><expr><name><name>ListenSocket</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ListenSocket</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>PGINVALID_SOCKET</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* If using syslogger, close the read side of the pipe */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>am_syslogger</name></expr>)</condition>
	<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
		<if_stmt><if>if <condition>(<expr><name><name>syslogPipe</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>syslogPipe</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>syslogPipe</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<if_stmt><if>if <condition>(<expr><name><name>syslogPipe</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>syslogPipe</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>syslogPipe</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_BONJOUR</name></cpp:ifdef>
	<comment type="block">/* If using Bonjour, close the connection to the mDNS daemon */</comment>
	<if_stmt><if>if <condition>(<expr><name>bonjour_sdref</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><call><name>DNSServiceRefSockFD</name><argument_list>(<argument><expr><name>bonjour_sdref</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<comment type="block">/*
 * reset_shared -- reset shared memory and semaphores
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>reset_shared</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Create or re-create shared memory and semaphores.
	 *
	 * Note: in each "cycle of life" we will normally assign the same IPC keys
	 * (if using SysV shmem and/or semas), since the port number is used to
	 * determine IPC keys.  This helps ensure that we will clean up dead IPC
	 * objects if the postmaster crashes and is restarted.
	 */</comment>
	<expr_stmt><expr><call><name>CreateSharedMemoryAndSemaphores</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SIGHUP -- reread config files, and tell children to do same
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SIGHUP_handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Shutdown</name> <operator>&lt;=</operator> <name>SmartShutdown</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"received SIGHUP, reloading configuration files"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SignalChildren</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>StartupPID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>StartupPID</name></expr></argument>, <argument><expr><name>SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>BgWriterPID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>BgWriterPID</name></expr></argument>, <argument><expr><name>SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>CheckpointerPID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>CheckpointerPID</name></expr></argument>, <argument><expr><name>SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>WalWriterPID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>WalWriterPID</name></expr></argument>, <argument><expr><name>SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>WalReceiverPID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>WalReceiverPID</name></expr></argument>, <argument><expr><name>SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>AutoVacPID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>AutoVacPID</name></expr></argument>, <argument><expr><name>SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>PgArchPID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>PgArchPID</name></expr></argument>, <argument><expr><name>SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>SysLoggerPID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>SysLoggerPID</name></expr></argument>, <argument><expr><name>SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>PgStatPID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>PgStatPID</name></expr></argument>, <argument><expr><name>SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Reload authentication config files too */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>load_hba</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pg_hba.conf was not reloaded"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>load_ident</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pg_ident.conf was not reloaded"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
		<comment type="block">/* Reload SSL configuration as well */</comment>
		<if_stmt><if>if <condition>(<expr><name>EnableSSL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>secure_initialize</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>LoadedSSL</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SSL configuration was not reloaded"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>secure_destroy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>LoadedSSL</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
		<comment type="block">/* Update the starting-point file for future children */</comment>
		<expr_stmt><expr><call><name>write_nondefault_variables</name><argument_list>(<argument><expr><name>PGC_SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UnBlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * pmdie -- signal handler for processing various postmaster signals.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pmdie</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"postmaster received signal %d"</literal></expr></argument>,
							 <argument><expr><name>postgres_signal_arg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>postgres_signal_arg</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SIGTERM</name></expr>:</case>

			<comment type="block">/*
			 * Smart Shutdown:
			 *
			 * Wait for children to end their work, then shut down.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>Shutdown</name> <operator>&gt;=</operator> <name>SmartShutdown</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>Shutdown</name> <operator>=</operator> <name>SmartShutdown</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"received smart shutdown request"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Report status */</comment>
			<expr_stmt><expr><call><name>AddToDataDirLockFile</name><argument_list>(<argument><expr><name>LOCK_FILE_LINE_PM_STATUS</name></expr></argument>, <argument><expr><name>PM_STATUS_STOPPING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SYSTEMD</name></cpp:ifdef>
			<expr_stmt><expr><call><name>sd_notify</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"STOPPING=1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<if_stmt><if>if <condition>(<expr><name>pmState</name> <operator>==</operator> <name>PM_RUN</name> <operator>||</operator> <name>pmState</name> <operator>==</operator> <name>PM_RECOVERY</name> <operator>||</operator>
				<name>pmState</name> <operator>==</operator> <name>PM_HOT_STANDBY</name> <operator>||</operator> <name>pmState</name> <operator>==</operator> <name>PM_STARTUP</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* autovac workers are told to shut down immediately */</comment>
				<comment type="block">/* and bgworkers too; does this need tweaking? */</comment>
				<expr_stmt><expr><call><name>SignalSomeChildren</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>,
								   <argument><expr><name>BACKEND_TYPE_AUTOVAC</name> <operator>|</operator> <name>BACKEND_TYPE_BGWORKER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* and the autovac launcher too */</comment>
				<if_stmt><if>if <condition>(<expr><name>AutoVacPID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>AutoVacPID</name></expr></argument>, <argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/* and the bgwriter too */</comment>
				<if_stmt><if>if <condition>(<expr><name>BgWriterPID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>BgWriterPID</name></expr></argument>, <argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/* and the walwriter too */</comment>
				<if_stmt><if>if <condition>(<expr><name>WalWriterPID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>WalWriterPID</name></expr></argument>, <argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * If we're in recovery, we can't kill the startup process
				 * right away, because at present doing so does not release
				 * its locks.  We might want to change this in a future
				 * release.  For the time being, the PM_WAIT_READONLY state
				 * indicates that we're waiting for the regular (read only)
				 * backends to die off; once they do, we'll kill the startup
				 * and walreceiver processes.
				 */</comment>
				<expr_stmt><expr><name>pmState</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>pmState</name> <operator>==</operator> <name>PM_RUN</name><operator>)</operator></expr> ?</condition><then>
					<expr><name>PM_WAIT_BACKUP</name></expr> </then><else>: <expr><name>PM_WAIT_READONLY</name></expr></else></ternary></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Now wait for online backup mode to end and backends to exit. If
			 * that is already the case, PostmasterStateMachine will take the
			 * next step.
			 */</comment>
			<expr_stmt><expr><call><name>PostmasterStateMachine</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>SIGINT</name></expr>:</case>

			<comment type="block">/*
			 * Fast Shutdown:
			 *
			 * Abort all children with SIGTERM (rollback active transactions
			 * and exit) and shut down when they are gone.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>Shutdown</name> <operator>&gt;=</operator> <name>FastShutdown</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>Shutdown</name> <operator>=</operator> <name>FastShutdown</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"received fast shutdown request"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Report status */</comment>
			<expr_stmt><expr><call><name>AddToDataDirLockFile</name><argument_list>(<argument><expr><name>LOCK_FILE_LINE_PM_STATUS</name></expr></argument>, <argument><expr><name>PM_STATUS_STOPPING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SYSTEMD</name></cpp:ifdef>
			<expr_stmt><expr><call><name>sd_notify</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"STOPPING=1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<if_stmt><if>if <condition>(<expr><name>StartupPID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>StartupPID</name></expr></argument>, <argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>BgWriterPID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>BgWriterPID</name></expr></argument>, <argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>WalReceiverPID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>WalReceiverPID</name></expr></argument>, <argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>pmState</name> <operator>==</operator> <name>PM_STARTUP</name> <operator>||</operator> <name>pmState</name> <operator>==</operator> <name>PM_RECOVERY</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>SignalSomeChildren</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>BACKEND_TYPE_BGWORKER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Only startup, bgwriter, walreceiver, possibly bgworkers,
				 * and/or checkpointer should be active in this state; we just
				 * signaled the first four, and we don't want to kill
				 * checkpointer yet.
				 */</comment>
				<expr_stmt><expr><name>pmState</name> <operator>=</operator> <name>PM_WAIT_BACKENDS</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>pmState</name> <operator>==</operator> <name>PM_RUN</name> <operator>||</operator>
					 <name>pmState</name> <operator>==</operator> <name>PM_WAIT_BACKUP</name> <operator>||</operator>
					 <name>pmState</name> <operator>==</operator> <name>PM_WAIT_READONLY</name> <operator>||</operator>
					 <name>pmState</name> <operator>==</operator> <name>PM_WAIT_BACKENDS</name> <operator>||</operator>
					 <name>pmState</name> <operator>==</operator> <name>PM_HOT_STANDBY</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aborting any active transactions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* shut down all backends and workers */</comment>
				<expr_stmt><expr><call><name>SignalSomeChildren</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>,
								   <argument><expr><name>BACKEND_TYPE_NORMAL</name> <operator>|</operator> <name>BACKEND_TYPE_AUTOVAC</name> <operator>|</operator>
								   <name>BACKEND_TYPE_BGWORKER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* and the autovac launcher too */</comment>
				<if_stmt><if>if <condition>(<expr><name>AutoVacPID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>AutoVacPID</name></expr></argument>, <argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/* and the walwriter too */</comment>
				<if_stmt><if>if <condition>(<expr><name>WalWriterPID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>WalWriterPID</name></expr></argument>, <argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>pmState</name> <operator>=</operator> <name>PM_WAIT_BACKENDS</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Now wait for backends to exit.  If there are none,
			 * PostmasterStateMachine will take the next step.
			 */</comment>
			<expr_stmt><expr><call><name>PostmasterStateMachine</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>SIGQUIT</name></expr>:</case>

			<comment type="block">/*
			 * Immediate Shutdown:
			 *
			 * abort all children with SIGQUIT, wait for them to exit,
			 * terminate remaining ones with SIGKILL, then exit without
			 * attempt to properly shut down the data base system.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>Shutdown</name> <operator>&gt;=</operator> <name>ImmediateShutdown</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>Shutdown</name> <operator>=</operator> <name>ImmediateShutdown</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"received immediate shutdown request"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Report status */</comment>
			<expr_stmt><expr><call><name>AddToDataDirLockFile</name><argument_list>(<argument><expr><name>LOCK_FILE_LINE_PM_STATUS</name></expr></argument>, <argument><expr><name>PM_STATUS_STOPPING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SYSTEMD</name></cpp:ifdef>
			<expr_stmt><expr><call><name>sd_notify</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"STOPPING=1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<expr_stmt><expr><call><name>TerminateChildren</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pmState</name> <operator>=</operator> <name>PM_WAIT_BACKENDS</name></expr>;</expr_stmt>

			<comment type="block">/* set stopwatch for them to die */</comment>
			<expr_stmt><expr><name>AbortStartTime</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Now wait for backends to exit.  If there are none,
			 * PostmasterStateMachine will take the next step.
			 */</comment>
			<expr_stmt><expr><call><name>PostmasterStateMachine</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UnBlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Reaper -- signal handler to cleanup after a child process dies.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>reaper</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pid</name></decl>;</decl_stmt>			<comment type="block">/* process id of dead child process */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>exitstatus</name></decl>;</decl_stmt>		<comment type="block">/* its exit status */</comment>

	<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"reaping dead processes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>pid</name> <operator>=</operator> <call><name>waitpid</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>exitstatus</name></expr></argument>, <argument><expr><name>WNOHANG</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We perform the following tasks when a process crashes
		 * 1. If no locks are held during a crash, we avoid postmaster restarts.
		 * 2. If any lock has been acquired or is in the process of being
		 *    acquired we take a conservative approach and restart the
		 *    postmaster.
		 */</comment>

		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ProcGlobal</name><operator>-&gt;</operator><name>allProcCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allProcs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<comment type="block">/*
			 * We take a conservative approach and restart the postmaster if
			 * a process dies while holding a lock.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <name><name>proc</name><operator>-&gt;</operator><name>pid</name></name> <operator>&amp;&amp;</operator> <name><name>proc</name><operator>-&gt;</operator><name>ybAnyLockAcquired</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>YbCrashWhileLockIntermediateState</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating active server processes due to backend crash while "</literal>
						<literal type="string">"acquiring LWLock"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Check if this child was a startup process.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <name>StartupPID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>StartupPID</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<comment type="block">/*
			 * Startup process exited in response to a shutdown request (or it
			 * completed normally regardless of the shutdown request).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>Shutdown</name> <operator>&gt;</operator> <name>NoShutdown</name> <operator>&amp;&amp;</operator>
				<operator>(</operator><call><name>EXIT_STATUS_0</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>EXIT_STATUS_1</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>StartupStatus</name> <operator>=</operator> <name>STARTUP_NOT_RUNNING</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>pmState</name> <operator>=</operator> <name>PM_WAIT_BACKENDS</name></expr>;</expr_stmt>
				<comment type="block">/* PostmasterStateMachine logic does the rest */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>EXIT_STATUS_3</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"shutdown at recovery target"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>StartupStatus</name> <operator>=</operator> <name>STARTUP_NOT_RUNNING</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>Shutdown</name> <operator>=</operator> <name>SmartShutdown</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>TerminateChildren</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>pmState</name> <operator>=</operator> <name>PM_WAIT_BACKENDS</name></expr>;</expr_stmt>
				<comment type="block">/* PostmasterStateMachine logic does the rest */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Unexpected exit of startup process (including FATAL exit)
			 * during PM_STARTUP is treated as catastrophic. There are no
			 * other processes running yet, so we can just exit.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>pmState</name> <operator>==</operator> <name>PM_STARTUP</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>EXIT_STATUS_0</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>LogChildExit</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"startup process"</literal></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aborting startup due to startup process failure"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExitPostmaster</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * After PM_STARTUP, any unexpected exit (including FATAL exit) of
			 * the startup process is catastrophic, so kill other children,
			 * and set StartupStatus so we don't try to reinitialize after
			 * they're gone.  Exception: if StartupStatus is STARTUP_SIGNALED,
			 * then we previously sent the startup process a SIGQUIT; so
			 * that's probably the reason it died, and we do want to try to
			 * restart in that case.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EXIT_STATUS_0</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>StartupStatus</name> <operator>==</operator> <name>STARTUP_SIGNALED</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>StartupStatus</name> <operator>=</operator> <name>STARTUP_NOT_RUNNING</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>StartupStatus</name> <operator>=</operator> <name>STARTUP_CRASHED</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><call><name>HandleChildCrash</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>exitstatus</name></expr></argument>,
								 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"startup process"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Startup succeeded, commence normal operations
			 */</comment>
			<expr_stmt><expr><name>StartupStatus</name> <operator>=</operator> <name>STARTUP_NOT_RUNNING</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>FatalError</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>YbCrashWhileLockIntermediateState</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>AbortStartTime</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ReachedNormalRunning</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>pmState</name> <operator>=</operator> <name>PM_RUN</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Crank up the background tasks, if we didn't do that already
			 * when we entered consistent recovery state.  It doesn't matter
			 * if this fails, we'll just try again later.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>CheckpointerPID</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>CheckpointerPID</name> <operator>=</operator> <call><name>StartCheckpointer</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>BgWriterPID</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>BgWriterPID</name> <operator>=</operator> <call><name>StartBackgroundWriter</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>WalWriterPID</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>WalWriterPID</name> <operator>=</operator> <call><name>StartWalWriter</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Likewise, start other special children as needed.  In a restart
			 * situation, some of them may be alive already.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsBinaryUpgrade</name> <operator>&amp;&amp;</operator> <call><name>AutoVacuumingActive</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
			    <name>AutoVacPID</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>YBIsEnabledInPostgresEnvVar</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>AutoVacPID</name> <operator>=</operator> <call><name>StartAutoVacLauncher</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>PgArchStartupAllowed</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>PgArchPID</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>PgArchPID</name> <operator>=</operator> <call><name>pgarch_start</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>PgStatPID</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>PgStatPID</name> <operator>=</operator> <call><name>pgstat_start</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* workers may be scheduled to start now */</comment>
			<expr_stmt><expr><call><name>maybe_start_bgworkers</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* at this point we are really open for business */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database system is ready to accept connections"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Report status */</comment>
			<expr_stmt><expr><call><name>AddToDataDirLockFile</name><argument_list>(<argument><expr><name>LOCK_FILE_LINE_PM_STATUS</name></expr></argument>, <argument><expr><name>PM_STATUS_READY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SYSTEMD</name></cpp:ifdef>
			<expr_stmt><expr><call><name>sd_notify</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"READY=1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Was it the bgwriter?  Normal exit can be ignored; we'll start a new
		 * one at the next iteration of the postmaster's main loop, if
		 * necessary.  Any other exit condition is treated as a crash.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <name>BgWriterPID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>BgWriterPID</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EXIT_STATUS_0</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>HandleChildCrash</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>exitstatus</name></expr></argument>,
								 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"background writer process"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Was it the checkpointer?
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <name>CheckpointerPID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>CheckpointerPID</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>EXIT_STATUS_0</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>pmState</name> <operator>==</operator> <name>PM_SHUTDOWN</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * OK, we saw normal exit of the checkpointer after it's been
				 * told to shut down.  We expect that it wrote a shutdown
				 * checkpoint.  (If for some reason it didn't, recovery will
				 * occur on next postmaster start.)
				 *
				 * At this point we should have no normal backend children
				 * left (else we'd not be in PM_SHUTDOWN state) but we might
				 * have dead_end children to wait for.
				 *
				 * If we have an archiver subprocess, tell it to do a last
				 * archive cycle and quit. Likewise, if we have walsender
				 * processes, tell them to send any remaining WAL and quit.
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Shutdown</name> <operator>&gt;</operator> <name>NoShutdown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Waken archiver for the last time */</comment>
				<if_stmt><if>if <condition>(<expr><name>PgArchPID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>PgArchPID</name></expr></argument>, <argument><expr><name>SIGUSR2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Waken walsenders for the last time. No regular backends
				 * should be around anymore.
				 */</comment>
				<expr_stmt><expr><call><name>SignalChildren</name><argument_list>(<argument><expr><name>SIGUSR2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>pmState</name> <operator>=</operator> <name>PM_SHUTDOWN_2</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * We can also shut down the stats collector now; there's
				 * nothing left for it to do.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>PgStatPID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>PgStatPID</name></expr></argument>, <argument><expr><name>SIGQUIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Any unexpected exit of the checkpointer (including FATAL
				 * exit) is treated as a crash.
				 */</comment>
				<expr_stmt><expr><call><name>HandleChildCrash</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>exitstatus</name></expr></argument>,
								 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"checkpointer process"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Was it the wal writer?  Normal exit can be ignored; we'll start a
		 * new one at the next iteration of the postmaster's main loop, if
		 * necessary.  Any other exit condition is treated as a crash.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <name>WalWriterPID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>WalWriterPID</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EXIT_STATUS_0</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>HandleChildCrash</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>exitstatus</name></expr></argument>,
								 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"WAL writer process"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Was it the wal receiver?  If exit status is zero (normal) or one
		 * (FATAL exit), we assume everything is all right just like normal
		 * backends.  (If we need a new wal receiver, we'll start one at the
		 * next iteration of the postmaster's main loop.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <name>WalReceiverPID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>WalReceiverPID</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EXIT_STATUS_0</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>EXIT_STATUS_1</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>HandleChildCrash</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>exitstatus</name></expr></argument>,
								 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"WAL receiver process"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Was it the autovacuum launcher?	Normal exit can be ignored; we'll
		 * start a new one at the next iteration of the postmaster's main
		 * loop, if necessary.  Any other exit condition is treated as a
		 * crash.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <name>AutoVacPID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>AutoVacPID</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EXIT_STATUS_0</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>HandleChildCrash</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>exitstatus</name></expr></argument>,
								 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"autovacuum launcher process"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Was it the archiver?  If so, just try to start a new one; no need
		 * to force reset of the rest of the system.  (If fail, we'll try
		 * again in future cycles of the main loop.).  Unless we were waiting
		 * for it to shut down; don't restart it in that case, and
		 * PostmasterStateMachine() will advance to the next shutdown step.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <name>PgArchPID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>PgArchPID</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EXIT_STATUS_0</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>LogChildExit</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"archiver process"</literal></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>PgArchStartupAllowed</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>PgArchPID</name> <operator>=</operator> <call><name>pgarch_start</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Was it the statistics collector?  If so, just try to start a new
		 * one; no need to force reset of the rest of the system.  (If fail,
		 * we'll try again in future cycles of the main loop.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <name>PgStatPID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>PgStatPID</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EXIT_STATUS_0</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>LogChildExit</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"statistics collector process"</literal></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>pmState</name> <operator>==</operator> <name>PM_RUN</name> <operator>||</operator> <name>pmState</name> <operator>==</operator> <name>PM_HOT_STANDBY</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>PgStatPID</name> <operator>=</operator> <call><name>pgstat_start</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Was it the system logger?  If so, try to start a new one */</comment>
		<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <name>SysLoggerPID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>SysLoggerPID</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<comment type="block">/* for safety's sake, launch new logger *first* */</comment>
			<expr_stmt><expr><name>SysLoggerPID</name> <operator>=</operator> <call><name>SysLogger_Start</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EXIT_STATUS_0</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>LogChildExit</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"system logger process"</literal></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Was it one of our background workers? */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>CleanupBackgroundWorker</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* have it be restarted */</comment>
			<expr_stmt><expr><name>HaveCrashedWorker</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Else do standard backend child cleanup.
		 */</comment>
		<expr_stmt><expr><call><name>CleanupBackend</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>YbCrashWhileLockIntermediateState</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>FatalError</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Since this is not a fatal crash, we are pursuing a clean exit. All
			 * we need to do is to clear the pgstat entry of the dead backend
			 * pid. In case of postmaster restart, it is unnecessary as all the
			 * shared memory state will be reset.
			 */</comment>
			<expr_stmt><expr><call><name>yb_pgstat_clear_entry_pid</name><argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>							<comment type="block">/* loop over pending child-death reports */</comment>

	<comment type="block">/*
	 * After cleaning out the SIGCHLD queue, see if we have any state changes
	 * or actions to make.
	 */</comment>
	<expr_stmt><expr><call><name>PostmasterStateMachine</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Done with signal handler */</comment>
	<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UnBlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Scan the bgworkers list and see if the given PID (which has just stopped
 * or crashed) is in it.  Handle its shutdown if so, and return true.  If not a
 * bgworker, return false.
 *
 * This is heavily based on CleanupBackend.  One important difference is that
 * we don't know yet that the dying process is a bgworker, so we must be silent
 * until we're sure it is.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CleanupBackgroundWorker</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>exitstatus</name></decl></parameter>)</parameter_list> <comment type="block">/* child's exit status */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>namebuf</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>slist_mutable_iter</name></type> <name>iter</name></decl>;</decl_stmt>

	<macro><name>slist_foreach_modify</name><argument_list>(<argument>iter</argument>, <argument>&amp;BackgroundWorkerList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RegisteredBgWorker</name> <modifier>*</modifier></type><name>rw</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rw</name> <operator>=</operator> <call><name>slist_container</name><argument_list>(<argument><expr><name>RegisteredBgWorker</name></expr></argument>, <argument><expr><name>rw_lnode</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rw</name><operator>-&gt;</operator><name>rw_pid</name></name> <operator>!=</operator> <name>pid</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
		<comment type="block">/* see CleanupBackend */</comment>
		<if_stmt><if>if <condition>(<expr><name>exitstatus</name> <operator>==</operator> <name>ERROR_WAIT_NO_CHILDREN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>exitstatus</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>namebuf</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"background worker \"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EXIT_STATUS_0</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Record timestamp, so we know when to restart the worker. */</comment>
			<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_crashed_at</name></name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Zero exit status means terminate */</comment>
			<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_crashed_at</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_terminate</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Additionally, for shared-memory-connected workers, just like a
		 * backend, any exit status other than 0 or 1 is considered a crash
		 * and causes a system-wide restart.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_flags</name></name> <operator>&amp;</operator> <name>BGWORKER_SHMEM_ACCESS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EXIT_STATUS_0</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>EXIT_STATUS_1</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>HandleChildCrash</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>exitstatus</name></expr></argument>, <argument><expr><name>namebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We must release the postmaster child slot whether this worker is
		 * connected to shared memory or not, but we only treat it as a crash
		 * if it is in fact connected.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ReleasePostmasterChildSlot</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_child_slot</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_flags</name></name> <operator>&amp;</operator> <name>BGWORKER_SHMEM_ACCESS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>HandleChildCrash</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>exitstatus</name></expr></argument>, <argument><expr><name>namebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Get it out of the BackendList and clear out remaining data */</comment>
		<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rw</name><operator>-&gt;</operator><name>rw_backend</name><operator>-&gt;</operator><name>elem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
		<expr_stmt><expr><call><name>ShmemBackendArrayRemove</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_backend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/*
		 * It's possible that this background worker started some OTHER
		 * background worker and asked to be notified when that worker started
		 * or stopped.  If so, cancel any notifications destined for the
		 * now-dead backend.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rw</name><operator>-&gt;</operator><name>rw_backend</name><operator>-&gt;</operator><name>bgworker_notify</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>BackgroundWorkerStopNotifications</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_backend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_backend</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_child_slot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReportBackgroundWorkerExit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* report child death */</comment>

		<expr_stmt><expr><call><name>LogChildExit</name><argument_list>(<argument><expr><ternary><condition><expr><call><name>EXIT_STATUS_0</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>DEBUG1</name></expr> </then><else>: <expr><name>LOG</name></expr></else></ternary></expr></argument>,
					 <argument><expr><name>namebuf</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CleanupBackend -- cleanup after terminated backend.
 *
 * Remove all local state associated with backend.
 *
 * If you change this, see also CleanupBackgroundWorker.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CleanupBackend</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>exitstatus</name></decl></parameter>)</parameter_list>	<comment type="block">/* child's exit status. */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_mutable_iter</name></type> <name>iter</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LogChildExit</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"server process"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If a backend dies in an ugly way then we must signal all other backends
	 * to quickdie.  If exit status is zero (normal) or one (FATAL exit), we
	 * assume everything is all right and proceed to remove the backend from
	 * the active backend list.
	 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>

	<comment type="block">/*
	 * On win32, also treat ERROR_WAIT_NO_CHILDREN (128) as nonfatal case,
	 * since that sometimes happens under load when the process fails to start
	 * properly (long before it starts using shared memory). Microsoft reports
	 * it is related to mutex failure:
	 * http://archives.postgresql.org/pgsql-hackers/2010-09/msg00790.php
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>exitstatus</name> <operator>==</operator> <name>ERROR_WAIT_NO_CHILDREN</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LogChildExit</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"server process"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>exitstatus</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EXIT_STATUS_0</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>EXIT_STATUS_1</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>HandleChildCrash</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>exitstatus</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"server process"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<macro><name>dlist_foreach_modify</name><argument_list>(<argument>iter</argument>, <argument>&amp;BackendList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Backend</name>    <modifier>*</modifier></type><name>bp</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>Backend</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>bp</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <name>pid</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bp</name><operator>-&gt;</operator><name>dead_end</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ReleasePostmasterChildSlot</name><argument_list>(<argument><expr><name><name>bp</name><operator>-&gt;</operator><name>child_slot</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Uh-oh, the child failed to clean itself up.  Treat as a
					 * crash after all.
					 */</comment>
					<expr_stmt><expr><call><name>HandleChildCrash</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>exitstatus</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"server process"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return;</return>
				</block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
				<expr_stmt><expr><call><name>ShmemBackendArrayRemove</name><argument_list>(<argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>bp</name><operator>-&gt;</operator><name>bgworker_notify</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * This backend may have been slated to receive SIGUSR1 when
				 * some background worker started or stopped.  Cancel those
				 * notifications, as we don't want to signal PIDs that are not
				 * PostgreSQL backends.  This gets skipped in the (probably
				 * very common) case where the backend has never requested any
				 * such notifications.
				 */</comment>
				<expr_stmt><expr><call><name>BackgroundWorkerStopNotifications</name><argument_list>(<argument><expr><name><name>bp</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * HandleChildCrash -- cleanup after failed backend, bgwriter, checkpointer,
 * walwriter, autovacuum, or background worker.
 *
 * The objectives here are to clean up our local state about the child
 * process, and to signal all other remaining children to quickdie.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>HandleChildCrash</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>exitstatus</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>procname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_mutable_iter</name></type> <name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>slist_iter</name></type>	<name>siter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Backend</name>    <modifier>*</modifier></type><name>bp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>take_action</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We only log messages and send signals if this is the first process
	 * crash and we're not doing an immediate shutdown; otherwise, we're only
	 * here to update postmaster's idea of live processes.  If we have already
	 * signalled children, nonzero exit status is to be expected, so don't
	 * clutter log.
	 */</comment>
	<expr_stmt><expr><name>take_action</name> <operator>=</operator> <operator>!</operator><name>FatalError</name> <operator>&amp;&amp;</operator> <name>Shutdown</name> <operator>!=</operator> <name>ImmediateShutdown</name></expr>;</expr_stmt>
	<comment type="block">/*
	 * If we enable the flag yb_pg_terminate_child_backend to false, it means
	 * that if a child has crashed in a safe state, we need not do a postmaster
	 * restart. We check for that condition in determine if we need to restart
	 * postmaster (the variable take_action determines that).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>YBIsEnabledInPostgresEnvVar</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>YBShouldRestartAllChildrenIfOneCrashes</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>take_action</name> <operator>=</operator> <name>take_action</name> <operator>&amp;&amp;</operator> <name>YbCrashWhileLockIntermediateState</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>YbCrashWhileLockIntermediateState</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>YbCrashWhileLockIntermediateState</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>take_action</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LogChildExit</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><name>procname</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating any other active server processes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Process background workers. */</comment>
	<macro><name>slist_foreach</name><argument_list>(<argument>siter</argument>, <argument>&amp;BackgroundWorkerList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RegisteredBgWorker</name> <modifier>*</modifier></type><name>rw</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rw</name> <operator>=</operator> <call><name>slist_container</name><argument_list>(<argument><expr><name>RegisteredBgWorker</name></expr></argument>, <argument><expr><name>rw_lnode</name></expr></argument>, <argument><expr><name><name>siter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>rw</name><operator>-&gt;</operator><name>rw_pid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* not running */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rw</name><operator>-&gt;</operator><name>rw_pid</name></name> <operator>==</operator> <name>pid</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Found entry for freshly-dead worker, so remove it.
			 */</comment>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>ReleasePostmasterChildSlot</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_child_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rw</name><operator>-&gt;</operator><name>rw_backend</name><operator>-&gt;</operator><name>elem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
			<expr_stmt><expr><call><name>ShmemBackendArrayRemove</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_backend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_backend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_backend</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_child_slot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<comment type="block">/* don't reset crashed_at */</comment>
			<comment type="block">/* don't report child stop, either */</comment>
			<comment type="block">/* Keep looping so we can signal remaining workers */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * This worker is still alive.  Unless we did so already, tell it
			 * to commit hara-kiri.
			 *
			 * SIGQUIT is the special signal that says exit without proc_exit
			 * and let the user know what's going on. But if SendStop is set
			 * (-s on command line), then we send SIGSTOP instead, so that we
			 * can get core dumps from all backends by hand.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>take_action</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"sending %s to process %d"</literal></expr></argument>,
										 <argument><expr><operator>(</operator><ternary><condition><expr><name>SendStop</name></expr> ?</condition><then> <expr><literal type="string">"SIGSTOP"</literal></expr> </then><else>: <expr><literal type="string">"SIGQUIT"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
										 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>rw</name><operator>-&gt;</operator><name>rw_pid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_pid</name></name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>SendStop</name></expr> ?</condition><then> <expr><name>SIGSTOP</name></expr> </then><else>: <expr><name>SIGQUIT</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Process regular backends */</comment>
	<macro><name>dlist_foreach_modify</name><argument_list>(<argument>iter</argument>, <argument>&amp;BackendList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>bp</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>Backend</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>bp</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <name>pid</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Found entry for freshly-dead backend, so remove it.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bp</name><operator>-&gt;</operator><name>dead_end</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>ReleasePostmasterChildSlot</name><argument_list>(<argument><expr><name><name>bp</name><operator>-&gt;</operator><name>child_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
				<expr_stmt><expr><call><name>ShmemBackendArrayRemove</name><argument_list>(<argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Keep looping so we can signal remaining backends */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * This backend is still alive.  Unless we did so already, tell it
			 * to commit hara-kiri.
			 *
			 * SIGQUIT is the special signal that says exit without proc_exit
			 * and let the user know what's going on. But if SendStop is set
			 * (-s on command line), then we send SIGSTOP instead, so that we
			 * can get core dumps from all backends by hand.
			 *
			 * We could exclude dead_end children here, but at least in the
			 * SIGSTOP case it seems better to include them.
			 *
			 * Background workers were already processed above; ignore them
			 * here.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>bp</name><operator>-&gt;</operator><name>bkend_type</name></name> <operator>==</operator> <name>BACKEND_TYPE_BGWORKER</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>take_action</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"sending %s to process %d"</literal></expr></argument>,
										 <argument><expr><operator>(</operator><ternary><condition><expr><name>SendStop</name></expr> ?</condition><then> <expr><literal type="string">"SIGSTOP"</literal></expr> </then><else>: <expr><literal type="string">"SIGQUIT"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
										 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>bp</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name><name>bp</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>SendStop</name></expr> ?</condition><then> <expr><name>SIGSTOP</name></expr> </then><else>: <expr><name>SIGQUIT</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Take care of the startup process too */</comment>
	<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <name>StartupPID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>StartupPID</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>StartupStatus</name> <operator>=</operator> <name>STARTUP_CRASHED</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>StartupPID</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>take_action</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"sending %s to process %d"</literal></expr></argument>,
								 <argument><expr><operator>(</operator><ternary><condition><expr><name>SendStop</name></expr> ?</condition><then> <expr><literal type="string">"SIGSTOP"</literal></expr> </then><else>: <expr><literal type="string">"SIGQUIT"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
								 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>StartupPID</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>StartupPID</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>SendStop</name></expr> ?</condition><then> <expr><name>SIGSTOP</name></expr> </then><else>: <expr><name>SIGQUIT</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>StartupStatus</name> <operator>=</operator> <name>STARTUP_SIGNALED</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Take care of the bgwriter too */</comment>
	<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <name>BgWriterPID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>BgWriterPID</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>BgWriterPID</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>take_action</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"sending %s to process %d"</literal></expr></argument>,
								 <argument><expr><operator>(</operator><ternary><condition><expr><name>SendStop</name></expr> ?</condition><then> <expr><literal type="string">"SIGSTOP"</literal></expr> </then><else>: <expr><literal type="string">"SIGQUIT"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
								 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>BgWriterPID</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>BgWriterPID</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>SendStop</name></expr> ?</condition><then> <expr><name>SIGSTOP</name></expr> </then><else>: <expr><name>SIGQUIT</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Take care of the checkpointer too */</comment>
	<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <name>CheckpointerPID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>CheckpointerPID</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>CheckpointerPID</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>take_action</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"sending %s to process %d"</literal></expr></argument>,
								 <argument><expr><operator>(</operator><ternary><condition><expr><name>SendStop</name></expr> ?</condition><then> <expr><literal type="string">"SIGSTOP"</literal></expr> </then><else>: <expr><literal type="string">"SIGQUIT"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
								 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>CheckpointerPID</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>CheckpointerPID</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>SendStop</name></expr> ?</condition><then> <expr><name>SIGSTOP</name></expr> </then><else>: <expr><name>SIGQUIT</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Take care of the walwriter too */</comment>
	<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <name>WalWriterPID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>WalWriterPID</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>WalWriterPID</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>take_action</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"sending %s to process %d"</literal></expr></argument>,
								 <argument><expr><operator>(</operator><ternary><condition><expr><name>SendStop</name></expr> ?</condition><then> <expr><literal type="string">"SIGSTOP"</literal></expr> </then><else>: <expr><literal type="string">"SIGQUIT"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
								 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>WalWriterPID</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>WalWriterPID</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>SendStop</name></expr> ?</condition><then> <expr><name>SIGSTOP</name></expr> </then><else>: <expr><name>SIGQUIT</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Take care of the walreceiver too */</comment>
	<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <name>WalReceiverPID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>WalReceiverPID</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>WalReceiverPID</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>take_action</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"sending %s to process %d"</literal></expr></argument>,
								 <argument><expr><operator>(</operator><ternary><condition><expr><name>SendStop</name></expr> ?</condition><then> <expr><literal type="string">"SIGSTOP"</literal></expr> </then><else>: <expr><literal type="string">"SIGQUIT"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
								 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>WalReceiverPID</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>WalReceiverPID</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>SendStop</name></expr> ?</condition><then> <expr><name>SIGSTOP</name></expr> </then><else>: <expr><name>SIGQUIT</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Take care of the autovacuum launcher too */</comment>
	<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <name>AutoVacPID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>AutoVacPID</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>AutoVacPID</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>take_action</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"sending %s to process %d"</literal></expr></argument>,
								 <argument><expr><operator>(</operator><ternary><condition><expr><name>SendStop</name></expr> ?</condition><then> <expr><literal type="string">"SIGSTOP"</literal></expr> </then><else>: <expr><literal type="string">"SIGQUIT"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
								 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>AutoVacPID</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>AutoVacPID</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>SendStop</name></expr> ?</condition><then> <expr><name>SIGSTOP</name></expr> </then><else>: <expr><name>SIGQUIT</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Force a power-cycle of the pgarch process too.  (This isn't absolutely
	 * necessary, but it seems like a good idea for robustness, and it
	 * simplifies the state-machine logic in the case where a shutdown request
	 * arrives during crash processing.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>PgArchPID</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>take_action</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"sending %s to process %d"</literal></expr></argument>,
								 <argument><expr><literal type="string">"SIGQUIT"</literal></expr></argument>,
								 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>PgArchPID</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>PgArchPID</name></expr></argument>, <argument><expr><name>SIGQUIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Force a power-cycle of the pgstat process too.  (This isn't absolutely
	 * necessary, but it seems like a good idea for robustness, and it
	 * simplifies the state-machine logic in the case where a shutdown request
	 * arrives during crash processing.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>PgStatPID</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>take_action</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"sending %s to process %d"</literal></expr></argument>,
								 <argument><expr><literal type="string">"SIGQUIT"</literal></expr></argument>,
								 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>PgStatPID</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>PgStatPID</name></expr></argument>, <argument><expr><name>SIGQUIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>allow_immediate_pgstat_restart</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>YBIsEnabledInPostgresEnvVar</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>YBShouldRestartAllChildrenIfOneCrashes</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>take_action</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<comment type="block">/* We do NOT restart the syslogger */</comment>

	<if_stmt><if>if <condition>(<expr><name>Shutdown</name> <operator>!=</operator> <name>ImmediateShutdown</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>FatalError</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* We now transit into a state of waiting for children to die */</comment>
	<if_stmt><if>if <condition>(<expr><name>pmState</name> <operator>==</operator> <name>PM_RECOVERY</name> <operator>||</operator>
		<name>pmState</name> <operator>==</operator> <name>PM_HOT_STANDBY</name> <operator>||</operator>
		<name>pmState</name> <operator>==</operator> <name>PM_RUN</name> <operator>||</operator>
		<name>pmState</name> <operator>==</operator> <name>PM_WAIT_BACKUP</name> <operator>||</operator>
		<name>pmState</name> <operator>==</operator> <name>PM_WAIT_READONLY</name> <operator>||</operator>
		<name>pmState</name> <operator>==</operator> <name>PM_SHUTDOWN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>pmState</name> <operator>=</operator> <name>PM_WAIT_BACKENDS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * .. and if this doesn't happen quickly enough, now the clock is ticking
	 * for us to kill them without mercy.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>AbortStartTime</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>AbortStartTime</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Log the death of a child process.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>LogChildExit</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lev</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>procname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>exitstatus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * size of activity_buffer is arbitrary, but set equal to default
	 * track_activity_query_size
	 */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>activity_buffer</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>activity</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EXIT_STATUS_0</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>activity</name> <operator>=</operator> <call><name>pgstat_get_crashed_backend_activity</name><argument_list>(<argument><expr><name>pid</name></expr></argument>,
													   <argument><expr><name>activity_buffer</name></expr></argument>,
													   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>activity_buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>WIFEXITED</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>lev</name></expr></argument>,

		<comment type="block">/*------
		  translator: %s is a noun phrase describing a child process, such as
		  "server process" */</comment>
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s (PID %d) exited with exit code %d"</literal></expr></argument>,
						<argument><expr><name>procname</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><call><name>WEXITSTATUS</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><name>activity</name></expr> ?</condition><then> <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed process was running: %s"</literal></expr></argument>, <argument><expr><name>activity</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>WIFSIGNALED</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>WTERMSIG</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SIGKILL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pgstat_report_query_termination</name><argument_list>(<argument><expr><literal type="string">"Terminated by SIGKILL"</literal></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>WTERMSIG</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SIGSEGV</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pgstat_report_query_termination</name><argument_list>(<argument><expr><literal type="string">"Terminated by SIGSEGV"</literal></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>lev</name></expr></argument>,

		<comment type="block">/*------
		  translator: %s is a noun phrase describing a child process, such as
		  "server process" */</comment>
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s (PID %d) was terminated by exception 0x%X"</literal></expr></argument>,
						<argument><expr><name>procname</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><call><name>WTERMSIG</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"See C include file \"ntstatus.h\" for a description of the hexadecimal value."</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><name>activity</name></expr> ?</condition><then> <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed process was running: %s"</literal></expr></argument>, <argument><expr><name>activity</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DECL_SYS_SIGLIST</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>HAVE_DECL_SYS_SIGLIST</name></expr></cpp:elif>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>lev</name></expr></argument>,

		<comment type="block">/*------
		  translator: %s is a noun phrase describing a child process, such as
		  "server process" */</comment>
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s (PID %d) was terminated by signal %d: %s"</literal></expr></argument>,
						<argument><expr><name>procname</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><call><name>WTERMSIG</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><ternary><condition><expr><call><name>WTERMSIG</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>NSIG</name></expr> ?</condition><then>
						<expr><name><name>sys_siglist</name><index>[<expr><call><name>WTERMSIG</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr>]</index></name></expr> </then><else>: <expr><literal type="string">"(unknown)"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><name>activity</name></expr> ?</condition><then> <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed process was running: %s"</literal></expr></argument>, <argument><expr><name>activity</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>lev</name></expr></argument>,

		<comment type="block">/*------
		  translator: %s is a noun phrase describing a child process, such as
		  "server process" */</comment>
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s (PID %d) was terminated by signal %d"</literal></expr></argument>,
						<argument><expr><name>procname</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><call><name>WTERMSIG</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><name>activity</name></expr> ?</condition><then> <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed process was running: %s"</literal></expr></argument>, <argument><expr><name>activity</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>lev</name></expr></argument>,

		<comment type="block">/*------
		  translator: %s is a noun phrase describing a child process, such as
		  "server process" */</comment>
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s (PID %d) exited with unrecognized status %d"</literal></expr></argument>,
						<argument><expr><name>procname</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><name>activity</name></expr> ?</condition><then> <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed process was running: %s"</literal></expr></argument>, <argument><expr><name>activity</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Advance the postmaster's state machine and take actions as appropriate
 *
 * This is common code for pmdie(), reaper() and sigusr1_handler(), which
 * receive the signals that might mean we need to change state.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PostmasterStateMachine</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>pmState</name> <operator>==</operator> <name>PM_WAIT_BACKUP</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * PM_WAIT_BACKUP state ends when online backup mode is not active.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BackupInProgress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>pmState</name> <operator>=</operator> <name>PM_WAIT_BACKENDS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>pmState</name> <operator>==</operator> <name>PM_WAIT_READONLY</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * PM_WAIT_READONLY state ends when we have no regular backends that
		 * have been started during recovery.  We kill the startup and
		 * walreceiver processes and transition to PM_WAIT_BACKENDS.  Ideally,
		 * we might like to kill these processes first and then wait for
		 * backends to die off, but that doesn't work at present because
		 * killing the startup process doesn't release its locks.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>CountChildren</name><argument_list>(<argument><expr><name>BACKEND_TYPE_NORMAL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>StartupPID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>StartupPID</name></expr></argument>, <argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>WalReceiverPID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>WalReceiverPID</name></expr></argument>, <argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>pmState</name> <operator>=</operator> <name>PM_WAIT_BACKENDS</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we are in a state-machine state that implies waiting for backends to
	 * exit, see if they're all gone, and change state if so.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>pmState</name> <operator>==</operator> <name>PM_WAIT_BACKENDS</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * PM_WAIT_BACKENDS state ends when we have no regular backends
		 * (including autovac workers), no bgworkers (including unconnected
		 * ones), and no walwriter, autovac launcher or bgwriter.  If we are
		 * doing crash recovery or an immediate shutdown then we expect the
		 * checkpointer to exit as well, otherwise not. The archiver, stats,
		 * and syslogger processes are disregarded since they are not
		 * connected to shared memory; we also disregard dead_end children
		 * here. Walsenders are also disregarded, they will be terminated
		 * later after writing the checkpoint record, like the archiver
		 * process.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>CountChildren</name><argument_list>(<argument><expr><name>BACKEND_TYPE_NORMAL</name> <operator>|</operator> <name>BACKEND_TYPE_WORKER</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name>StartupPID</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name>WalReceiverPID</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name>BgWriterPID</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>CheckpointerPID</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			 <operator>(</operator><operator>!</operator><name>FatalError</name> <operator>&amp;&amp;</operator> <name>Shutdown</name> <operator>&lt;</operator> <name>ImmediateShutdown</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
			<name>WalWriterPID</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name>AutoVacPID</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>Shutdown</name> <operator>&gt;=</operator> <name>ImmediateShutdown</name> <operator>||</operator> <name>FatalError</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Start waiting for dead_end children to die.  This state
				 * change causes ServerLoop to stop creating new ones.
				 */</comment>
				<expr_stmt><expr><name>pmState</name> <operator>=</operator> <name>PM_WAIT_DEAD_END</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * We already SIGQUIT'd the archiver and stats processes, if
				 * any, when we started immediate shutdown or entered
				 * FatalError state.
				 */</comment>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * If we get here, we are proceeding with normal shutdown. All
				 * the regular children are gone, and it's time to tell the
				 * checkpointer to do a shutdown checkpoint.
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Shutdown</name> <operator>&gt;</operator> <name>NoShutdown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Start the checkpointer if not running */</comment>
				<if_stmt><if>if <condition>(<expr><name>CheckpointerPID</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>CheckpointerPID</name> <operator>=</operator> <call><name>StartCheckpointer</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/* And tell it to shut down */</comment>
				<if_stmt><if>if <condition>(<expr><name>CheckpointerPID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>CheckpointerPID</name></expr></argument>, <argument><expr><name>SIGUSR2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>pmState</name> <operator>=</operator> <name>PM_SHUTDOWN</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * If we failed to fork a checkpointer, just shut down.
					 * Any required cleanup will happen at next restart. We
					 * set FatalError so that an "abnormal shutdown" message
					 * gets logged when we exit.
					 */</comment>
					<expr_stmt><expr><name>FatalError</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>pmState</name> <operator>=</operator> <name>PM_WAIT_DEAD_END</name></expr>;</expr_stmt>

					<comment type="block">/* Kill the walsenders, archiver and stats collector too */</comment>
					<expr_stmt><expr><call><name>SignalChildren</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>PgArchPID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>PgArchPID</name></expr></argument>, <argument><expr><name>SIGQUIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>PgStatPID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>PgStatPID</name></expr></argument>, <argument><expr><name>SIGQUIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>pmState</name> <operator>==</operator> <name>PM_SHUTDOWN_2</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * PM_SHUTDOWN_2 state ends when there's no other children than
		 * dead_end children left. There shouldn't be any regular backends
		 * left by now anyway; what we're really waiting for is walsenders and
		 * archiver.
		 *
		 * Walreceiver should normally be dead by now, but not when a fast
		 * shutdown is performed during recovery.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>PgArchPID</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>CountChildren</name><argument_list>(<argument><expr><name>BACKEND_TYPE_ALL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name>WalReceiverPID</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>pmState</name> <operator>=</operator> <name>PM_WAIT_DEAD_END</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>pmState</name> <operator>==</operator> <name>PM_WAIT_DEAD_END</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * PM_WAIT_DEAD_END state ends when the BackendList is entirely empty
		 * (ie, no dead_end children remain), and the archiver and stats
		 * collector are gone too.
		 *
		 * The reason we wait for those two is to protect them against a new
		 * postmaster starting conflicting subprocesses; this isn't an
		 * ironclad protection, but it at least helps in the
		 * shutdown-and-immediately-restart scenario.  Note that they have
		 * already been sent appropriate shutdown signals, either during a
		 * normal state transition leading up to PM_WAIT_DEAD_END, or during
		 * FatalError processing.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BackendList</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name>PgArchPID</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>PgStatPID</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* These other guys should be dead already */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>StartupPID</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>WalReceiverPID</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>BgWriterPID</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CheckpointerPID</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>WalWriterPID</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>AutoVacPID</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* syslogger is not considered here */</comment>
			<expr_stmt><expr><name>pmState</name> <operator>=</operator> <name>PM_NO_CHILDREN</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we've been told to shut down, we exit as soon as there are no
	 * remaining children.  If there was a crash, cleanup will occur at the
	 * next startup.  (Before PostgreSQL 8.3, we tried to recover from the
	 * crash before exiting, but that seems unwise if we are quitting because
	 * we got SIGTERM from init --- there may well not be time for recovery
	 * before init decides to SIGKILL us.)
	 *
	 * Note that the syslogger continues to run.  It will exit when it sees
	 * EOF on its input pipe, which happens when there are no more upstream
	 * processes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Shutdown</name> <operator>&gt;</operator> <name>NoShutdown</name> <operator>&amp;&amp;</operator> <name>pmState</name> <operator>==</operator> <name>PM_NO_CHILDREN</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>FatalError</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"abnormal database system shutdown"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExitPostmaster</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Terminate exclusive backup mode to avoid recovery after a clean
			 * fast shutdown.  Since an exclusive backup can only be taken
			 * during normal running (and not, for example, while running
			 * under Hot Standby) it only makes sense to do this if we reached
			 * normal running. If we're still in recovery, the backup file is
			 * one we're recovering *from*, and we must keep it around so that
			 * recovery restarts from the right place.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>ReachedNormalRunning</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>CancelBackup</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Normal exit from the postmaster is here */</comment>
			<expr_stmt><expr><call><name>ExitPostmaster</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the startup process failed, or the user does not want an automatic
	 * restart after backend crashes, wait for all non-syslogger children to
	 * exit, and then exit postmaster.  We don't try to reinitialize when the
	 * startup process fails, because more than likely it will just fail again
	 * and we will keep trying forever.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>pmState</name> <operator>==</operator> <name>PM_NO_CHILDREN</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>StartupStatus</name> <operator>==</operator> <name>STARTUP_CRASHED</name> <operator>||</operator> <operator>!</operator><name>restart_after_crash</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExitPostmaster</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we need to recover from a crash, wait for all non-syslogger children
	 * to exit, then reset shmem and StartupDataBase.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>FatalError</name> <operator>&amp;&amp;</operator> <name>pmState</name> <operator>==</operator> <name>PM_NO_CHILDREN</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"all server processes terminated; reinitializing"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* allow background workers to immediately restart */</comment>
		<expr_stmt><expr><call><name>ResetBackgroundWorkerCrashTimes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>shmem_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* re-read control file into local memory */</comment>
		<expr_stmt><expr><call><name>LocalProcessControlFile</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>reset_shared</name><argument_list>(<argument><expr><name>PostPortNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>StartupPID</name> <operator>=</operator> <call><name>StartupDataBase</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>StartupPID</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>StartupStatus</name> <operator>=</operator> <name>STARTUP_RUNNING</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pmState</name> <operator>=</operator> <name>PM_STARTUP</name></expr>;</expr_stmt>
		<comment type="block">/* crash recovery started, reset SIGKILL flag */</comment>
		<expr_stmt><expr><name>AbortStartTime</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Send a signal to a postmaster child process
 *
 * On systems that have setsid(), each child process sets itself up as a
 * process group leader.  For signals that are generally interpreted in the
 * appropriate fashion, we signal the entire process group not just the
 * direct child process.  This allows us to, for example, SIGQUIT a blocked
 * archive_recovery script, or SIGINT a script being run by a backend via
 * system().
 *
 * There is a race condition for recently-forked children: they might not
 * have executed setsid() yet.  So we signal the child directly as well as
 * the group.  We assume such a child will handle the signal before trying
 * to spawn any grandchild processes.  We also assume that signaling the
 * child twice will not cause any problems.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>signal_child</name><parameter_list>(<parameter><decl><type><name>pid_t</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>signal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>kill</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>signal</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"kill(%ld,%d) failed: %m"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name>pid</name></expr></argument>, <argument><expr><name>signal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SETSID</name></cpp:ifdef>
	<switch>switch <condition>(<expr><name>signal</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SIGINT</name></expr>:</case>
		<case>case <expr><name>SIGTERM</name></expr>:</case>
		<case>case <expr><name>SIGQUIT</name></expr>:</case>
		<case>case <expr><name>SIGSTOP</name></expr>:</case>
		<case>case <expr><name>SIGKILL</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>kill</name><argument_list>(<argument><expr><operator>-</operator><name>pid</name></expr></argument>, <argument><expr><name>signal</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"kill(%ld,%d) failed: %m"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><operator>-</operator><name>pid</name><operator>)</operator></expr></argument>, <argument><expr><name>signal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Send a signal to the targeted children (but NOT special children;
 * dead_end children are never signaled, either).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>SignalSomeChildren</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>signal</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_iter</name></type>	<name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>signaled</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;BackendList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Backend</name>    <modifier>*</modifier></type><name>bp</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>Backend</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>bp</name><operator>-&gt;</operator><name>dead_end</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Since target == BACKEND_TYPE_ALL is the most common case, we test
		 * it first and avoid touching shared memory for every child.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>target</name> <operator>!=</operator> <name>BACKEND_TYPE_ALL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Assign bkend_type for any recently announced WAL Sender
			 * processes.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>bp</name><operator>-&gt;</operator><name>bkend_type</name></name> <operator>==</operator> <name>BACKEND_TYPE_NORMAL</name> <operator>&amp;&amp;</operator>
				<call><name>IsPostmasterChildWalSender</name><argument_list>(<argument><expr><name><name>bp</name><operator>-&gt;</operator><name>child_slot</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>bp</name><operator>-&gt;</operator><name>bkend_type</name></name> <operator>=</operator> <name>BACKEND_TYPE_WALSND</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>target</name> <operator>&amp;</operator> <name><name>bp</name><operator>-&gt;</operator><name>bkend_type</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"sending signal %d to process %d"</literal></expr></argument>,
								 <argument><expr><name>signal</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>bp</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name><name>bp</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><name>signal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>signaled</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block>
	<return>return <expr><name>signaled</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Send a termination signal to children.  This considers all of our children
 * processes, except syslogger and dead_end backends.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>TerminateChildren</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>signal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SignalChildren</name><argument_list>(<argument><expr><name>signal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>StartupPID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>StartupPID</name></expr></argument>, <argument><expr><name>signal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>signal</name> <operator>==</operator> <name>SIGQUIT</name> <operator>||</operator> <name>signal</name> <operator>==</operator> <name>SIGKILL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>StartupStatus</name> <operator>=</operator> <name>STARTUP_SIGNALED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>BgWriterPID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>BgWriterPID</name></expr></argument>, <argument><expr><name>signal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>CheckpointerPID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>CheckpointerPID</name></expr></argument>, <argument><expr><name>signal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>WalWriterPID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>WalWriterPID</name></expr></argument>, <argument><expr><name>signal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>WalReceiverPID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>WalReceiverPID</name></expr></argument>, <argument><expr><name>signal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>AutoVacPID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>AutoVacPID</name></expr></argument>, <argument><expr><name>signal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>PgArchPID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>PgArchPID</name></expr></argument>, <argument><expr><name>signal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>PgStatPID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>PgStatPID</name></expr></argument>, <argument><expr><name>signal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * BackendStartup -- start backend process
 *
 * returns: STATUS_ERROR if the fork failed, STATUS_OK otherwise.
 *
 * Note: if you change this code, also consider StartAutovacuumWorker.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>BackendStartup</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Backend</name>    <modifier>*</modifier></type><name>bn</name></decl>;</decl_stmt>				<comment type="block">/* for backend cleanup */</comment>
	<decl_stmt><decl><type><name>pid_t</name></type>		<name>pid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Create backend data structure.  Better before the fork() so we can
	 * handle failure cleanly.
	 */</comment>
	<expr_stmt><expr><name>bn</name> <operator>=</operator> <operator>(</operator><name>Backend</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Backend</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bn</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Compute the cancel key that will be assigned to this backend. The
	 * backend will have its own copy in the forked-off process' value of
	 * MyCancelKey, so that it can transmit the key to the frontend.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RandomCancelKey</name><argument_list>(<argument><expr><operator>&amp;</operator><name>MyCancelKey</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>bn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not generate random cancel key"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>bn</name><operator>-&gt;</operator><name>cancel_key</name></name> <operator>=</operator> <name>MyCancelKey</name></expr>;</expr_stmt>

	<comment type="block">/* Pass down canAcceptConnections state */</comment>
	<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>canAcceptConnections</name></name> <operator>=</operator> <call><name>canAcceptConnections</name><argument_list>(<argument><expr><name>BACKEND_TYPE_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bn</name><operator>-&gt;</operator><name>dead_end</name></name> <operator>=</operator> <operator>(</operator><name><name>port</name><operator>-&gt;</operator><name>canAcceptConnections</name></name> <operator>!=</operator> <name>CAC_OK</name> <operator>&amp;&amp;</operator>
					<name><name>port</name><operator>-&gt;</operator><name>canAcceptConnections</name></name> <operator>!=</operator> <name>CAC_WAITBACKUP</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Unless it's a dead_end child, assign it a child slot number
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bn</name><operator>-&gt;</operator><name>dead_end</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>bn</name><operator>-&gt;</operator><name>child_slot</name></name> <operator>=</operator> <name>MyPMChildSlot</name> <operator>=</operator> <call><name>AssignPostmasterChildSlot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>bn</name><operator>-&gt;</operator><name>child_slot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Hasn't asked to be notified about any bgworkers yet */</comment>
	<expr_stmt><expr><name><name>bn</name><operator>-&gt;</operator><name>bgworker_notify</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
	<expr_stmt><expr><name>pid</name> <operator>=</operator> <call><name>backend_forkexec</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* !EXEC_BACKEND */</comment>
	<expr_stmt><expr><name>pid</name> <operator>=</operator> <call><name>fork_process</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>				<comment type="block">/* child */</comment>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>bn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Detangle from postmaster */</comment>
		<expr_stmt><expr><call><name>InitPostmasterChild</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Close the postmaster's sockets */</comment>
		<expr_stmt><expr><call><name>ClosePostmasterPorts</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Perform additional initialization and collect startup packet */</comment>
		<expr_stmt><expr><call><name>BackendInitialize</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* And run the backend */</comment>
		<expr_stmt><expr><call><name>BackendRun</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* EXEC_BACKEND */</comment>

	<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* in parent, fork failed */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bn</name><operator>-&gt;</operator><name>dead_end</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>ReleasePostmasterChildSlot</name><argument_list>(<argument><expr><name><name>bn</name><operator>-&gt;</operator><name>child_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>bn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fork new process for connection: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>report_fork_failure_to_client</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name>save_errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* in parent, successful fork */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"forked new backend, pid=%d socket=%d"</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>pid</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>port</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Everything's been successful, it's safe to add this backend to our list
	 * of backends.
	 */</comment>
	<expr_stmt><expr><name><name>bn</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name>pid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bn</name><operator>-&gt;</operator><name>bkend_type</name></name> <operator>=</operator> <name>BACKEND_TYPE_NORMAL</name></expr>;</expr_stmt>	<comment type="block">/* Can change later to WALSND */</comment>
	<expr_stmt><expr><call><name>dlist_push_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BackendList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bn</name><operator>-&gt;</operator><name>elem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bn</name><operator>-&gt;</operator><name>dead_end</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ShmemBackendArrayAdd</name><argument_list>(<argument><expr><name>bn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__linux__</name></cpp:ifdef>
	<decl_stmt><decl><type><name>char</name></type> <name><name>file_name</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>file_name</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>file_name</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"/proc/%d/oom_score_adj"</literal></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>fPtr</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>fPtr</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>file_name</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
	 * oom_score_adj varies from -1000 to 1000. The lower the value, the lower
	 * the chance that it's going to be killed. Here, we are setting low priority
	 * (YbBackendOomScoreAdj) for postgres connections so that during out of
	 * memory, postgres connections are killed first. We do that be setting a
	 * high oom_score_adj value for the postgres connection.
	 */</comment>
	<if_stmt><if>if<condition>(<expr><name>fPtr</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>saved_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"error %d: %s, unable to open file %s"</literal></expr></argument>, <argument><expr><name>saved_errno</name></expr></argument>,
				<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>saved_errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>file_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name>YbBackendOomScoreAdj</name></expr></argument>, <argument><expr><name>fPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Try to report backend fork() failure to client before we close the
 * connection.  Since we do not care to risk blocking the postmaster on
 * this connection, we set the connection to non-blocking and try only once.
 *
 * This is grungy special-purpose code; we cannot use backend libpq since
 * it's not up and running.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>report_fork_failure_to_client</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>errnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buffer</name><index>[<expr><literal type="number">1000</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>

	<comment type="block">/* Format the error message packet (always V2 protocol) */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"E%s%s\n"</literal></expr></argument>,
			 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not fork new process for connection: "</literal></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set port to non-blocking.  Don't do send() if this fails */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_set_noblock</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* We'll retry after EINTR, but ignore all other failures */</comment>
	<do>do
	<block>{<block_content>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>send</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition>;</do>
</block_content>}</block></function>


<comment type="block">/*
 * BackendInitialize -- initialize an interactive (postmaster-child)
 *				backend process, and collect the client's startup packet.
 *
 * returns: nothing.  Will not return at all if there's any failure.
 *
 * Note: this code does not depend on having any access to shared memory.
 * In the EXEC_BACKEND case, we are physically attached to shared memory
 * but have not yet set up most of our local pointers to shmem structures.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>BackendInitialize</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>remote_host</name><index>[<expr><name>NI_MAXHOST</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>remote_port</name><index>[<expr><name>NI_MAXSERV</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>remote_ps_data</name><index>[<expr><name>NI_MAXHOST</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* Save port etc. for ps status */</comment>
	<expr_stmt><expr><name>MyProcPort</name> <operator>=</operator> <name>port</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * PreAuthDelay is a debugging aid for investigating problems in the
	 * authentication cycle: it can be set in postgresql.conf to allow time to
	 * attach to the newly-forked backend with a debugger.  (See also
	 * PostAuthDelay, which we allow clients to pass through PGOPTIONS, but it
	 * is not honored until after authentication.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>PreAuthDelay</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>PreAuthDelay</name> <operator>*</operator> <literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* This flag will remain set until InitPostgres finishes authentication */</comment>
	<expr_stmt><expr><name>ClientAuthInProgress</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* limit visibility of log messages */</comment>

	<comment type="block">/* save process start time */</comment>
	<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>SessionStartTime</name></name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>MyStartTime</name> <operator>=</operator> <call><name>timestamptz_to_time_t</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>SessionStartTime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set these to empty in case they are needed before we set them up */</comment>
	<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>remote_host</name></name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>remote_port</name></name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize libpq and enable reporting of ereport errors to the client.
	 * Must do this now because authentication uses libpq to send messages.
	 */</comment>
	<expr_stmt><expr><call><name>pq_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>					<comment type="block">/* initialize libpq to talk to client */</comment>
	<expr_stmt><expr><name>whereToSendOutput</name> <operator>=</operator> <name>DestRemote</name></expr>;</expr_stmt> <comment type="block">/* now safe to ereport to client */</comment>

	<comment type="block">/*
	 * We arrange for a simple exit(1) if we receive SIGTERM or SIGQUIT or
	 * timeout while trying to collect the startup packet.  Otherwise the
	 * postmaster cannot shutdown the database FAST or IMMED cleanly if a
	 * buggy client fails to send the packet promptly.  XXX it follows that
	 * the remainder of this function must tolerate losing control at any
	 * instant.  Likewise, any pg_on_exit_callback registered before or during
	 * this function must be prepared to execute at any instant between here
	 * and the end of this function.  Furthermore, affected callbacks execute
	 * partially or not at all when a second exit-inducing signal arrives
	 * after proc_exit_prepare() decrements on_proc_exit_index.  (Thanks to
	 * that mechanic, callbacks need not anticipate more than one call.)  This
	 * is fragile; it ought to instead follow the norm of handling interrupts
	 * at selected, safe opportunities.
	 */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>startup_die</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><name>startup_die</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitializeTimeouts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* establishes SIGALRM handler */</comment>
	<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>StartupBlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get the remote host name and port for logging and status display.
	 */</comment>
	<expr_stmt><expr><name><name>remote_host</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>remote_port</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>pg_getnameinfo_all</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>port</name><operator>-&gt;</operator><name>raddr</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>raddr</name><operator>.</operator><name>salen</name></name></expr></argument>,
								  <argument><expr><name>remote_host</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>remote_host</name></expr></argument>)</argument_list></sizeof></expr></argument>,
								  <argument><expr><name>remote_port</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>remote_port</name></expr></argument>)</argument_list></sizeof></expr></argument>,
								  <argument><expr><operator>(</operator><ternary><condition><expr><name>log_hostname</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>NI_NUMERICHOST</name></expr></else></ternary><operator>)</operator> <operator>|</operator> <name>NI_NUMERICSERV</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"pg_getnameinfo_all() failed: %s"</literal></expr></argument>,
								 <argument><expr><call><name>gai_strerror</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>remote_port</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>remote_ps_data</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>remote_ps_data</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>remote_host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>remote_ps_data</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>remote_ps_data</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s(%s)"</literal></expr></argument>, <argument><expr><name>remote_host</name></expr></argument>, <argument><expr><name>remote_port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Save remote_host and remote_port in port structure (after this, they
	 * will appear in log_line_prefix data for log messages).
	 */</comment>
	<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>remote_host</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>remote_host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>remote_port</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>remote_port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* And now we can issue the Log_connections message, if wanted */</comment>
	<if_stmt><if>if <condition>(<expr><name>Log_connections</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>remote_port</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"connection received: host=%s port=%s"</literal></expr></argument>,
							<argument><expr><name>remote_host</name></expr></argument>,
							<argument><expr><name>remote_port</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"connection received: host=%s"</literal></expr></argument>,
							<argument><expr><name>remote_host</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we did a reverse lookup to name, we might as well save the results
	 * rather than possibly repeating the lookup during authentication.
	 *
	 * Note that we don't want to specify NI_NAMEREQD above, because then we'd
	 * get nothing useful for a client without an rDNS entry.  Therefore, we
	 * must check whether we got a numeric IPv4 or IPv6 address, and not save
	 * it into remote_hostname if so.  (This test is conservative and might
	 * sometimes classify a hostname as numeric, but an error in that
	 * direction is safe; it only results in a possible extra lookup.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>log_hostname</name> <operator>&amp;&amp;</operator>
		<name>ret</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<call><name>strspn</name><argument_list>(<argument><expr><name>remote_host</name></expr></argument>, <argument><expr><literal type="string">"0123456789."</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>remote_host</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>strspn</name><argument_list>(<argument><expr><name>remote_host</name></expr></argument>, <argument><expr><literal type="string">"0123456789ABCDEFabcdef:"</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>remote_host</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>remote_hostname</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>remote_host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Ready to begin client interaction.  We will give up and exit(1) after a
	 * time delay, so that a broken client can't hog a connection
	 * indefinitely.  PreAuthDelay and any DNS interactions above don't count
	 * against the time limit.
	 *
	 * Note: AuthenticationTimeout is applied here while waiting for the
	 * startup packet, and then again in InitPostgres for the duration of any
	 * authentication operations.  So a hostile client could tie up the
	 * process for nearly twice AuthenticationTimeout before we kick him off.
	 *
	 * Note: because PostgresMain will call InitializeTimeouts again, the
	 * registration of STARTUP_PACKET_TIMEOUT will be lost.  This is okay
	 * since we never use it again after this function.
	 */</comment>
	<expr_stmt><expr><call><name>RegisterTimeout</name><argument_list>(<argument><expr><name>STARTUP_PACKET_TIMEOUT</name></expr></argument>, <argument><expr><name>StartupPacketTimeoutHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>enable_timeout_after</name><argument_list>(<argument><expr><name>STARTUP_PACKET_TIMEOUT</name></expr></argument>, <argument><expr><name>AuthenticationTimeout</name> <operator>*</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Receive the startup packet (which might turn out to be a cancel request
	 * packet).
	 */</comment>
	<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>ProcessStartupPacket</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Stop here if it was bad or a cancel packet.  ProcessStartupPacket
	 * already did any appropriate error reporting.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Now that we have the user and database name, we can set the process
	 * title for ps.  It's good to do this as early as possible in startup.
	 *
	 * For a walsender, the ps display is set in the following form:
	 *
	 * postgres: walsender &lt;user&gt; &lt;host&gt; &lt;activity&gt;
	 *
	 * To achieve that, we pass "walsender" as username and username as dbname
	 * to init_ps_display(). XXX: should add a new variant of
	 * init_ps_display() to avoid abusing the parameters like this.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>am_walsender</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>init_ps_display</name><argument_list>(<argument><expr><call><name>pgstat_get_backend_desc</name><argument_list>(<argument><expr><name>B_WAL_SENDER</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>, <argument><expr><name>remote_ps_data</name></expr></argument>,
						<argument><expr><ternary><condition><expr><name>update_process_title</name></expr> ?</condition><then> <expr><literal type="string">"authentication"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>init_ps_display</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>database_name</name></name></expr></argument>, <argument><expr><name>remote_ps_data</name></expr></argument>,
						<argument><expr><ternary><condition><expr><name>update_process_title</name></expr> ?</condition><then> <expr><literal type="string">"authentication"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Disable the timeout, and prevent SIGTERM/SIGQUIT again.
	 */</comment>
	<expr_stmt><expr><call><name>disable_timeout</name><argument_list>(<argument><expr><name>STARTUP_PACKET_TIMEOUT</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * BackendRun -- set up the backend's argument list and invoke PostgresMain()
 *
 * returns:
 *		Shouldn't return at all.
 *		If PostgresMain() fails, return status.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>BackendRun</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>av</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxac</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ac</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>secs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>usecs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Don't want backend to be able to see the postmaster random number
	 * generator state.  We have to clobber the static random_seed *and* start
	 * a new random sequence in the random() library function.
	 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_STRONG_RANDOM</name></cpp:ifndef>
	<expr_stmt><expr><name>random_seed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>random_start_time</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<comment type="block">/* slightly hacky way to convert timestamptz into integers */</comment>
	<expr_stmt><expr><call><name>TimestampDifference</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>SessionStartTime</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>secs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>usecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ADDRESS_SANITIZER</name></cpp:ifdef>
	<comment type="block">/* YugaByte fix for ASAN */</comment>
	<expr_stmt><expr><call><name>srandom</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <operator>(</operator><name>MyProcPid</name> <operator>^</operator> <operator>(</operator><operator>(</operator><name>int64_t</name><operator>)</operator> <name>usecs</name> <operator>&lt;&lt;</operator> <literal type="number">12</literal><operator>)</operator> <operator>^</operator> <name>secs</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>srandom</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <operator>(</operator><name>MyProcPid</name> <operator>^</operator> <operator>(</operator><name>usecs</name> <operator>&lt;&lt;</operator> <literal type="number">12</literal><operator>)</operator> <operator>^</operator> <name>secs</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


	<comment type="block">/*
	 * Now, build the argv vector that will be given to PostgresMain.
	 *
	 * The maximum possible number of commandline arguments that could come
	 * from ExtraOptions is (strlen(ExtraOptions) + 1) / 2; see
	 * pg_split_opts().
	 */</comment>
	<expr_stmt><expr><name>maxac</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>					<comment type="block">/* for fixed args supplied below */</comment>
	<expr_stmt><expr><name>maxac</name> <operator>+=</operator> <operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name>ExtraOptions</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>av</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
									  <argument><expr><name>maxac</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ac</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"postgres"</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Pass any backend switches specified with -o on the postmaster's own
	 * command line.  We assume these are secure.
	 */</comment>
	<expr_stmt><expr><call><name>pg_split_opts</name><argument_list>(<argument><expr><name>av</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ac</name></expr></argument>, <argument><expr><name>ExtraOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ac</name> <operator>&lt;</operator> <name>maxac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Debug: print arguments being passed to backend
	 */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%s child[%d]: starting with ("</literal></expr></argument>,
							 <argument><expr><name>progname</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ac</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"\t%s"</literal></expr></argument>, <argument><expr><name><name>av</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure we aren't in PostmasterContext anymore.  (We can't delete it
	 * just yet, though, because InitPostgres will need the HBA data.)
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PostgresMain</name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><name>av</name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>database_name</name></name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>

<comment type="block">/*
 * postmaster_forkexec -- fork and exec a postmaster subprocess
 *
 * The caller must have set up the argv array already, except for argv[2]
 * which will be filled with the name of the temp variable file.
 *
 * Returns the child process PID, or -1 on fork failure (a suitable error
 * message has been logged on failure).
 *
 * All uses of this routine will dispatch to SubPostmasterMain in the
 * child process.
 */</comment>
<function><type><name>pid_t</name></type>
<name>postmaster_forkexec</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Port</name></type>		<name>port</name></decl>;</decl_stmt>

	<comment type="block">/* This entry point passes dummy values for the Port variables */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>port</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>internal_forkexec</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>port</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * backend_forkexec -- fork/exec off a backend process
 *
 * Some operating systems (WIN32) don't have fork() so we have to simulate
 * it by storing parameters that need to be passed to the child and
 * then create a new child process.
 *
 * returns the pid of the fork/exec'd process, or -1 on failure
 */</comment>
<function><type><specifier>static</specifier> <name>pid_t</name></type>
<name>backend_forkexec</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>av</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ac</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"postgres"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"--forkbackend"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>			<comment type="block">/* filled in by internal_forkexec */</comment>

	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ac</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>av</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>internal_forkexec</name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><name>av</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>

<comment type="block">/*
 * internal_forkexec non-win32 implementation
 *
 * - writes out backend variables to the parameter file
 * - fork():s, and then exec():s the child process
 */</comment>
<function><type><specifier>static</specifier> <name>pid_t</name></type>
<name>internal_forkexec</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>tmpBackendFileNum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pid_t</name></type>		<name>pid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>tmpfilename</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackendParameters</name></type> <name>param</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>save_backend_variables</name><argument_list>(<argument><expr><operator>&amp;</operator><name>param</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* log made by save_backend_variables */</comment>

	<comment type="block">/* Calculate name for temp file */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tmpfilename</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s.backend_var.%d.%lu"</literal></expr></argument>,
			 <argument><expr><name>PG_TEMP_FILES_DIR</name></expr></argument>, <argument><expr><name>PG_TEMP_FILE_PREFIX</name></expr></argument>,
			 <argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><operator>++</operator><name>tmpBackendFileNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Open file */</comment>
	<expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>tmpfilename</name></expr></argument>, <argument><expr><name>PG_BINARY_W</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fp</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * As in OpenTemporaryFileInTablespace, try to make the temp-file
		 * directory, ignoring errors.
		 */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>MakePGDirectory</name><argument_list>(<argument><expr><name>PG_TEMP_FILES_DIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>tmpfilename</name></expr></argument>, <argument><expr><name>PG_BINARY_W</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fp</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>tmpfilename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><operator>&amp;</operator><name>param</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>tmpfilename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Release file */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>tmpfilename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Make sure caller set up argv properly */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>argc</name> <operator>&gt;=</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>argc</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--fork"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Insert temp file name after --fork argument */</comment>
	<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>tmpfilename</name></expr>;</expr_stmt>

	<comment type="block">/* Fire off execv in child */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>pid</name> <operator>=</operator> <call><name>fork_process</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>execv</name><argument_list>(<argument><expr><name>postgres_exec_path</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not execute server process \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>postgres_exec_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* We're already in the child process here, can't return */</comment>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>pid</name></expr>;</return>					<comment type="block">/* Parent returns pid, or -1 on fork failure */</comment>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* WIN32 */</comment>

<comment type="block">/*
 * internal_forkexec win32 implementation
 *
 * - starts backend using CreateProcess(), in suspended state
 * - writes out backend variables to the parameter file
 *	- during this, duplicates handles and sockets required for
 *	  inheritance into the new process
 * - resumes execution of the new process once the backend parameter
 *	 file is complete.
 */</comment>
<function><type><specifier>static</specifier> <name>pid_t</name></type>
<name>internal_forkexec</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>retry_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>STARTUPINFO</name></type> <name>si</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PROCESS_INFORMATION</name></type> <name>pi</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>cmdLine</name><index>[<expr><name>MAXPGPATH</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HANDLE</name></type>		<name>paramHandle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackendParameters</name> <modifier>*</modifier></type><name>param</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SECURITY_ATTRIBUTES</name></type> <name>sa</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>paramHandleStr</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>win32_deadchild_waitinfo</name> <modifier>*</modifier></type><name>childinfo</name></decl>;</decl_stmt>

	<comment type="block">/* Make sure caller set up argv properly */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>argc</name> <operator>&gt;=</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>argc</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--fork"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Resume here if we need to retry */</comment>
<label><name>retry</name>:</label>

	<comment type="block">/* Set up shared memory for parameter passing */</comment>
	<expr_stmt><expr><call><name>ZeroMemory</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sa</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sa</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sa</name><operator>.</operator><name>nLength</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sa</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sa</name><operator>.</operator><name>bInheritHandle</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>paramHandle</name> <operator>=</operator> <call><name>CreateFileMapping</name><argument_list>(<argument><expr><name>INVALID_HANDLE_VALUE</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>sa</name></expr></argument>,
									<argument><expr><name>PAGE_READWRITE</name></expr></argument>,
									<argument><expr><literal type="number">0</literal></expr></argument>,
									<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BackendParameters</name></expr></argument>)</argument_list></sizeof></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>paramHandle</name> <operator>==</operator> <name>INVALID_HANDLE_VALUE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"could not create backend parameter file mapping: error code %lu"</literal></expr></argument>,
			 <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>MapViewOfFile</name><argument_list>(<argument><expr><name>paramHandle</name></expr></argument>, <argument><expr><name>FILE_MAP_WRITE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BackendParameters</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>param</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"could not map backend parameter memory: error code %lu"</literal></expr></argument>,
			 <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>paramHandle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Insert temp file name after --fork argument */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN64</name></cpp:ifdef>
	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>paramHandleStr</name></expr></argument>, <argument><expr><literal type="string">"%llu"</literal></expr></argument>, <argument><expr><operator>(</operator><name>LONG_PTR</name><operator>)</operator> <name>paramHandle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>paramHandleStr</name></expr></argument>, <argument><expr><literal type="string">"%lu"</literal></expr></argument>, <argument><expr><operator>(</operator><name>DWORD</name><operator>)</operator> <name>paramHandle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>paramHandleStr</name></expr>;</expr_stmt>

	<comment type="block">/* Format the cmd line */</comment>
	<expr_stmt><expr><name><name>cmdLine</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmdLine</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cmdLine</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmdLine</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cmdLine</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmdLine</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"\"%s\""</literal></expr></argument>, <argument><expr><name>postgres_exec_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>j</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>cmdLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cmdLine</name> <operator>+</operator> <name>j</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmdLine</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>j</name></expr></argument>, <argument><expr><literal type="string">" \"%s\""</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if <condition>(<expr><name><name>cmdLine</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmdLine</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"subprocess command line too long"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pi</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pi</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>si</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>.</operator><name>cb</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>si</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create the subprocess in a suspended state. This will be resumed later,
	 * once we have written out the parameter file.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CreateProcess</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>cmdLine</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>CREATE_SUSPENDED</name></expr></argument>,
					   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>si</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pi</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"CreateProcess call failed: %m (error code %lu)"</literal></expr></argument>,
			 <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>save_backend_variables</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name><name>pi</name><operator>.</operator><name>hProcess</name></name></expr></argument>, <argument><expr><name><name>pi</name><operator>.</operator><name>dwProcessId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * log made by save_backend_variables, but we have to clean up the
		 * mess with the half-started process
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TerminateProcess</name><argument_list>(<argument><expr><name><name>pi</name><operator>.</operator><name>hProcess</name></name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"could not terminate unstarted process: error code %lu"</literal></expr></argument>,
									 <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>pi</name><operator>.</operator><name>hProcess</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>pi</name><operator>.</operator><name>hThread</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>				<comment type="block">/* log made by save_backend_variables */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Drop the parameter shared memory that is now inherited to the backend */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UnmapViewOfFile</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"could not unmap view of backend parameter file: error code %lu"</literal></expr></argument>,
			 <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CloseHandle</name><argument_list>(<argument><expr><name>paramHandle</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"could not close handle to backend parameter file: error code %lu"</literal></expr></argument>,
			 <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Reserve the memory region used by our main shared memory segment before
	 * we resume the child process.  Normally this should succeed, but if ASLR
	 * is active then it might sometimes fail due to the stack or heap having
	 * gotten mapped into that range.  In that case, just terminate the
	 * process and retry.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pgwin32_ReserveSharedMemoryRegion</name><argument_list>(<argument><expr><name><name>pi</name><operator>.</operator><name>hProcess</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* pgwin32_ReserveSharedMemoryRegion already made a log entry */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TerminateProcess</name><argument_list>(<argument><expr><name><name>pi</name><operator>.</operator><name>hProcess</name></name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"could not terminate process that failed to reserve memory: error code %lu"</literal></expr></argument>,
									 <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>pi</name><operator>.</operator><name>hProcess</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>pi</name><operator>.</operator><name>hThread</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>++</operator><name>retry_count</name> <operator>&lt;</operator> <literal type="number">100</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>retry</name>;</goto></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"giving up after too many tries to reserve shared memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"This might be caused by ASLR or antivirus software."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now that the backend variables are written out, we start the child
	 * thread so it can start initializing while we set up the rest of the
	 * parent state.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ResumeThread</name><argument_list>(<argument><expr><name><name>pi</name><operator>.</operator><name>hThread</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TerminateProcess</name><argument_list>(<argument><expr><name><name>pi</name><operator>.</operator><name>hProcess</name></name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"could not terminate unstartable process: error code %lu"</literal></expr></argument>,
									 <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>pi</name><operator>.</operator><name>hProcess</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>pi</name><operator>.</operator><name>hThread</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>pi</name><operator>.</operator><name>hProcess</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>pi</name><operator>.</operator><name>hThread</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"could not resume thread of unstarted process: error code %lu"</literal></expr></argument>,
								 <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Queue a waiter for to signal when this child dies. The wait will be
	 * handled automatically by an operating system thread pool.
	 *
	 * Note: use malloc instead of palloc, since it needs to be thread-safe.
	 * Struct will be free():d from the callback function that runs on a
	 * different thread.
	 */</comment>
	<expr_stmt><expr><name>childinfo</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>win32_deadchild_waitinfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>childinfo</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>childinfo</name><operator>-&gt;</operator><name>procHandle</name></name> <operator>=</operator> <name><name>pi</name><operator>.</operator><name>hProcess</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>childinfo</name><operator>-&gt;</operator><name>procId</name></name> <operator>=</operator> <name><name>pi</name><operator>.</operator><name>dwProcessId</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RegisterWaitForSingleObject</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>childinfo</name><operator>-&gt;</operator><name>waitHandle</name></name></expr></argument>,
									 <argument><expr><name><name>pi</name><operator>.</operator><name>hProcess</name></name></expr></argument>,
									 <argument><expr><name>pgwin32_deadchild_callback</name></expr></argument>,
									 <argument><expr><name>childinfo</name></expr></argument>,
									 <argument><expr><name>INFINITE</name></expr></argument>,
									 <argument><expr><name>WT_EXECUTEONLYONCE</name> <operator>|</operator> <name>WT_EXECUTEINWAITTHREAD</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"could not register process for wait: error code %lu"</literal></expr></argument>,
								 <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Don't close pi.hProcess here - the wait thread needs access to it */</comment>

	<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>pi</name><operator>.</operator><name>hThread</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>pi</name><operator>.</operator><name>dwProcessId</name></name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>


<comment type="block">/*
 * SubPostmasterMain -- Get the fork/exec'd process into a state equivalent
 *			to what it would be if we'd simply forked on Unix, and then
 *			dispatch to the appropriate place.
 *
 * The first two command line arguments are expected to be "--forkFOO"
 * (where FOO indicates which postmaster child we are to become), and
 * the name of a variables file that we can read to load data that would
 * have been inherited by fork() on Unix.  Remaining arguments go to the
 * subprocess FooMain() routine.
 */</comment>
<function><type><name>void</name></type>
<name>SubPostmasterMain</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Port</name></type>		<name>port</name></decl>;</decl_stmt>

	<comment type="block">/* In EXEC_BACKEND case we will not have inherited these settings */</comment>
	<expr_stmt><expr><name>IsPostmasterEnvironment</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>whereToSendOutput</name> <operator>=</operator> <name>DestNone</name></expr>;</expr_stmt>

	<comment type="block">/* Setup as postmaster child */</comment>
	<expr_stmt><expr><call><name>InitPostmasterChild</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Setup essential subsystems (to ensure elog() behaves sanely) */</comment>
	<expr_stmt><expr><call><name>InitializeGUCOptions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check we got appropriate args */</comment>
	<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"invalid subpostmaster invocation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Read in the variables file */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>port</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Port</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>read_backend_variables</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Close the postmaster's sockets (as soon as we know them) */</comment>
	<expr_stmt><expr><call><name>ClosePostmasterPorts</name><argument_list>(<argument><expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--forklog"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set reference point for stack-depth checking
	 */</comment>
	<expr_stmt><expr><call><name>set_stack_base</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up memory area for GSS information. Mirrors the code in ConnCreate
	 * for the non-exec case.
	 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_GSS</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_SSPI</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><name><name>port</name><operator>.</operator><name>gss</name></name> <operator>=</operator> <operator>(</operator><name>pg_gssinfo</name> <operator>*</operator><operator>)</operator> <call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pg_gssinfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>port</name><operator>.</operator><name>gss</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * If appropriate, physically re-attach to shared memory segment. We want
	 * to do this before going any further to ensure that we can attach at the
	 * same address the postmaster used.  On the other hand, if we choose not
	 * to re-attach, we may have other cleanup to do.
	 *
	 * If testing EXEC_BACKEND on Linux, you should run this as root before
	 * starting the postmaster:
	 *
	 * echo 0 &gt;/proc/sys/kernel/randomize_va_space
	 *
	 * This prevents using randomized stack and code addresses that cause the
	 * child process's memory map to be different from the parent's, making it
	 * sometimes impossible to attach to shared memory at the desired address.
	 * Return the setting to its old value (usually '1' or '2') when finished.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--forkbackend"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--forkavlauncher"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--forkavworker"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--forkboot"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strncmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--forkbgworker="</literal></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PGSharedMemoryReAttach</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PGSharedMemoryNoReAttach</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* autovacuum needs this set before calling InitProcess */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--forkavlauncher"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AutovacuumLauncherIAm</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--forkavworker"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AutovacuumWorkerIAm</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Start our win32 signal implementation. This has to be done after we
	 * read the backend variables, because we need to pick up the signal pipe
	 * from the parent process.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<expr_stmt><expr><call><name>pgwin32_signal_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* In EXEC_BACKEND case we will not have inherited these settings */</comment>
	<expr_stmt><expr><call><name>pqinitmask</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Read in remaining GUC variables */</comment>
	<expr_stmt><expr><call><name>read_nondefault_variables</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check that the data directory looks valid, which will also check the
	 * privileges on the data directory and update our umask and file/group
	 * variables for creating files later.  Note: this should really be done
	 * before we create any files or directories.
	 */</comment>
	<expr_stmt><expr><call><name>checkDataDir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * (re-)read control file, as it contains config. The postmaster will
	 * already have read this, but this process doesn't know about that.
	 */</comment>
	<expr_stmt><expr><call><name>LocalProcessControlFile</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reload any libraries that were preloaded by the postmaster.  Since we
	 * exec'd this process, those libraries didn't come along with us; but we
	 * should load them into all child processes to be consistent with the
	 * non-EXEC_BACKEND behavior.
	 */</comment>
	<expr_stmt><expr><call><name>process_shared_preload_libraries</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Run backend or appropriate child */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--forkbackend"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>argc</name> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* shouldn't be any more args */</comment>

		<comment type="block">/*
		 * Need to reinitialize the SSL library in the backend, since the
		 * context structures contain function pointers and cannot be passed
		 * through the parameter file.
		 *
		 * If for some reason reload fails (maybe the user installed broken
		 * key files), soldier on without SSL; that's better than all
		 * connections becoming impossible.
		 *
		 * XXX should we do this in all child processes?  For the moment it's
		 * enough to do it in backend children.
		 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>EnableSSL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>secure_initialize</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>LoadedSSL</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SSL configuration could not be loaded in child process"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/*
		 * Perform additional initialization and collect startup packet.
		 *
		 * We want to do this before InitProcess() for a couple of reasons: 1.
		 * so that we aren't eating up a PGPROC slot while waiting on the
		 * client. 2. so that if InitProcess() fails due to being out of
		 * PGPROC slots, we have already initialized libpq and are able to
		 * report the error to the client.
		 */</comment>
		<expr_stmt><expr><call><name>BackendInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Restore basic shared memory pointers */</comment>
		<expr_stmt><expr><call><name>InitShmemAccess</name><argument_list>(<argument><expr><name>UsedShmemSegAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Need a PGPROC to run CreateSharedMemoryAndSemaphores */</comment>
		<expr_stmt><expr><call><name>InitProcess</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Attach process to shared data structures */</comment>
		<expr_stmt><expr><call><name>CreateSharedMemoryAndSemaphores</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* And run the backend */</comment>
		<expr_stmt><expr><call><name>BackendRun</name><argument_list>(<argument><expr><operator>&amp;</operator><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* does not return */</comment>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--forkboot"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Restore basic shared memory pointers */</comment>
		<expr_stmt><expr><call><name>InitShmemAccess</name><argument_list>(<argument><expr><name>UsedShmemSegAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Need a PGPROC to run CreateSharedMemoryAndSemaphores */</comment>
		<expr_stmt><expr><call><name>InitAuxiliaryProcess</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Attach process to shared data structures */</comment>
		<expr_stmt><expr><call><name>CreateSharedMemoryAndSemaphores</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>AuxiliaryProcessMain</name><argument_list>(<argument><expr><name>argc</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>argv</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* does not return */</comment>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--forkavlauncher"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Restore basic shared memory pointers */</comment>
		<expr_stmt><expr><call><name>InitShmemAccess</name><argument_list>(<argument><expr><name>UsedShmemSegAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Need a PGPROC to run CreateSharedMemoryAndSemaphores */</comment>
		<expr_stmt><expr><call><name>InitProcess</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Attach process to shared data structures */</comment>
		<expr_stmt><expr><call><name>CreateSharedMemoryAndSemaphores</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>AutoVacLauncherMain</name><argument_list>(<argument><expr><name>argc</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>argv</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* does not return */</comment>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--forkavworker"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Restore basic shared memory pointers */</comment>
		<expr_stmt><expr><call><name>InitShmemAccess</name><argument_list>(<argument><expr><name>UsedShmemSegAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Need a PGPROC to run CreateSharedMemoryAndSemaphores */</comment>
		<expr_stmt><expr><call><name>InitProcess</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Attach process to shared data structures */</comment>
		<expr_stmt><expr><call><name>CreateSharedMemoryAndSemaphores</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>AutoVacWorkerMain</name><argument_list>(<argument><expr><name>argc</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>argv</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* does not return */</comment>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--forkbgworker="</literal></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>shmem_slot</name></decl>;</decl_stmt>

		<comment type="block">/* do this as early as possible; in particular, before InitProcess() */</comment>
		<expr_stmt><expr><name>IsBackgroundWorker</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/* Restore basic shared memory pointers */</comment>
		<expr_stmt><expr><call><name>InitShmemAccess</name><argument_list>(<argument><expr><name>UsedShmemSegAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Need a PGPROC to run CreateSharedMemoryAndSemaphores */</comment>
		<expr_stmt><expr><call><name>InitProcess</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Attach process to shared data structures */</comment>
		<expr_stmt><expr><call><name>CreateSharedMemoryAndSemaphores</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Fetch MyBgworkerEntry from shared memory */</comment>
		<expr_stmt><expr><name>shmem_slot</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <literal type="number">15</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>MyBgworkerEntry</name> <operator>=</operator> <call><name>BackgroundWorkerEntry</name><argument_list>(<argument><expr><name>shmem_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>StartBackgroundWorker</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--forkarch"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Do not want to attach to shared memory */</comment>

		<expr_stmt><expr><call><name>PgArchiverMain</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* does not return */</comment>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--forkcol"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Do not want to attach to shared memory */</comment>

		<expr_stmt><expr><call><name>PgstatCollectorMain</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* does not return */</comment>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--forklog"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Do not want to attach to shared memory */</comment>

		<expr_stmt><expr><call><name>SysLoggerMain</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* does not return */</comment>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>					<comment type="block">/* shouldn't get here */</comment>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* EXEC_BACKEND */</comment>


<comment type="block">/*
 * ExitPostmaster -- cleanup
 *
 * Do NOT call exit() directly --- always go through here!
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExitPostmaster</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_PTHREAD_IS_THREADED_NP</name></cpp:ifdef>

	<comment type="block">/*
	 * There is no known cause for a postmaster to become multithreaded after
	 * startup.  Recheck to account for the possibility of unknown causes.
	 * This message uses LOG level, because an unclean shutdown at this point
	 * would usually not look much different from a clean shutdown.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pthread_is_threaded_np</name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"postmaster became multithreaded"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Please report this to &lt;pgsql-bugs@postgresql.org&gt;."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* should cleanup shared memory and kill all backends */</comment>

	<comment type="block">/*
	 * Not sure of the semantics here.  When the Postmaster dies, should the
	 * backends all be killed? probably not.
	 *
	 * MUST		-- vadim 05-10-1999
	 */</comment>

	<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * sigusr1_handler - handle signal conditions from child processes
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sigusr1_handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Process background worker state change. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>CheckPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_BACKGROUND_WORKER_CHANGE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>BackgroundWorkerStateChange</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>StartWorkerNeeded</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * RECOVERY_STARTED and BEGIN_HOT_STANDBY signals are ignored in
	 * unexpected states. If the startup process quickly starts up, completes
	 * recovery, exits, we might process the death of the startup process
	 * first. We don't want to go back to recovery in that case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>CheckPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_RECOVERY_STARTED</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name>pmState</name> <operator>==</operator> <name>PM_STARTUP</name> <operator>&amp;&amp;</operator> <name>Shutdown</name> <operator>==</operator> <name>NoShutdown</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* WAL redo has started. We're out of reinitialization. */</comment>
		<expr_stmt><expr><name>FatalError</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>AbortStartTime</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Crank up the background tasks.  It doesn't matter if this fails,
		 * we'll just try again later.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CheckpointerPID</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>CheckpointerPID</name> <operator>=</operator> <call><name>StartCheckpointer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>BgWriterPID</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>BgWriterPID</name> <operator>=</operator> <call><name>StartBackgroundWriter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Start the archiver if we're responsible for (re-)archiving received
		 * files.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>PgArchPID</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>XLogArchivingAlways</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>PgArchPID</name> <operator>=</operator> <call><name>pgarch_start</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If we aren't planning to enter hot standby mode later, treat
		 * RECOVERY_STARTED as meaning we're out of startup, and report status
		 * accordingly.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>EnableHotStandby</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>AddToDataDirLockFile</name><argument_list>(<argument><expr><name>LOCK_FILE_LINE_PM_STATUS</name></expr></argument>, <argument><expr><name>PM_STATUS_STANDBY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SYSTEMD</name></cpp:ifdef>
			<expr_stmt><expr><call><name>sd_notify</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"READY=1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>pmState</name> <operator>=</operator> <name>PM_RECOVERY</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>CheckPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_BEGIN_HOT_STANDBY</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name>pmState</name> <operator>==</operator> <name>PM_RECOVERY</name> <operator>&amp;&amp;</operator> <name>Shutdown</name> <operator>==</operator> <name>NoShutdown</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Likewise, start other special children as needed.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>PgStatPID</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>PgStatPID</name> <operator>=</operator> <call><name>pgstat_start</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database system is ready to accept read only connections"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Report status */</comment>
		<expr_stmt><expr><call><name>AddToDataDirLockFile</name><argument_list>(<argument><expr><name>LOCK_FILE_LINE_PM_STATUS</name></expr></argument>, <argument><expr><name>PM_STATUS_READY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SYSTEMD</name></cpp:ifdef>
		<expr_stmt><expr><call><name>sd_notify</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"READY=1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr_stmt><expr><name>pmState</name> <operator>=</operator> <name>PM_HOT_STANDBY</name></expr>;</expr_stmt>
		<comment type="block">/* Some workers may be scheduled to start now */</comment>
		<expr_stmt><expr><name>StartWorkerNeeded</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>StartWorkerNeeded</name> <operator>||</operator> <name>HaveCrashedWorker</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>maybe_start_bgworkers</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CheckPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_WAKEN_ARCHIVER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name>PgArchPID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Send SIGUSR1 to archiver process, to wake it up and begin archiving
		 * next WAL file.
		 */</comment>
		<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>PgArchPID</name></expr></argument>, <argument><expr><name>SIGUSR1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CheckPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_ROTATE_LOGFILE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name>SysLoggerPID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Tell syslogger to rotate logfile */</comment>
		<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>SysLoggerPID</name></expr></argument>, <argument><expr><name>SIGUSR1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CheckPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_START_AUTOVAC_LAUNCHER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name>Shutdown</name> <operator>==</operator> <name>NoShutdown</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>YBIsEnabledInPostgresEnvVar</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Start one iteration of the autovacuum daemon, even if autovacuuming
		 * is nominally not enabled.  This is so we can have an active defense
		 * against transaction ID wraparound.  We set a flag for the main loop
		 * to do it rather than trying to do it here --- this is because the
		 * autovac process itself may send the signal, and we want to handle
		 * that by launching another iteration as soon as the current one
		 * completes.
		 */</comment>
		<expr_stmt><expr><name>start_autovac_launcher</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CheckPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_START_AUTOVAC_WORKER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name>Shutdown</name> <operator>==</operator> <name>NoShutdown</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>YBIsEnabledInPostgresEnvVar</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* The autovacuum launcher wants us to start a worker process. */</comment>
		<expr_stmt><expr><call><name>StartAutovacuumWorker</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CheckPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_START_WALRECEIVER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
	    <operator>!</operator><call><name>YBIsEnabledInPostgresEnvVar</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Startup Process wants us to start the walreceiver process. */</comment>
		<comment type="block">/* Start immediately if possible, else remember request for later. */</comment>
		<expr_stmt><expr><name>WalReceiverRequested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MaybeStartWalReceiver</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CheckPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_ADVANCE_STATE_MACHINE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>pmState</name> <operator>==</operator> <name>PM_WAIT_BACKUP</name> <operator>||</operator> <name>pmState</name> <operator>==</operator> <name>PM_WAIT_BACKENDS</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Advance postmaster's state machine */</comment>
		<expr_stmt><expr><call><name>PostmasterStateMachine</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CheckPromoteSignal</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>StartupPID</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>pmState</name> <operator>==</operator> <name>PM_STARTUP</name> <operator>||</operator> <name>pmState</name> <operator>==</operator> <name>PM_RECOVERY</name> <operator>||</operator>
		 <name>pmState</name> <operator>==</operator> <name>PM_HOT_STANDBY</name> <operator>||</operator> <name>pmState</name> <operator>==</operator> <name>PM_WAIT_READONLY</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Tell startup process to finish recovery */</comment>
		<expr_stmt><expr><call><name>signal_child</name><argument_list>(<argument><expr><name>StartupPID</name></expr></argument>, <argument><expr><name>SIGUSR2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UnBlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SIGTERM or SIGQUIT while processing startup packet.
 * Clean up and exit(1).
 *
 * XXX: possible future improvement: try to send a message indicating
 * why we are disconnecting.  Problem is to be sure we don't block while
 * doing so, nor mess up SSL initialization.  In practice, if the client
 * has wedged here, it probably couldn't do anything with the message anyway.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>startup_die</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Dummy signal handler
 *
 * We use this for signals that we don't actually use in the postmaster,
 * but we do use in backends.  If we were to SIG_IGN such signals in the
 * postmaster, then a newly started backend might drop a signal that arrives
 * before it's able to reconfigure its signal processing.  (See notes in
 * tcop/postgres.c.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dummy_handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
</block_content>}</block></function>

<comment type="block">/*
 * Timeout while processing startup packet.
 * As for startup_die(), we clean up and exit(1).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>StartupPacketTimeoutHandler</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Generate a random cancel key.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>RandomCancelKey</name><parameter_list>(<parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>cancel_key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STRONG_RANDOM</name></cpp:ifdef>
	<return>return <expr><call><name>pg_strong_random</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>cancel_key</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

	<comment type="block">/*
	 * If built with --disable-strong-random, use plain old erand48.
	 *
	 * We cannot use pg_backend_random() in postmaster, because it stores its
	 * state in shared memory.
	 */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>short</name></type> <name><name>seed</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Select a random seed at the time of first receiving a request.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>random_seed</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>random_stop_time</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>random_stop_time</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>seed</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>short</name><operator>)</operator> <name><name>random_start_time</name><operator>.</operator><name>tv_usec</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>seed</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>short</name><operator>)</operator> <operator>(</operator><name><name>random_stop_time</name><operator>.</operator><name>tv_usec</name></name><operator>)</operator> <operator>^</operator> <operator>(</operator><name><name>random_start_time</name><operator>.</operator><name>tv_usec</name></name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>seed</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>short</name><operator>)</operator> <operator>(</operator><name><name>random_stop_time</name><operator>.</operator><name>tv_usec</name></name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name>random_seed</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>cancel_key</name> <operator>=</operator> <call><name>pg_jrand48</name><argument_list>(<argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Count up number of child processes of specified types (dead_end children
 * are always excluded).
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CountChildren</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_iter</name></type>	<name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;BackendList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Backend</name>    <modifier>*</modifier></type><name>bp</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>Backend</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>bp</name><operator>-&gt;</operator><name>dead_end</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Since target == BACKEND_TYPE_ALL is the most common case, we test
		 * it first and avoid touching shared memory for every child.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>target</name> <operator>!=</operator> <name>BACKEND_TYPE_ALL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Assign bkend_type for any recently announced WAL Sender
			 * processes.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>bp</name><operator>-&gt;</operator><name>bkend_type</name></name> <operator>==</operator> <name>BACKEND_TYPE_NORMAL</name> <operator>&amp;&amp;</operator>
				<call><name>IsPostmasterChildWalSender</name><argument_list>(<argument><expr><name><name>bp</name><operator>-&gt;</operator><name>child_slot</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>bp</name><operator>-&gt;</operator><name>bkend_type</name></name> <operator>=</operator> <name>BACKEND_TYPE_WALSND</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>target</name> <operator>&amp;</operator> <name><name>bp</name><operator>-&gt;</operator><name>bkend_type</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<return>return <expr><name>cnt</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * StartChildProcess -- start an auxiliary process for the postmaster
 *
 * "type" determines what kind of child will be started.  All child types
 * initially go to AuxiliaryProcessMain, which will handle common setup.
 *
 * Return value of StartChildProcess is subprocess' PID, or 0 if failed
 * to start subprocess.
 */</comment>
<function><type><specifier>static</specifier> <name>pid_t</name></type>
<name>StartChildProcess</name><parameter_list>(<parameter><decl><type><name>AuxProcType</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pid_t</name></type>		<name>pid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>av</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ac</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>typebuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>YBIsEnabledInPostgresEnvVar</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
	    <operator>(</operator><name>type</name> <operator>==</operator> <name>BgWriterProcess</name> <operator>||</operator>
		 <name>type</name> <operator>==</operator> <name>WalWriterProcess</name> <operator>||</operator>
		 <name>type</name> <operator>==</operator> <name>WalReceiverProcess</name><operator>)</operator></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/*
	 * Set up command-line arguments for subprocess
	 */</comment>
	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"postgres"</literal></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"--forkboot"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>			<comment type="block">/* filled in by postmaster_forkexec */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>typebuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>typebuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"-x%d"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>typebuf</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ac</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>av</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
	<expr_stmt><expr><name>pid</name> <operator>=</operator> <call><name>postmaster_forkexec</name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><name>av</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* !EXEC_BACKEND */</comment>
	<expr_stmt><expr><name>pid</name> <operator>=</operator> <call><name>fork_process</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>				<comment type="block">/* child */</comment>
	<block>{<block_content>
		<expr_stmt><expr><call><name>InitPostmasterChild</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Close the postmaster's sockets */</comment>
		<expr_stmt><expr><call><name>ClosePostmasterPorts</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Release postmaster's working memory context */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>PostmasterContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>PostmasterContext</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>AuxiliaryProcessMain</name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><name>av</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExitPostmaster</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* EXEC_BACKEND */</comment>

	<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* in parent, fork failed */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name>type</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>StartupProcess</name></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fork startup process: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>BgWriterProcess</name></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fork background writer process: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>CheckpointerProcess</name></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fork checkpointer process: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>WalWriterProcess</name></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fork WAL writer process: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>WalReceiverProcess</name></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fork WAL receiver process: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fork process: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<comment type="block">/*
		 * fork failure is fatal during startup, but there's no need to choke
		 * immediately if starting other child types fails.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>StartupProcess</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExitPostmaster</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * in parent, successful fork
	 */</comment>
	<return>return <expr><name>pid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * StartAutovacuumWorker
 *		Start an autovac worker process.
 *
 * This function is here because it enters the resulting PID into the
 * postmaster's private backends list.
 *
 * NB -- this code very roughly matches BackendStartup.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>StartAutovacuumWorker</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Backend</name>    <modifier>*</modifier></type><name>bn</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If not in condition to run a process, don't try, but handle it like a
	 * fork failure.  This does not normally happen, since the signal is only
	 * supposed to be sent by autovacuum launcher when it's OK to do it, but
	 * we have to check to avoid race-condition problems during DB state
	 * changes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>canAcceptConnections</name><argument_list>(<argument><expr><name>BACKEND_TYPE_AUTOVAC</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CAC_OK</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Compute the cancel key that will be assigned to this session. We
		 * probably don't need cancel keys for autovac workers, but we'd
		 * better have something random in the field to prevent unfriendly
		 * people from sending cancels to them.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RandomCancelKey</name><argument_list>(<argument><expr><operator>&amp;</operator><name>MyCancelKey</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not generate random cancel key"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>bn</name> <operator>=</operator> <operator>(</operator><name>Backend</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Backend</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>bn</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>bn</name><operator>-&gt;</operator><name>cancel_key</name></name> <operator>=</operator> <name>MyCancelKey</name></expr>;</expr_stmt>

			<comment type="block">/* Autovac workers are not dead_end and need a child slot */</comment>
			<expr_stmt><expr><name><name>bn</name><operator>-&gt;</operator><name>dead_end</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>bn</name><operator>-&gt;</operator><name>child_slot</name></name> <operator>=</operator> <name>MyPMChildSlot</name> <operator>=</operator> <call><name>AssignPostmasterChildSlot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>bn</name><operator>-&gt;</operator><name>bgworker_notify</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>bn</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <call><name>StartAutoVacWorker</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>bn</name><operator>-&gt;</operator><name>pid</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>bn</name><operator>-&gt;</operator><name>bkend_type</name></name> <operator>=</operator> <name>BACKEND_TYPE_AUTOVAC</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>dlist_push_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BackendList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bn</name><operator>-&gt;</operator><name>elem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
				<expr_stmt><expr><call><name>ShmemBackendArrayAdd</name><argument_list>(<argument><expr><name>bn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<comment type="block">/* all OK */</comment>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * fork failed, fall through to report -- actual error message was
			 * logged by StartAutoVacWorker
			 */</comment>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>ReleasePostmasterChildSlot</name><argument_list>(<argument><expr><name><name>bn</name><operator>-&gt;</operator><name>child_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>bn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Report the failure to the launcher, if it's running.  (If it's not, we
	 * might not even be connected to shared memory, so don't try to call
	 * AutoVacWorkerFailed.)  Note that we also need to signal it so that it
	 * responds to the condition, but we don't do that here, instead waiting
	 * for ServerLoop to do it.  This way we avoid a ping-pong signalling in
	 * quick succession between the autovac launcher and postmaster in case
	 * things get ugly.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>AutoVacPID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AutoVacWorkerFailed</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>avlauncher_needs_signal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * MaybeStartWalReceiver
 *		Start the WAL receiver process, if not running and our state allows.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MaybeStartWalReceiver</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>WalReceiverPID</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>pmState</name> <operator>==</operator> <name>PM_STARTUP</name> <operator>||</operator> <name>pmState</name> <operator>==</operator> <name>PM_RECOVERY</name> <operator>||</operator>
		 <name>pmState</name> <operator>==</operator> <name>PM_HOT_STANDBY</name> <operator>||</operator> <name>pmState</name> <operator>==</operator> <name>PM_WAIT_READONLY</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<name>Shutdown</name> <operator>==</operator> <name>NoShutdown</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>WalReceiverPID</name> <operator>=</operator> <call><name>StartWalReceiver</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>WalReceiverRequested</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Create the opts file
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CreateOptsFile</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fullprogname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPTS_FILE</name></cpp:macro>	<cpp:value>"postmaster.opts"</cpp:value></cpp:define>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fp</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>OPTS_FILE</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"could not create file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>OPTS_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>fullprogname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">" \"%s\""</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"could not write file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>OPTS_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MaxLivePostmasterChildren
 *
 * This reports the number of entries needed in per-child-process arrays
 * (the PMChildFlags array, and if EXEC_BACKEND the ShmemBackendArray).
 * These arrays include regular backends, autovac workers, walsenders
 * and background workers, but not special children nor dead_end children.
 * This allows the arrays to have a fixed maximum size, to wit the same
 * too-many-children limit enforced by canAcceptConnections().  The exact value
 * isn't too critical as long as it's more than MaxBackends.
 */</comment>
<function><type><name>int</name></type>
<name>MaxLivePostmasterChildren</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><literal type="number">2</literal> <operator>*</operator> <operator>(</operator><name>MaxConnections</name> <operator>+</operator> <name>autovacuum_max_workers</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator>
				<name>max_worker_processes</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Connect background worker to a database.
 */</comment>
<function><type><name>void</name></type>
<name>BackgroundWorkerInitializeConnection</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>username</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BackgroundWorker</name> <modifier>*</modifier></type><name>worker</name> <init>= <expr><name>MyBgworkerEntry</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* XXX is this the right errcode? */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>worker</name><operator>-&gt;</operator><name>bgw_flags</name></name> <operator>&amp;</operator> <name>BGWORKER_BACKEND_DATABASE_CONNECTION</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database connection requirement not indicated during registration"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>InitPostgres</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>username</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>BGWORKER_BYPASS_ALLOWCONN</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* it had better not gotten out of "init" mode yet */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsInitProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid processing mode in background worker"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>SetProcessingMode</name><argument_list>(<argument><expr><name>NormalProcessing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Connect background worker to a database using OIDs.
 */</comment>
<function><type><name>void</name></type>
<name>BackgroundWorkerInitializeConnectionByOid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>dboid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>useroid</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BackgroundWorker</name> <modifier>*</modifier></type><name>worker</name> <init>= <expr><name>MyBgworkerEntry</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* XXX is this the right errcode? */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>worker</name><operator>-&gt;</operator><name>bgw_flags</name></name> <operator>&amp;</operator> <name>BGWORKER_BACKEND_DATABASE_CONNECTION</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database connection requirement not indicated during registration"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>InitPostgres</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>dboid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>useroid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>BGWORKER_BYPASS_ALLOWCONN</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* it had better not gotten out of "init" mode yet */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsInitProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid processing mode in background worker"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>SetProcessingMode</name><argument_list>(<argument><expr><name>NormalProcessing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Block/unblock signals in a background worker
 */</comment>
<function><type><name>void</name></type>
<name>BackgroundWorkerBlockSignals</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>BackgroundWorkerUnblockSignals</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UnBlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>pid_t</name></type>
<name>bgworker_forkexec</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>shmem_slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>av</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ac</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>forkav</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>forkav</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"--forkbgworker=%d"</literal></expr></argument>, <argument><expr><name>shmem_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"postgres"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>forkav</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>			<comment type="block">/* filled in by postmaster_forkexec */</comment>
	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ac</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>av</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>postmaster_forkexec</name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><name>av</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Start a new bgworker.
 * Starting time conditions must have been checked already.
 *
 * Returns true on success, false on failure.
 * In either case, update the RegisteredBgWorker's state appropriately.
 *
 * This code is heavily based on autovacuum.c, q.v.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>do_start_bgworker</name><parameter_list>(<parameter><decl><type><name>RegisteredBgWorker</name> <modifier>*</modifier></type><name>rw</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pid_t</name></type>		<name>worker_pid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_pid</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate and assign the Backend element.  Note we must do this before
	 * forking, so that we can handle failures (out of memory or child-process
	 * slots) cleanly.
	 *
	 * Treat failure as though the worker had crashed.  That way, the
	 * postmaster will wait a bit before attempting to start it again; if we
	 * tried again right away, most likely we'd find ourselves hitting the
	 * same resource-exhaustion condition.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>assign_backendlist_entry</name><argument_list>(<argument><expr><name>rw</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_crashed_at</name></name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"starting background worker process \"%s\""</literal></expr></argument>,
					<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
	<switch>switch <condition>(<expr><operator>(</operator><name>worker_pid</name> <operator>=</operator> <call><name>bgworker_forkexec</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_shmem_slot</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<switch>switch <condition>(<expr><operator>(</operator><name>worker_pid</name> <operator>=</operator> <call><name>fork_process</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{<block_content>
		<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
			<comment type="block">/* in postmaster, fork failed ... */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fork worker process: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* undo what assign_backendlist_entry did */</comment>
			<expr_stmt><expr><call><name>ReleasePostmasterChildSlot</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_child_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_child_slot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_backend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_backend</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<comment type="block">/* mark entry as crashed, so we'll try again later */</comment>
			<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_crashed_at</name></name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifndef>
		<case>case <expr><literal type="number">0</literal></expr>:</case>
			<comment type="block">/* in postmaster child ... */</comment>
			<expr_stmt><expr><call><name>InitPostmasterChild</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Close the postmaster's sockets */</comment>
			<expr_stmt><expr><call><name>ClosePostmasterPorts</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Before blowing away PostmasterContext, save this bgworker's
			 * data where it can find it.
			 */</comment>
			<expr_stmt><expr><name>MyBgworkerEntry</name> <operator>=</operator> <operator>(</operator><name>BackgroundWorker</name> <operator>*</operator><operator>)</operator>
				<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BackgroundWorker</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>MyBgworkerEntry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BackgroundWorker</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Release postmaster's working memory context */</comment>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>PostmasterContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>PostmasterContext</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>StartBackgroundWorker</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>			<comment type="block">/* should not get here */</comment>
			<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<default>default:</default>
			<comment type="block">/* in postmaster, fork successful ... */</comment>
			<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_pid</name></name> <operator>=</operator> <name>worker_pid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_backend</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name><name>rw</name><operator>-&gt;</operator><name>rw_pid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReportBackgroundWorkerPID</name><argument_list>(<argument><expr><name>rw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* add new worker to lists of backends */</comment>
			<expr_stmt><expr><call><name>dlist_push_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BackendList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rw</name><operator>-&gt;</operator><name>rw_backend</name><operator>-&gt;</operator><name>elem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
			<expr_stmt><expr><call><name>ShmemBackendArrayAdd</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_backend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></switch></block_content></block></switch>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Does the current postmaster state require starting a worker with the
 * specified start_time?
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>bgworker_should_start_now</name><parameter_list>(<parameter><decl><type><name>BgWorkerStartTime</name></type> <name>start_time</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>pmState</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PM_NO_CHILDREN</name></expr>:</case>
		<case>case <expr><name>PM_WAIT_DEAD_END</name></expr>:</case>
		<case>case <expr><name>PM_SHUTDOWN_2</name></expr>:</case>
		<case>case <expr><name>PM_SHUTDOWN</name></expr>:</case>
		<case>case <expr><name>PM_WAIT_BACKENDS</name></expr>:</case>
		<case>case <expr><name>PM_WAIT_READONLY</name></expr>:</case>
		<case>case <expr><name>PM_WAIT_BACKUP</name></expr>:</case>
			<break>break;</break>

		<case>case <expr><name>PM_RUN</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>start_time</name> <operator>==</operator> <name>BgWorkerStart_RecoveryFinished</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<case>case <expr><name>PM_HOT_STANDBY</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>start_time</name> <operator>==</operator> <name>BgWorkerStart_ConsistentState</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<case>case <expr><name>PM_RECOVERY</name></expr>:</case>
		<case>case <expr><name>PM_STARTUP</name></expr>:</case>
		<case>case <expr><name>PM_INIT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>start_time</name> <operator>==</operator> <name>BgWorkerStart_PostmasterStart</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* fall through */</comment>

	</block_content>}</block></switch>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Allocate the Backend struct for a connected background worker, but don't
 * add it to the list of backends just yet.
 *
 * On failure, return false without changing any worker state.
 *
 * Some info from the Backend is copied into the passed rw.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>assign_backendlist_entry</name><parameter_list>(<parameter><decl><type><name>RegisteredBgWorker</name> <modifier>*</modifier></type><name>rw</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Backend</name>    <modifier>*</modifier></type><name>bn</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check that database state allows another connection.  Currently the
	 * only possible failure is CAC_TOOMANY, so we just log an error message
	 * based on that rather than checking the error code precisely.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>canAcceptConnections</name><argument_list>(<argument><expr><name>BACKEND_TYPE_BGWORKER</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CAC_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIGURATION_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no slot available for new worker process"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Compute the cancel key that will be assigned to this session. We
	 * probably don't need cancel keys for background workers, but we'd better
	 * have something random in the field to prevent unfriendly people from
	 * sending cancels to them.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RandomCancelKey</name><argument_list>(<argument><expr><operator>&amp;</operator><name>MyCancelKey</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not generate random cancel key"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>bn</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Backend</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>bn</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>bn</name><operator>-&gt;</operator><name>cancel_key</name></name> <operator>=</operator> <name>MyCancelKey</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bn</name><operator>-&gt;</operator><name>child_slot</name></name> <operator>=</operator> <name>MyPMChildSlot</name> <operator>=</operator> <call><name>AssignPostmasterChildSlot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bn</name><operator>-&gt;</operator><name>bkend_type</name></name> <operator>=</operator> <name>BACKEND_TYPE_BGWORKER</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bn</name><operator>-&gt;</operator><name>dead_end</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bn</name><operator>-&gt;</operator><name>bgworker_notify</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_backend</name></name> <operator>=</operator> <name>bn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_child_slot</name></name> <operator>=</operator> <name><name>bn</name><operator>-&gt;</operator><name>child_slot</name></name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * If the time is right, start background worker(s).
 *
 * As a side effect, the bgworker control variables are set or reset
 * depending on whether more workers may need to be started.
 *
 * We limit the number of workers started per call, to avoid consuming the
 * postmaster's attention for too long when many such requests are pending.
 * As long as StartWorkerNeeded is true, ServerLoop will not block and will
 * call this function again after dealing with any other issues.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>maybe_start_bgworkers</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_BGWORKERS_TO_LAUNCH</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_launched</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>now</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>slist_mutable_iter</name></type> <name>iter</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * During crash recovery, we have no need to be called until the state
	 * transition out of recovery.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>FatalError</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>StartWorkerNeeded</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>HaveCrashedWorker</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Don't need to be called again unless we find a reason for it below */</comment>
	<expr_stmt><expr><name>StartWorkerNeeded</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>HaveCrashedWorker</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<macro><name>slist_foreach_modify</name><argument_list>(<argument>iter</argument>, <argument>&amp;BackgroundWorkerList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RegisteredBgWorker</name> <modifier>*</modifier></type><name>rw</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rw</name> <operator>=</operator> <call><name>slist_container</name><argument_list>(<argument><expr><name>RegisteredBgWorker</name></expr></argument>, <argument><expr><name>rw_lnode</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* ignore if already running */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rw</name><operator>-&gt;</operator><name>rw_pid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* if marked for death, clean up and remove from list */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rw</name><operator>-&gt;</operator><name>rw_terminate</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ForgetBackgroundWorker</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If this worker has crashed previously, maybe it needs to be
		 * restarted (unless on registration it specified it doesn't want to
		 * be restarted at all).  Check how long ago did a crash last happen.
		 * If the last crash is too recent, don't start it right away; let it
		 * be restarted once enough time has passed.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rw</name><operator>-&gt;</operator><name>rw_crashed_at</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_restart_time</name></name> <operator>==</operator> <name>BGW_NEVER_RESTART</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>notify_pid</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>notify_pid</name> <operator>=</operator> <name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_notify_pid</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ForgetBackgroundWorker</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Report worker is gone now. */</comment>
				<if_stmt><if>if <condition>(<expr><name>notify_pid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name>notify_pid</name></expr></argument>, <argument><expr><name>SIGUSR1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* read system time only when needed */</comment>
			<if_stmt><if>if <condition>(<expr><name>now</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_crashed_at</name></name></expr></argument>, <argument><expr><name>now</name></expr></argument>,
											<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_restart_time</name></name> <operator>*</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Set flag to remember that we have workers to start later */</comment>
				<expr_stmt><expr><name>HaveCrashedWorker</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>bgworker_should_start_now</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_start_time</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* reset crash time before trying to start worker */</comment>
			<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_crashed_at</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<comment type="block">/*
			 * Try to start the worker.
			 *
			 * On failure, give up processing workers for now, but set
			 * StartWorkerNeeded so we'll come back here on the next iteration
			 * of ServerLoop to try again.  (We don't want to wait, because
			 * there might be additional ready-to-run workers.)  We could set
			 * HaveCrashedWorker as well, since this worker is now marked
			 * crashed, but there's no need because the next run of this
			 * function will do that.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>do_start_bgworker</name><argument_list>(<argument><expr><name>rw</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>StartWorkerNeeded</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * If we've launched as many workers as allowed, quit, but have
			 * ServerLoop call us again to look for additional ready-to-run
			 * workers.  There might not be any, but we'll find out the next
			 * time we run.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>++</operator><name>num_launched</name> <operator>&gt;=</operator> <name>MAX_BGWORKERS_TO_LAUNCH</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>StartWorkerNeeded</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * When a backend asks to be notified about worker state changes, we
 * set a flag in its backend entry.  The background worker machinery needs
 * to know when such backends exit.
 */</comment>
<function><type><name>bool</name></type>
<name>PostmasterMarkPIDForWorkerNotify</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_iter</name></type>	<name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Backend</name>    <modifier>*</modifier></type><name>bp</name></decl>;</decl_stmt>

	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;BackendList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>bp</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>Backend</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>bp</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <name>pid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>bp</name><operator>-&gt;</operator><name>bgworker_notify</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>

<comment type="block">/*
 * The following need to be available to the save/restore_backend_variables
 * functions.  They are marked NON_EXEC_STATIC in their home modules.
 */</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <name>slock_t</name> <modifier>*</modifier></type><name>ShmemLock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>slock_t</name> <modifier>*</modifier></type><name>ProcStructLock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>PGPROC</name> <modifier>*</modifier></type><name>AuxiliaryProcs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>PMSignalData</name> <modifier>*</modifier></type><name>PMSignalState</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>pgsocket</name></type> <name>pgStatSock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>pg_time_t</name></type> <name>first_syslogger_file_time</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>write_inheritable_socket</name><parameter_list>(<parameter><type><name>dest</name></type></parameter>, <parameter><type><name>src</name></type></parameter>, <parameter><type><name>childpid</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((*(dest) = (src)), true)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>read_inheritable_socket</name><parameter_list>(<parameter><type><name>dest</name></type></parameter>, <parameter><type><name>src</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(*(dest) = *(src))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>write_duplicated_handle</name><argument_list>(<argument><expr><name>HANDLE</name> <operator>*</operator><name>dest</name></expr></argument>, <argument><expr><name>HANDLE</name> <name>src</name></expr></argument>, <argument><expr><name>HANDLE</name> <name>child</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>write_inheritable_socket</name><argument_list>(<argument><expr><name>InheritableSocket</name> <operator>*</operator><name>dest</name></expr></argument>, <argument><expr><name>SOCKET</name> <name>src</name></expr></argument>,
						 <argument><expr><name>pid_t</name> <name>childPid</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>read_inheritable_socket</name><argument_list>(<argument><expr><name>SOCKET</name> <operator>*</operator><name>dest</name></expr></argument>, <argument><expr><name>InheritableSocket</name> <operator>*</operator><name>src</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* Save critical backend variables into the BackendParameters struct */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type>
<name>save_backend_variables</name><argument_list>(<argument><expr><name>BackendParameters</name> <operator>*</operator><name>param</name></expr></argument>, <argument><expr><name>Port</name> <operator>*</operator><name>port</name></expr></argument>)</argument_list>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
static <name>bool</name>
<name>save_backend_variables</name><argument_list>(<argument><expr><name>BackendParameters</name> <operator>*</operator><name>param</name></expr></argument>, <argument><expr><name>Port</name> <operator>*</operator><name>port</name></expr></argument>,
					   <argument><expr><name>HANDLE</name> <name>childProcess</name></expr></argument>, <argument><expr><name>pid_t</name> <name>childPid</name></expr></argument>)</argument_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>param</name><operator>-&gt;</operator><name>port</name></name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Port</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>write_inheritable_socket</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>param</name><operator>-&gt;</operator><name>portsocket</name></name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>childPid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>DataDir</name></name></expr></argument>, <argument><expr><name>DataDir</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>param</name><operator>-&gt;</operator><name>ListenSocket</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ListenSocket</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ListenSocket</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>MyCancelKey</name></name> <operator>=</operator> <name>MyCancelKey</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>MyPMChildSlot</name></name> <operator>=</operator> <name>MyPMChildSlot</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>UsedShmemSegID</name></name> <operator>=</operator> <name>UsedShmemSegID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>UsedShmemSegAddr</name></name> <operator>=</operator> <name>UsedShmemSegAddr</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>ShmemLock</name></name> <operator>=</operator> <name>ShmemLock</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>ShmemVariableCache</name></name> <operator>=</operator> <name>ShmemVariableCache</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>ShmemBackendArray</name></name> <operator>=</operator> <name>ShmemBackendArray</name></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_SPINLOCKS</name></cpp:ifndef>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>SpinlockSemaArray</name></name> <operator>=</operator> <name>SpinlockSemaArray</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>NamedLWLockTrancheRequests</name></name> <operator>=</operator> <name>NamedLWLockTrancheRequests</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>NamedLWLockTrancheArray</name></name> <operator>=</operator> <name>NamedLWLockTrancheArray</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>MainLWLockArray</name></name> <operator>=</operator> <name>MainLWLockArray</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>ProcStructLock</name></name> <operator>=</operator> <name>ProcStructLock</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>ProcGlobal</name></name> <operator>=</operator> <name>ProcGlobal</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>AuxiliaryProcs</name></name> <operator>=</operator> <name>AuxiliaryProcs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>PreparedXactProcs</name></name> <operator>=</operator> <name>PreparedXactProcs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>PMSignalState</name></name> <operator>=</operator> <name>PMSignalState</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>write_inheritable_socket</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>param</name><operator>-&gt;</operator><name>pgStatSock</name></name></expr></argument>, <argument><expr><name>pgStatSock</name></expr></argument>, <argument><expr><name>childPid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>PostmasterPid</name></name> <operator>=</operator> <name>PostmasterPid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>PgStartTime</name></name> <operator>=</operator> <name>PgStartTime</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>PgReloadTime</name></name> <operator>=</operator> <name>PgReloadTime</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>first_syslogger_file_time</name></name> <operator>=</operator> <name>first_syslogger_file_time</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>redirection_done</name></name> <operator>=</operator> <name>redirection_done</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>IsBinaryUpgrade</name></name> <operator>=</operator> <name>IsBinaryUpgrade</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>max_safe_fds</name></name> <operator>=</operator> <name>max_safe_fds</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>MaxBackends</name></name> <operator>=</operator> <name>MaxBackends</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>PostmasterHandle</name></name> <operator>=</operator> <name>PostmasterHandle</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>write_duplicated_handle</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>param</name><operator>-&gt;</operator><name>initial_signal_pipe</name></name></expr></argument>,
								 <argument><expr><call><name>pgwin32_create_signal_listener</name><argument_list>(<argument><expr><name>childPid</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>childProcess</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>param</name><operator>-&gt;</operator><name>postmaster_alive_fds</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>postmaster_alive_fds</name></expr></argument>,
		   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>postmaster_alive_fds</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>param</name><operator>-&gt;</operator><name>syslogPipe</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>syslogPipe</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>syslogPipe</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>my_exec_path</name></name></expr></argument>, <argument><expr><name>my_exec_path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>pkglib_path</name></name></expr></argument>, <argument><expr><name>pkglib_path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>ExtraOptions</name></name></expr></argument>, <argument><expr><name>ExtraOptions</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<comment type="block">/*
 * Duplicate a handle for usage in a child process, and write the child
 * process instance of the handle to the parameter file.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>write_duplicated_handle</name><parameter_list>(<parameter><decl><type><name>HANDLE</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>HANDLE</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>HANDLE</name></type> <name>childProcess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HANDLE</name></type>		<name>hChild</name> <init>= <expr><name>INVALID_HANDLE_VALUE</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DuplicateHandle</name><argument_list>(<argument><expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></argument>,
						 <argument><expr><name>src</name></expr></argument>,
						 <argument><expr><name>childProcess</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>hChild</name></expr></argument>,
						 <argument><expr><literal type="number">0</literal></expr></argument>,
						 <argument><expr><name>TRUE</name></expr></argument>,
						 <argument><expr><name>DUPLICATE_CLOSE_SOURCE</name> <operator>|</operator> <name>DUPLICATE_SAME_ACCESS</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"could not duplicate handle to be written to backend parameter file: error code %lu"</literal></expr></argument>,
								 <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>dest</name> <operator>=</operator> <name>hChild</name></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Duplicate a socket for usage in a child process, and write the resulting
 * structure to the parameter file.
 * This is required because a number of LSPs (Layered Service Providers) very
 * common on Windows (antivirus, firewalls, download managers etc) break
 * straight socket inheritance.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>write_inheritable_socket</name><parameter_list>(<parameter><decl><type><name>InheritableSocket</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>SOCKET</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>pid_t</name></type> <name>childpid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>origsocket</name></name> <operator>=</operator> <name>src</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>src</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>src</name> <operator>!=</operator> <name>PGINVALID_SOCKET</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Actual socket */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>WSADuplicateSocket</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>childpid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dest</name><operator>-&gt;</operator><name>wsainfo</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not duplicate socket %d for use in backend: error code %d"</literal></expr></argument>,
							<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>src</name></expr></argument>, <argument><expr><call><name>WSAGetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Read a duplicate socket structure back, and get the socket descriptor.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>read_inheritable_socket</name><parameter_list>(<parameter><decl><type><name>SOCKET</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>InheritableSocket</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SOCKET</name></type>		<name>s</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>origsocket</name></name> <operator>==</operator> <name>PGINVALID_SOCKET</name> <operator>||</operator> <name><name>src</name><operator>-&gt;</operator><name>origsocket</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Not a real socket! */</comment>
		<expr_stmt><expr><operator>*</operator><name>dest</name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>origsocket</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Actual socket, so create from structure */</comment>
		<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>WSASocket</name><argument_list>(<argument><expr><name>FROM_PROTOCOL_INFO</name></expr></argument>,
					  <argument><expr><name>FROM_PROTOCOL_INFO</name></expr></argument>,
					  <argument><expr><name>FROM_PROTOCOL_INFO</name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name><name>src</name><operator>-&gt;</operator><name>wsainfo</name></name></expr></argument>,
					  <argument><expr><literal type="number">0</literal></expr></argument>,
					  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>INVALID_SOCKET</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"could not create inherited socket: error code %d\n"</literal></expr></argument>,
						 <argument><expr><call><name>WSAGetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>dest</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * To make sure we don't get two references to the same socket, close
		 * the original one. (This would happen when inheritance actually
		 * works..
		 */</comment>
		<expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>origsocket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>read_backend_variables</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BackendParameters</name></type> <name>param</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<comment type="block">/* Non-win32 implementation reads from file */</comment>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>

	<comment type="block">/* Open file */</comment>
	<expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>PG_BINARY_R</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fp</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"could not open backend variables file \"%s\": %s\n"</literal></expr></argument>,
					 <argument><expr><name>id</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>param</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"could not read from backend variables file \"%s\": %s\n"</literal></expr></argument>,
					 <argument><expr><name>id</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Release file */</comment>
	<expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"could not remove file \"%s\": %s\n"</literal></expr></argument>,
					 <argument><expr><name>id</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<comment type="block">/* Win32 version uses mapped file */</comment>
	<decl_stmt><decl><type><name>HANDLE</name></type>		<name>paramHandle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackendParameters</name> <modifier>*</modifier></type><name>paramp</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN64</name></cpp:ifdef>
	<expr_stmt><expr><name>paramHandle</name> <operator>=</operator> <operator>(</operator><name>HANDLE</name><operator>)</operator> <call><name>_atoi64</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>paramHandle</name> <operator>=</operator> <operator>(</operator><name>HANDLE</name><operator>)</operator> <call><name>atol</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>paramp</name> <operator>=</operator> <call><name>MapViewOfFile</name><argument_list>(<argument><expr><name>paramHandle</name></expr></argument>, <argument><expr><name>FILE_MAP_READ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>paramp</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"could not map view of backend variables: error code %lu\n"</literal></expr></argument>,
					 <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>param</name></expr></argument>, <argument><expr><name>paramp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BackendParameters</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UnmapViewOfFile</name><argument_list>(<argument><expr><name>paramp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"could not unmap view of backend variables: error code %lu\n"</literal></expr></argument>,
					 <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CloseHandle</name><argument_list>(<argument><expr><name>paramHandle</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"could not close handle to backend parameter variables: error code %lu\n"</literal></expr></argument>,
					 <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>restore_backend_variables</name><argument_list>(<argument><expr><operator>&amp;</operator><name>param</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Restore critical backend variables from the BackendParameters struct */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>restore_backend_variables</name><parameter_list>(<parameter><decl><type><name>BackendParameters</name> <modifier>*</modifier></type><name>param</name></decl></parameter>, <parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>param</name><operator>-&gt;</operator><name>port</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Port</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>read_inheritable_socket</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>port</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>param</name><operator>-&gt;</operator><name>portsocket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SetDataDir</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>DataDir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ListenSocket</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>param</name><operator>-&gt;</operator><name>ListenSocket</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ListenSocket</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>MyCancelKey</name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>MyCancelKey</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>MyPMChildSlot</name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>MyPMChildSlot</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>UsedShmemSegID</name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>UsedShmemSegID</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>UsedShmemSegAddr</name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>UsedShmemSegAddr</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>ShmemLock</name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>ShmemLock</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ShmemVariableCache</name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>ShmemVariableCache</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ShmemBackendArray</name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>ShmemBackendArray</name></name></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_SPINLOCKS</name></cpp:ifndef>
	<expr_stmt><expr><name>SpinlockSemaArray</name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>SpinlockSemaArray</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>NamedLWLockTrancheRequests</name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>NamedLWLockTrancheRequests</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>NamedLWLockTrancheArray</name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>NamedLWLockTrancheArray</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>MainLWLockArray</name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>MainLWLockArray</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ProcStructLock</name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>ProcStructLock</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ProcGlobal</name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>ProcGlobal</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>AuxiliaryProcs</name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>AuxiliaryProcs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>PreparedXactProcs</name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>PreparedXactProcs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>PMSignalState</name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>PMSignalState</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>read_inheritable_socket</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pgStatSock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>param</name><operator>-&gt;</operator><name>pgStatSock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>PostmasterPid</name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>PostmasterPid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>PgStartTime</name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>PgStartTime</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>PgReloadTime</name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>PgReloadTime</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>first_syslogger_file_time</name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>first_syslogger_file_time</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>redirection_done</name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>redirection_done</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>IsBinaryUpgrade</name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>IsBinaryUpgrade</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>max_safe_fds</name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>max_safe_fds</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>MaxBackends</name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>MaxBackends</name></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<expr_stmt><expr><name>PostmasterHandle</name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>PostmasterHandle</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pgwin32_initial_signal_pipe</name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>initial_signal_pipe</name></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>postmaster_alive_fds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>param</name><operator>-&gt;</operator><name>postmaster_alive_fds</name></name></expr></argument>,
		   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>postmaster_alive_fds</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>syslogPipe</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>param</name><operator>-&gt;</operator><name>syslogPipe</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>syslogPipe</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>my_exec_path</name></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>my_exec_path</name></name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>pkglib_path</name></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>pkglib_path</name></name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>ExtraOptions</name></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>ExtraOptions</name></name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Size</name></type>
<name>ShmemBackendArraySize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>mul_size</name><argument_list>(<argument><expr><call><name>MaxLivePostmasterChildren</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Backend</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ShmemBackendArrayAllocation</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name> <init>= <expr><call><name>ShmemBackendArraySize</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>ShmemBackendArray</name> <operator>=</operator> <operator>(</operator><name>Backend</name> <operator>*</operator><operator>)</operator> <call><name>ShmemAlloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Mark all slots as empty */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ShmemBackendArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ShmemBackendArrayAdd</name><parameter_list>(<parameter><decl><type><name>Backend</name> <modifier>*</modifier></type><name>bn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* The array slot corresponding to my PMChildSlot should be free */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><name><name>bn</name><operator>-&gt;</operator><name>child_slot</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ShmemBackendArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pid</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ShmemBackendArray</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>bn</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ShmemBackendArrayRemove</name><parameter_list>(<parameter><decl><type><name>Backend</name> <modifier>*</modifier></type><name>bn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><name><name>bn</name><operator>-&gt;</operator><name>child_slot</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ShmemBackendArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pid</name> <operator>==</operator> <name><name>bn</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Mark the slot as empty */</comment>
	<expr_stmt><expr><name><name>ShmemBackendArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* EXEC_BACKEND */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>

<comment type="block">/*
 * Subset implementation of waitpid() for Windows.  We assume pid is -1
 * (that is, check all child processes) and options is WNOHANG (don't wait).
 */</comment>
<function><type><specifier>static</specifier> <name>pid_t</name></type>
<name>waitpid</name><parameter_list>(<parameter><decl><type><name>pid_t</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>exitstatus</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DWORD</name></type>		<name>dwd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ULONG_PTR</name></type>	<name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OVERLAPPED</name> <modifier>*</modifier></type><name>ovl</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check if there are any dead children. If there are, return the pid of
	 * the first one that died.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>GetQueuedCompletionStatus</name><argument_list>(<argument><expr><name>win32ChildQueue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dwd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ovl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>exitstatus</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>key</name></expr>;</expr_stmt>
		<return>return <expr><name>dwd</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Note! Code below executes on a thread pool! All operations must
 * be thread safe! Note that elog() and friends must *not* be used.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name> <name>WINAPI</name></type>
<name>pgwin32_deadchild_callback</name><parameter_list>(<parameter><decl><type><name>PVOID</name></type> <name>lpParameter</name></decl></parameter>, <parameter><decl><type><name>BOOLEAN</name></type> <name>TimerOrWaitFired</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>win32_deadchild_waitinfo</name> <modifier>*</modifier></type><name>childinfo</name> <init>= <expr><operator>(</operator><name>win32_deadchild_waitinfo</name> <operator>*</operator><operator>)</operator> <name>lpParameter</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DWORD</name></type>		<name>exitcode</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>TimerOrWaitFired</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* timeout. Should never happen, since we use
								 * INFINITE as timeout value. */</comment>

	<comment type="block">/*
	 * Remove handle from wait - required even though it's set to wait only
	 * once
	 */</comment>
	<expr_stmt><expr><call><name>UnregisterWaitEx</name><argument_list>(<argument><expr><name><name>childinfo</name><operator>-&gt;</operator><name>waitHandle</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GetExitCodeProcess</name><argument_list>(<argument><expr><name><name>childinfo</name><operator>-&gt;</operator><name>procHandle</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exitcode</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Should never happen. Inform user and set a fixed exitcode.
		 */</comment>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"could not read exit code for process\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>exitcode</name> <operator>=</operator> <literal type="number">255</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PostQueuedCompletionStatus</name><argument_list>(<argument><expr><name>win32ChildQueue</name></expr></argument>, <argument><expr><name><name>childinfo</name><operator>-&gt;</operator><name>procId</name></name></expr></argument>, <argument><expr><operator>(</operator><name>ULONG_PTR</name><operator>)</operator> <name>exitcode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"could not post child completion status\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Handle is per-process, so we close it here instead of in the
	 * originating thread
	 */</comment>
	<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>childinfo</name><operator>-&gt;</operator><name>procHandle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Free struct that was allocated before the call to
	 * RegisterWaitForSingleObject()
	 */</comment>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>childinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Queue SIGCHLD signal */</comment>
	<expr_stmt><expr><call><name>pg_queue_signal</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>

<comment type="block">/*
 * Initialize one and only handle for monitoring postmaster death.
 *
 * Called once in the postmaster, so that child processes can subsequently
 * monitor if their parent is dead.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitPostmasterDeathWatchHandle</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>

	<comment type="block">/*
	 * Create a pipe. Postmaster holds the write end of the pipe open
	 * (POSTMASTER_FD_OWN), and children hold the read end. Children can pass
	 * the read file descriptor to select() to wake up in case postmaster
	 * dies, or check for postmaster death with a (read() == 0). Children must
	 * close the write end as soon as possible after forking, because EOF
	 * won't be signaled in the read end until all processes have closed the
	 * write fd. That is taken care of in ClosePostmasterPorts().
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MyProcPid</name> <operator>==</operator> <name>PostmasterPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pipe</name><argument_list>(<argument><expr><name>postmaster_alive_fds</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"could not create pipe to monitor postmaster death: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Set O_NONBLOCK to allow testing for the fd's presence with a read()
	 * call.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>fcntl</name><argument_list>(<argument><expr><name><name>postmaster_alive_fds</name><index>[<expr><name>POSTMASTER_FD_WATCH</name></expr>]</index></name></expr></argument>, <argument><expr><name>F_SETFL</name></expr></argument>, <argument><expr><name>O_NONBLOCK</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_socket_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"could not set postmaster death monitoring pipe to nonblocking mode: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

	<comment type="block">/*
	 * On Windows, we use a process handle for the same purpose.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>DuplicateHandle</name><argument_list>(<argument><expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></argument>,
						<argument><expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></argument>,
						<argument><expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>PostmasterHandle</name></expr></argument>,
						<argument><expr><literal type="number">0</literal></expr></argument>,
						<argument><expr><name>TRUE</name></expr></argument>,
						<argument><expr><name>DUPLICATE_SAME_ACCESS</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"could not duplicate postmaster handle: error code %lu"</literal></expr></argument>,
								 <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>
</block_content>}</block></function></block_content></block></function>
</unit>
