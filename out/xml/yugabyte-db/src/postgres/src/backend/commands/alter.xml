<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/commands/alter.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * alter.c
 *	  Drivers for generic alter commands
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/commands/alter.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaccess.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_conversion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_event_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_foreign_data_wrapper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_foreign_server.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_language.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_largeobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_largeobject_metadata.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opclass.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opfamily.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_subscription.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_statistic_ext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_ts_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_ts_dict.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_ts_parser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_ts_template.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/alter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/collationcmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/conversioncmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/event_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/policy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/proclang.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/publicationcmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/schemacmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/subscriptioncmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablegroup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/typecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/user.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteDefine.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>AlterObjectNamespace_internal</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>nspOid</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Raise an error to the effect that an object of the given name is already
 * present in the given namespace.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>report_name_conflict</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>classId</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>msgfmt</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>classId</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>EventTriggerRelationId</name></expr>:</case>
			<expr_stmt><expr><name>msgfmt</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"event trigger \"%s\" already exists"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ForeignDataWrapperRelationId</name></expr>:</case>
			<expr_stmt><expr><name>msgfmt</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"foreign-data wrapper \"%s\" already exists"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ForeignServerRelationId</name></expr>:</case>
			<expr_stmt><expr><name>msgfmt</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"server \"%s\" already exists"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>LanguageRelationId</name></expr>:</case>
			<expr_stmt><expr><name>msgfmt</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"language \"%s\" already exists"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PublicationRelationId</name></expr>:</case>
			<expr_stmt><expr><name>msgfmt</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"publication \"%s\" already exists"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SubscriptionRelationId</name></expr>:</case>
			<expr_stmt><expr><name>msgfmt</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"subscription \"%s\" already exists"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported object class %u"</literal></expr></argument>, <argument><expr><name>classId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><name>msgfmt</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>report_namespace_conflict</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>classId</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>nspOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>msgfmt</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>nspOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>classId</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>ConversionRelationId</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>nspOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>msgfmt</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"conversion \"%s\" already exists in schema \"%s\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>StatisticExtRelationId</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>nspOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>msgfmt</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"statistics object \"%s\" already exists in schema \"%s\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>TSParserRelationId</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>nspOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>msgfmt</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"text search parser \"%s\" already exists in schema \"%s\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>TSDictionaryRelationId</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>nspOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>msgfmt</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"text search dictionary \"%s\" already exists in schema \"%s\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>TSTemplateRelationId</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>nspOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>msgfmt</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"text search template \"%s\" already exists in schema \"%s\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>TSConfigRelationId</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>nspOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>msgfmt</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"text search configuration \"%s\" already exists in schema \"%s\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported object class %u"</literal></expr></argument>, <argument><expr><name>classId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><name>msgfmt</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>nspOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AlterObjectRename_internal
 *
 * Generic function to rename the given object, for simple cases (won't
 * work for tables, nor other cases where we need to do more than change
 * the name column of a single catalog entry).
 *
 * rel: catalog relation containing object (RowExclusiveLock'd by caller)
 * objectId: OID of object to be renamed
 * new_name: CString representation of new name
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AlterObjectRename_internal</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objectId</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>new_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>classId</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>oidCacheId</name> <init>= <expr><call><name>get_object_catcache_oid</name><argument_list>(<argument><expr><name>classId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nameCacheId</name> <init>= <expr><call><name>get_object_catcache_name</name><argument_list>(<argument><expr><name>classId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>Anum_name</name> <init>= <expr><call><name>get_object_attnum_name</name><argument_list>(<argument><expr><name>classId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>Anum_namespace</name> <init>= <expr><call><name>get_object_attnum_namespace</name><argument_list>(<argument><expr><name>classId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>Anum_owner</name> <init>= <expr><call><name>get_object_attnum_owner</name><argument_list>(<argument><expr><name>classId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectType</name></type>	<name>objtype</name> <init>= <expr><call><name>get_object_type</name><argument_list>(<argument><expr><name>classId</name></expr></argument>, <argument><expr><name>objectId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>oldtup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>old_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>replaces</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NameData</name></type>	<name>nameattrdata</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldtup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>oidCacheId</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objectId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for object %u of catalog \"%s\""</literal></expr></argument>,
			 <argument><expr><name>objectId</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>, <argument><expr><name>Anum_name</name></expr></argument>,
						 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>old_name</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><call><name>DatumGetName</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get OID of namespace */</comment>
	<if_stmt><if>if <condition>(<expr><name>Anum_namespace</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>, <argument><expr><name>Anum_namespace</name></expr></argument>,
							 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Permission checks ... superusers can always do it */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Fail if object does not have an explicit owner */</comment>
		<if_stmt><if>if <condition>(<expr><name>Anum_owner</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser to rename %s"</literal></expr></argument>,
							 <argument><expr><call><name>getObjectDescriptionOids</name><argument_list>(<argument><expr><name>classId</name></expr></argument>, <argument><expr><name>objectId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Otherwise, must be owner of the existing object */</comment>
		<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>, <argument><expr><name>Anum_owner</name></expr></argument>,
							 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>has_privs_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>objtype</name></expr></argument>, <argument><expr><name>old_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* User must have CREATE privilege on the namespace */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_namespace_aclcheck</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
											  <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_SCHEMA</name></expr></argument>,
							   <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check for duplicate name (more friendly than unique-index failure).
	 * Since this is just a friendliness check, we can just skip it in cases
	 * where there isn't suitable support.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>classId</name> <operator>==</operator> <name>ProcedureRelationId</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>proc</name> <init>= <expr><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>IsThereFunctionInNamespace</name><argument_list>(<argument><expr><name>new_name</name></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>pronargs</name></name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>proargtypes</name></name></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>pronamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>classId</name> <operator>==</operator> <name>CollationRelationId</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_collation</name></type> <name>coll</name> <init>= <expr><operator>(</operator><name>Form_pg_collation</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>IsThereCollationInNamespace</name><argument_list>(<argument><expr><name>new_name</name></expr></argument>, <argument><expr><name><name>coll</name><operator>-&gt;</operator><name>collnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>classId</name> <operator>==</operator> <name>OperatorClassRelationId</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_opclass</name></type> <name>opc</name> <init>= <expr><operator>(</operator><name>Form_pg_opclass</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>IsThereOpClassInNamespace</name><argument_list>(<argument><expr><name>new_name</name></expr></argument>, <argument><expr><name><name>opc</name><operator>-&gt;</operator><name>opcmethod</name></name></expr></argument>,
								  <argument><expr><name><name>opc</name><operator>-&gt;</operator><name>opcnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>classId</name> <operator>==</operator> <name>OperatorFamilyRelationId</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_opfamily</name></type> <name>opf</name> <init>= <expr><operator>(</operator><name>Form_pg_opfamily</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>IsThereOpFamilyInNamespace</name><argument_list>(<argument><expr><name>new_name</name></expr></argument>, <argument><expr><name><name>opf</name><operator>-&gt;</operator><name>opfmethod</name></name></expr></argument>,
								   <argument><expr><name><name>opf</name><operator>-&gt;</operator><name>opfnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>classId</name> <operator>==</operator> <name>SubscriptionRelationId</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>SearchSysCacheExists2</name><argument_list>(<argument><expr><name>SUBSCRIPTIONNAME</name></expr></argument>, <argument><expr><name>MyDatabaseId</name></expr></argument>,
								  <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>new_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>report_name_conflict</name><argument_list>(<argument><expr><name>classId</name></expr></argument>, <argument><expr><name>new_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>nameCacheId</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>SearchSysCacheExists2</name><argument_list>(<argument><expr><name>nameCacheId</name></expr></argument>,
									  <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>new_name</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>report_namespace_conflict</name><argument_list>(<argument><expr><name>classId</name></expr></argument>, <argument><expr><name>new_name</name></expr></argument>, <argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>nameCacheId</name></expr></argument>,
									  <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>new_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>report_name_conflict</name><argument_list>(<argument><expr><name>classId</name></expr></argument>, <argument><expr><name>new_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Build modified tuple */</comment>
	<expr_stmt><expr><name>values</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nulls</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>replaces</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nameattrdata</name></expr></argument>, <argument><expr><name>new_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_name</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nameattrdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_name</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>newtup</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>replaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Perform actual update */</comment>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oldtup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>classId</name></expr></argument>, <argument><expr><name>objectId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Release memory */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>replaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Executes an ALTER OBJECT / RENAME TO statement.  Based on the object
 * type, the function appropriate to that type is executed.
 *
 * Return value is the address of the renamed object.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>ExecRenameStmt</name><parameter_list>(<parameter><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OBJECT_TABCONSTRAINT</name></expr>:</case>
		<case>case <expr><name>OBJECT_DOMCONSTRAINT</name></expr>:</case>
			<return>return <expr><call><name>RenameConstraint</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>OBJECT_DATABASE</name></expr>:</case>
			<return>return <expr><call><name>RenameDatabase</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>OBJECT_ROLE</name></expr>:</case>
			<return>return <expr><call><name>RenameRole</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>OBJECT_SCHEMA</name></expr>:</case>
			<return>return <expr><call><name>RenameSchema</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>OBJECT_YBTABLEGROUP</name></expr>:</case>
			<return>return <expr><call><name>RenameTablegroup</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>OBJECT_TABLESPACE</name></expr>:</case>
			<return>return <expr><call><name>RenameTableSpace</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
		<case>case <expr><name>OBJECT_SEQUENCE</name></expr>:</case>
		<case>case <expr><name>OBJECT_VIEW</name></expr>:</case>
		<case>case <expr><name>OBJECT_MATVIEW</name></expr>:</case>
		<case>case <expr><name>OBJECT_INDEX</name></expr>:</case>
		<case>case <expr><name>OBJECT_FOREIGN_TABLE</name></expr>:</case>
			<return>return <expr><call><name>RenameRelation</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>OBJECT_COLUMN</name></expr>:</case>
		<case>case <expr><name>OBJECT_ATTRIBUTE</name></expr>:</case>
			<return>return <expr><call><name>renameatt</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>OBJECT_RULE</name></expr>:</case>
			<return>return <expr><call><name>RenameRewriteRule</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>,
									 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>OBJECT_TRIGGER</name></expr>:</case>
			<return>return <expr><call><name>renametrig</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>OBJECT_POLICY</name></expr>:</case>
			<return>return <expr><call><name>rename_policy</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>OBJECT_DOMAIN</name></expr>:</case>
		<case>case <expr><name>OBJECT_TYPE</name></expr>:</case>
			<return>return <expr><call><name>RenameType</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</return>
		
		<case>case <expr><name>OBJECT_FUNCTION</name></expr>:</case>
			<return>return <expr><call><name>RenameFunction</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>OBJECT_AGGREGATE</name></expr>:</case>
		<case>case <expr><name>OBJECT_COLLATION</name></expr>:</case>
		<case>case <expr><name>OBJECT_CONVERSION</name></expr>:</case>
		<case>case <expr><name>OBJECT_EVENT_TRIGGER</name></expr>:</case>
		<case>case <expr><name>OBJECT_FDW</name></expr>:</case>
		<case>case <expr><name>OBJECT_FOREIGN_SERVER</name></expr>:</case>
		<case>case <expr><name>OBJECT_OPCLASS</name></expr>:</case>
		<case>case <expr><name>OBJECT_OPFAMILY</name></expr>:</case>
		<case>case <expr><name>OBJECT_LANGUAGE</name></expr>:</case>
		<case>case <expr><name>OBJECT_PROCEDURE</name></expr>:</case>
		<case>case <expr><name>OBJECT_ROUTINE</name></expr>:</case>
		<case>case <expr><name>OBJECT_STATISTIC_EXT</name></expr>:</case>
		<case>case <expr><name>OBJECT_TSCONFIGURATION</name></expr>:</case>
		<case>case <expr><name>OBJECT_TSDICTIONARY</name></expr>:</case>
		<case>case <expr><name>OBJECT_TSPARSER</name></expr>:</case>
		<case>case <expr><name>OBJECT_TSTEMPLATE</name></expr>:</case>
		<case>case <expr><name>OBJECT_PUBLICATION</name></expr>:</case>
		<case>case <expr><name>OBJECT_SUBSCRIPTION</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Relation</name></type>	<name>catalog</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>get_object_address</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name></expr></argument>,
											 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>object</name></name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>relation</name></expr></argument>,
											 <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>relation</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>catalog</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>address</name><operator>.</operator><name>classId</name></name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>AlterObjectRename_internal</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>,
										   <argument><expr><name><name>address</name><operator>.</operator><name>objectId</name></name></expr></argument>,
										   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<return>return <expr><name>address</name></expr>;</return>
			</block_content>}</block>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized rename stmt type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>InvalidObjectAddress</name></expr>;</return>	<comment type="block">/* keep compiler happy */</comment>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Executes an ALTER OBJECT / DEPENDS ON [EXTENSION] statement.
 *
 * Return value is the address of the altered object.  refAddress is an output
 * argument which, if not null, receives the address of the object that the
 * altered object now depends on.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>ExecAlterObjectDependsStmt</name><parameter_list>(<parameter><decl><type><name>AlterObjectDependsStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>refAddress</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>refAddr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>address</name> <operator>=</operator>
		<call><name>get_object_address_rv</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>object</name></name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>rel</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If a relation was involved, it would have been opened and locked. We
	 * don't need the relation here, but we'll retain the lock until commit.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>rel</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>refAddr</name> <operator>=</operator> <call><name>get_object_address</name><argument_list>(<argument><expr><name>OBJECT_EXTENSION</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>extname</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>rel</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rel</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>refAddress</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>refAddress</name> <operator>=</operator> <name>refAddr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>address</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>refAddr</name></expr></argument>, <argument><expr><name>DEPENDENCY_AUTO_EXTENSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Executes an ALTER OBJECT / SET SCHEMA statement.  Based on the object
 * type, the function appropriate to that type is executed.
 *
 * Return value is that of the altered object.
 *
 * oldSchemaAddr is an output argument which, if not NULL, is set to the object
 * address of the original schema.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>ExecAlterObjectSchemaStmt</name><parameter_list>(<parameter><decl><type><name>AlterObjectSchemaStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>,
						  <parameter><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>oldSchemaAddr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oldNspOid</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OBJECT_EXTENSION</name></expr>:</case>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterExtensionNamespace</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><operator>(</operator><name>Value</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newschema</name></name></expr></argument>,
											  <argument><expr><ternary><condition><expr><name>oldSchemaAddr</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>oldNspOid</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OBJECT_FOREIGN_TABLE</name></expr>:</case>
		<case>case <expr><name>OBJECT_SEQUENCE</name></expr>:</case>
		<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
		<case>case <expr><name>OBJECT_VIEW</name></expr>:</case>
		<case>case <expr><name>OBJECT_MATVIEW</name></expr>:</case>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterTableNamespace</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>,
										  <argument><expr><ternary><condition><expr><name>oldSchemaAddr</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>oldNspOid</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OBJECT_DOMAIN</name></expr>:</case>
		<case>case <expr><name>OBJECT_TYPE</name></expr>:</case>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterTypeNamespace</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newschema</name></name></expr></argument>,
										 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name></expr></argument>,
										 <argument><expr><ternary><condition><expr><name>oldSchemaAddr</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>oldNspOid</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/* generic code path */</comment>
		<case>case <expr><name>OBJECT_AGGREGATE</name></expr>:</case>
		<case>case <expr><name>OBJECT_COLLATION</name></expr>:</case>
		<case>case <expr><name>OBJECT_CONVERSION</name></expr>:</case>
		<case>case <expr><name>OBJECT_FUNCTION</name></expr>:</case>
		<case>case <expr><name>OBJECT_OPERATOR</name></expr>:</case>
		<case>case <expr><name>OBJECT_OPCLASS</name></expr>:</case>
		<case>case <expr><name>OBJECT_OPFAMILY</name></expr>:</case>
		<case>case <expr><name>OBJECT_PROCEDURE</name></expr>:</case>
		<case>case <expr><name>OBJECT_ROUTINE</name></expr>:</case>
		<case>case <expr><name>OBJECT_STATISTIC_EXT</name></expr>:</case>
		<case>case <expr><name>OBJECT_TSCONFIGURATION</name></expr>:</case>
		<case>case <expr><name>OBJECT_TSDICTIONARY</name></expr>:</case>
		<case>case <expr><name>OBJECT_TSPARSER</name></expr>:</case>
		<case>case <expr><name>OBJECT_TSTEMPLATE</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Relation</name></type>	<name>catalog</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>classId</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>nspOid</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>get_object_address</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name></expr></argument>,
											 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>object</name></name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>relation</name></expr></argument>,
											 <argument><expr><name>AccessExclusiveLock</name></expr></argument>,
											 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>relation</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>classId</name> <operator>=</operator> <name><name>address</name><operator>.</operator><name>classId</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>catalog</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>classId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>nspOid</name> <operator>=</operator> <call><name>LookupCreationNamespace</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newschema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>oldNspOid</name> <operator>=</operator> <call><name>AlterObjectNamespace_internal</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name><name>address</name><operator>.</operator><name>objectId</name></name></expr></argument>,
														  <argument><expr><name>nspOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized AlterObjectSchemaStmt type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>InvalidObjectAddress</name></expr>;</return>	<comment type="block">/* keep compiler happy */</comment>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name>oldSchemaAddr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><operator>*</operator><name>oldSchemaAddr</name></expr></argument>, <argument><expr><name>NamespaceRelationId</name></expr></argument>, <argument><expr><name>oldNspOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Change an object's namespace given its classOid and object Oid.
 *
 * Objects that don't have a namespace should be ignored.
 *
 * This function is currently used only by ALTER EXTENSION SET SCHEMA,
 * so it only needs to cover object types that can be members of an
 * extension, and it doesn't have to deal with certain special cases
 * such as not wanting to process array types --- those should never
 * be direct members of an extension anyway.  Nonetheless, we insist
 * on listing all OCLASS types in the switch.
 *
 * Returns the OID of the object's previous namespace, or InvalidOid if
 * object doesn't have a schema.
 */</comment>
<function><type><name>Oid</name></type>
<name>AlterObjectNamespace_oid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>classId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>nspOid</name></decl></parameter>,
						 <parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objsMoved</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oldNspOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>dep</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>dep</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>classId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dep</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>objid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dep</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><call><name>getObjectClass</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dep</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OCLASS_CLASS</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>objid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>oldNspOid</name> <operator>=</operator> <call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>AlterTableNamespaceInternal</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>oldNspOid</name></expr></argument>, <argument><expr><name>nspOid</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>OCLASS_TYPE</name></expr>:</case>
			<expr_stmt><expr><name>oldNspOid</name> <operator>=</operator> <call><name>AlterTypeNamespace_oid</name><argument_list>(<argument><expr><name>objid</name></expr></argument>, <argument><expr><name>nspOid</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OCLASS_PROC</name></expr>:</case>
		<case>case <expr><name>OCLASS_COLLATION</name></expr>:</case>
		<case>case <expr><name>OCLASS_CONVERSION</name></expr>:</case>
		<case>case <expr><name>OCLASS_OPERATOR</name></expr>:</case>
		<case>case <expr><name>OCLASS_OPCLASS</name></expr>:</case>
		<case>case <expr><name>OCLASS_OPFAMILY</name></expr>:</case>
		<case>case <expr><name>OCLASS_STATISTIC_EXT</name></expr>:</case>
		<case>case <expr><name>OCLASS_TSPARSER</name></expr>:</case>
		<case>case <expr><name>OCLASS_TSDICT</name></expr>:</case>
		<case>case <expr><name>OCLASS_TSTEMPLATE</name></expr>:</case>
		<case>case <expr><name>OCLASS_TSCONFIG</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Relation</name></type>	<name>catalog</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>catalog</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>classId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>oldNspOid</name> <operator>=</operator> <call><name>AlterObjectNamespace_internal</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>objid</name></expr></argument>,
														  <argument><expr><name>nspOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>OCLASS_CAST</name></expr>:</case>
		<case>case <expr><name>OCLASS_CONSTRAINT</name></expr>:</case>
		<case>case <expr><name>OCLASS_DEFAULT</name></expr>:</case>
		<case>case <expr><name>OCLASS_LANGUAGE</name></expr>:</case>
		<case>case <expr><name>OCLASS_LARGEOBJECT</name></expr>:</case>
		<case>case <expr><name>OCLASS_AM</name></expr>:</case>
		<case>case <expr><name>OCLASS_AMOP</name></expr>:</case>
		<case>case <expr><name>OCLASS_AMPROC</name></expr>:</case>
		<case>case <expr><name>OCLASS_REWRITE</name></expr>:</case>
		<case>case <expr><name>OCLASS_TRIGGER</name></expr>:</case>
		<case>case <expr><name>OCLASS_SCHEMA</name></expr>:</case>
		<case>case <expr><name>OCLASS_ROLE</name></expr>:</case>
		<case>case <expr><name>OCLASS_DATABASE</name></expr>:</case>
		<case>case <expr><name>OCLASS_TBLGROUP</name></expr>:</case>
		<case>case <expr><name>OCLASS_TBLSPACE</name></expr>:</case>
		<case>case <expr><name>OCLASS_FDW</name></expr>:</case>
		<case>case <expr><name>OCLASS_FOREIGN_SERVER</name></expr>:</case>
		<case>case <expr><name>OCLASS_USER_MAPPING</name></expr>:</case>
		<case>case <expr><name>OCLASS_DEFACL</name></expr>:</case>
		<case>case <expr><name>OCLASS_EXTENSION</name></expr>:</case>
		<case>case <expr><name>OCLASS_EVENT_TRIGGER</name></expr>:</case>
		<case>case <expr><name>OCLASS_POLICY</name></expr>:</case>
		<case>case <expr><name>OCLASS_PUBLICATION</name></expr>:</case>
		<case>case <expr><name>OCLASS_PUBLICATION_REL</name></expr>:</case>
		<case>case <expr><name>OCLASS_SUBSCRIPTION</name></expr>:</case>
		<case>case <expr><name>OCLASS_TRANSFORM</name></expr>:</case>
			<comment type="block">/* ignore object types that don't have schema-qualified names */</comment>
			<break>break;</break>

			<comment type="block">/*
			 * There's intentionally no default: case here; we want the
			 * compiler to warn if a new OCLASS hasn't been handled above.
			 */</comment>
	</block_content>}</block></switch>

	<return>return <expr><name>oldNspOid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generic function to change the namespace of a given object, for simple
 * cases (won't work for tables, nor other cases where we need to do more
 * than change the namespace column of a single catalog entry).
 *
 * rel: catalog relation containing object (RowExclusiveLock'd by caller)
 * objid: OID of object to change the namespace of
 * nspOid: OID of new namespace
 *
 * Returns the OID of the object's previous namespace.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>AlterObjectNamespace_internal</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>nspOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>classId</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>oidCacheId</name> <init>= <expr><call><name>get_object_catcache_oid</name><argument_list>(<argument><expr><name>classId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nameCacheId</name> <init>= <expr><call><name>get_object_catcache_name</name><argument_list>(<argument><expr><name>classId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>Anum_name</name> <init>= <expr><call><name>get_object_attnum_name</name><argument_list>(<argument><expr><name>classId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>Anum_namespace</name> <init>= <expr><call><name>get_object_attnum_namespace</name><argument_list>(<argument><expr><name>classId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>Anum_owner</name> <init>= <expr><call><name>get_object_attnum_owner</name><argument_list>(<argument><expr><name>classId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectType</name></type>	<name>objtype</name> <init>= <expr><call><name>get_object_type</name><argument_list>(<argument><expr><name>classId</name></expr></argument>, <argument><expr><name>objid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oldNspOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>name</name></decl>,
				<decl><type ref="prev"/><name>namespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>,
				<decl><type ref="prev"/><name>newtup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>replaces</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>oidCacheId</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* should not happen */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for object %u of catalog \"%s\""</literal></expr></argument>,
			 <argument><expr><name>objid</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><name>Anum_name</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>namespace</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><name>Anum_namespace</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldNspOid</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>namespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the object is already in the correct namespace, we don't need to do
	 * anything except fire the object access hook.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>oldNspOid</name> <operator>==</operator> <name>nspOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>classId</name></expr></argument>, <argument><expr><name>objid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>oldNspOid</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Check basic namespace related issues */</comment>
	<expr_stmt><expr><call><name>CheckSetNamespace</name><argument_list>(<argument><expr><name>oldNspOid</name></expr></argument>, <argument><expr><name>nspOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Permission checks ... superusers can always do it */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>owner</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>

		<comment type="block">/* Fail if object does not have an explicit owner */</comment>
		<if_stmt><if>if <condition>(<expr><name>Anum_owner</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser to set schema of %s"</literal></expr></argument>,
							 <argument><expr><call><name>getObjectDescriptionOids</name><argument_list>(<argument><expr><name>classId</name></expr></argument>, <argument><expr><name>objid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Otherwise, must be owner of the existing object */</comment>
		<expr_stmt><expr><name>owner</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><name>Anum_owner</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>owner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>has_privs_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>objtype</name></expr></argument>,
						   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><call><name>DatumGetName</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* User must have CREATE privilege on new namespace */</comment>
		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_namespace_aclcheck</name><argument_list>(<argument><expr><name>nspOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_SCHEMA</name></expr></argument>,
						   <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>nspOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check for duplicate name (more friendly than unique-index failure).
	 * Since this is just a friendliness check, we can just skip it in cases
	 * where there isn't suitable support.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>classId</name> <operator>==</operator> <name>ProcedureRelationId</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>proc</name> <init>= <expr><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>IsThereFunctionInNamespace</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>pronargs</name></name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>proargtypes</name></name></expr></argument>, <argument><expr><name>nspOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>classId</name> <operator>==</operator> <name>CollationRelationId</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_collation</name></type> <name>coll</name> <init>= <expr><operator>(</operator><name>Form_pg_collation</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>IsThereCollationInNamespace</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>coll</name><operator>-&gt;</operator><name>collname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nspOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>classId</name> <operator>==</operator> <name>OperatorClassRelationId</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_opclass</name></type> <name>opc</name> <init>= <expr><operator>(</operator><name>Form_pg_opclass</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>IsThereOpClassInNamespace</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>opc</name><operator>-&gt;</operator><name>opcname</name></name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name><name>opc</name><operator>-&gt;</operator><name>opcmethod</name></name></expr></argument>, <argument><expr><name>nspOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>classId</name> <operator>==</operator> <name>OperatorFamilyRelationId</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_opfamily</name></type> <name>opf</name> <init>= <expr><operator>(</operator><name>Form_pg_opfamily</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>IsThereOpFamilyInNamespace</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>opf</name><operator>-&gt;</operator><name>opfname</name></name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name><name>opf</name><operator>-&gt;</operator><name>opfmethod</name></name></expr></argument>, <argument><expr><name>nspOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>nameCacheId</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			 <call><name>SearchSysCacheExists2</name><argument_list>(<argument><expr><name>nameCacheId</name></expr></argument>, <argument><expr><name>name</name></expr></argument>,
								   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>nspOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>report_namespace_conflict</name><argument_list>(<argument><expr><name>classId</name></expr></argument>,
								  <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><call><name>DatumGetName</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>nspOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Build modified tuple */</comment>
	<expr_stmt><expr><name>values</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nulls</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>replaces</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_namespace</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>nspOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_namespace</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>newtup</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>replaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Perform actual update */</comment>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Release memory */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>replaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* update dependencies to point to the new schema */</comment>
	<expr_stmt><expr><call><name>changeDependencyFor</name><argument_list>(<argument><expr><name>classId</name></expr></argument>, <argument><expr><name>objid</name></expr></argument>,
						<argument><expr><name>NamespaceRelationId</name></expr></argument>, <argument><expr><name>oldNspOid</name></expr></argument>, <argument><expr><name>nspOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>classId</name></expr></argument>, <argument><expr><name>objid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>oldNspOid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Executes an ALTER OBJECT / OWNER TO statement.  Based on the object
 * type, the function appropriate to that type is executed.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>ExecAlterOwnerStmt</name><parameter_list>(<parameter><decl><type><name>AlterOwnerStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>newowner</name> <init>= <expr><call><name>get_rolespec_oid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newowner</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OBJECT_DATABASE</name></expr>:</case>
			<return>return <expr><call><name>AlterDatabaseOwner</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><operator>(</operator><name>Value</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>newowner</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>OBJECT_SCHEMA</name></expr>:</case>
			<return>return <expr><call><name>AlterSchemaOwner</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><operator>(</operator><name>Value</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>newowner</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>OBJECT_TYPE</name></expr>:</case>
		<case>case <expr><name>OBJECT_DOMAIN</name></expr>:</case>		<comment type="block">/* same as TYPE */</comment>
			<return>return <expr><call><name>AlterTypeOwner</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>newowner</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name></expr></argument>)</argument_list></call></expr>;</return>
			<break>break;</break>

		<case>case <expr><name>OBJECT_FDW</name></expr>:</case>
			<return>return <expr><call><name>AlterForeignDataWrapperOwner</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><operator>(</operator><name>Value</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><name>newowner</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>OBJECT_FOREIGN_SERVER</name></expr>:</case>
			<return>return <expr><call><name>AlterForeignServerOwner</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><operator>(</operator><name>Value</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name>newowner</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>OBJECT_EVENT_TRIGGER</name></expr>:</case>
			<return>return <expr><call><name>AlterEventTriggerOwner</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><operator>(</operator><name>Value</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>newowner</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>OBJECT_PUBLICATION</name></expr>:</case>
			<return>return <expr><call><name>AlterPublicationOwner</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><operator>(</operator><name>Value</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>newowner</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>OBJECT_SUBSCRIPTION</name></expr>:</case>
			<return>return <expr><call><name>AlterSubscriptionOwner</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><operator>(</operator><name>Value</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>newowner</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>OBJECT_YBTABLEGROUP</name></expr>:</case>
			<return>return <expr><call><name>AlterTablegroupOwner</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><operator>(</operator><name>Value</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>newowner</name></expr></argument>)</argument_list></call></expr>;</return>
		
		<case>case <expr><name>OBJECT_FUNCTION</name></expr>:</case>
			<return>return <expr><call><name>AlterFunctionOwner</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>,  <argument><expr><name>newowner</name></expr></argument>)</argument_list></call></expr>;</return>

			<comment type="block">/* Generic cases */</comment>
		<case>case <expr><name>OBJECT_AGGREGATE</name></expr>:</case>
		<case>case <expr><name>OBJECT_COLLATION</name></expr>:</case>
		<case>case <expr><name>OBJECT_CONVERSION</name></expr>:</case>
		<case>case <expr><name>OBJECT_LANGUAGE</name></expr>:</case>
		<case>case <expr><name>OBJECT_LARGEOBJECT</name></expr>:</case>
		<case>case <expr><name>OBJECT_OPERATOR</name></expr>:</case>
		<case>case <expr><name>OBJECT_OPCLASS</name></expr>:</case>
		<case>case <expr><name>OBJECT_OPFAMILY</name></expr>:</case>
		<case>case <expr><name>OBJECT_PROCEDURE</name></expr>:</case>
		<case>case <expr><name>OBJECT_ROUTINE</name></expr>:</case>
		<case>case <expr><name>OBJECT_STATISTIC_EXT</name></expr>:</case>
		<case>case <expr><name>OBJECT_TABLESPACE</name></expr>:</case>
		<case>case <expr><name>OBJECT_TSDICTIONARY</name></expr>:</case>
		<case>case <expr><name>OBJECT_TSCONFIGURATION</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Relation</name></type>	<name>catalog</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>classId</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>get_object_address</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name></expr></argument>,
											 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>object</name></name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>relation</name></expr></argument>,
											 <argument><expr><name>AccessExclusiveLock</name></expr></argument>,
											 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>relation</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>classId</name> <operator>=</operator> <name><name>address</name><operator>.</operator><name>classId</name></name></expr>;</expr_stmt>

				<comment type="block">/*
				 * XXX - get_object_address returns Oid of pg_largeobject
				 * catalog for OBJECT_LARGEOBJECT because of historical
				 * reasons.  Fix up it here.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>classId</name> <operator>==</operator> <name>LargeObjectRelationId</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>classId</name> <operator>=</operator> <name>LargeObjectMetadataRelationId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>catalog</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>classId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>AlterObjectOwner_internal</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name><name>address</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><name>newowner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<return>return <expr><name>address</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized AlterOwnerStmt type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>InvalidObjectAddress</name></expr>;</return>	<comment type="block">/* keep compiler happy */</comment>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Generic function to change the ownership of a given object, for simple
 * cases (won't work for tables, nor other cases where we need to do more than
 * change the ownership column of a single catalog entry).
 *
 * rel: catalog relation containing object (RowExclusiveLock'd by caller)
 * objectId: OID of object to change the ownership of
 * new_ownerId: OID of new object owner
 */</comment>
<function><type><name>void</name></type>
<name>AlterObjectOwner_internal</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objectId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>new_ownerId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>classId</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>Anum_owner</name> <init>= <expr><call><name>get_object_attnum_owner</name><argument_list>(<argument><expr><name>classId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>Anum_namespace</name> <init>= <expr><call><name>get_object_attnum_namespace</name><argument_list>(<argument><expr><name>classId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>Anum_acl</name> <init>= <expr><call><name>get_object_attnum_acl</name><argument_list>(<argument><expr><name>classId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>Anum_name</name> <init>= <expr><call><name>get_object_attnum_name</name><argument_list>(<argument><expr><name>classId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>oldtup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>old_ownerId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldtup</name> <operator>=</operator> <call><name>get_catalog_object_by_oid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>objectId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>oldtup</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for object %u of catalog \"%s\""</literal></expr></argument>,
			 <argument><expr><name>objectId</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>, <argument><expr><name>Anum_owner</name></expr></argument>,
						 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>old_ownerId</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Anum_namespace</name> <operator>!=</operator> <name>InvalidAttrNumber</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>, <argument><expr><name>Anum_namespace</name></expr></argument>,
							 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>old_ownerId</name> <operator>!=</operator> <name>new_ownerId</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>nattrs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>replaces</name></decl>;</decl_stmt>

		<comment type="block">/* Superusers can bypass permission checks */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ObjectType</name></type>	<name>objtype</name> <init>= <expr><call><name>get_object_type</name><argument_list>(<argument><expr><name>classId</name></expr></argument>, <argument><expr><name>objectId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* must be owner */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>has_privs_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>old_ownerId</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>objname</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name></type>		<name><name>namebuf</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>Anum_name</name> <operator>!=</operator> <name>InvalidAttrNumber</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>, <argument><expr><name>Anum_name</name></expr></argument>,
										 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>objname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><call><name>DatumGetName</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>namebuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>namebuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>,
							 <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>objname</name> <operator>=</operator> <name>namebuf</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>objtype</name></expr></argument>, <argument><expr><name>objname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Must be able to become new owner */</comment>
			<expr_stmt><expr><call><name>check_is_member_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>new_ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* New owner must have CREATE privilege on namespace */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_namespace_aclcheck</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>, <argument><expr><name>new_ownerId</name></expr></argument>,
												  <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_SCHEMA</name></expr></argument>,
								   <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Build a modified tuple */</comment>
		<expr_stmt><expr><name>nattrs</name> <operator>=</operator> <call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>values</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nattrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nulls</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nattrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>replaces</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nattrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_owner</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>new_ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_owner</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Determine the modified ACL for the new owner.  This is only
		 * necessary when the ACL is non-null.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>Anum_acl</name> <operator>!=</operator> <name>InvalidAttrNumber</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>,
								 <argument><expr><name>Anum_acl</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>newAcl</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>newAcl</name> <operator>=</operator> <call><name>aclnewowner</name><argument_list>(<argument><expr><call><name>DatumGetAclP</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>old_ownerId</name></expr></argument>, <argument><expr><name>new_ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_acl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>newAcl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_acl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>newtup</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>replaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Perform actual update */</comment>
		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Update owner dependency reference */</comment>
		<if_stmt><if>if <condition>(<expr><name>classId</name> <operator>==</operator> <name>LargeObjectMetadataRelationId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>classId</name> <operator>=</operator> <name>LargeObjectRelationId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>changeDependencyOnOwner</name><argument_list>(<argument><expr><name>classId</name></expr></argument>, <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>new_ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Release memory */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>replaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>classId</name></expr></argument>, <argument><expr><name>objectId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
