<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/commands/ybccmds.c"><comment type="block">/*--------------------------------------------------------------------------------------------------
 *
 * ybccmds.c
 *        YB commands for creating and altering table structures and settings
 *
 * Copyright (c) YugaByte, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied.  See the License for the specific language governing permissions and limitations
 * under the License.
 *
 * IDENTIFICATION
 *        src/backend/commands/ybccmds.c
 *
 *------------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_attribute.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_database.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/yb_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/yb_catalog_version.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablegroup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/ybccmds.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/tuptable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/ybcExpr.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"yb/yql/pggate/ybc_pggate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_yb_utils.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_utilcmd.h"</cpp:file></cpp:include>

<comment type="block">/* Yugabyte includes */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_yb_tablegroup.h"</cpp:file></cpp:include>

<comment type="block">/* Utility function to calculate column sorting options */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ColumnSortingOptions</name><parameter_list>(<parameter><decl><type><name>SortByDir</name></type> <name>dir</name></decl></parameter>, <parameter><decl><type><name>SortByNulls</name></type> <name>nulls</name></decl></parameter>, <parameter><decl><type><name>bool</name><modifier>*</modifier></type> <name>is_desc</name></decl></parameter>, <parameter><decl><type><name>bool</name><modifier>*</modifier></type> <name>is_nulls_first</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>dir</name> <operator>==</operator> <name>SORTBY_DESC</name></expr>)</condition> <block>{<block_content>
	<comment type="block">/*
	 * From postgres doc NULLS FIRST is the default for DESC order.
	 * So SORTBY_NULLS_DEFAULT is equal to SORTBY_NULLS_FIRST here.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>is_desc</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>is_nulls_first</name> <operator>=</operator> <operator>(</operator><name>nulls</name> <operator>!=</operator> <name>SORTBY_NULLS_LAST</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
	<comment type="block">/*
	 * From postgres doc ASC is the default sort order and NULLS LAST is the default for it.
	 * So SORTBY_DEFAULT is equal to SORTBY_ASC and SORTBY_NULLS_DEFAULT is equal
	 * to SORTBY_NULLS_LAST here.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>is_desc</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>is_nulls_first</name> <operator>=</operator> <operator>(</operator><name>nulls</name> <operator>==</operator> <name>SORTBY_NULLS_FIRST</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* -------------------------------------------------------------------------- */</comment>
<comment type="block">/*  Database Functions. */</comment>

<function><type><name>void</name></type>
<name>YBCCreateDatabase</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>dboid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>src_dboid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>next_oid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>colocated</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>YBIsDBCatalogVersionMode</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * In per database catalog version mode, disallow create database
		 * if we come too close to the limit.
		 */</comment>
		<decl_stmt><decl><type><name>int64_t</name></type> <name>num_databases</name> <init>= <expr><call><name>YbGetNumberOfDatabases</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64_t</name></type> <name>num_reserved</name> <init>=
			<expr><operator>*</operator><call><name>YBCGetGFlags</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>ysql_num_databases_reserved_in_db_catalog_version_mode</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>kYBCMaxNumDbCatalogVersions</name> <operator>-</operator> <name>num_databases</name> <operator>&lt;=</operator> <name>num_reserved</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too many databases"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>YBCPgStatement</name></type> <name>handle</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgNewCreateDatabase</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>,
										  <argument><expr><name>dboid</name></expr></argument>,
										  <argument><expr><name>src_dboid</name></expr></argument>,
										  <argument><expr><name>next_oid</name></expr></argument>,
										  <argument><expr><name>colocated</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>handle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgExecCreateDatabase</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>YBIsDBCatalogVersionMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>YbCreateMasterDBCatalogVersionTableEntry</name><argument_list>(<argument><expr><name>dboid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>YBCDropDatabase</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>dboid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>YBCPgStatement</name></type> <name>handle</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgNewDropDatabase</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>,
										<argument><expr><name>dboid</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>handle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>not_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>HandleYBStatusIgnoreNotFound</name><argument_list>(<argument><expr><call><name>YBCPgExecDropDatabase</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>not_found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>not_found</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>YBIsDBCatalogVersionMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>YbDeleteMasterDBCatalogVersionTableEntry</name><argument_list>(<argument><expr><name>dboid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>YBCReserveOids</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>dboid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>next_oid</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>begin_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>end_oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgReserveOids</name><argument_list>(<argument><expr><name>dboid</name></expr></argument>,
									<argument><expr><name>next_oid</name></expr></argument>,
									<argument><expr><name>count</name></expr></argument>,
									<argument><expr><name>begin_oid</name></expr></argument>,
									<argument><expr><name>end_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ------------------------------------------------------------------------- */</comment>
<comment type="block">/*  Tablegroup Functions. */</comment>
<function><type><name>void</name></type>
<name>YBCCreateTablegroup</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>grp_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>tablespace_oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>YBCPgStatement</name></type> <name>handle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>db_name</name> <init>= <expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgNewCreateTablegroup</name><argument_list>(<argument><expr><name>db_name</name></expr></argument>, <argument><expr><name>MyDatabaseId</name></expr></argument>,
											<argument><expr><name>grp_oid</name></expr></argument>, <argument><expr><name>tablespace_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>handle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgExecCreateTablegroup</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>YBCDropTablegroup</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>grpoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>YBCPgStatement</name></type> <name>handle</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgNewDropTablegroup</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>, <argument><expr><name>grpoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>handle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>YBSaveDdlHandle</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ------------------------------------------------------------------------- */</comment>
<comment type="block">/*  Table Functions. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>CreateTableAddColumn</name><parameter_list>(<parameter><decl><type><name>YBCPgStatement</name></type> <name>handle</name></decl></parameter>,
								 <parameter><decl><type><name>Form_pg_attribute</name></type> <name>att</name></decl></parameter>,
								 <parameter><decl><type><name>bool</name></type> <name>is_hash</name></decl></parameter>,
								 <parameter><decl><type><name>bool</name></type> <name>is_primary</name></decl></parameter>,
								 <parameter><decl><type><name>bool</name></type> <name>is_desc</name></decl></parameter>,
								 <parameter><decl><type><name>bool</name></type> <name>is_nulls_first</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>AttrNumber</name></type> <name>attnum</name> <init>= <expr><name><name>att</name><operator>-&gt;</operator><name>attnum</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>YBCPgTypeEntity</name> <modifier>*</modifier></type><name>col_type</name> <init>= <expr><call><name>YbDataTypeFromOidMod</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>,
															<argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgCreateTableAddColumn</name><argument_list>(<argument><expr><name>handle</name></expr></argument>,
											 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name>attnum</name></expr></argument>,
											 <argument><expr><name>col_type</name></expr></argument>,
											 <argument><expr><name>is_hash</name></expr></argument>,
											 <argument><expr><name>is_primary</name></expr></argument>,
											 <argument><expr><name>is_desc</name></expr></argument>,
											 <argument><expr><name>is_nulls_first</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Utility function to add columns to the YB create statement
 * Columns need to be sent in order first hash columns, then rest of primary
 * key columns, then regular columns.
 *
 * Table counts as colocated if it has a tablegroup or resides within the
 * colocated database and hasn't opted-out from colocation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>CreateTableAddColumns</name><parameter_list>(<parameter><decl><type><name>YBCPgStatement</name></type> <name>handle</name></decl></parameter>,
								  <parameter><decl><type><name>TupleDesc</name></type> <name>desc</name></decl></parameter>,
								  <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>primary_key</name></decl></parameter>,
								  <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>colocated</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>  <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexElem</name> <modifier>*</modifier></type><name>index_elem</name></decl>;</decl_stmt>

	<comment type="block">/* For tables created WITH (oids = true), we expect oid column to be the only PK. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>desc</name><operator>-&gt;</operator><name>tdhasoid</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>primary_key</name> <operator>||</operator>
			<call><name>list_length</name><argument_list>(<argument><expr><name><name>primary_key</name><operator>-&gt;</operator><name>yb_index_params</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>IndexElem</name></expr></argument>, <argument><expr><name><name>primary_key</name><operator>-&gt;</operator><name>yb_index_params</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>name</name></expr></argument>,
				   <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"OID should be the only primary key column"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>index_elem</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>IndexElem</name></expr></argument>, <argument><expr><name><name>primary_key</name><operator>-&gt;</operator><name>yb_index_params</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>SortByDir</name></type> <name>order</name> <init>= <expr><name><name>index_elem</name><operator>-&gt;</operator><name>ordering</name></name></expr></init></decl>;</decl_stmt>
		<comment type="block">/*
		 * We can only have OID columns on system catalog tables
		 * and we disallow hash partitioning on those, so OID is not allowed
		 * to be a hash column - but that will be caught normally.
		 */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>is_hash</name> <init>= <expr><operator>(</operator><name>order</name> <operator>==</operator> <name>SORTBY_HASH</name> <operator>||</operator>
						<operator>(</operator><name>order</name> <operator>==</operator> <name>SORTBY_DEFAULT</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>colocated</name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>is_desc</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>is_nulls_first</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ColumnSortingOptions</name><argument_list>(<argument><expr><name>order</name></expr></argument>,
							 <argument><expr><name><name>index_elem</name><operator>-&gt;</operator><name>nulls_ordering</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>is_desc</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>is_nulls_first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>YBCPgTypeEntity</name> <modifier>*</modifier></type><name>col_type</name> <init>=
			<expr><call><name>YbDataTypeFromOidMod</name><argument_list>(<argument><expr><name>ObjectIdAttributeNumber</name></expr></argument>, <argument><expr><name>OIDOID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgCreateTableAddColumn</name><argument_list>(<argument><expr><name>handle</name></expr></argument>,
												 <argument><expr><literal type="string">"oid"</literal></expr></argument>,
												 <argument><expr><name>ObjectIdAttributeNumber</name></expr></argument>,
												 <argument><expr><name>col_type</name></expr></argument>,
												 <argument><expr><name>is_hash</name></expr></argument>,
												 <argument><expr><name>true</name></expr></argument> <comment type="block">/* is_primary */</comment>,
												 <argument><expr><name>is_desc</name></expr></argument>,
												 <argument><expr><name>is_nulls_first</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>primary_key</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Add all key columns first with respect to compound key order */</comment>
		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>primary_key-&gt;yb_index_params</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>index_elem</name> <operator>=</operator> <call><name>lfirst_node</name><argument_list>(<argument><expr><name>IndexElem</name></expr></argument>, <argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>column_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>desc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>index_elem</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>YbDataTypeIsValidForKey</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PRIMARY KEY containing column of type"</literal>
										<literal type="string">" '%s' not yet supported"</literal></expr></argument>,
										<argument><expr><call><name>YBPgTypeOidToStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<decl_stmt><decl><type><name>SortByDir</name></type> <name>order</name> <init>= <expr><name><name>index_elem</name><operator>-&gt;</operator><name>ordering</name></name></expr></init></decl>;</decl_stmt>
					<comment type="block">/* In YB mode, the first column defaults to HASH if it is
					 * not set and its table is not colocated */</comment>
					<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>is_first_key</name> <init>=
						<expr><name>cell</name> <operator>==</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>primary_key</name><operator>-&gt;</operator><name>yb_index_params</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type> <name>is_hash</name> <init>= <expr><operator>(</operator><name>order</name> <operator>==</operator> <name>SORTBY_HASH</name> <operator>||</operator>
									<operator>(</operator><name>is_first_key</name> <operator>&amp;&amp;</operator>
									 <name>order</name> <operator>==</operator> <name>SORTBY_DEFAULT</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>colocated</name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type> <name>is_desc</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type> <name>is_nulls_first</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>ColumnSortingOptions</name><argument_list>(<argument><expr><name>order</name></expr></argument>,
										 <argument><expr><name><name>index_elem</name><operator>-&gt;</operator><name>nulls_ordering</name></name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>is_desc</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>is_nulls_first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>CreateTableAddColumn</name><argument_list>(<argument><expr><name>handle</name></expr></argument>,
										 <argument><expr><name>att</name></expr></argument>,
										 <argument><expr><name>is_hash</name></expr></argument>,
										 <argument><expr><name>true</name></expr></argument> <comment type="block">/* is_primary */</comment>,
										 <argument><expr><name>is_desc</name></expr></argument>,
										 <argument><expr><name>is_nulls_first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>column_found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>column_found</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Column '%s' not found in table"</literal></expr></argument>,
								<argument><expr><name><name>index_elem</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Add all non-key columns */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>desc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>is_key</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>primary_key</name></expr>)</condition><block type="pseudo"><block_content>
			<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>primary_key-&gt;yb_index_params</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>IndexElem</name> <modifier>*</modifier></type><name>index_elem</name> <init>= <expr><operator>(</operator><name>IndexElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>index_elem</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>is_key</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_key</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CreateTableAddColumn</name><argument_list>(<argument><expr><name>handle</name></expr></argument>,
								 <argument><expr><name>att</name></expr></argument>,
								 <argument><expr><name>false</name></expr></argument> <comment type="block">/* is_hash */</comment>,
								 <argument><expr><name>false</name></expr></argument> <comment type="block">/* is_primary */</comment>,
								 <argument><expr><name>false</name></expr></argument> <comment type="block">/* is_desc */</comment>,
								 <argument><expr><name>false</name></expr></argument> <comment type="block">/* is_nulls_first */</comment>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>YBTransformPartitionSplitPoints</name><parameter_list>(<parameter><decl><type><name>YBCPgStatement</name></type> <name>yb_stmt</name></decl></parameter>,
								<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>split_points</name></decl></parameter>,
								<parameter><decl><type><name>Form_pg_attribute</name> <modifier>*</modifier></type><name>attrs</name></decl></parameter>,
								<parameter><decl><type><name>int</name></type> <name>attr_count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Parser state for type conversion and validation */</comment>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Construct values */</comment>
	<decl_stmt><decl><type><name>PartitionRangeDatum</name> <modifier>*</modifier></type><name><name>datums</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>datum_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>split_points</argument>)</argument_list></macro> <block>{<block_content>
		<expr_stmt><expr><call><name>YBTransformPartitionSplitValue</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attrs</name></expr></argument>, <argument><expr><name>attr_count</name></expr></argument>,
										<argument><expr><name>datums</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>datum_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Convert the values to yugabyte format and bind to statement. */</comment>
		<decl_stmt><decl><type><name>YBCPgExpr</name></type> <name><name>exprs</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>
		<for>for <control>(<init><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name>datum_count</name></expr>;</condition> <incr><expr><name>idx</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<switch>switch <condition>(<expr><name><name>datums</name><index>[<expr><name>idx</name></expr>]</index></name><operator>-&gt;</operator><name>kind</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>PARTITION_RANGE_DATUM_VALUE</name></expr>:</case>
				<block>{<block_content>
					<comment type="block">/* Given value is not null. Convert it to YugaByte format. */</comment>
					<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name><name>datums</name><index>[<expr><name>idx</name></expr>]</index></name><operator>-&gt;</operator><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<comment type="block">/*
					 * Use attr-&gt;attcollation because the split value will be compared against
					 * collation-encoded strings that are encoded using the column collation.
					 * We assume collation-encoding will likely to retain the similar key
					 * distribution as the original text values.
					 */</comment>
					<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><name><name>attrs</name><index>[<expr><name>idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name><name>exprs</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <call><name>YBCNewConstant</name><argument_list>(<argument><expr><name>yb_stmt</name></expr></argument>, <argument><expr><name><name>value</name><operator>-&gt;</operator><name>consttype</name></name></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>,
												<argument><expr><name><name>value</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* is_null */</comment>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>

				<case>case <expr><name>PARTITION_RANGE_DATUM_MAXVALUE</name></expr>:</case>
				<block>{<block_content>
					<comment type="block">/* Create MINVALUE in YugaByte format */</comment>
					<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><name><name>attrs</name><index>[<expr><name>idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name><name>exprs</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <call><name>YBCNewConstantVirtual</name><argument_list>(<argument><expr><name>yb_stmt</name></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
													   <argument><expr><name>YB_YQL_DATUM_LIMIT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>

				<case>case <expr><name>PARTITION_RANGE_DATUM_MINVALUE</name></expr>:</case>
				<block>{<block_content>
					<comment type="block">/* Create MINVALUE in YugaByte format */</comment>
					<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><name><name>attrs</name><index>[<expr><name>idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name><name>exprs</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <call><name>YBCNewConstantVirtual</name><argument_list>(<argument><expr><name>yb_stmt</name></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
													   <argument><expr><name>YB_YQL_DATUM_LIMIT_MIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>
			</block_content>}</block></switch>
		</block_content>}</block></for>

		<comment type="block">/* Defaulted to MINVALUE for the rest of the columns that are not assigned a value */</comment>
		<for>for <control>(<init>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name>attr_count</name></expr>;</condition> <incr><expr><name>idx</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><name><name>attrs</name><index>[<expr><name>idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>exprs</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <call><name>YBCNewConstantVirtual</name><argument_list>(<argument><expr><name>yb_stmt</name></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
											   <argument><expr><name>YB_YQL_DATUM_LIMIT_MIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Add the split boundary to CREATE statement */</comment>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgAddSplitBoundary</name><argument_list>(<argument><expr><name>yb_stmt</name></expr></argument>, <argument><expr><name>exprs</name></expr></argument>, <argument><expr><name>attr_count</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/* Utility function to handle split points */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>CreateTableHandleSplitOptions</name><parameter_list>(<parameter><decl><type><name>YBCPgStatement</name></type> <name>handle</name></decl></parameter>,
										  <parameter><decl><type><name>TupleDesc</name></type> <name>desc</name></decl></parameter>,
										  <parameter><decl><type><name>OptSplit</name> <modifier>*</modifier></type><name>split_options</name></decl></parameter>,
										  <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>primary_key</name></decl></parameter>,
										  <parameter><decl><type><name>Oid</name></type> <name>namespaceId</name></decl></parameter>,
										  <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>colocated</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Address both types of split options */</comment>
	<switch>switch <condition>(<expr><name><name>split_options</name><operator>-&gt;</operator><name>split_type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>NUM_TABLETS</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/* Make sure we have HASH columns */</comment>
			<decl_stmt><decl><type><name>bool</name></type> <name>hashable</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>primary_key</name></expr>)</condition> <block>{<block_content>
				<comment type="block">/* If a primary key exists, we utilize it to check its ordering */</comment>
				<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>head</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name><name>primary_key</name><operator>-&gt;</operator><name>yb_index_params</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>IndexElem</name> <modifier>*</modifier></type><name>index_elem</name> <init>= <expr><operator>(</operator><name>IndexElem</name><operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>index_elem</name> <operator>||</operator>
				   <operator>!</operator><operator>(</operator><name><name>index_elem</name><operator>-&gt;</operator><name>ordering</name></name> <operator>==</operator> <name>SORTBY_HASH</name> <operator>||</operator>
				   <name><name>index_elem</name><operator>-&gt;</operator><name>ordering</name></name> <operator>==</operator> <name>SORTBY_DEFAULT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>hashable</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if> <else>else <block>{<block_content>
				<comment type="block">/* In the abscence of a primary key, we use ybrowid as the PK to hash partition */</comment>
				<decl_stmt><decl><type><name>bool</name></type> <name>is_pg_catalog_table_</name> <init>=
					<expr><call><name>IsSystemNamespace</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsToastNamespace</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<comment type="block">/*
				 * Checking if  table_oid is valid simple means if the table is
				 * part of a tablegroup.
				 */</comment>
				<expr_stmt><expr><name>hashable</name> <operator>=</operator> <operator>!</operator><name>is_pg_catalog_table_</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>colocated</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hashable</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"HASH columns must be present to "</literal>
							<literal type="string">"split by number of tablets"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* Tell pggate about it */</comment>
			<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgCreateTableSetNumTablets</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name><name>split_options</name><operator>-&gt;</operator><name>num_tablets</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>SPLIT_POINTS</name></expr>:</case>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>primary_key</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Cannot split table that does not have primary key"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Find the column descriptions for primary key (split columns). */</comment>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name><name>attrs</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>attr_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>primary_key-&gt;yb_index_params</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>col_name</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>IndexElem</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>name</name></expr></init></decl>;</decl_stmt>
				<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>desc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>col_name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>attrs</name><index>[<expr><name>attr_count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>att</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
			</block_content>}</block>

			<comment type="block">/* Analyze split_points and add them to CREATE statement */</comment>
			<expr_stmt><expr><call><name>YBTransformPartitionSplitPoints</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name><name>split_options</name><operator>-&gt;</operator><name>split_points</name></name></expr></argument>, <argument><expr><name>attrs</name></expr></argument>, <argument><expr><name>attr_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Invalid split options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>YBCCreateTable</name><parameter_list>(<parameter><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>relkind</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>desc</name></decl></parameter>,
			   <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>namespaceId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>tablegroupId</name></decl></parameter>,
			   <parameter><decl><type><name>Oid</name></type> <name>colocationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>tablespaceId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>matviewPgTableId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator>
		<name>relkind</name> <operator>!=</operator> <name>RELKIND_MATVIEW</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return> <comment type="block">/* Nothing to do. */</comment>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>YBCPgStatement</name></type> <name>handle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>       <modifier>*</modifier></type><name>listptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>           <name>is_shared_relation</name> <init>= <expr><name>tablespaceId</name> <operator>==</operator> <name>GLOBALTABLESPACE_OID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>            <name>databaseId</name>         <init>= <expr><call><name>YBCGetDatabaseOidFromShared</name><argument_list>(<argument><expr><name>is_shared_relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>           <name>is_matview</name>         <init>= <expr><name>relkind</name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>db_name</name> <init>= <expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>databaseId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schema_name</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>schema_name</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>schema_name</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>YBC_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"Creating Table %s.%s.%s"</literal></expr></argument>,
					 <argument><expr><name>db_name</name></expr></argument>,
					 <argument><expr><name>schema_name</name></expr></argument>,
					 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>primary_key</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>listptr</argument>, <argument>stmt-&gt;constraints</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>listptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_PRIMARY</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>primary_key</name> <operator>=</operator> <name>constraint</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If this is a partition table, check whether it needs to inherit the same
	 * primary key as the parent partitioned table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>primary_key</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>partbound</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * This relation is not created yet and not visible to other
		 * backends. It doesn't really matter what lock we take here.
		 */</comment>
		<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Find the parent partitioned table */</comment>
		<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>rv</name> <init>= <expr><operator>(</operator><name>RangeVar</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><call><name>list_head</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>inhRelations</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>	<name>parentOid</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Relation</name></type> <name>parentRel</name> <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name>parentOid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>tablegroupId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tablegroupId</name> <operator>=</operator> <call><name>YbGetTableProperties</name><argument_list>(<argument><expr><name>parentRel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>tablegroup_oid</name></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>idxlist</name> <init>= <expr><call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>parentRel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>idxlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Relation</name></type>    <name>idxRel</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<comment type="block">/* Fetch pg_index tuple for source index from relcache entry */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name><name>idxRel</name><operator>-&gt;</operator><name>rd_indextuple</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>indisprimary</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * This is not a primary key index so this doesn't matter.
				 */</comment>
				<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attmap</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>idxstmt</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>         <name>constraintOid</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>attmap</name> <operator>=</operator> <call><name>convert_tuples_by_name_map</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>parentRel</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>idxstmt</name> <operator>=</operator>
				<call><name>generateClonedIndexStmt</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>idxRel</name></expr></argument>,
						<argument><expr><name>attmap</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>natts</name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>constraintOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>primary_key</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>primary_key</name><operator>-&gt;</operator><name>contype</name></name>      <operator>=</operator> <name>CONSTR_PRIMARY</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>primary_key</name><operator>-&gt;</operator><name>conname</name></name>      <operator>=</operator> <name><name>idxstmt</name><operator>-&gt;</operator><name>idxname</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>primary_key</name><operator>-&gt;</operator><name>options</name></name>      <operator>=</operator> <name><name>idxstmt</name><operator>-&gt;</operator><name>options</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>primary_key</name><operator>-&gt;</operator><name>indexspace</name></name>   <operator>=</operator> <name><name>idxstmt</name><operator>-&gt;</operator><name>tableSpace</name></name></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>idxcell</name></decl>;</decl_stmt>
			<macro><name>foreach</name><argument_list>(<argument>idxcell</argument>, <argument>idxstmt-&gt;indexParams</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>IndexElem</name><modifier>*</modifier></type> <name>ielem</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>idxcell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name><name>primary_key</name><operator>-&gt;</operator><name>keys</name></name> <operator>=</operator>
					<call><name>lappend</name><argument_list>(<argument><expr><name><name>primary_key</name><operator>-&gt;</operator><name>keys</name></name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>ielem</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>primary_key</name><operator>-&gt;</operator><name>yb_index_params</name></name> <operator>=</operator>
					<call><name>lappend</name><argument_list>(<argument><expr><name><name>primary_key</name><operator>-&gt;</operator><name>yb_index_params</name></name></expr></argument>, <argument><expr><name>ielem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>

			<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>parentRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* By default, inherit the colocated option from the database */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_colocated_via_database</name> <init>= <expr><name>MyDatabaseColocated</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Handle user-supplied colocated reloption */</comment>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>opt_cell</name></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>opt_cell</argument>, <argument>stmt-&gt;options</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>def</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>opt_cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * A check in parse_utilcmd.c makes sure only one of these two options
		 * can be specified.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"colocated"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"colocation"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>tablegroupId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use \'colocation=true/false\' with tablegroup"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<decl_stmt><decl><type><name>bool</name></type> <name>colocated_relopt</name> <init>= <expr><call><name>defGetBoolean</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>MyDatabaseColocated</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>is_colocated_via_database</name> <operator>=</operator> <name>colocated_relopt</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>colocated_relopt</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot set colocation true on a non-colocated"</literal>
								<literal type="string">" database"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* The following break is fine because there should only be one
			 * colocated reloption at this point due to checks in
			 * parseRelOptions */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>is_colocated_via_database</name> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>tablespacename</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create colocated table with a tablespace"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>colocationId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_colocated_via_database</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>tablegroupId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot set colocation_id for non-colocated table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Lazily create an underlying tablegroup in a colocated database if needed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_colocated_via_database</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>MyColocatedDatabaseLegacy</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tablegroupId</name> <operator>=</operator> <call><name>get_tablegroup_oid</name><argument_list>(<argument><expr><name>DEFAULT_TABLEGROUP_NAME</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Default tablegroup doesn't exist, so create it. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>tablegroupId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Regardless of the current user, let postgres be the owner of the
			 * default tablegroup in a colocated database.
			 */</comment>
			<decl_stmt><decl><type><name>RoleSpec</name> <modifier>*</modifier></type><name>spec</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RoleSpec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>spec</name><operator>-&gt;</operator><name>roletype</name></name> <operator>=</operator> <name>ROLESPEC_CSTRING</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>spec</name><operator>-&gt;</operator><name>rolename</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"postgres"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>CreateTableGroupStmt</name> <modifier>*</modifier></type><name>tablegroup_stmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CreateTableGroupStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>tablegroup_stmt</name><operator>-&gt;</operator><name>tablegroupname</name></name> <operator>=</operator> <name>DEFAULT_TABLEGROUP_NAME</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tablegroup_stmt</name><operator>-&gt;</operator><name>implicit</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tablegroup_stmt</name><operator>-&gt;</operator><name>owner</name></name> <operator>=</operator> <name>spec</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>tablegroupId</name> <operator>=</operator> <call><name>CreateTableGroup</name><argument_list>(<argument><expr><name>tablegroup_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>tablegroupname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>DEFAULT_TABLEGROUP_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Record dependency between the table and default tablegroup. */</comment>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>, <decl><type ref="prev"/><name>default_tablegroup</name></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>relationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>default_tablegroup</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>YbTablegroupRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>default_tablegroup</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>tablegroupId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>default_tablegroup</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>default_tablegroup</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgNewCreateTable</name><argument_list>(<argument><expr><name>db_name</name></expr></argument>,
									   <argument><expr><name>schema_name</name></expr></argument>,
									   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>,
									   <argument><expr><name>databaseId</name></expr></argument>,
									   <argument><expr><name>relationId</name></expr></argument>,
									   <argument><expr><name>is_shared_relation</name></expr></argument>,
									   <argument><expr><name>false</name></expr></argument>, <comment type="block">/* if_not_exists */</comment>
									   <argument><expr><name>primary_key</name> <operator>==</operator> <name>NULL</name></expr></argument> <comment type="block">/* add_primary_key */</comment>,
									   <argument><expr><name>is_colocated_via_database</name></expr></argument>,
									   <argument><expr><name>tablegroupId</name></expr></argument>,
									   <argument><expr><name>colocationId</name></expr></argument>,
									   <argument><expr><name>tablespaceId</name></expr></argument>,
									   <argument><expr><name>is_matview</name></expr></argument>,
									   <argument><expr><name>matviewPgTableId</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>handle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CreateTableAddColumns</name><argument_list>(<argument><expr><name>handle</name></expr></argument>,
						  <argument><expr><name>desc</name></expr></argument>,
						  <argument><expr><name>primary_key</name></expr></argument>,
						  <argument><expr><name>is_colocated_via_database</name> <operator>||</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>tablegroupId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Handle SPLIT statement, if present */</comment>
	<decl_stmt><decl><type><name>OptSplit</name> <modifier>*</modifier></type><name>split_options</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>split_options</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>split_options</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>is_colocated_via_database</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create colocated table with split option"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>CreateTableHandleSplitOptions</name><argument_list>(
			<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><name>split_options</name></expr></argument>, <argument><expr><name>primary_key</name></expr></argument>, <argument><expr><name>namespaceId</name></expr></argument>,
			<argument><expr><name>is_colocated_via_database</name> <operator>||</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>tablegroupId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Create the table. */</comment>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgExecCreateTable</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>YBCDropTable</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>YbTableProperties</name></type> <name>yb_props</name> <init>= <expr><call><name>YbTryGetTableProperties</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>yb_props</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Table was not found on YB side, nothing to do */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/*
	 * However, since we were likely hitting the cache, we still need to
	 * safeguard against NotFound errors.
	 */</comment>

	<decl_stmt><decl><type><name>YBCPgStatement</name></type> <name>handle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>databaseId</name> <init>= <expr><call><name>YBCGetDatabaseOid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Create table-level tombstone for colocated (via DB or tablegroup) tables */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>yb_props</name><operator>-&gt;</operator><name>is_colocated</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>not_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>HandleYBStatusIgnoreNotFound</name><argument_list>(<argument><expr><call><name>YBCPgNewTruncateColocated</name><argument_list>(<argument><expr><name>databaseId</name></expr></argument>,
															   <argument><expr><call><name>YbGetStorageRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
															   <argument><expr><name>false</name></expr></argument>,
															   <argument><expr><name>false</name></expr></argument>,
															   <argument><expr><operator>&amp;</operator><name>handle</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>not_found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		 * Since the creation of the handle could return a 'NotFound' error,
		 * execute the statement only if the handle is valid.
		 */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>valid_handle</name> <init>= <expr><operator>!</operator><name>not_found</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>valid_handle</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>HandleYBStatusIgnoreNotFound</name><argument_list>(<argument><expr><call><name>YBCPgDmlBindTable</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>not_found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>rows_affected_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>HandleYBStatusIgnoreNotFound</name><argument_list>(<argument><expr><call><name>YBCPgDmlExecWriteOp</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rows_affected_count</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>not_found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Drop the table */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>not_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>HandleYBStatusIgnoreNotFound</name><argument_list>(<argument><expr><call><name>YBCPgNewDropTable</name><argument_list>(<argument><expr><name>databaseId</name></expr></argument>,
													   <argument><expr><call><name>YbGetStorageRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
													   <argument><expr><name>false</name></expr></argument>, <comment type="block">/* if_exists */</comment>
													   <argument><expr><operator>&amp;</operator><name>handle</name></expr></argument>)</argument_list></call></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name>not_found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>not_found</name></expr>)</condition>
		<block>{<block_content>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/*
		 * YSQL DDL Rollback is not yet supported for colocated tables.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><call><name>YBCGetGFlags</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>ysql_ddl_rollback_enabled</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>yb_props</name><operator>-&gt;</operator><name>is_colocated</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The following issues a request to the YB-Master to drop the
			 * table once this transaction commits.
			 */</comment>
			<expr_stmt><expr><call><name>HandleYBStatusIgnoreNotFound</name><argument_list>(<argument><expr><call><name>YBCPgExecDropTable</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>not_found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/*
		 * YSQL DDL Rollback is disabled/unsupported. This means DocDB will not
		 * rollback the drop if the transaction ends up failing. We cannot
		 * abort drop in DocDB so postpone the execution until the rest of the
		 * statement/txn finishes executing.
		 */</comment>
		<expr_stmt><expr><call><name>YBSaveDdlHandle</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>YbTruncate</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>YBCPgStatement</name></type> <name>handle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relationId</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>databaseId</name> <init>= <expr><call><name>YBCGetDatabaseOid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isRegionLocal</name> <init>= <expr><call><name>YBCIsRegionLocal</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>YbGetTableProperties</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>is_colocated</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Create table-level tombstone for colocated/tablegroup/syscatalog
		 * relations.
		 */</comment>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgNewTruncateColocated</name><argument_list>(<argument><expr><name>databaseId</name></expr></argument>,
												 <argument><expr><name>relationId</name></expr></argument>,
												 <argument><expr><name>false</name></expr></argument>,
												 <argument><expr><name>isRegionLocal</name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>handle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlBindTable</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>rows_affected_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlExecWriteOp</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rows_affected_count</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Send truncate table RPC to master for non-colocated relations */</comment>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgNewTruncateTable</name><argument_list>(<argument><expr><name>databaseId</name></expr></argument>,
											 <argument><expr><name>relationId</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>handle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgExecTruncateTable</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasindex</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Truncate the associated secondary indexes */</comment>
	<decl_stmt><decl><type><name>List</name>	 <modifier>*</modifier></type><name>indexlist</name> <init>= <expr><call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>indexlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>indexId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* PK index is not secondary index, skip */</comment>
		<if_stmt><if>if <condition>(<expr><name>indexId</name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_pkindex</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Lock level doesn't fully work in YB.  Since YB TRUNCATE is already
		 * considered to not be transaction-safe, it doesn't really matter.
		 */</comment>
		<decl_stmt><decl><type><name>Relation</name></type> <name>indexRel</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>YbTruncate</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>indexlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Utility function to handle split points */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CreateIndexHandleSplitOptions</name><parameter_list>(<parameter><decl><type><name>YBCPgStatement</name></type> <name>handle</name></decl></parameter>,
                              <parameter><decl><type><name>TupleDesc</name></type> <name>desc</name></decl></parameter>,
                              <parameter><decl><type><name>OptSplit</name> <modifier>*</modifier></type><name>split_options</name></decl></parameter>,
                              <parameter><decl><type><name>int16</name> <modifier>*</modifier></type> <name>coloptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Address both types of split options */</comment>
	<switch>switch <condition>(<expr><name><name>split_options</name><operator>-&gt;</operator><name>split_type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>NUM_TABLETS</name></expr>:</case>
			<comment type="block">/* Make sure we have HASH columns */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>coloptions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <name>INDOPTION_HASH</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"HASH columns must be present to split by number of tablets"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgCreateIndexSetNumTablets</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name><name>split_options</name><operator>-&gt;</operator><name>num_tablets</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>SPLIT_POINTS</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/* Construct array to SPLIT column datatypes */</comment>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name><name>attrs</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>attr_count</name></decl>;</decl_stmt>
			<for>for <control>(<init><expr><name>attr_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attr_count</name> <operator>&lt;</operator> <name><name>desc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>attr_count</name></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name><name>attrs</name><index>[<expr><name>attr_count</name></expr>]</index></name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>attr_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>

			<comment type="block">/* Analyze split_points and add them to CREATE statement */</comment>
			<expr_stmt><expr><call><name>YBTransformPartitionSplitPoints</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name><name>split_options</name><operator>-&gt;</operator><name>split_points</name></name></expr></argument>, <argument><expr><name>attrs</name></expr></argument>, <argument><expr><name>attr_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Illegal memory state for SPLIT options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>YBCCreateIndex</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>indexName</name></decl></parameter>,
			   <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>,
			   <parameter><decl><type><name>TupleDesc</name></type> <name>indexTupleDesc</name></decl></parameter>,
			   <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>coloptions</name></decl></parameter>,
			   <parameter><decl><type><name>Datum</name></type> <name>reloptions</name></decl></parameter>,
			   <parameter><decl><type><name>Oid</name></type> <name>indexId</name></decl></parameter>,
			   <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
			   <parameter><decl><type><name>OptSplit</name> <modifier>*</modifier></type><name>split_options</name></decl></parameter>,
			   <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>skip_index_backfill</name></decl></parameter>,
			   <parameter><decl><type><name>Oid</name></type> <name>tablegroupId</name></decl></parameter>,
			   <parameter><decl><type><name>Oid</name></type> <name>colocationId</name></decl></parameter>,
			   <parameter><decl><type><name>Oid</name></type> <name>tablespaceId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>db_name</name>	  <init>= <expr><call><name>get_database_name</name><argument_list>(<argument><expr><call><name>YBCGetDatabaseOid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schema_name</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>YBC_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"Creating index %s.%s.%s"</literal></expr></argument>,
					 <argument><expr><name>db_name</name></expr></argument>,
					 <argument><expr><name>schema_name</name></expr></argument>,
					 <argument><expr><name>indexName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>YBCPgStatement</name></type> <name>handle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgNewCreateIndex</name><argument_list>(<argument><expr><name>db_name</name></expr></argument>,
									   <argument><expr><name>schema_name</name></expr></argument>,
									   <argument><expr><name>indexName</name></expr></argument>,
									   <argument><expr><call><name>YBCGetDatabaseOid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name>indexId</name></expr></argument>,
									   <argument><expr><call><name>YbGetStorageRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relisshared</name></name></expr></argument>,
									   <argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Unique</name></name></expr></argument>,
									   <argument><expr><name>skip_index_backfill</name></expr></argument>,
									   <argument><expr><name>false</name></expr></argument>, <comment type="block">/* if_not_exists */</comment>
									   <argument><expr><name>tablegroupId</name></expr></argument>,
									   <argument><expr><name>colocationId</name></expr></argument>,
									   <argument><expr><name>tablespaceId</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>handle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>indexTupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type>     <name>att</name>         <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>indexTupleDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>                  <modifier>*</modifier></type><name>attname</name>    <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>            <name>attnum</name>      <init>= <expr><name><name>att</name><operator>-&gt;</operator><name>attnum</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>YBCPgTypeEntity</name> <modifier>*</modifier></type><name>col_type</name>   <init>= <expr><call><name>YbDataTypeFromOidMod</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type>            <name>is_key</name>      <init>= <expr><operator>(</operator><name>i</name> <operator>&lt;</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexKeyAttrs</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>is_key</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>YbDataTypeIsValidForKey</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"INDEX on column of type '%s' not yet supported"</literal></expr></argument>,
								<argument><expr><call><name>YBPgTypeOidToStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><specifier>const</specifier> <name>int16</name></type> <name>options</name>        <init>= <expr><name><name>coloptions</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type>  <name>is_hash</name>        <init>= <expr><name>options</name> <operator>&amp;</operator> <name>INDOPTION_HASH</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type>  <name>is_desc</name>        <init>= <expr><name>options</name> <operator>&amp;</operator> <name>INDOPTION_DESC</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type>  <name>is_nulls_first</name> <init>= <expr><name>options</name> <operator>&amp;</operator> <name>INDOPTION_NULLS_FIRST</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgCreateIndexAddColumn</name><argument_list>(<argument><expr><name>handle</name></expr></argument>,
												 <argument><expr><name>attname</name></expr></argument>,
												 <argument><expr><name>attnum</name></expr></argument>,
												 <argument><expr><name>col_type</name></expr></argument>,
												 <argument><expr><name>is_hash</name></expr></argument>,
												 <argument><expr><name>is_key</name></expr></argument>,
												 <argument><expr><name>is_desc</name></expr></argument>,
												 <argument><expr><name>is_nulls_first</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Handle SPLIT statement, if present */</comment>
	<if_stmt><if>if <condition>(<expr><name>split_options</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CreateIndexHandleSplitOptions</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>indexTupleDesc</name></expr></argument>, <argument><expr><name>split_options</name></expr></argument>, <argument><expr><name>coloptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Create the index. */</comment>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgExecCreateIndex</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name><modifier>*</modifier></type>
<name>YBCPrepareAlterTableCmd</name><parameter_list>(<parameter><decl><type><name>AlterTableCmd</name><modifier>*</modifier></type> <name>cmd</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>handles</name></decl></parameter>,
						<parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>col</name></decl></parameter>, <parameter><decl><type><name>bool</name><modifier>*</modifier></type> <name>needsYBAlter</name></decl></parameter>,
						<parameter><decl><type><name>YBCPgStatement</name><modifier>*</modifier></type> <name>rollbackHandle</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>isPartitionOfAlteredTable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>isPartitionOfAlteredTable</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * This function was invoked on a child partition table to reflect
		 * the effects of Alter on its parent.
		 */</comment>
		<switch>switch <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>AT_AddColumnRecurse</name></expr>:</case>
			<case>case <expr><name>AT_DropColumnRecurse</name></expr>:</case>
			<case>case <expr><name>AT_AddConstraintRecurse</name></expr>:</case>
			<case>case <expr><name>AT_DropConstraintRecurse</name></expr>:</case>
				<break>break;</break>
			<default>default:</default>
				<comment type="block">/*
				 * This is not an alter command on a partitioned table that
				 * needs to trickle down to its child partitions. Nothing to
				 * do.
				 */</comment>
				<return>return <expr><name>handles</name></expr>;</return>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>YbGetStorageRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<switch>switch <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AT_AddColumn</name></expr>:</case>
		<case>case <expr><name>AT_AddColumnToView</name></expr>:</case>
		<case>case <expr><name>AT_AddColumnRecurse</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ColumnDef</name><modifier>*</modifier></type> <name>colDef</name> <init>= <expr><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>typeOid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>typeTuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>order</name></decl>;</decl_stmt>

			<comment type="block">/* Skip yb alter for IF NOT EXISTS with existing column */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>missing_ok</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>typeTuple</name> <operator>=</operator> <call><name>typenameType</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>typeOid</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>order</name> <operator>=</operator> <call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>+</operator> <operator>*</operator><name>col</name></expr>;</expr_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>YBCPgTypeEntity</name> <modifier>*</modifier></type><name>col_type</name> <init>= <expr><call><name>YbDataTypeFromOidMod</name><argument_list>(<argument><expr><name>order</name></expr></argument>, <argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>handles</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>YBCPgStatement</name></type> <name>add_col_handle</name> <init>=
				<expr><operator>(</operator><name>YBCPgStatement</name><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><call><name>list_head</name><argument_list>(<argument><expr><name>handles</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgAlterTableAddColumn</name><argument_list>(<argument><expr><name>add_col_handle</name></expr></argument>,
													<argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>,
													<argument><expr><name>order</name></expr></argument>,
													<argument><expr><name>col_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>++</operator><operator>(</operator><operator>*</operator><name>col</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>needsYBAlter</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Prepare the handle that will be used to rollback
			 * this change at the DocDB side. This is an add column
			 * statement, thus the equivalent rollback operation
			 * will be to drop the column.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>rollbackHandle</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgNewAlterTable</name><argument_list>(<argument><expr><call><name>YBCGetDatabaseOid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><name>relationId</name></expr></argument>,
												  <argument><expr><name>rollbackHandle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgAlterTableDropColumn</name><argument_list>(<argument><expr><operator>*</operator><name>rollbackHandle</name></expr></argument>,
													 <argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>AT_DropColumn</name></expr>:</case>
		<case>case <expr><name>AT_DropColumnRecurse</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/* Skip yb alter for IF EXISTS with non-existent column */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>missing_ok</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>handles</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>YBCPgStatement</name></type> <name>drop_col_handle</name> <init>=
				<expr><operator>(</operator><name>YBCPgStatement</name><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><call><name>list_head</name><argument_list>(<argument><expr><name>handles</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgAlterTableDropColumn</name><argument_list>(<argument><expr><name>drop_col_handle</name></expr></argument>,
													 <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>needsYBAlter</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>AT_AddIndexConstraint</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>index</name> <init>= <expr><operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>
			<comment type="block">/* Only allow adding indexes when it is a unique or primary key constraint */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>index</name><operator>-&gt;</operator><name>unique</name></name> <operator>||</operator> <name><name>index</name><operator>-&gt;</operator><name>primary</name></name><operator>)</operator> <operator>||</operator> <operator>!</operator><name><name>index</name><operator>-&gt;</operator><name>isconstraint</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"This ALTER TABLE command"</literal>
								<literal type="string">" is not yet supported."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>AT_AlterColumnType</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/*
			 * Only supports variants that don't require on-disk changes.
			 * For now, that is just varchar and varbit.
			 */</comment>
			<decl_stmt><decl><type><name>ColumnDef</name><modifier>*</modifier></type>			<name>colDef</name> <init>= <expr><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTuple</name></type>			<name>typeTuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type>	<name>attTup</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>					<name>curTypId</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>					<name>newTypId</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>				<name>curTypMod</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>				<name>newTypMod</name></decl>;</decl_stmt>

			<comment type="block">/* Get current typid and typmod of the column. */</comment>
			<expr_stmt><expr><name>typeTuple</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
								<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>attTup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>curTypId</name> <operator>=</operator> <name><name>attTup</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>curTypMod</name> <operator>=</operator> <name><name>attTup</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Get the new typid and typmod of the column. */</comment>
			<expr_stmt><expr><call><name>typenameTypeIdAndMod</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newTypId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newTypMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Only varbit and varchar don't cause on-disk changes. */</comment>
			<switch>switch <condition>(<expr><name>newTypId</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>VARCHAROID</name></expr>:</case>
				<case>case <expr><name>VARBITOID</name></expr>:</case>
				<block>{<block_content>
					<comment type="block">/*
					* Check for type equality, and that the new size is greater than or equal
					* to the old size, unless the current size is infinite (-1).
					*/</comment>
					<if_stmt><if>if <condition>(<expr><name>newTypId</name> <operator>!=</operator> <name>curTypId</name> <operator>||</operator>
						<operator>(</operator><name>newTypMod</name> <operator>&lt;</operator> <name>curTypMod</name> <operator>&amp;&amp;</operator> <name>newTypMod</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>||</operator>
						<operator>(</operator><name>newTypMod</name> <operator>&gt;</operator> <name>curTypMod</name> <operator>&amp;&amp;</operator> <name>curTypMod</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"This ALTER TABLE command is not yet supported."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<break>break;</break>
				</block_content>}</block>

				<default>default:</default>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>newTypId</name> <operator>==</operator> <name>curTypId</name> <operator>&amp;&amp;</operator> <name>newTypMod</name> <operator>==</operator> <name>curTypMod</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* Types are the same, no changes will occur. */</comment>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
					<comment type="block">/* timestamp &lt;-&gt; timestamptz type change is allowed
						if no rewrite is needed */</comment>
					<if_stmt><if>if <condition>(<expr><name>curTypId</name> <operator>==</operator> <name>TIMESTAMPOID</name> <operator>&amp;&amp;</operator> <name>newTypId</name> <operator>==</operator> <name>TIMESTAMPTZOID</name> <operator>&amp;&amp;</operator>
						<operator>!</operator><call><name>TimestampTimestampTzRequiresRewrite</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>curTypId</name> <operator>==</operator> <name>TIMESTAMPTZOID</name> <operator>&amp;&amp;</operator> <name>newTypId</name> <operator>==</operator> <name>TIMESTAMPOID</name> <operator>&amp;&amp;</operator>
						<operator>!</operator><call><name>TimestampTimestampTzRequiresRewrite</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"This ALTER TABLE command is not yet supported."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
			</block_content>}</block></switch>
			<comment type="block">/*
			 * Do not allow collation update because that requires different collation
			 * encoding and therefore can cause on-disk changes.
			 */</comment>
			<decl_stmt><decl><type><name>Oid</name></type> <name>cur_collation_id</name> <init>= <expr><name><name>attTup</name><operator>-&gt;</operator><name>attcollation</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>new_collation_id</name> <init>= <expr><call><name>GetColumnDefCollation</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>colDef</name></expr></argument>, <argument><expr><name>newTypId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>cur_collation_id</name> <operator>!=</operator> <name>new_collation_id</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"This ALTER TABLE command is not yet supported."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>AT_AddIndex</name></expr>:</case>
		<case>case <expr><name>AT_AddConstraint</name></expr>:</case>
		<case>case <expr><name>AT_AddConstraintRecurse</name></expr>:</case>
		<case>case <expr><name>AT_DropConstraint</name></expr>:</case>
		<case>case <expr><name>AT_DropConstraintRecurse</name></expr>:</case>
		<case>case <expr><name>AT_DropOids</name></expr>:</case>
		<case>case <expr><name>AT_EnableTrig</name></expr>:</case>
		<case>case <expr><name>AT_EnableAlwaysTrig</name></expr>:</case>
		<case>case <expr><name>AT_EnableReplicaTrig</name></expr>:</case>
		<case>case <expr><name>AT_EnableTrigAll</name></expr>:</case>
		<case>case <expr><name>AT_EnableTrigUser</name></expr>:</case>
		<case>case <expr><name>AT_DisableTrig</name></expr>:</case>
		<case>case <expr><name>AT_DisableTrigAll</name></expr>:</case>
		<case>case <expr><name>AT_DisableTrigUser</name></expr>:</case>
		<case>case <expr><name>AT_ChangeOwner</name></expr>:</case>
		<case>case <expr><name>AT_ColumnDefault</name></expr>:</case>
		<case>case <expr><name>AT_DropNotNull</name></expr>:</case>
		<case>case <expr><name>AT_SetNotNull</name></expr>:</case>
		<case>case <expr><name>AT_AddIdentity</name></expr>:</case>
		<case>case <expr><name>AT_SetIdentity</name></expr>:</case>
		<case>case <expr><name>AT_DropIdentity</name></expr>:</case>
		<case>case <expr><name>AT_EnableRowSecurity</name></expr>:</case>
		<case>case <expr><name>AT_DisableRowSecurity</name></expr>:</case>
		<case>case <expr><name>AT_SetStatistics</name></expr>:</case>
		<case>case <expr><name>AT_ForceRowSecurity</name></expr>:</case>
		<case>case <expr><name>AT_NoForceRowSecurity</name></expr>:</case>
		<case>case <expr><name>AT_AttachPartition</name></expr>:</case>
		<case>case <expr><name>AT_DetachPartition</name></expr>:</case>
		<case>case <expr><name>AT_SetTableSpace</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>!=</operator> <name>AT_DropConstraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Excluding the ALTER ADD PRIMARY KEY use case as
			 * the operation will update schema version itself.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>yb_is_add_primary_key</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>handles</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * For these cases a YugaByte metadata does not need to be updated
			 * but we still need to increment the schema version.
			 */</comment>
			<decl_stmt><decl><type><name>ListCell</name><modifier>*</modifier></type> <name>handle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<macro><name>foreach</name><argument_list>(<argument>handle</argument>, <argument>handles</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>YBCPgStatement</name></type> <name>increment_schema_handle</name> <init>=
					<expr><operator>(</operator><name>YBCPgStatement</name><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(
					<argument><expr><call><name>YBCPgAlterTableIncrementSchemaVersion</name><argument_list>(
						<argument><expr><name>increment_schema_handle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<decl_stmt><decl><type><name>Relation</name></type> <name>dependent_rel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>YBCPgStatement</name></type> <name>alter_cmd_handle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<comment type="block">/*
			 * For attach and detach partition cases, assigning
			 * the partition table as dependent relation.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>==</operator> <name>AT_AttachPartition</name> <operator>||</operator>
				<name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>==</operator> <name>AT_DetachPartition</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>dependent_rel</name> <operator>=</operator> <call><name>heap_openrv</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>PartitionCmd</name> <operator>*</operator><operator>)</operator><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name><operator>)</operator><operator>-&gt;</operator><name>name</name></expr></argument>,
											<argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/*
				 * If the partition table is not YB supported table including
				 * foreign table, skip schema version increment.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsYBBackedRelation</name><argument_list>(<argument><expr><name>dependent_rel</name></expr></argument>)</argument_list></call> <operator>||</operator>
					<name><name>dependent_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>dependent_rel</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>dependent_rel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<comment type="block">/*
			 * For add foreign key case, assigning the primary key table
			 * as dependent relation.
			 */</comment>
			<if type="elseif">else if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>==</operator> <name>AT_AddConstraintRecurse</name> <operator>&amp;&amp;</operator>
					 <operator>(</operator><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name><operator>)</operator><operator>-&gt;</operator><name>contype</name> <operator>==</operator> <name>CONSTR_FOREIGN</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>dependent_rel</name> <operator>=</operator> <call><name>heap_openrv</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name><operator>)</operator><operator>-&gt;</operator><name>pktable</name></expr></argument>,
											<argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<comment type="block">/*
			 * For drop foreign key case, assigning the primary key table
			 * as dependent relation.
			 */</comment>
			<if type="elseif">else if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>==</operator> <name>AT_DropConstraintRecurse</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>HeapTuple</name></type> <name>reltup</name> <init>=
					<expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						 <argument><expr><literal type="string">"Cache lookup failed for relation %u"</literal></expr></argument>,
						  <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>relform</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>relform</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Oid</name></type> <name>constraint_oid</name> <init>= <expr><call><name>get_relation_constraint_oid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>,
																	 <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
																	 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(
						<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>constraint_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYSTEM_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Cache lookup failed for constraint %u"</literal></expr></argument>,
										<argument><expr><name>constraint_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>con</name> <init>=
						<expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/*
					 * Excluding the ALTER DROP PRIMARY KEY use case
					 * as the operation will update schema version itself.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTRAINT_PRIMARY</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>handles</name></expr>;</return></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTRAINT_FOREIGN</name> <operator>&amp;&amp;</operator>
						<name>relationId</name> <operator>!=</operator> <name><name>con</name><operator>-&gt;</operator><name>confrelid</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>dependent_rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>confrelid</name></name></expr></argument>,
												  <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<comment type="block">/*
			 * For add index case, assigning the table where index
			 * is built on as dependent relation.
			 */</comment>
			<if type="elseif">else if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>==</operator> <name>AT_AddIndex</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>index</name> <init>= <expr><operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>
				<comment type="block">/*
				 * Only allow adding indexes when it is a unique
				 * or primary key constraint
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>index</name><operator>-&gt;</operator><name>unique</name></name> <operator>||</operator> <name><name>index</name><operator>-&gt;</operator><name>primary</name></name><operator>)</operator> <operator>||</operator> <operator>!</operator><name><name>index</name><operator>-&gt;</operator><name>isconstraint</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"This ALTER TABLE command is"</literal>
									<literal type="string">" not yet supported."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>dependent_rel</name> <operator>=</operator> <call><name>heap_openrv</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
											<argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/*
			 * If dependent relation exists, apply increment schema version
			 * operation on the dependent relation.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>dependent_rel</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>dependent_rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(
					<argument><expr><call><name>YBCPgNewAlterTable</name><argument_list>(
						<argument><expr><call><name>YBCGetDatabaseOidByRelid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>YbGetStorageRelid</name><argument_list>(<argument><expr><name>dependent_rel</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>alter_cmd_handle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(
					<argument><expr><call><name>YBCPgAlterTableIncrementSchemaVersion</name><argument_list>(<argument><expr><name>alter_cmd_handle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>handles</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>handles</name></expr></argument>, <argument><expr><name>alter_cmd_handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>dependent_rel</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><operator>*</operator><name>needsYBAlter</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"This ALTER TABLE command is not yet supported."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>handles</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>List</name><modifier>*</modifier></type>
<name>YBCPrepareAlterTable</name><parameter_list>(<parameter><decl><type><name>List</name><modifier>*</modifier><modifier>*</modifier></type> <name>subcmds</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>subcmds_size</name></decl></parameter>,
					 <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
					 <parameter><decl><type><name>YBCPgStatement</name> <modifier>*</modifier></type><name>rollbackHandle</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>isPartitionOfAlteredTable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Appropriate lock was already taken */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsYBRelation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>handles</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YBCPgStatement</name></type> <name>db_handle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgNewAlterTable</name><argument_list>(<argument><expr><call><name>YBCGetDatabaseOidByRelid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>YbGetStorageRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>db_handle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>handles</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>handles</name></expr></argument>, <argument><expr><name>db_handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lcmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>col</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>needsYBAlter</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>cmd_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>cmd_idx</name> <operator>&lt;</operator> <name>subcmds_size</name></expr>;</condition> <incr><expr><operator>++</operator><name>cmd_idx</name></expr></incr>)</control>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>lcmd</argument>, <argument>subcmds[cmd_idx]</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>handles</name> <operator>=</operator> <call><name>YBCPrepareAlterTableCmd</name><argument_list>(
						<argument><expr><operator>(</operator><name>AlterTableCmd</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lcmd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>handles</name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>col</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>needsYBAlter</name></expr></argument>, <argument><expr><name>rollbackHandle</name></expr></argument>,
						<argument><expr><name>isPartitionOfAlteredTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>needsYBAlter</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>handles</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>YBCExecAlterTable</name><parameter_list>(<parameter><decl><type><name>YBCPgStatement</name></type> <name>handle</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>handle</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsYBRelationById</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgExecAlterTable</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>YBCRename</name><parameter_list>(<parameter><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>YBCPgStatement</name></type>	<name>handle</name>     <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>				<name>databaseId</name> <init>= <expr><call><name>YBCGetDatabaseOidByRelid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>		   <modifier>*</modifier></type><name>db_name</name>	   <init>= <expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>databaseId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>		<name>rel</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OBJECT_MATVIEW</name></expr>:</case>
			<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>RelationIdGetRelation</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgNewAlterTable</name><argument_list>(<argument><expr><name>databaseId</name></expr></argument>,
											  <argument><expr><call><name>YbGetStorageRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>handle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgAlterTableRenameTable</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>db_name</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_INDEX</name></expr>:</case>
		<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
			<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgNewAlterTable</name><argument_list>(<argument><expr><name>databaseId</name></expr></argument>,
											  <argument><expr><name>relationId</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>handle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgAlterTableRenameTable</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>db_name</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OBJECT_COLUMN</name></expr>:</case>
		<case>case <expr><name>OBJECT_ATTRIBUTE</name></expr>:</case>
			<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>RelationIdGetRelation</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgNewAlterTable</name><argument_list>(<argument><expr><name>databaseId</name></expr></argument>,
											  <argument><expr><call><name>YbGetStorageRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>handle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgAlterTableRenameColumn</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Renaming this object is not yet supported."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>YBCExecAlterTable</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>YBCDropIndex</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>YbTableProperties</name></type> <name>yb_props</name> <init>= <expr><call><name>YbTryGetTableProperties</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>yb_props</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Index was not found on YB side, nothing to do */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/*
	 * However, since we were likely hitting the cache, we still need to
	 * safeguard against NotFound errors.
	 */</comment>

	<decl_stmt><decl><type><name>YBCPgStatement</name></type> <name>handle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>indexId</name>      <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>databaseId</name>   <init>= <expr><call><name>YBCGetDatabaseOid</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Create table-level tombstone for colocated (via DB or tablegroup) indexes */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>yb_props</name><operator>-&gt;</operator><name>is_colocated</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>not_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>HandleYBStatusIgnoreNotFound</name><argument_list>(<argument><expr><call><name>YBCPgNewTruncateColocated</name><argument_list>(<argument><expr><name>databaseId</name></expr></argument>,
															   <argument><expr><name>indexId</name></expr></argument>,
															   <argument><expr><name>false</name></expr></argument>,
															   <argument><expr><name>false</name></expr></argument>,
															   <argument><expr><operator>&amp;</operator><name>handle</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>not_found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>valid_handle</name> <init>= <expr><operator>!</operator><name>not_found</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>valid_handle</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>HandleYBStatusIgnoreNotFound</name><argument_list>(<argument><expr><call><name>YBCPgDmlBindTable</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>not_found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>rows_affected_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>HandleYBStatusIgnoreNotFound</name><argument_list>(<argument><expr><call><name>YBCPgDmlExecWriteOp</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rows_affected_count</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>not_found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Drop the index table */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>not_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>HandleYBStatusIgnoreNotFound</name><argument_list>(<argument><expr><call><name>YBCPgNewDropIndex</name><argument_list>(<argument><expr><name>databaseId</name></expr></argument>,
													   <argument><expr><name>indexId</name></expr></argument>,
													   <argument><expr><name>false</name></expr></argument>, <comment type="block">/* if_exists */</comment>
													   <argument><expr><operator>&amp;</operator><name>handle</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>not_found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>valid_handle</name> <init>= <expr><operator>!</operator><name>not_found</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>valid_handle</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We cannot abort drop in DocDB so postpone the execution until
			 * the rest of the statement/txn is finished executing.
			 */</comment>
			<expr_stmt><expr><call><name>YBSaveDdlHandle</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>YbBackfillIndex</name><parameter_list>(<parameter><decl><type><name>BackfillIndexStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>indexInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>heapId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>indexId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>heapRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>indexRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupOutputState</name> <modifier>*</modifier></type><name>tstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YbPgExecOutParam</name> <modifier>*</modifier></type><name>out_param</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>save_userid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_sec_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_nestlevel</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><call><name>YBCGetGFlags</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>ysql_disable_index_backfill</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"backfill is not enabled"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Examine oid list.  Currently, we only allow it to be a single oid, but
	 * later it should handle multiple oids of indexes on the same indexed
	 * table.
	 * TODO(jason): fix from here downwards for issue #4785.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>oid_list</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only a single oid is allowed in BACKFILL INDEX (see"</literal>
						<literal type="string">" issue #4785)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>stmt-&gt;oid_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>indexId</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>heapId</name> <operator>=</operator> <call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="line">// TODO(jason): why ShareLock instead of ShareUpdateExclusiveLock?</comment>
	<expr_stmt><expr><name>heapRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>heapId</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Switch to the table owner's userid, so that any index functions are run
	 * as that user.  Also lock down security-restricted operations and
	 * arrange to make GUC variable changes local to this command.
	 */</comment>
	<expr_stmt><expr><call><name>GetUserIdAndSecContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>save_userid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_sec_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name><name>heapRel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relowner</name></name></expr></argument>,
						   <argument><expr><name>save_sec_context</name> <operator>|</operator> <name>SECURITY_RESTRICTED_OPERATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>save_nestlevel</name> <operator>=</operator> <call><name>NewGUCNestLevel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>indexRel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>indexInfo</name> <operator>=</operator> <call><name>BuildIndexInfo</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * The index should be ready for writes because it should be on the
	 * BACKFILLING permission.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ReadyForInserts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Concurrent</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_BrokenHotChain</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>out_param</name> <operator>=</operator> <call><name>YbCreateExecOutParam</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>index_backfill</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>,
				   <argument><expr><name>indexRel</name></expr></argument>,
				   <argument><expr><name>indexInfo</name></expr></argument>,
				   <argument><expr><name>false</name></expr></argument>,
				   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>bfinfo</name></name></expr></argument>,
				   <argument><expr><name>out_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Roll back any GUC changes executed by index functions */</comment>
	<expr_stmt><expr><call><name>AtEOXact_GUC</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>save_nestlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Restore userid and security context */</comment>
	<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name>save_userid</name></expr></argument>, <argument><expr><name>save_sec_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* output tuples */</comment>
	<expr_stmt><expr><name>tstate</name> <operator>=</operator> <call><name>begin_tup_output_tupdesc</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><call><name>YbBackfillIndexResultDesc</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>do_text_output_oneline</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>, <argument><expr><name><name>out_param</name><operator>-&gt;</operator><name>bfoutput</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>end_tup_output</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>TupleDesc</name></type> <name>YbBackfillIndexResultDesc</name><parameter_list>(<parameter><decl><type><name>BackfillIndexStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result_type</name> <init>= <expr><name>TEXTOID</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Need a tuple descriptor representing a single TEXT or XML column */</comment>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"BACKFILL SPEC"</literal></expr></argument>,
					   <argument><expr><name>result_type</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>tupdesc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>YbDropAndRecreateIndex</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>index_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>new_rel_id</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>old_rel</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>new_to_old_attmap</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>index_rel</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><name>index_oid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Construct the new CREATE INDEX stmt */</comment>

	<decl_stmt><decl><type><name>IndexStmt</name><modifier>*</modifier></type> <name>index_stmt</name> <init>= <expr><call><name>generateClonedIndexStmt</name><argument_list>(<argument><expr><name>NULL</name></expr></argument> <comment type="block">/* heapRel, we provide an oid instead */</comment>,
					<argument><expr><name>new_rel_id</name></expr></argument>,
					<argument><expr><name>index_rel</name></expr></argument>,
					<argument><expr><name>new_to_old_attmap</name></expr></argument>,
					<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>old_rel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>natts</name></expr></argument>,
					<argument><expr><name>NULL</name></expr></argument> <comment type="block">/* parent constraint OID pointer */</comment>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>index_name</name> <init>= <expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>index_rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>index_namespace_name</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>index_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>index_stmt</name><operator>-&gt;</operator><name>idxname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>index_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>index_rel</name></expr></argument>,  <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Drop old index */</comment>

	<decl_stmt><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>DropStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>removeType</name></name> <operator>=</operator> <name>OBJECT_INDEX</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>objects</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>index_namespace_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>index_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>behavior</name></name> <operator>=</operator> <name>DROP_CASCADE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RemoveRelations</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create the new index */</comment>

	<expr_stmt><expr><call><name>DefineIndex</name><argument_list>(<argument><expr><name>new_rel_id</name></expr></argument>,
				<argument><expr><name>index_stmt</name></expr></argument>,
				<argument><expr><name>InvalidOid</name></expr></argument>, <comment type="block">/* no predefined OID */</comment>
				<argument><expr><name>InvalidOid</name></expr></argument>, <comment type="block">/* no parent index */</comment>
				<argument><expr><name>InvalidOid</name></expr></argument>, <comment type="block">/* no parent constraint */</comment>
				<argument><expr><name>false</name></expr></argument>, <comment type="block">/* is_alter_table */</comment>
				<argument><expr><name>false</name></expr></argument>, <comment type="block">/* check_rights */</comment>
				<argument><expr><name>false</name></expr></argument>, <comment type="block">/* check_not_in_use */</comment>
				<argument><expr><name>false</name></expr></argument>, <comment type="block">/* skip_build */</comment>
				<argument><expr><name>true</name></expr></argument> <comment type="block">/* quiet */</comment>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ------------------------------------------------------------------------- */</comment>
<comment type="block">/*  System validation. */</comment>
<function><type><name>void</name></type>
<name>YBCValidatePlacement</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>placement_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgValidatePlacement</name><argument_list>(<argument><expr><name>placement_info</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
