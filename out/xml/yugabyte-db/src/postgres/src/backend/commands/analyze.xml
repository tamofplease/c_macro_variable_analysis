<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/commands/analyze.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * analyze.c
 *	  the Postgres statistics generator
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/commands/analyze.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/multixact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupconvert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tuptoaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/visibilitymap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/yb_scan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_statistic_ext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/vacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/fdwapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_oper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/autovacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"statistics/extended_stats_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"statistics/statistics.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/attoptcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_rusage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/sampling.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/sortsupport.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>


<comment type="block">/* Per-index data for ANALYZE */</comment>
<typedef>typedef <type><struct>struct <name>AnlIndexData</name>
<block>{
	<decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>indexInfo</name></decl>;</decl_stmt>		<comment type="block">/* BuildIndexInfo result */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>tupleFract</name></decl>;</decl_stmt>		<comment type="block">/* fraction of rows for partial index */</comment>
	<decl_stmt><decl><type><name>VacAttrStats</name> <modifier>*</modifier><modifier>*</modifier></type><name>vacattrstats</name></decl>;</decl_stmt>	<comment type="block">/* index attrs to analyze */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>attr_cnt</name></decl>;</decl_stmt>
}</block></struct></type> <name>AnlIndexData</name>;</typedef>


<comment type="block">/* Default statistics target (GUC parameter) */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>default_statistics_target</name> <init>= <expr><literal type="number">100</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* A few variables that don't seem worth passing around as parameters */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>anl_context</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>BufferAccessStrategy</name></type> <name>vac_strategy</name></decl>;</decl_stmt>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>do_analyze_rel</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>,
			   <parameter><decl><type><name>VacuumParams</name> <modifier>*</modifier></type><name>params</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>va_cols</name></decl></parameter>,
			   <parameter><decl><type><name>AcquireSampleRowsFunc</name></type> <name>acquirefunc</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>relpages</name></decl></parameter>,
			   <parameter><decl><type><name>bool</name></type> <name>inh</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>in_outer_xact</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>compute_index_stats</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>totalrows</name></decl></parameter>,
					<parameter><decl><type><name>AnlIndexData</name> <modifier>*</modifier></type><name>indexdata</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nindexes</name></decl></parameter>,
					<parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numrows</name></decl></parameter>,
					<parameter><decl><type><name>MemoryContext</name></type> <name>col_context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>VacAttrStats</name> <modifier>*</modifier></type><name>examine_attribute</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>,
				  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>index_expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>acquire_sample_rows</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>,
					<parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targrows</name></decl></parameter>,
					<parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totalrows</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totaldeadrows</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>compare_rows</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>acquire_inherited_sample_rows</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>,
							  <parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targrows</name></decl></parameter>,
							  <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totalrows</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totaldeadrows</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>yb_acquire_sample_rows</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>,
					   <parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targrows</name></decl></parameter>,
					   <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totalrows</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totaldeadrows</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>update_attstats</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inh</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>natts</name></decl></parameter>, <parameter><decl><type><name>VacAttrStats</name> <modifier>*</modifier><modifier>*</modifier></type><name>vacattrstats</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>std_fetch_func</name><parameter_list>(<parameter><decl><type><name>VacAttrStatsP</name></type> <name>stats</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rownum</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>ind_fetch_func</name><parameter_list>(<parameter><decl><type><name>VacAttrStatsP</name></type> <name>stats</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rownum</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 *	analyze_rel() -- analyze one relation
 *
 * relid identifies the relation to analyze.  If relation is supplied, use
 * the name therein for reporting any failure to open/lock the rel; do not
 * use it once we've successfully opened the rel, since it might be stale.
 */</comment>
<function><type><name>void</name></type>
<name>analyze_rel</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>,
			<parameter><decl><type><name>VacuumParams</name> <modifier>*</modifier></type><name>params</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>va_cols</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>in_outer_xact</name></decl></parameter>,
			<parameter><decl><type><name>BufferAccessStrategy</name></type> <name>bstrategy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>onerel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>elevel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AcquireSampleRowsFunc</name></type> <name>acquirefunc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>relpages</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>rel_lock</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Select logging level */</comment>
	<if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>VACOPT_VERBOSE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>INFO</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>DEBUG2</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Set up static variables */</comment>
	<expr_stmt><expr><name>vac_strategy</name> <operator>=</operator> <name>bstrategy</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check for user-requested abort.
	 */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Open the relation, getting ShareUpdateExclusiveLock to ensure that two
	 * ANALYZEs don't run on it concurrently.  (This also locks out a
	 * concurrent VACUUM, which doesn't matter much at the moment but might
	 * matter if we ever try to accumulate stats on dead tuples.) If the rel
	 * has been dropped since we last saw it, we don't need to process it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>VACOPT_NOWAIT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>onerel</name> <operator>=</operator> <call><name>try_relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>ConditionalLockRelationOid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>onerel</name> <operator>=</operator> <call><name>try_relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>onerel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rel_lock</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If we failed to open or lock the relation, emit a log message before
	 * exiting.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>onerel</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the RangeVar is not defined, we do not have enough information
		 * to provide a meaningful log statement.  Chances are that
		 * analyze_rel's caller has intentionally not provided this
		 * information so that this logging is skipped, anyway.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>relation</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Determine the log level.  For autovacuum logs, we emit a LOG if
		 * log_autovacuum_min_duration is not disabled.  For manual ANALYZE,
		 * we emit a WARNING to match the log statements in the permissions
		 * checks.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>WARNING</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>log_min_duration</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>LOG</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return;</return></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rel_lock</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_LOCK_NOT_AVAILABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping analyze of \"%s\" --- lock not available"</literal></expr></argument>,
							<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping analyze of \"%s\" --- relation no longer exists"</literal></expr></argument>,
							<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check permissions --- this should match vacuum's check!
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
		  <operator>(</operator><call><name>pg_database_ownercheck</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relisshared</name></name><operator>)</operator><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No need for a WARNING if we already complained during VACUUM */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relisshared</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping \"%s\" --- only superuser can analyze it"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnamespace</name></name> <operator>==</operator> <name>PG_CATALOG_NAMESPACE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping \"%s\" --- only superuser or database owner can analyze it"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping \"%s\" --- only table or database owner can analyze it"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Silently ignore tables that are temp tables of other backends ---
	 * trying to analyze these is rather pointless, since their contents are
	 * probably not up-to-date on disk.  (We don't throw a warning here; it
	 * would just lead to chatter during a database-wide ANALYZE.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We can ANALYZE any table except pg_statistic. See update_attstats
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>StatisticRelationId</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check that it's of an analyzable relkind, and set up appropriately.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsYBRelation</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>acquirefunc</name> <operator>=</operator> <name>yb_acquire_sample_rows</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>relpages</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
			 <name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Regular table, so we'll use the regular row acquisition function */</comment>
		<expr_stmt><expr><name>acquirefunc</name> <operator>=</operator> <name>acquire_sample_rows</name></expr>;</expr_stmt>
		<comment type="block">/* Also get regular table's size */</comment>
		<expr_stmt><expr><name>relpages</name> <operator>=</operator> <call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For a foreign table, call the FDW's hook function to see whether it
		 * supports analysis.
		 */</comment>
		<decl_stmt><decl><type><name>FdwRoutine</name> <modifier>*</modifier></type><name>fdwroutine</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>ok</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>fdwroutine</name> <operator>=</operator> <call><name>GetFdwRoutineForRelation</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>AnalyzeForeignTable</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name><name>fdwroutine</name><operator>-&gt;</operator><name>AnalyzeForeignTable</name></name><argument_list>(<argument><expr><name>onerel</name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>acquirefunc</name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>relpages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping \"%s\" --- cannot analyze this foreign table"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For partitioned tables, we want to do the recursive ANALYZE below.
		 */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* No need for a WARNING if we already complained during VACUUM */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping \"%s\" --- cannot analyze non-tables or special system tables"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * OK, let's do it.  First let other backends know I'm in ANALYZE.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>vacuumFlags</name></name> <operator>|=</operator> <name>PROC_IN_ANALYZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do the normal non-recursive ANALYZE.  We can skip this for partitioned
	 * tables, which don't contain any rows.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>do_analyze_rel</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>va_cols</name></expr></argument>, <argument><expr><name>acquirefunc</name></expr></argument>,
					   <argument><expr><name>relpages</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>in_outer_xact</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If there are child tables, do recursive ANALYZE.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhassubclass</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>do_analyze_rel</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>va_cols</name></expr></argument>, <argument><expr><name>acquirefunc</name></expr></argument>, <argument><expr><name>relpages</name></expr></argument>,
					   <argument><expr><name>true</name></expr></argument>, <argument><expr><name>in_outer_xact</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Close source relation now, but keep lock so that no one deletes it
	 * before we commit.  (If someone did, they'd fail to clean up the entries
	 * we made in pg_statistic.  Also, releasing the lock before commit would
	 * expose us to concurrent-update failures in update_attstats.)
	 */</comment>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reset my PGXACT flag.  Note: we need this here, and not in vacuum_rel,
	 * because the vacuum flag is cleared by the end-of-xact code.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>vacuumFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>PROC_IN_ANALYZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	do_analyze_rel() -- analyze one relation, recursively or not
 *
 * Note that "acquirefunc" is only relevant for the non-inherited case.
 * For the inherited case, acquire_inherited_sample_rows() determines the
 * appropriate acquirefunc for each child table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>do_analyze_rel</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>VacuumParams</name> <modifier>*</modifier></type><name>params</name></decl></parameter>,
			   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>va_cols</name></decl></parameter>, <parameter><decl><type><name>AcquireSampleRowsFunc</name></type> <name>acquirefunc</name></decl></parameter>,
			   <parameter><decl><type><name>BlockNumber</name></type> <name>relpages</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inh</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>in_outer_xact</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>attr_cnt</name></decl>,
				<decl><type ref="prev"/><name>tcnt</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>,
				<decl><type ref="prev"/><name>ind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name>   <modifier>*</modifier></type><name>Irel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nindexes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasindex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VacAttrStats</name> <modifier>*</modifier><modifier>*</modifier></type><name>vacattrstats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AnlIndexData</name> <modifier>*</modifier></type><name>indexdata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>targrows</name></decl>,
				<decl><type ref="prev"/><name>numrows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>totalrows</name></decl>,
				<decl><type ref="prev"/><name>totaldeadrows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name>  <modifier>*</modifier></type><name>rows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGRUsage</name></type>	<name>ru0</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>starttime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>caller_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>save_userid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_sec_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_nestlevel</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>inh</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"analyzing \"%s.%s\" inheritance tree"</literal></expr></argument>,
						<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"analyzing \"%s.%s\""</literal></expr></argument>,
						<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Set up a working context so that we can easily free whatever junk gets
	 * created.
	 */</comment>
	<expr_stmt><expr><name>anl_context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr></argument>,
										<argument><expr><literal type="string">"Analyze"</literal></expr></argument>,
										<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>caller_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>anl_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Switch to the table owner's userid, so that any index functions are run
	 * as that user.  Also lock down security-restricted operations and
	 * arrange to make GUC variable changes local to this command.
	 */</comment>
	<expr_stmt><expr><call><name>GetUserIdAndSecContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>save_userid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_sec_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relowner</name></name></expr></argument>,
						   <argument><expr><name>save_sec_context</name> <operator>|</operator> <name>SECURITY_RESTRICTED_OPERATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>save_nestlevel</name> <operator>=</operator> <call><name>NewGUCNestLevel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* measure elapsed time iff autovacuum logging requires it */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>params</name><operator>-&gt;</operator><name>log_min_duration</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_rusage_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ru0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>log_min_duration</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>starttime</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Determine which columns to analyze
	 *
	 * Note that system attributes are never analyzed, so we just reject them
	 * at the lookup stage.  We also reject duplicate column mentions.  (We
	 * could alternatively ignore duplicates, but analyzing a column twice
	 * won't work; we'd end up making a conflicting update in pg_statistic.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>va_cols</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>unique_cols</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>vacattrstats</name> <operator>=</operator> <operator>(</operator><name>VacAttrStats</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>va_cols</name></expr></argument>)</argument_list></call> <operator>*</operator>
												<sizeof>sizeof<argument_list>(<argument><expr><name>VacAttrStats</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tcnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>le</argument>, <argument>va_cols</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>col</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>attnameAttNum</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>col</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
								<argument><expr><name>col</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>unique_cols</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" appears more than once"</literal></expr></argument>,
								<argument><expr><name>col</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>unique_cols</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>unique_cols</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>vacattrstats</name><index>[<expr><name>tcnt</name></expr>]</index></name> <operator>=</operator> <call><name>examine_attribute</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>vacattrstats</name><index>[<expr><name>tcnt</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>tcnt</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><name>attr_cnt</name> <operator>=</operator> <name>tcnt</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>attr_cnt</name> <operator>=</operator> <name><name>onerel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>vacattrstats</name> <operator>=</operator> <operator>(</operator><name>VacAttrStats</name> <operator>*</operator><operator>*</operator><operator>)</operator>
			<call><name>palloc</name><argument_list>(<argument><expr><name>attr_cnt</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>VacAttrStats</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tcnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>attr_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>vacattrstats</name><index>[<expr><name>tcnt</name></expr>]</index></name> <operator>=</operator> <call><name>examine_attribute</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>vacattrstats</name><index>[<expr><name>tcnt</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>tcnt</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name>attr_cnt</name> <operator>=</operator> <name>tcnt</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Open all indexes of the relation, and see if there are any analyzable
	 * columns in the indexes.  We do not analyze index columns if there was
	 * an explicit column list in the ANALYZE command, however.  If we are
	 * doing a recursive scan, we don't want to touch the parent's indexes at
	 * all.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>inh</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>vac_open_indexes</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nindexes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Irel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>Irel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nindexes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>hasindex</name> <operator>=</operator> <operator>(</operator><name>nindexes</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>indexdata</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>hasindex</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>indexdata</name> <operator>=</operator> <operator>(</operator><name>AnlIndexData</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nindexes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AnlIndexData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>ind</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ind</name> <operator>&lt;</operator> <name>nindexes</name></expr>;</condition> <incr><expr><name>ind</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AnlIndexData</name> <modifier>*</modifier></type><name>thisdata</name> <init>= <expr><operator>&amp;</operator><name><name>indexdata</name><index>[<expr><name>ind</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>indexInfo</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>thisdata</name><operator>-&gt;</operator><name>indexInfo</name></name> <operator>=</operator> <name>indexInfo</name> <operator>=</operator> <call><name>BuildIndexInfo</name><argument_list>(<argument><expr><name><name>Irel</name><index>[<expr><name>ind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>thisdata</name><operator>-&gt;</operator><name>tupleFract</name></name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt> <comment type="block">/* fix later if partial */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Expressions</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name>va_cols</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>indexpr_item</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Expressions</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>thisdata</name><operator>-&gt;</operator><name>vacattrstats</name></name> <operator>=</operator> <operator>(</operator><name>VacAttrStats</name> <operator>*</operator><operator>*</operator><operator>)</operator>
					<call><name>palloc</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexAttrs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>VacAttrStats</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>tcnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexAttrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>keycol</name> <init>= <expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_IndexAttrNumbers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>keycol</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* Found an index expression */</comment>
						<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>indexkey</name></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name>indexpr_item</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* shouldn't happen */</comment>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too few entries in indexprs list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>indexkey</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>indexpr_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>indexpr_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>indexpr_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>thisdata</name><operator>-&gt;</operator><name>vacattrstats</name><index>[<expr><name>tcnt</name></expr>]</index></name> <operator>=</operator>
							<call><name>examine_attribute</name><argument_list>(<argument><expr><name><name>Irel</name><index>[<expr><name>ind</name></expr>]</index></name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>indexkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name><name>thisdata</name><operator>-&gt;</operator><name>vacattrstats</name><index>[<expr><name>tcnt</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>tcnt</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
				<expr_stmt><expr><name><name>thisdata</name><operator>-&gt;</operator><name>attr_cnt</name></name> <operator>=</operator> <name>tcnt</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Determine how many rows we need to sample, using the worst case from
	 * all analyzable columns.  We use a lower bound of 100 rows to avoid
	 * possible overflow in Vitter's algorithm.  (Note: that will also be the
	 * target in the corner case where there are no analyzable columns.)
	 */</comment>
	<expr_stmt><expr><name>targrows</name> <operator>=</operator> <literal type="number">100</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>attr_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>targrows</name> <operator>&lt;</operator> <name><name>vacattrstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>minrows</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>targrows</name> <operator>=</operator> <name><name>vacattrstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>minrows</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<for>for <control>(<init><expr><name>ind</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ind</name> <operator>&lt;</operator> <name>nindexes</name></expr>;</condition> <incr><expr><name>ind</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AnlIndexData</name> <modifier>*</modifier></type><name>thisdata</name> <init>= <expr><operator>&amp;</operator><name><name>indexdata</name><index>[<expr><name>ind</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>thisdata</name><operator>-&gt;</operator><name>attr_cnt</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>targrows</name> <operator>&lt;</operator> <name><name>thisdata</name><operator>-&gt;</operator><name>vacattrstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>minrows</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>targrows</name> <operator>=</operator> <name><name>thisdata</name><operator>-&gt;</operator><name>vacattrstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>minrows</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Acquire the sample rows
	 */</comment>
	<expr_stmt><expr><name>rows</name> <operator>=</operator> <operator>(</operator><name>HeapTuple</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>targrows</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HeapTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>inh</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>numrows</name> <operator>=</operator> <call><name>acquire_inherited_sample_rows</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>,
												<argument><expr><name>rows</name></expr></argument>, <argument><expr><name>targrows</name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>totalrows</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>totaldeadrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>numrows</name> <operator>=</operator> <call>(<modifier>*</modifier><name>acquirefunc</name>) <argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>,
								  <argument><expr><name>rows</name></expr></argument>, <argument><expr><name>targrows</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>totalrows</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>totaldeadrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Compute the statistics.  Temporary results during the calculations for
	 * each column are stored in a child context.  The calc routines are
	 * responsible to make sure that whatever they store into the VacAttrStats
	 * structure is allocated in anl_context.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numrows</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>col_context</name></decl>,
					<decl><type ref="prev"/><name>old_context</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>col_context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>anl_context</name></expr></argument>,
											<argument><expr><literal type="string">"Analyze Column"</literal></expr></argument>,
											<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>col_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>attr_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>VacAttrStats</name> <modifier>*</modifier></type><name>stats</name> <init>= <expr><name><name>vacattrstats</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AttributeOpts</name> <modifier>*</modifier></type><name>aopt</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name>rows</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>=</operator> <name><name>onerel</name><operator>-&gt;</operator><name>rd_att</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name><name>stats</name><operator>-&gt;</operator><name>compute_stats</name></name><argument_list>(<argument><expr><name>stats</name></expr></argument>,
								 <argument><expr><name>std_fetch_func</name></expr></argument>,
								 <argument><expr><name>numrows</name></expr></argument>,
								 <argument><expr><name>totalrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If the appropriate flavor of the n_distinct option is
			 * specified, override with the corresponding value.
			 */</comment>
			<expr_stmt><expr><name>aopt</name> <operator>=</operator> <call><name>get_attribute_options</name><argument_list>(<argument><expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>aopt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>float8</name></type>		<name>n_distinct</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>n_distinct</name> <operator>=</operator> <ternary><condition><expr><name>inh</name></expr> ?</condition><then> <expr><name><name>aopt</name><operator>-&gt;</operator><name>n_distinct_inherited</name></name></expr> </then><else>: <expr><name><name>aopt</name><operator>-&gt;</operator><name>n_distinct</name></name></expr></else></ternary></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>n_distinct</name> <operator>!=</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <name>n_distinct</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name>col_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>hasindex</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>compute_index_stats</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>totalrows</name></expr></argument>,
								<argument><expr><name>indexdata</name></expr></argument>, <argument><expr><name>nindexes</name></expr></argument>,
								<argument><expr><name>rows</name></expr></argument>, <argument><expr><name>numrows</name></expr></argument>,
								<argument><expr><name>col_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>col_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Emit the completed stats rows into pg_statistic, replacing any
		 * previous statistics for the target columns. (If there are stats in
		 * pg_statistic for columns we didn't process, we leave them alone.)
		 */</comment>
		<expr_stmt><expr><call><name>update_attstats</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>inh</name></expr></argument>,
						<argument><expr><name>attr_cnt</name></expr></argument>, <argument><expr><name>vacattrstats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>ind</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ind</name> <operator>&lt;</operator> <name>nindexes</name></expr>;</condition> <incr><expr><name>ind</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AnlIndexData</name> <modifier>*</modifier></type><name>thisdata</name> <init>= <expr><operator>&amp;</operator><name><name>indexdata</name><index>[<expr><name>ind</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>update_attstats</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>Irel</name><index>[<expr><name>ind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							<argument><expr><name><name>thisdata</name><operator>-&gt;</operator><name>attr_cnt</name></name></expr></argument>, <argument><expr><name><name>thisdata</name><operator>-&gt;</operator><name>vacattrstats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Build extended statistics (if there are any). */</comment>
		<expr_stmt><expr><call><name>BuildRelationExtStatistics</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>totalrows</name></expr></argument>, <argument><expr><name>numrows</name></expr></argument>, <argument><expr><name>rows</name></expr></argument>, <argument><expr><name>attr_cnt</name></expr></argument>,
								   <argument><expr><name>vacattrstats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Update pages/tuples stats in pg_class ... but not if we're doing
	 * inherited stats.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>inh</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>relallvisible</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>visibilitymap_count</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relallvisible</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>vac_update_relstats</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>,
							<argument><expr><name>relpages</name></expr></argument>,
							<argument><expr><name>totalrows</name></expr></argument>,
							<argument><expr><name>relallvisible</name></expr></argument>,
							<argument><expr><name>hasindex</name></expr></argument>,
							<argument><expr><name>InvalidTransactionId</name></expr></argument>,
							<argument><expr><name>InvalidMultiXactId</name></expr></argument>,
							<argument><expr><name>in_outer_xact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Same for indexes. Vacuum always scans all indexes, so if we're part of
	 * VACUUM ANALYZE, don't overwrite the accurate count already inserted by
	 * VACUUM.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>inh</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>ind</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ind</name> <operator>&lt;</operator> <name>nindexes</name></expr>;</condition> <incr><expr><name>ind</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AnlIndexData</name> <modifier>*</modifier></type><name>thisdata</name> <init>= <expr><operator>&amp;</operator><name><name>indexdata</name><index>[<expr><name>ind</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>totalindexrows</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>totalindexrows</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name><name>thisdata</name><operator>-&gt;</operator><name>tupleFract</name></name> <operator>*</operator> <name>totalrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>vac_update_relstats</name><argument_list>(<argument><expr><name><name>Irel</name><index>[<expr><name>ind</name></expr>]</index></name></expr></argument>,
								<argument><expr><call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name><name>Irel</name><index>[<expr><name>ind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>totalindexrows</name></expr></argument>,
								<argument><expr><literal type="number">0</literal></expr></argument>,
								<argument><expr><name>false</name></expr></argument>,
								<argument><expr><name>InvalidTransactionId</name></expr></argument>,
								<argument><expr><name>InvalidMultiXactId</name></expr></argument>,
								<argument><expr><name>in_outer_xact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Report ANALYZE to the stats collector, too.  However, if doing
	 * inherited stats we shouldn't report, because the stats collector only
	 * tracks per-table stats.  Reset the changes_since_analyze counter only
	 * if we analyzed all columns; otherwise, there is still work for
	 * auto-analyze to do.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>inh</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgstat_report_analyze</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>totalrows</name></expr></argument>, <argument><expr><name>totaldeadrows</name></expr></argument>,
							  <argument><expr><operator>(</operator><name>va_cols</name> <operator>==</operator> <name>NIL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* If this isn't part of VACUUM ANALYZE, let index AMs do cleanup */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>ind</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ind</name> <operator>&lt;</operator> <name>nindexes</name></expr>;</condition> <incr><expr><name>ind</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type><name>stats</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>IndexVacuumInfo</name></type> <name>ivinfo</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>index</name></name> <operator>=</operator> <name><name>Irel</name><index>[<expr><name>ind</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>analyze_only</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>estimated_count</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>message_level</name></name> <operator>=</operator> <name>elevel</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>num_heap_tuples</name></name> <operator>=</operator> <name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltuples</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>strategy</name></name> <operator>=</operator> <name>vac_strategy</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>stats</name> <operator>=</operator> <call><name>index_vacuum_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ivinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>stats</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>stats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Done with indexes */</comment>
	<expr_stmt><expr><call><name>vac_close_indexes</name><argument_list>(<argument><expr><name>nindexes</name></expr></argument>, <argument><expr><name>Irel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Log the action if appropriate */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>params</name><operator>-&gt;</operator><name>log_min_duration</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>log_min_duration</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name>starttime</name></expr></argument>, <argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>,
									   <argument><expr><name><name>params</name><operator>-&gt;</operator><name>log_min_duration</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"automatic analyze of table \"%s.%s.%s\" system usage: %s"</literal></expr></argument>,
							<argument><expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>pg_rusage_show</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ru0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Roll back any GUC changes executed by index functions */</comment>
	<expr_stmt><expr><call><name>AtEOXact_GUC</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>save_nestlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Restore userid and security context */</comment>
	<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name>save_userid</name></expr></argument>, <argument><expr><name>save_sec_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Restore current context and release memory */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>caller_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>anl_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>anl_context</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Compute statistics about indexes of a relation
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compute_index_stats</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>totalrows</name></decl></parameter>,
					<parameter><decl><type><name>AnlIndexData</name> <modifier>*</modifier></type><name>indexdata</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nindexes</name></decl></parameter>,
					<parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numrows</name></decl></parameter>,
					<parameter><decl><type><name>MemoryContext</name></type> <name>col_context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>ind_context</name></decl>,
				<decl><type ref="prev"/><name>old_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>isnull</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ind</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ind_context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>anl_context</name></expr></argument>,
										<argument><expr><literal type="string">"Analyze Index"</literal></expr></argument>,
										<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ind_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>ind</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ind</name> <operator>&lt;</operator> <name>nindexes</name></expr>;</condition> <incr><expr><name>ind</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AnlIndexData</name> <modifier>*</modifier></type><name>thisdata</name> <init>= <expr><operator>&amp;</operator><name><name>indexdata</name><index>[<expr><name>ind</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>indexInfo</name> <init>= <expr><name><name>thisdata</name><operator>-&gt;</operator><name>indexInfo</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>attr_cnt</name> <init>= <expr><name><name>thisdata</name><operator>-&gt;</operator><name>attr_cnt</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>predicate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>exprvals</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>exprnulls</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>numindexrows</name></decl>,
					<decl><type ref="prev"/><name>tcnt</name></decl>,
					<decl><type ref="prev"/><name>rowno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>totalindexrows</name></decl>;</decl_stmt>

		<comment type="block">/* Ignore index if no columns to analyze and not partial */</comment>
		<if_stmt><if>if <condition>(<expr><name>attr_cnt</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Predicate</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Need an EState for evaluation of index expressions and
		 * partial-index predicates.  Create it in the per-index context to be
		 * sure it gets cleaned up at the bottom of the loop.
		 */</comment>
		<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Need a slot to hold the current heap tuple, too */</comment>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Arrange for econtext's scan tuple to be the tuple under test */</comment>
		<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

		<comment type="block">/* Set up execution state for predicate. */</comment>
		<expr_stmt><expr><name>predicate</name> <operator>=</operator> <call><name>ExecPrepareQual</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Predicate</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Compute and save index expression values */</comment>
		<expr_stmt><expr><name>exprvals</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numrows</name> <operator>*</operator> <name>attr_cnt</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>exprnulls</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numrows</name> <operator>*</operator> <name>attr_cnt</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>numindexrows</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>tcnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>rowno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>rowno</name> <operator>&lt;</operator> <name>numrows</name></expr>;</condition> <incr><expr><name>rowno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>heapTuple</name> <init>= <expr><name><name>rows</name><index>[<expr><name>rowno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>vacuum_delay_point</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Reset the per-tuple context each time, to reclaim any cruft
			 * left behind by evaluating the predicate or index expressions.
			 */</comment>
			<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Set up for predicate or expression evaluation */</comment>
			<expr_stmt><expr><call><name>ExecStoreHeapTuple</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* If index is partial, check predicate */</comment>
			<if_stmt><if>if <condition>(<expr><name>predicate</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecQual</name><argument_list>(<argument><expr><name>predicate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>numindexrows</name><operator>++</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>attr_cnt</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Evaluate the index row to compute expression values. We
				 * could do this by hand, but FormIndexDatum is convenient.
				 */</comment>
				<expr_stmt><expr><call><name>FormIndexDatum</name><argument_list>(<argument><expr><name>indexInfo</name></expr></argument>,
							   <argument><expr><name>slot</name></expr></argument>,
							   <argument><expr><name>estate</name></expr></argument>,
							   <argument><expr><name>values</name></expr></argument>,
							   <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Save just the columns we care about.  We copy the values
				 * into ind_context from the estate's per-tuple context.
				 */</comment>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>attr_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>VacAttrStats</name> <modifier>*</modifier></type><name>stats</name> <init>= <expr><name><name>thisdata</name><operator>-&gt;</operator><name>vacattrstats</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attnum</name></name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>isnull</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>exprvals</name><index>[<expr><name>tcnt</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>exprnulls</name><index>[<expr><name>tcnt</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name><name>exprvals</name><index>[<expr><name>tcnt</name></expr>]</index></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
												   <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>,
												   <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>exprnulls</name><index>[<expr><name>tcnt</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<expr_stmt><expr><name>tcnt</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Having counted the number of rows that pass the predicate in the
		 * sample, we can estimate the total number of rows in the index.
		 */</comment>
		<expr_stmt><expr><name><name>thisdata</name><operator>-&gt;</operator><name>tupleFract</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>numindexrows</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>numrows</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>totalindexrows</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name><name>thisdata</name><operator>-&gt;</operator><name>tupleFract</name></name> <operator>*</operator> <name>totalrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now we can compute the statistics for the expression columns.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>numindexrows</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>col_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>attr_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>VacAttrStats</name> <modifier>*</modifier></type><name>stats</name> <init>= <expr><name><name>thisdata</name><operator>-&gt;</operator><name>vacattrstats</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>AttributeOpts</name> <modifier>*</modifier></type><name>aopt</name> <init>=
				<expr><call><name>get_attribute_options</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attrelid</name></name></expr></argument>,
									  <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>exprvals</name></name> <operator>=</operator> <name>exprvals</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>exprnulls</name></name> <operator>=</operator> <name>exprnulls</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>rowstride</name></name> <operator>=</operator> <name>attr_cnt</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name><name>stats</name><operator>-&gt;</operator><name>compute_stats</name></name><argument_list>(<argument><expr><name>stats</name></expr></argument>,
									 <argument><expr><name>ind_fetch_func</name></expr></argument>,
									 <argument><expr><name>numindexrows</name></expr></argument>,
									 <argument><expr><name>totalindexrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If the n_distinct option is specified, it overrides the
				 * above computation.  For indices, we always use just
				 * n_distinct, not n_distinct_inherited.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>aopt</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>aopt</name><operator>-&gt;</operator><name>n_distinct</name></name> <operator>!=</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <name><name>aopt</name><operator>-&gt;</operator><name>n_distinct</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name>col_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* And clean up */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ind_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name>ind_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>ind_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * examine_attribute -- pre-analysis of a single column
 *
 * Determine whether the column is analyzable; if so, create and initialize
 * a VacAttrStats struct for it.  If not, return NULL.
 *
 * If index_expr isn't NULL, then we're trying to analyze an expression index,
 * and index_expr is the expression tree representing the column's data.
 */</comment>
<function><type><specifier>static</specifier> <name>VacAttrStats</name> <modifier>*</modifier></type>
<name>examine_attribute</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>index_expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>typtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VacAttrStats</name> <modifier>*</modifier></type><name>stats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ok</name></decl>;</decl_stmt>

	<comment type="block">/* Never analyze dropped columns */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Don't analyze column if user has specified not to */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Create the VacAttrStats struct.  Note that we only have a copy of the
	 * fixed fields of the pg_attribute tuple.
	 */</comment>
	<expr_stmt><expr><name>stats</name> <operator>=</operator> <operator>(</operator><name>VacAttrStats</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VacAttrStats</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name></name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ATTRIBUTE_FIXED_PART_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name></name></expr></argument>, <argument><expr><name>attr</name></expr></argument>, <argument><expr><name>ATTRIBUTE_FIXED_PART_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * When analyzing an expression index, believe the expression tree's type
	 * not the column datatype --- the latter might be the opckeytype storage
	 * type of the opclass, which is not interesting for our purposes.  (Note:
	 * if we did anything with non-expression index columns, we'd need to
	 * figure out where to get the correct type info from, but for now that's
	 * not a problem.)	It's not clear whether anyone will care about the
	 * typmod, but we store that too just in case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>index_expr</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtypid</name></name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>index_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtypmod</name></name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><name>index_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtypid</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtypmod</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>typtuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>,
								   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtypid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>typtuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtypid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name></name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>anl_context</name></name> <operator>=</operator> <name>anl_context</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>tupattnum</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * The fields describing the stats-&gt;stavalues[n] element types default to
	 * the type of the data being analyzed, but the type-specific typanalyze
	 * function can change them if it wants to store something else.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>STATISTIC_NUM_SLOTS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statypid</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrtypid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statyplen</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statypbyval</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statypalign</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Call the type-specific typanalyze function.  If none is specified, use
	 * std_typanalyze().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typanalyze</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>OidFunctionCall1</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typanalyze</name></name></expr></argument>,
										   <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>stats</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name>std_typanalyze</name><argument_list>(<argument><expr><name>stats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name> <operator>||</operator> <name><name>stats</name><operator>-&gt;</operator><name>compute_stats</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>stats</name><operator>-&gt;</operator><name>minrows</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>typtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>stats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>stats</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * acquire_sample_rows -- acquire a random sample of rows from the table
 *
 * Selected rows are returned in the caller-allocated array rows[], which
 * must have at least targrows entries.
 * The actual number of rows selected is returned as the function result.
 * We also estimate the total numbers of live and dead rows in the table,
 * and return them into *totalrows and *totaldeadrows, respectively.
 *
 * The returned list of tuples is in order by physical position in the table.
 * (We will rely on this later to derive correlation estimates.)
 *
 * As of May 2004 we use a new two-stage method:  Stage one selects up
 * to targrows random blocks (or all blocks, if there aren't so many).
 * Stage two scans these blocks and uses the Vitter algorithm to create
 * a random sample of targrows rows (or less, if there are less in the
 * sample of blocks).  The two stages are executed simultaneously: each
 * block is processed as soon as stage one returns its number and while
 * the rows are read stage two controls which ones are to be inserted
 * into the sample.
 *
 * Although every row has an equal chance of ending up in the final
 * sample, this sampling method is not perfect: not every possible
 * sample has an equal chance of being selected.  For large relations
 * the number of different blocks represented by the sample tends to be
 * too small.  We can live with that for now.  Improvements are welcome.
 *
 * An important property of this sampling method is that because we do
 * look at a statistically unbiased set of blocks, we should get
 * unbiased estimates of the average numbers of live and dead rows per
 * block.  The previous sampling method put too much credence in the row
 * density near the start of the table.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>acquire_sample_rows</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>,
					<parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targrows</name></decl></parameter>,
					<parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totalrows</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totaldeadrows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>numrows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* # rows now in reservoir */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>samplerows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* total # rows collected */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>liverows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* # live rows seen */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>deadrows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* # dead rows seen */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>rowstoskip</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* -1 means not set yet */</comment>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>totalblocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>OldestXmin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockSamplerData</name></type> <name>bs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReservoirStateData</name></type> <name>rstate</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>targrows</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>totalblocks</name> <operator>=</operator> <call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Need a cutoff xmin for HeapTupleSatisfiesVacuum */</comment>
	<expr_stmt><expr><name>OldestXmin</name> <operator>=</operator> <call><name>GetOldestXmin</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>PROCARRAY_FLAGS_VACUUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Prepare for sampling block numbers */</comment>
	<expr_stmt><expr><call><name>BlockSampler_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bs</name></expr></argument>, <argument><expr><name>totalblocks</name></expr></argument>, <argument><expr><name>targrows</name></expr></argument>, <argument><expr><call><name>random</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Prepare for sampling rows */</comment>
	<expr_stmt><expr><call><name>reservoir_init_selection_state</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rstate</name></expr></argument>, <argument><expr><name>targrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Outer loop over blocks to sample */</comment>
	<while>while <condition>(<expr><call><name>BlockSampler_HasMore</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bs</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>targblock</name> <init>= <expr><call><name>BlockSampler_Next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>targbuffer</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Page</name></type>		<name>targpage</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>targoffset</name></decl>,
					<decl><type ref="prev"/><name>maxoffset</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>vacuum_delay_point</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We must maintain a pin on the target page's buffer to ensure that
		 * the maxoffset value stays good (else concurrent VACUUM might delete
		 * tuples out from under us).  Hence, pin the page until we are done
		 * looking at it.  We also choose to hold sharelock on the buffer
		 * throughout --- we could release and re-acquire sharelock for each
		 * tuple, but since we aren't doing much work per tuple, the extra
		 * lock traffic is probably better avoided.
		 */</comment>
		<expr_stmt><expr><name>targbuffer</name> <operator>=</operator> <call><name>ReadBufferExtended</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>targblock</name></expr></argument>,
										<argument><expr><name>RBM_NORMAL</name></expr></argument>, <argument><expr><name>vac_strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>targbuffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>targpage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>targbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>maxoffset</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>targpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Inner loop over all tuples on the selected page */</comment>
		<for>for <control>(<init><expr><name>targoffset</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>targoffset</name> <operator>&lt;=</operator> <name>maxoffset</name></expr>;</condition> <incr><expr><name>targoffset</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>targtuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>sample_it</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>targpage</name></expr></argument>, <argument><expr><name>targoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We ignore unused and redirect line pointers.  DEAD line
			 * pointers should be counted as dead, because we need vacuum to
			 * run to get rid of them.  Note that this rule agrees with the
			 * way that heap_page_prune() counts things.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>ItemIdIsDead</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>deadrows</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>targtuple</name><operator>.</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>targblock</name></expr></argument>, <argument><expr><name>targoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>targtuple</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>targtuple</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>targpage</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>targtuple</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>targtuple</name><operator>.</operator><name>t_ybctid</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <name>NULL</name></expr>;</expr_stmt>

			<switch>switch <condition>(<expr><call><name>HeapTupleSatisfiesVacuum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targtuple</name></expr></argument>,
											 <argument><expr><name>OldestXmin</name></expr></argument>,
											 <argument><expr><name>targbuffer</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>HEAPTUPLE_LIVE</name></expr>:</case>
					<expr_stmt><expr><name>sample_it</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>liverows</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>HEAPTUPLE_DEAD</name></expr>:</case>
				<case>case <expr><name>HEAPTUPLE_RECENTLY_DEAD</name></expr>:</case>
					<comment type="block">/* Count dead and recently-dead rows */</comment>
					<expr_stmt><expr><name>deadrows</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>HEAPTUPLE_INSERT_IN_PROGRESS</name></expr>:</case>

					<comment type="block">/*
					 * Insert-in-progress rows are not counted.  We assume
					 * that when the inserting transaction commits or aborts,
					 * it will send a stats message to increment the proper
					 * count.  This works right only if that transaction ends
					 * after we finish analyzing the table; if things happen
					 * in the other order, its stats update will be
					 * overwritten by ours.  However, the error will be large
					 * only if the other transaction runs long enough to
					 * insert many tuples, so assuming it will finish after us
					 * is the safer option.
					 *
					 * A special case is that the inserting transaction might
					 * be our own.  In this case we should count and sample
					 * the row, to accommodate users who load a table and
					 * analyze it in one transaction.  (pgstat_report_analyze
					 * has to adjust the numbers we send to the stats
					 * collector to make this come out right.)
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name><name>targtuple</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>sample_it</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>liverows</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<break>break;</break>

				<case>case <expr><name>HEAPTUPLE_DELETE_IN_PROGRESS</name></expr>:</case>

					<comment type="block">/*
					 * We count and sample delete-in-progress rows the same as
					 * live ones, so that the stats counters come out right if
					 * the deleting transaction commits after us, per the same
					 * reasoning given above.
					 *
					 * If the delete was done by our own transaction, however,
					 * we must count the row as dead to make
					 * pgstat_report_analyze's stats adjustments come out
					 * right.  (Note: this works out properly when the row was
					 * both inserted and deleted in our xact.)
					 *
					 * The net effect of these choices is that we act as
					 * though an IN_PROGRESS transaction hasn't happened yet,
					 * except if it is our own transaction, which we assume
					 * has happened.
					 *
					 * This approach ensures that we behave sanely if we see
					 * both the pre-image and post-image rows for a row being
					 * updated by a concurrent transaction: we will sample the
					 * pre-image but not the post-image.  We also get sane
					 * results if the concurrent transaction never commits.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetUpdateXid</name><argument_list>(<argument><expr><name><name>targtuple</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>deadrows</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name>sample_it</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>liverows</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<break>break;</break>

				<default>default:</default>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected HeapTupleSatisfiesVacuum result"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>

			<if_stmt><if>if <condition>(<expr><name>sample_it</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * The first targrows sample rows are simply copied into the
				 * reservoir. Then we start replacing tuples in the sample
				 * until we reach the end of the relation.  This algorithm is
				 * from Jeff Vitter's paper (see full citation below). It
				 * works by repeatedly computing the number of tuples to skip
				 * before selecting a tuple, which replaces a randomly chosen
				 * element of the reservoir (current set of tuples).  At all
				 * times the reservoir is a true random sample of the tuples
				 * we've passed over so far, so when we fall off the end of
				 * the relation we're done.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>numrows</name> <operator>&lt;</operator> <name>targrows</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>rows</name><index>[<expr><name>numrows</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * t in Vitter's paper is the number of records already
					 * processed.  If we need to compute a new S value, we
					 * must use the not-yet-incremented value of samplerows as
					 * t.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>rowstoskip</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>rowstoskip</name> <operator>=</operator> <call><name>reservoir_get_next_S</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rstate</name></expr></argument>, <argument><expr><name>samplerows</name></expr></argument>, <argument><expr><name>targrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name>rowstoskip</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * Found a suitable tuple, so save it, replacing one
						 * old tuple at random
						 */</comment>
						<decl_stmt><decl><type><name>int</name></type>			<name>k</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>targrows</name> <operator>*</operator> <call><name>sampler_random_fract</name><argument_list>(<argument><expr><name><name>rstate</name><operator>.</operator><name>randstate</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>k</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>k</name> <operator>&lt;</operator> <name>targrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name><name>rows</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>rows</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><name>rowstoskip</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><name>samplerows</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Now release the lock and pin on the page */</comment>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>targbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * If we didn't find as many tuples as we wanted then we're done. No sort
	 * is needed, since they're already in order.
	 *
	 * Otherwise we need to sort the collected tuples by position
	 * (itempointer). It's not worth worrying about corner cases where the
	 * tuples are already sorted.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numrows</name> <operator>==</operator> <name>targrows</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>rows</name></expr></argument>, <argument><expr><name>numrows</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HeapTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>compare_rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Estimate total numbers of live and dead rows in relation, extrapolating
	 * on the assumption that the average tuple density in pages we didn't
	 * scan is the same as in the pages we did scan.  Since what we scanned is
	 * a random sample of the pages in the relation, this should be a good
	 * assumption.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>bs</name><operator>.</operator><name>m</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>totalrows</name> <operator>=</operator> <call><name>floor</name><argument_list>(<argument><expr><operator>(</operator><name>liverows</name> <operator>/</operator> <name><name>bs</name><operator>.</operator><name>m</name></name><operator>)</operator> <operator>*</operator> <name>totalblocks</name> <operator>+</operator> <literal type="number">0.5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>totaldeadrows</name> <operator>=</operator> <call><name>floor</name><argument_list>(<argument><expr><operator>(</operator><name>deadrows</name> <operator>/</operator> <name><name>bs</name><operator>.</operator><name>m</name></name><operator>)</operator> <operator>*</operator> <name>totalblocks</name> <operator>+</operator> <literal type="number">0.5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>totalrows</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>totaldeadrows</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Emit some interesting relation info
	 */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\": scanned %d of %u pages, "</literal>
					<literal type="string">"containing %.0f live rows and %.0f dead rows; "</literal>
					<literal type="string">"%d rows in sample, %.0f estimated total rows"</literal></expr></argument>,
					<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name><name>bs</name><operator>.</operator><name>m</name></name></expr></argument>, <argument><expr><name>totalblocks</name></expr></argument>,
					<argument><expr><name>liverows</name></expr></argument>, <argument><expr><name>deadrows</name></expr></argument>,
					<argument><expr><name>numrows</name></expr></argument>, <argument><expr><operator>*</operator><name>totalrows</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>numrows</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * qsort comparator for sorting rows[] array
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compare_rows</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ha</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>HeapTuple</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>hb</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>HeapTuple</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>ba</name> <init>= <expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ha</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>oa</name> <init>= <expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ha</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>bb</name> <init>= <expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hb</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>ob</name> <init>= <expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hb</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>ba</name> <operator>&lt;</operator> <name>bb</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>ba</name> <operator>&gt;</operator> <name>bb</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>oa</name> <operator>&lt;</operator> <name>ob</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>oa</name> <operator>&gt;</operator> <name>ob</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * acquire_inherited_sample_rows -- acquire sample rows from inheritance tree
 *
 * This has the same API as acquire_sample_rows, except that rows are
 * collected from all inheritance children as well as the specified table.
 * We fail and return zero if there are no inheritance children, or if all
 * children are foreign tables that don't support ANALYZE.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>acquire_inherited_sample_rows</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>,
							  <parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targrows</name></decl></parameter>,
							  <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totalrows</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totaldeadrows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tableOIDs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name>   <modifier>*</modifier></type><name>rels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AcquireSampleRowsFunc</name> <modifier>*</modifier></type><name>acquirefuncs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name>	   <modifier>*</modifier></type><name>relblocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>totalblocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numrows</name></decl>,
				<decl><type ref="prev"/><name>nrels</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_child</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Find all members of inheritance set.  We only need AccessShareLock on
	 * the children.
	 */</comment>
	<expr_stmt><expr><name>tableOIDs</name> <operator>=</operator>
		<call><name>find_all_inheritors</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check that there's at least one descendant, else fail.  This could
	 * happen despite analyze_rel's relhassubclass check, if table once had a
	 * child but no longer does.  In that case, we can clear the
	 * relhassubclass field so as not to make the same mistake again later.
	 * (This is safe because we hold ShareUpdateExclusiveLock.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>tableOIDs</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* CCI because we already updated the pg_class row in this command */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetRelationHasSubclass</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping analyze of \"%s.%s\" inheritance tree --- this inheritance tree contains no child tables"</literal></expr></argument>,
						<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Identify acquirefuncs to use, and count blocks in all the relations.
	 * The result could overflow BlockNumber, so we use double arithmetic.
	 */</comment>
	<expr_stmt><expr><name>rels</name> <operator>=</operator> <operator>(</operator><name>Relation</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>tableOIDs</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Relation</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>acquirefuncs</name> <operator>=</operator> <operator>(</operator><name>AcquireSampleRowsFunc</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>tableOIDs</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AcquireSampleRowsFunc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>relblocks</name> <operator>=</operator> <operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>tableOIDs</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>totalblocks</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>nrels</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>has_child</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>tableOIDs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>childOID</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>childrel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AcquireSampleRowsFunc</name></type> <name>acquirefunc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>relpages</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/* We already got the needed lock */</comment>
		<expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>childOID</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Ignore if temp table of another backend */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* ... but release the lock on it */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>childrel</name> <operator>!=</operator> <name>onerel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Check table type (MATVIEW can't happen, but might as well allow) */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>childrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
			<name><name>childrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Regular table, so use the regular row acquisition function */</comment>
			<expr_stmt><expr><name>acquirefunc</name> <operator>=</operator> <name>acquire_sample_rows</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>relpages</name> <operator>=</operator> <call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>childrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * For a foreign table, call the FDW's hook function to see
			 * whether it supports analysis.
			 */</comment>
			<decl_stmt><decl><type><name>FdwRoutine</name> <modifier>*</modifier></type><name>fdwroutine</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>ok</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>fdwroutine</name> <operator>=</operator> <call><name>GetFdwRoutineForRelation</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>AnalyzeForeignTable</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name><name>fdwroutine</name><operator>-&gt;</operator><name>AnalyzeForeignTable</name></name><argument_list>(<argument><expr><name>childrel</name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>acquirefunc</name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>relpages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* ignore, but release the lock on it */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>childrel</name> <operator>!=</operator> <name>onerel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * ignore, but release the lock on it.  don't try to unlock the
			 * passed-in relation
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>childrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>childrel</name> <operator>!=</operator> <name>onerel</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* OK, we'll process this child */</comment>
		<expr_stmt><expr><name>has_child</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rels</name><index>[<expr><name>nrels</name></expr>]</index></name> <operator>=</operator> <name>childrel</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>acquirefuncs</name><index>[<expr><name>nrels</name></expr>]</index></name> <operator>=</operator> <name>acquirefunc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relblocks</name><index>[<expr><name>nrels</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>relpages</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>totalblocks</name> <operator>+=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>relpages</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nrels</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If we don't have at least one child table to consider, fail.  If the
	 * relation is a partitioned table, it's not counted as a child table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>has_child</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping analyze of \"%s.%s\" inheritance tree --- this inheritance tree contains no analyzable child tables"</literal></expr></argument>,
						<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now sample rows from each relation, proportionally to its fraction of
	 * the total block count.  (This might be less than desirable if the child
	 * rels have radically different free-space percentages, but it's not
	 * clear that it's worth working harder.)
	 */</comment>
	<expr_stmt><expr><name>numrows</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>totalrows</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>totaldeadrows</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nrels</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>childrel</name> <init>= <expr><name><name>rels</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AcquireSampleRowsFunc</name></type> <name>acquirefunc</name> <init>= <expr><name><name>acquirefuncs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>childblocks</name> <init>= <expr><name><name>relblocks</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>childblocks</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>childtargrows</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>childtargrows</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>rint</name><argument_list>(<argument><expr><name>targrows</name> <operator>*</operator> <name>childblocks</name> <operator>/</operator> <name>totalblocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Make sure we don't overrun due to roundoff error */</comment>
			<expr_stmt><expr><name>childtargrows</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>childtargrows</name></expr></argument>, <argument><expr><name>targrows</name> <operator>-</operator> <name>numrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>childtargrows</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>childrows</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>double</name></type>		<name>trows</name></decl>,
							<decl><type ref="prev"/><name>tdrows</name></decl>;</decl_stmt>

				<comment type="block">/* Fetch a random sample of the child's rows */</comment>
				<expr_stmt><expr><name>childrows</name> <operator>=</operator> <call>(<modifier>*</modifier><name>acquirefunc</name>) <argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>,
											<argument><expr><name>rows</name> <operator>+</operator> <name>numrows</name></expr></argument>, <argument><expr><name>childtargrows</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>trows</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tdrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* We may need to convert from child's rowtype to parent's */</comment>
				<if_stmt><if>if <condition>(<expr><name>childrows</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>equalTupleDescs</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>map</name> <operator>=</operator> <call><name>convert_tuples_by_name</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>map</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

						<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>childrows</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
						<block>{<block_content>
							<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtup</name></decl>;</decl_stmt>

							<expr_stmt><expr><name>newtup</name> <operator>=</operator> <call><name>execute_attr_map_tuple</name><argument_list>(<argument><expr><name><name>rows</name><index>[<expr><name>numrows</name> <operator>+</operator> <name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name><name>rows</name><index>[<expr><name>numrows</name> <operator>+</operator> <name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>rows</name><index>[<expr><name>numrows</name> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <name>newtup</name></expr>;</expr_stmt>
						</block_content>}</block></for>
						<expr_stmt><expr><call><name>free_conversion_map</name><argument_list>(<argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* And add to counts */</comment>
				<expr_stmt><expr><name>numrows</name> <operator>+=</operator> <name>childrows</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>totalrows</name> <operator>+=</operator> <name>trows</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>totaldeadrows</name> <operator>+=</operator> <name>tdrows</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Note: we cannot release the child-table locks, since we may have
		 * pointers to their TOAST tables in the sampled rows.
		 */</comment>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>numrows</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * yb_acquire_sample_rows -- acquire a random sample of rows from the YB table
 *
 * This has the same API as acquire_sample_rows, and uses similar approach.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>yb_acquire_sample_rows</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>,
					   <parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targrows</name></decl></parameter>,
					   <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totalrows</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totaldeadrows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>YbSample</name></type>	<name>ybSample</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numrows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>targrows</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Prepare to take sample */</comment>
	<expr_stmt><expr><name>ybSample</name> <operator>=</operator> <call><name>ybBeginSample</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>targrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Loop over the table blocks until sample is selected */</comment>
	<while>while <condition>(<expr><call><name>ybSampleNextBlock</name><argument_list>(<argument><expr><name>ybSample</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>vacuum_delay_point</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Fetch selected rows */</comment>
	<expr_stmt><expr><name>numrows</name> <operator>=</operator> <call><name>ybFetchSample</name><argument_list>(<argument><expr><name>ybSample</name></expr></argument>, <argument><expr><name>rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get row counters */</comment>
	<expr_stmt><expr><operator>*</operator><name>totalrows</name> <operator>=</operator> <name><name>ybSample</name><operator>-&gt;</operator><name>liverows</name></name> <operator>+</operator> <name><name>ybSample</name><operator>-&gt;</operator><name>deadrows</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>totaldeadrows</name> <operator>=</operator> <name><name>ybSample</name><operator>-&gt;</operator><name>deadrows</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\": scanned, "</literal>
					<literal type="string">"%d rows in sample, %.0f estimated total rows"</literal></expr></argument>,
					<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>numrows</name></expr></argument>, <argument><expr><operator>*</operator><name>totalrows</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>numrows</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	update_attstats() -- update attribute statistics for one relation
 *
 *		Statistics are stored in several places: the pg_class row for the
 *		relation has stats about the whole relation, and there is a
 *		pg_statistic row for each (non-system) attribute that has ever
 *		been analyzed.  The pg_class values are updated by VACUUM, not here.
 *
 *		pg_statistic rows are just added or updated normally.  This means
 *		that pg_statistic will probably contain some deleted rows at the
 *		completion of a vacuum cycle, unless it happens to get vacuumed last.
 *
 *		To keep things simple, we punt for pg_statistic, and don't try
 *		to compute or store rows for pg_statistic itself in pg_statistic.
 *		This could possibly be made to work, but it's not worth the trouble.
 *		Note analyze_rel() has seen to it that we won't come here when
 *		vacuuming pg_statistic itself.
 *
 *		Note: there would be a race condition here if two backends could
 *		ANALYZE the same table concurrently.  Presently, we lock that out
 *		by taking a self-exclusive lock on the relation in analyze_rel().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>update_attstats</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inh</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>natts</name></decl></parameter>, <parameter><decl><type><name>VacAttrStats</name> <modifier>*</modifier><modifier>*</modifier></type><name>vacattrstats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>sd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attno</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>natts</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* nothing to do */</comment>

	<expr_stmt><expr><name>sd</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>StatisticRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>attno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attno</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>attno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>VacAttrStats</name> <modifier>*</modifier></type><name>stats</name> <init>= <expr><name><name>vacattrstats</name><index>[<expr><name>attno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>stup</name></decl>,
					<decl><type ref="prev"/><name>oldtup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
					<decl><type ref="prev"/><name>k</name></decl>,
					<decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_statistic</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>Natts_pg_statistic</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>replaces</name><index>[<expr><name>Natts_pg_statistic</name></expr>]</index></name></decl>;</decl_stmt>

		<comment type="block">/* Ignore attr if we weren't able to collect stats */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stats</name><operator>-&gt;</operator><name>stats_valid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Construct a new pg_statistic tuple
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Natts_pg_statistic</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_statistic_starelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_statistic_staattnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int16GetDatum</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_statistic_stainherit</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>inh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_statistic_stanullfrac</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Float4GetDatum</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_statistic_stawidth</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_statistic_stadistinct</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Float4GetDatum</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name>Anum_pg_statistic_stakind1</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>STATISTIC_NUM_SLOTS</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int16GetDatum</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>stakind</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* stakindN */</comment>
		</block_content>}</block></for>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name>Anum_pg_statistic_staop1</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>STATISTIC_NUM_SLOTS</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>staop</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* staopN */</comment>
		</block_content>}</block></for>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name>Anum_pg_statistic_stanumbers1</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>STATISTIC_NUM_SLOTS</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>nnum</name> <init>= <expr><name><name>stats</name><operator>-&gt;</operator><name>numnumbers</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>nnum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>numdatums</name> <init>= <expr><operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nnum</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arry</name></decl>;</decl_stmt>

				<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>nnum</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>numdatums</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <call><name>Float4GetDatum</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>stanumbers</name><index>[<expr><name>k</name></expr>]</index><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
				<comment type="block">/* XXX knows more than it should about type float4: */</comment>
				<expr_stmt><expr><name>arry</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><name>numdatums</name></expr></argument>, <argument><expr><name>nnum</name></expr></argument>,
									   <argument><expr><name>FLOAT4OID</name></expr></argument>,
									   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>float4</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>FLOAT4PASSBYVAL</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>arry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* stanumbersN */</comment>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name>Anum_pg_statistic_stavalues1</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>STATISTIC_NUM_SLOTS</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>stats</name><operator>-&gt;</operator><name>numvalues</name><index>[<expr><name>k</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arry</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>arry</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>stavalues</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>,
									   <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>numvalues</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>,
									   <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>statypid</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>,
									   <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>statyplen</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>,
									   <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>statypbyval</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>,
									   <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>statypalign</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>arry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* stavaluesN */</comment>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Is there already a pg_statistic tuple for this attribute? */</comment>
		<expr_stmt><expr><name>oldtup</name> <operator>=</operator> <call><name>SearchSysCache3</name><argument_list>(<argument><expr><name>STATRELATTINH</name></expr></argument>,
								 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>inh</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Yes, replace it */</comment>
			<expr_stmt><expr><name>stup</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>,
									 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>sd</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>values</name></expr></argument>,
									 <argument><expr><name>nulls</name></expr></argument>,
									 <argument><expr><name>replaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>sd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>stup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* No, insert new tuple */</comment>
			<expr_stmt><expr><name>stup</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>sd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>sd</name></expr></argument>, <argument><expr><name>stup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>stup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>sd</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Standard fetch function for use by compute_stats subroutines.
 *
 * This exists to provide some insulation between compute_stats routines
 * and the actual storage of the sample data.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>std_fetch_func</name><parameter_list>(<parameter><decl><type><name>VacAttrStatsP</name></type> <name>stats</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rownum</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><name><name>stats</name><operator>-&gt;</operator><name>tupattnum</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><name><name>stats</name><operator>-&gt;</operator><name>rows</name><index>[<expr><name>rownum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name> <init>= <expr><name><name>stats</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch function for analyzing index expressions.
 *
 * We have not bothered to construct index tuples, instead the data is
 * just in Datum arrays.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>ind_fetch_func</name><parameter_list>(<parameter><decl><type><name>VacAttrStatsP</name></type> <name>stats</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rownum</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* exprvals and exprnulls are already offset for proper column */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <name>rownum</name> <operator>*</operator> <name><name>stats</name><operator>-&gt;</operator><name>rowstride</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>exprnulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	<return>return <expr><name><name>stats</name><operator>-&gt;</operator><name>exprvals</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*==========================================================================
 *
 * Code below this point represents the "standard" type-specific statistics
 * analysis algorithms.  This code can be replaced on a per-data-type basis
 * by setting a nonzero value in pg_type.typanalyze.
 *
 *==========================================================================
 */</comment>


<comment type="block">/*
 * To avoid consuming too much memory during analysis and/or too much space
 * in the resulting pg_statistic rows, we ignore varlena datums that are wider
 * than WIDTH_THRESHOLD (after detoasting!).  This is legitimate for MCV
 * and distinct-value calculations since a wide value is unlikely to be
 * duplicated at all, much less be a most-common value.  For the same reason,
 * ignoring wide values will not affect our estimates of histogram bin
 * boundaries very much.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WIDTH_THRESHOLD</name></cpp:macro>  <cpp:value>1024</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>swapInt</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>do {int _tmp; _tmp=a; a=b; b=_tmp;} while(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>swapDatum</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>do {Datum _tmp; _tmp=a; a=b; b=_tmp;} while(0)</cpp:value></cpp:define>

<comment type="block">/*
 * Extra information used by the default analysis routines
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name></decl>;</decl_stmt>			<comment type="block">/* # of duplicates */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>first</name></decl>;</decl_stmt>			<comment type="block">/* values[] index of first occurrence */</comment>
}</block></struct></type> <name>ScalarMCVItem</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>SortSupport</name></type> <name>ssup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>tupnoLink</name></decl>;</decl_stmt>
}</block></struct></type> <name>CompareScalarsContext</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>compute_trivial_stats</name><parameter_list>(<parameter><decl><type><name>VacAttrStatsP</name></type> <name>stats</name></decl></parameter>,
					  <parameter><decl><type><name>AnalyzeAttrFetchFunc</name></type> <name>fetchfunc</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>samplerows</name></decl></parameter>,
					  <parameter><decl><type><name>double</name></type> <name>totalrows</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>compute_distinct_stats</name><parameter_list>(<parameter><decl><type><name>VacAttrStatsP</name></type> <name>stats</name></decl></parameter>,
					   <parameter><decl><type><name>AnalyzeAttrFetchFunc</name></type> <name>fetchfunc</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>samplerows</name></decl></parameter>,
					   <parameter><decl><type><name>double</name></type> <name>totalrows</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>compute_scalar_stats</name><parameter_list>(<parameter><decl><type><name>VacAttrStatsP</name></type> <name>stats</name></decl></parameter>,
					 <parameter><decl><type><name>AnalyzeAttrFetchFunc</name></type> <name>fetchfunc</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>samplerows</name></decl></parameter>,
					 <parameter><decl><type><name>double</name></type> <name>totalrows</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>compare_scalars</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>compare_mcvs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>analyze_mcv_list</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>mcv_counts</name></decl></parameter>,
				 <parameter><decl><type><name>int</name></type> <name>num_mcv</name></decl></parameter>,
				 <parameter><decl><type><name>double</name></type> <name>stadistinct</name></decl></parameter>,
				 <parameter><decl><type><name>double</name></type> <name>stanullfrac</name></decl></parameter>,
				 <parameter><decl><type><name>int</name></type> <name>samplerows</name></decl></parameter>,
				 <parameter><decl><type><name>double</name></type> <name>totalrows</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * std_typanalyze -- the default type-specific typanalyze function
 */</comment>
<function><type><name>bool</name></type>
<name>std_typanalyze</name><parameter_list>(<parameter><decl><type><name>VacAttrStats</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ltopr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>eqopr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StdAnalyzeData</name> <modifier>*</modifier></type><name>mystats</name></decl>;</decl_stmt>

	<comment type="block">/* If the attstattarget column is negative, use the default value */</comment>
	<comment type="block">/* NB: it is okay to scribble on stats-&gt;attr since it's a copy */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name> <operator>=</operator> <name>default_statistics_target</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Look for default "&lt;" and "=" operators for column's type */</comment>
	<expr_stmt><expr><call><name>get_sort_group_operators</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtypid</name></name></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>ltopr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eqopr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Save the operator info for compute_stats routines */</comment>
	<expr_stmt><expr><name>mystats</name> <operator>=</operator> <operator>(</operator><name>StdAnalyzeData</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>StdAnalyzeData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mystats</name><operator>-&gt;</operator><name>eqopr</name></name> <operator>=</operator> <name>eqopr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mystats</name><operator>-&gt;</operator><name>eqfunc</name></name> <operator>=</operator> <ternary><condition><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>eqopr</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>get_opcode</name><argument_list>(<argument><expr><name>eqopr</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>InvalidOid</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mystats</name><operator>-&gt;</operator><name>ltopr</name></name> <operator>=</operator> <name>ltopr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>extra_data</name></name> <operator>=</operator> <name>mystats</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Determine which standard statistics algorithm to use
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>eqopr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>ltopr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Seems to be a scalar datatype */</comment>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>compute_stats</name></name> <operator>=</operator> <name>compute_scalar_stats</name></expr>;</expr_stmt>
		<comment type="block">/*--------------------
		 * The following choice of minrows is based on the paper
		 * "Random sampling for histogram construction: how much is enough?"
		 * by Surajit Chaudhuri, Rajeev Motwani and Vivek Narasayya, in
		 * Proceedings of ACM SIGMOD International Conference on Management
		 * of Data, 1998, Pages 436-447.  Their Corollary 1 to Theorem 5
		 * says that for table size n, histogram size k, maximum relative
		 * error in bin size f, and error probability gamma, the minimum
		 * random sample size is
		 *		r = 4 * k * ln(2*n/gamma) / f^2
		 * Taking f = 0.5, gamma = 0.01, n = 10^6 rows, we obtain
		 *		r = 305.82 * k
		 * Note that because of the log function, the dependence on n is
		 * quite weak; even at n = 10^12, a 300*k sample gives &lt;= 0.66
		 * bin size error with probability 0.99.  So there's no real need to
		 * scale for n, which is a good thing because we don't necessarily
		 * know it at this point.
		 *--------------------
		 */</comment>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>minrows</name></name> <operator>=</operator> <literal type="number">300</literal> <operator>*</operator> <name><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>eqopr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We can still recognize distinct values */</comment>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>compute_stats</name></name> <operator>=</operator> <name>compute_distinct_stats</name></expr>;</expr_stmt>
		<comment type="block">/* Might as well use the same minrows as above */</comment>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>minrows</name></name> <operator>=</operator> <literal type="number">300</literal> <operator>*</operator> <name><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Can't do much but the trivial stuff */</comment>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>compute_stats</name></name> <operator>=</operator> <name>compute_trivial_stats</name></expr>;</expr_stmt>
		<comment type="block">/* Might as well use the same minrows as above */</comment>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>minrows</name></name> <operator>=</operator> <literal type="number">300</literal> <operator>*</operator> <name><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *	compute_trivial_stats() -- compute very basic column statistics
 *
 *	We use this when we cannot find a hash "=" operator for the datatype.
 *
 *	We determine the fraction of non-null rows and the average datum width.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compute_trivial_stats</name><parameter_list>(<parameter><decl><type><name>VacAttrStatsP</name></type> <name>stats</name></decl></parameter>,
					  <parameter><decl><type><name>AnalyzeAttrFetchFunc</name></type> <name>fetchfunc</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>samplerows</name></decl></parameter>,
					  <parameter><decl><type><name>double</name></type> <name>totalrows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>null_cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nonnull_cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>total_width</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_varlena</name> <init>= <expr><operator>(</operator><operator>!</operator><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typbyval</name></name> <operator>&amp;&amp;</operator>
							  <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_varwidth</name> <init>= <expr><operator>(</operator><operator>!</operator><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typbyval</name></name> <operator>&amp;&amp;</operator>
							   <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>samplerows</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>vacuum_delay_point</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>fetchfunc</name><argument_list>(<argument><expr><name>stats</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Check for null/nonnull */</comment>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>null_cnt</name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>nonnull_cnt</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * If it's a variable-width field, add up widths for average width
		 * calculation.  Note that if the value is toasted, we use the toasted
		 * width.  We don't bother with this calculation if it's a fixed-width
		 * type.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>is_varlena</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>total_width</name> <operator>+=</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>is_varwidth</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* must be cstring */</comment>
			<expr_stmt><expr><name>total_width</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* We can only compute average width if we found some non-null values. */</comment>
	<if_stmt><if>if <condition>(<expr><name>nonnull_cnt</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stats_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<comment type="block">/* Do the simple null-frac and width stats */</comment>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>null_cnt</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>samplerows</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>is_varwidth</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <name>total_width</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>nonnull_cnt</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>	<comment type="block">/* "unknown" */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>null_cnt</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We found only nulls; assume the column is entirely null */</comment>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stats_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>is_varwidth</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* "unknown" */</comment>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>	<comment type="block">/* "unknown" */</comment>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *	compute_distinct_stats() -- compute column statistics including ndistinct
 *
 *	We use this when we can find only an "=" operator for the datatype.
 *
 *	We determine the fraction of non-null rows, the average width, the
 *	most common values, and the (estimated) number of distinct values.
 *
 *	The most common values are determined by brute force: we keep a list
 *	of previously seen values, ordered by number of times seen, as we scan
 *	the samples.  A newly seen value is inserted just after the last
 *	multiply-seen value, causing the bottommost (oldest) singly-seen value
 *	to drop off the list.  The accuracy of this method, and also its cost,
 *	depend mainly on the length of the list we are willing to keep.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compute_distinct_stats</name><parameter_list>(<parameter><decl><type><name>VacAttrStatsP</name></type> <name>stats</name></decl></parameter>,
					   <parameter><decl><type><name>AnalyzeAttrFetchFunc</name></type> <name>fetchfunc</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>samplerows</name></decl></parameter>,
					   <parameter><decl><type><name>double</name></type> <name>totalrows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>null_cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nonnull_cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>toowide_cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>total_width</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_varlena</name> <init>= <expr><operator>(</operator><operator>!</operator><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typbyval</name></name> <operator>&amp;&amp;</operator>
							  <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_varwidth</name> <init>= <expr><operator>(</operator><operator>!</operator><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typbyval</name></name> <operator>&amp;&amp;</operator>
							   <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>f_cmpeq</name></decl>;</decl_stmt>
	<typedef>typedef <type><struct>struct
	<block>{
		<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>count</name></decl>;</decl_stmt>
	}</block></struct></type> <name>TrackItem</name>;</typedef>
	<decl_stmt><decl><type><name>TrackItem</name>  <modifier>*</modifier></type><name>track</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>track_cnt</name></decl>,
				<decl><type ref="prev"/><name>track_max</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_mcv</name> <init>= <expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StdAnalyzeData</name> <modifier>*</modifier></type><name>mystats</name> <init>= <expr><operator>(</operator><name>StdAnalyzeData</name> <operator>*</operator><operator>)</operator> <name><name>stats</name><operator>-&gt;</operator><name>extra_data</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We track up to 2*n values for an n-element MCV list; but at least 10
	 */</comment>
	<expr_stmt><expr><name>track_max</name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <name>num_mcv</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>track_max</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>track_max</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>track</name> <operator>=</operator> <operator>(</operator><name>TrackItem</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>track_max</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TrackItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>track_cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name><name>mystats</name><operator>-&gt;</operator><name>eqfunc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>f_cmpeq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>samplerows</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>match</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>firstcount1</name></decl>,
					<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>vacuum_delay_point</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>fetchfunc</name><argument_list>(<argument><expr><name>stats</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Check for null/nonnull */</comment>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>null_cnt</name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>nonnull_cnt</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * If it's a variable-width field, add up widths for average width
		 * calculation.  Note that if the value is toasted, we use the toasted
		 * width.  We don't bother with this calculation if it's a fixed-width
		 * type.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>is_varlena</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>total_width</name> <operator>+=</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If the value is toasted, we want to detoast it just once to
			 * avoid repeated detoastings and resultant excess memory usage
			 * during the comparisons.  Also, check to see if the value is
			 * excessively wide, and if so don't detoast at all --- just
			 * ignore the value.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>toast_raw_datum_size</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>WIDTH_THRESHOLD</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>toowide_cnt</name><operator>++</operator></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>is_varwidth</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* must be cstring */</comment>
			<expr_stmt><expr><name>total_width</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * See if the value matches anything we're already tracking.
		 */</comment>
		<expr_stmt><expr><name>match</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>firstcount1</name> <operator>=</operator> <name>track_cnt</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>track_cnt</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/* We always use the default collation for statistics */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>f_cmpeq</name></expr></argument>,
											   <argument><expr><name>DEFAULT_COLLATION_OID</name></expr></argument>,
											   <argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <name>firstcount1</name> <operator>&amp;&amp;</operator> <name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>firstcount1</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>match</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Found a match */</comment>
			<expr_stmt><expr><name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>count</name><operator>++</operator></expr>;</expr_stmt>
			<comment type="block">/* This value may now need to "bubble up" in the track list */</comment>
			<while>while <condition>(<expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>&gt;</operator> <name><name>track</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>count</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>swapDatum</name><argument_list>(<argument><expr><name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>, <argument><expr><name><name>track</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>swapInt</name><argument_list>(<argument><expr><name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>count</name></expr></argument>, <argument><expr><name><name>track</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>j</name><operator>--</operator></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* No match.  Insert at head of count-1 list */</comment>
			<if_stmt><if>if <condition>(<expr><name>track_cnt</name> <operator>&lt;</operator> <name>track_max</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>track_cnt</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>track_cnt</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&gt;</operator> <name>firstcount1</name></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name><name>track</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>=</operator> <name><name>track</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>count</name></expr>;</expr_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><name>firstcount1</name> <operator>&lt;</operator> <name>track_cnt</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>track</name><index>[<expr><name>firstcount1</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>track</name><index>[<expr><name>firstcount1</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* We can only compute real stats if we found some non-null values. */</comment>
	<if_stmt><if>if <condition>(<expr><name>nonnull_cnt</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>nmultiple</name></decl>,
					<decl><type ref="prev"/><name>summultiple</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stats_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<comment type="block">/* Do the simple null-frac and width stats */</comment>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>null_cnt</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>samplerows</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>is_varwidth</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <name>total_width</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>nonnull_cnt</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Count the number of values we found multiple times */</comment>
		<expr_stmt><expr><name>summultiple</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>nmultiple</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>nmultiple</name> <operator>&lt;</operator> <name>track_cnt</name></expr>;</condition> <incr><expr><name>nmultiple</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>track</name><index>[<expr><name>nmultiple</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>summultiple</name> <operator>+=</operator> <name><name>track</name><index>[<expr><name>nmultiple</name></expr>]</index></name><operator>.</operator><name>count</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>nmultiple</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If we found no repeated non-null values, assume it's a unique
			 * column; but be sure to discount for any nulls we found.
			 */</comment>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1.0</literal> <operator>*</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>track_cnt</name> <operator>&lt;</operator> <name>track_max</name> <operator>&amp;&amp;</operator> <name>toowide_cnt</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				 <name>nmultiple</name> <operator>==</operator> <name>track_cnt</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Our track list includes every value in the sample, and every
			 * value appeared more than once.  Assume the column has just
			 * these values.  (This case is meant to address columns with
			 * small, fixed sets of possible values, such as boolean or enum
			 * columns.  If there are any values that appear just once in the
			 * sample, including too-wide values, we should assume that that's
			 * not what we're dealing with.)
			 */</comment>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <name>track_cnt</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*----------
			 * Estimate the number of distinct values using the estimator
			 * proposed by Haas and Stokes in IBM Research Report RJ 10025:
			 *		n*d / (n - f1 + f1*n/N)
			 * where f1 is the number of distinct values that occurred
			 * exactly once in our sample of n rows (from a total of N),
			 * and d is the total number of distinct values in the sample.
			 * This is their Duj1 estimator; the other estimators they
			 * recommend are considerably more complex, and are numerically
			 * very unstable when n is much smaller than N.
			 *
			 * In this calculation, we consider only non-nulls.  We used to
			 * include rows with null values in the n and N counts, but that
			 * leads to inaccurate answers in columns with many nulls, and
			 * it's intuitively bogus anyway considering the desired result is
			 * the number of distinct non-null values.
			 *
			 * We assume (not very reliably!) that all the multiply-occurring
			 * values are reflected in the final track[] list, and the other
			 * nonnull values all appeared but once.  (XXX this usually
			 * results in a drastic overestimate of ndistinct.  Can we do
			 * any better?)
			 *----------
			 */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>f1</name> <init>= <expr><name>nonnull_cnt</name> <operator>-</operator> <name>summultiple</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>d</name> <init>= <expr><name>f1</name> <operator>+</operator> <name>nmultiple</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>n</name> <init>= <expr><name>samplerows</name> <operator>-</operator> <name>null_cnt</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>N</name> <init>= <expr><name>totalrows</name> <operator>*</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>stadistinct</name></decl>;</decl_stmt>

			<comment type="block">/* N == 0 shouldn't happen, but just in case ... */</comment>
			<if_stmt><if>if <condition>(<expr><name>N</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>stadistinct</name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>*</operator> <name>d</name><operator>)</operator> <operator>/</operator> <operator>(</operator><operator>(</operator><name>n</name> <operator>-</operator> <name>f1</name><operator>)</operator> <operator>+</operator> <name>f1</name> <operator>*</operator> <name>n</name> <operator>/</operator> <name>N</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>stadistinct</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/* Clamp to sane range in case of roundoff error */</comment>
			<if_stmt><if>if <condition>(<expr><name>stadistinct</name> <operator>&lt;</operator> <name>d</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>stadistinct</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>stadistinct</name> <operator>&gt;</operator> <name>N</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>stadistinct</name> <operator>=</operator> <name>N</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* And round to integer */</comment>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <call><name>floor</name><argument_list>(<argument><expr><name>stadistinct</name> <operator>+</operator> <literal type="number">0.5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * If we estimated the number of distinct values at more than 10% of
		 * the total row count (a very arbitrary limit), then assume that
		 * stadistinct should scale with the row count rather than be a fixed
		 * value.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>&gt;</operator> <literal type="number">0.1</literal> <operator>*</operator> <name>totalrows</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <operator>-</operator><operator>(</operator><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>/</operator> <name>totalrows</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Decide how many values are worth storing as most-common values. If
		 * we are able to generate a complete MCV list (all the values in the
		 * sample will fit, and we think these are all the ones in the table),
		 * then do so.  Otherwise, store only those values that are
		 * significantly more common than the values not in the list.
		 *
		 * Note: the first of these cases is meant to address columns with
		 * small, fixed sets of possible values, such as boolean or enum
		 * columns.  If we can *completely* represent the column population by
		 * an MCV list that will fit into the stats target, then we should do
		 * so and thus provide the planner with complete information.  But if
		 * the MCV list is not complete, it's generally worth being more
		 * selective, and not just filling it all the way up to the stats
		 * target.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>track_cnt</name> <argument_list type="generic">&lt; <argument><expr><name>track_max</name> <operator>&amp;&amp;</operator> <name>toowide_cnt</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name></expr></argument> &gt;</argument_list></name> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name>track_cnt</name> <operator>&lt;=</operator> <name>num_mcv</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Track list includes all values seen, and all will fit */</comment>
			<expr_stmt><expr><name>num_mcv</name> <operator>=</operator> <name>track_cnt</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>mcv_counts</name></decl>;</decl_stmt>

			<comment type="block">/* Incomplete list; decide how many values are worth keeping */</comment>
			<if_stmt><if>if <condition>(<expr><name>num_mcv</name> <operator>&gt;</operator> <name>track_cnt</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>num_mcv</name> <operator>=</operator> <name>track_cnt</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>num_mcv</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>mcv_counts</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_mcv</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_mcv</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>mcv_counts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>track</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>count</name></expr>;</expr_stmt></block_content></block></for>

				<expr_stmt><expr><name>num_mcv</name> <operator>=</operator> <call><name>analyze_mcv_list</name><argument_list>(<argument><expr><name>mcv_counts</name></expr></argument>, <argument><expr><name>num_mcv</name></expr></argument>,
										   <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name></expr></argument>,
										   <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name></expr></argument>,
										   <argument><expr><name>samplerows</name></expr></argument>, <argument><expr><name>totalrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Generate MCV slot entry */</comment>
		<if_stmt><if>if <condition>(<expr><name>num_mcv</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_context</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>mcv_values</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>float4</name>	   <modifier>*</modifier></type><name>mcv_freqs</name></decl>;</decl_stmt>

			<comment type="block">/* Must copy the target values into anl_context */</comment>
			<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>anl_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>mcv_values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_mcv</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>mcv_freqs</name> <operator>=</operator> <operator>(</operator><name>float4</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_mcv</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>float4</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_mcv</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name><name>mcv_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>track</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>,
										  <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>,
										  <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>mcv_freqs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>track</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>samplerows</name></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stakind</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>STATISTIC_KIND_MCV</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>staop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>mystats</name><operator>-&gt;</operator><name>eqopr</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanumbers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>mcv_freqs</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>numnumbers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>num_mcv</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stavalues</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>mcv_values</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>numvalues</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>num_mcv</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Accept the defaults for stats-&gt;statypid and others. They have
			 * been set before we were called (see vacuum.h)
			 */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>null_cnt</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We found only nulls; assume the column is entirely null */</comment>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stats_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>is_varwidth</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* "unknown" */</comment>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>	<comment type="block">/* "unknown" */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We don't need to bother cleaning up any of our temporary palloc's */</comment>
</block_content>}</block></function>


<comment type="block">/*
 *	compute_scalar_stats() -- compute column statistics
 *
 *	We use this when we can find "=" and "&lt;" operators for the datatype.
 *
 *	We determine the fraction of non-null rows, the average width, the
 *	most common values, the (estimated) number of distinct values, the
 *	distribution histogram, and the correlation of physical to logical order.
 *
 *	The desired stats can be determined fairly easily after sorting the
 *	data values into order.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compute_scalar_stats</name><parameter_list>(<parameter><decl><type><name>VacAttrStatsP</name></type> <name>stats</name></decl></parameter>,
					 <parameter><decl><type><name>AnalyzeAttrFetchFunc</name></type> <name>fetchfunc</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>samplerows</name></decl></parameter>,
					 <parameter><decl><type><name>double</name></type> <name>totalrows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>null_cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nonnull_cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>toowide_cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>total_width</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_varlena</name> <init>= <expr><operator>(</operator><operator>!</operator><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typbyval</name></name> <operator>&amp;&amp;</operator>
							  <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_varwidth</name> <init>= <expr><operator>(</operator><operator>!</operator><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typbyval</name></name> <operator>&amp;&amp;</operator>
							   <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>corr_xysum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SortSupportData</name></type> <name>ssup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScalarItem</name> <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>values_cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>tupnoLink</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScalarMCVItem</name> <modifier>*</modifier></type><name>track</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>track_cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_mcv</name> <init>= <expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_bins</name> <init>= <expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StdAnalyzeData</name> <modifier>*</modifier></type><name>mystats</name> <init>= <expr><operator>(</operator><name>StdAnalyzeData</name> <operator>*</operator><operator>)</operator> <name><name>stats</name><operator>-&gt;</operator><name>extra_data</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>ScalarItem</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>samplerows</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ScalarItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupnoLink</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>samplerows</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>track</name> <operator>=</operator> <operator>(</operator><name>ScalarMCVItem</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_mcv</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ScalarMCVItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ssup</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ssup</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ssup</name><operator>.</operator><name>ssup_cxt</name></name> <operator>=</operator> <call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* We always use the default collation for statistics */</comment>
	<expr_stmt><expr><name><name>ssup</name><operator>.</operator><name>ssup_collation</name></name> <operator>=</operator> <name>DEFAULT_COLLATION_OID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ssup</name><operator>.</operator><name>ssup_nulls_first</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * For now, don't perform abbreviated key conversion, because full values
	 * are required for MCV slot generation.  Supporting that optimization
	 * would necessitate teaching compare_scalars() to call a tie-breaker.
	 */</comment>
	<expr_stmt><expr><name><name>ssup</name><operator>.</operator><name>abbreviate</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PrepareSortSupportFromOrderingOp</name><argument_list>(<argument><expr><name><name>mystats</name><operator>-&gt;</operator><name>ltopr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ssup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initial scan to find sortable values */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>samplerows</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>vacuum_delay_point</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>fetchfunc</name><argument_list>(<argument><expr><name>stats</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Check for null/nonnull */</comment>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>null_cnt</name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>nonnull_cnt</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * If it's a variable-width field, add up widths for average width
		 * calculation.  Note that if the value is toasted, we use the toasted
		 * width.  We don't bother with this calculation if it's a fixed-width
		 * type.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>is_varlena</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>total_width</name> <operator>+=</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If the value is toasted, we want to detoast it just once to
			 * avoid repeated detoastings and resultant excess memory usage
			 * during the comparisons.  Also, check to see if the value is
			 * excessively wide, and if so don't detoast at all --- just
			 * ignore the value.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>toast_raw_datum_size</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>WIDTH_THRESHOLD</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>toowide_cnt</name><operator>++</operator></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>is_varwidth</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* must be cstring */</comment>
			<expr_stmt><expr><name>total_width</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Add it to the list to be sorted */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>values_cnt</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>values_cnt</name></expr>]</index></name><operator>.</operator><name>tupno</name> <operator>=</operator> <name>values_cnt</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tupnoLink</name><index>[<expr><name>values_cnt</name></expr>]</index></name> <operator>=</operator> <name>values_cnt</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>values_cnt</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* We can only compute real stats if we found some sortable values. */</comment>
	<if_stmt><if>if <condition>(<expr><name>values_cnt</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>ndistinct</name></decl>,	<comment type="block">/* # distinct values in sample */</comment>
					<decl><type ref="prev"/><name>nmultiple</name></decl>,	<comment type="block">/* # that appear multiple times */</comment>
					<decl><type ref="prev"/><name>num_hist</name></decl>,
					<decl><type ref="prev"/><name>dups_cnt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>slot_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CompareScalarsContext</name></type> <name>cxt</name></decl>;</decl_stmt>

		<comment type="block">/* Sort the collected values */</comment>
		<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>ssup</name></name> <operator>=</operator> <operator>&amp;</operator><name>ssup</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>tupnoLink</name></name> <operator>=</operator> <name>tupnoLink</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>qsort_arg</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>values</name></expr></argument>, <argument><expr><name>values_cnt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScalarItem</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				  <argument><expr><name>compare_scalars</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now scan the values in order, find the most common ones, and also
		 * accumulate ordering-correlation statistics.
		 *
		 * To determine which are most common, we first have to count the
		 * number of duplicates of each value.  The duplicates are adjacent in
		 * the sorted list, so a brute-force approach is to compare successive
		 * datum values until we find two that are not equal. However, that
		 * requires N-1 invocations of the datum comparison routine, which are
		 * completely redundant with work that was done during the sort.  (The
		 * sort algorithm must at some point have compared each pair of items
		 * that are adjacent in the sorted order; otherwise it could not know
		 * that it's ordered the pair correctly.) We exploit this by having
		 * compare_scalars remember the highest tupno index that each
		 * ScalarItem has been found equal to.  At the end of the sort, a
		 * ScalarItem's tupnoLink will still point to itself if and only if it
		 * is the last item of its group of duplicates (since the group will
		 * be ordered by tupno).
		 */</comment>
		<expr_stmt><expr><name>corr_xysum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>ndistinct</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>nmultiple</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>dups_cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>values_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>tupno</name> <init>= <expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tupno</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>corr_xysum</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>i</name><operator>)</operator> <operator>*</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>tupno</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>dups_cnt</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>tupnoLink</name><index>[<expr><name>tupno</name></expr>]</index></name> <operator>==</operator> <name>tupno</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Reached end of duplicates of this value */</comment>
				<expr_stmt><expr><name>ndistinct</name><operator>++</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>dups_cnt</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>nmultiple</name><operator>++</operator></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>track_cnt</name> <argument_list type="generic">&lt; <argument><expr><name>num_mcv</name> <operator>||</operator>
						<name>dups_cnt</name></expr></argument> &gt;</argument_list></name> <name><name>track</name><index>[<expr><name>track_cnt</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>count</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * Found a new item for the mcv list; find its
						 * position, bubbling down old items if needed. Loop
						 * invariant is that j points at an empty/ replaceable
						 * slot.
						 */</comment>
						<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name>track_cnt</name> <operator>&lt;</operator> <name>num_mcv</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>track_cnt</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>track_cnt</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><name>dups_cnt</name> <operator>&lt;=</operator> <name><name>track</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>count</name></expr>)</condition><block type="pseudo"><block_content>
								<break>break;</break></block_content></block></if></if_stmt>
							<expr_stmt><expr><name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>=</operator> <name><name>track</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>count</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>first</name> <operator>=</operator> <name><name>track</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>first</name></expr>;</expr_stmt>
						</block_content>}</block></for>
						<expr_stmt><expr><name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>=</operator> <name>dups_cnt</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>first</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>dups_cnt</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>dups_cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stats_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<comment type="block">/* Do the simple null-frac and width stats */</comment>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>null_cnt</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>samplerows</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>is_varwidth</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <name>total_width</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>nonnull_cnt</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>nmultiple</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If we found no repeated non-null values, assume it's a unique
			 * column; but be sure to discount for any nulls we found.
			 */</comment>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1.0</literal> <operator>*</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>toowide_cnt</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nmultiple</name> <operator>==</operator> <name>ndistinct</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Every value in the sample appeared more than once.  Assume the
			 * column has just these values.  (This case is meant to address
			 * columns with small, fixed sets of possible values, such as
			 * boolean or enum columns.  If there are any values that appear
			 * just once in the sample, including too-wide values, we should
			 * assume that that's not what we're dealing with.)
			 */</comment>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <name>ndistinct</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*----------
			 * Estimate the number of distinct values using the estimator
			 * proposed by Haas and Stokes in IBM Research Report RJ 10025:
			 *		n*d / (n - f1 + f1*n/N)
			 * where f1 is the number of distinct values that occurred
			 * exactly once in our sample of n rows (from a total of N),
			 * and d is the total number of distinct values in the sample.
			 * This is their Duj1 estimator; the other estimators they
			 * recommend are considerably more complex, and are numerically
			 * very unstable when n is much smaller than N.
			 *
			 * In this calculation, we consider only non-nulls.  We used to
			 * include rows with null values in the n and N counts, but that
			 * leads to inaccurate answers in columns with many nulls, and
			 * it's intuitively bogus anyway considering the desired result is
			 * the number of distinct non-null values.
			 *
			 * Overwidth values are assumed to have been distinct.
			 *----------
			 */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>f1</name> <init>= <expr><name>ndistinct</name> <operator>-</operator> <name>nmultiple</name> <operator>+</operator> <name>toowide_cnt</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>d</name> <init>= <expr><name>f1</name> <operator>+</operator> <name>nmultiple</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>n</name> <init>= <expr><name>samplerows</name> <operator>-</operator> <name>null_cnt</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>N</name> <init>= <expr><name>totalrows</name> <operator>*</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>stadistinct</name></decl>;</decl_stmt>

			<comment type="block">/* N == 0 shouldn't happen, but just in case ... */</comment>
			<if_stmt><if>if <condition>(<expr><name>N</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>stadistinct</name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>*</operator> <name>d</name><operator>)</operator> <operator>/</operator> <operator>(</operator><operator>(</operator><name>n</name> <operator>-</operator> <name>f1</name><operator>)</operator> <operator>+</operator> <name>f1</name> <operator>*</operator> <name>n</name> <operator>/</operator> <name>N</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>stadistinct</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/* Clamp to sane range in case of roundoff error */</comment>
			<if_stmt><if>if <condition>(<expr><name>stadistinct</name> <operator>&lt;</operator> <name>d</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>stadistinct</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>stadistinct</name> <operator>&gt;</operator> <name>N</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>stadistinct</name> <operator>=</operator> <name>N</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* And round to integer */</comment>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <call><name>floor</name><argument_list>(<argument><expr><name>stadistinct</name> <operator>+</operator> <literal type="number">0.5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * If we estimated the number of distinct values at more than 10% of
		 * the total row count (a very arbitrary limit), then assume that
		 * stadistinct should scale with the row count rather than be a fixed
		 * value.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>&gt;</operator> <literal type="number">0.1</literal> <operator>*</operator> <name>totalrows</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <operator>-</operator><operator>(</operator><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>/</operator> <name>totalrows</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Decide how many values are worth storing as most-common values. If
		 * we are able to generate a complete MCV list (all the values in the
		 * sample will fit, and we think these are all the ones in the table),
		 * then do so.  Otherwise, store only those values that are
		 * significantly more common than the values not in the list.
		 *
		 * Note: the first of these cases is meant to address columns with
		 * small, fixed sets of possible values, such as boolean or enum
		 * columns.  If we can *completely* represent the column population by
		 * an MCV list that will fit into the stats target, then we should do
		 * so and thus provide the planner with complete information.  But if
		 * the MCV list is not complete, it's generally worth being more
		 * selective, and not just filling it all the way up to the stats
		 * target.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>track_cnt</name> <operator>==</operator> <name>ndistinct</name> <operator>&amp;&amp;</operator> <name>toowide_cnt</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name>track_cnt</name> <operator>&lt;=</operator> <name>num_mcv</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Track list includes all values seen, and all will fit */</comment>
			<expr_stmt><expr><name>num_mcv</name> <operator>=</operator> <name>track_cnt</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>mcv_counts</name></decl>;</decl_stmt>

			<comment type="block">/* Incomplete list; decide how many values are worth keeping */</comment>
			<if_stmt><if>if <condition>(<expr><name>num_mcv</name> <operator>&gt;</operator> <name>track_cnt</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>num_mcv</name> <operator>=</operator> <name>track_cnt</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>num_mcv</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>mcv_counts</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_mcv</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_mcv</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>mcv_counts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>track</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>count</name></expr>;</expr_stmt></block_content></block></for>

				<expr_stmt><expr><name>num_mcv</name> <operator>=</operator> <call><name>analyze_mcv_list</name><argument_list>(<argument><expr><name>mcv_counts</name></expr></argument>, <argument><expr><name>num_mcv</name></expr></argument>,
										   <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name></expr></argument>,
										   <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name></expr></argument>,
										   <argument><expr><name>samplerows</name></expr></argument>, <argument><expr><name>totalrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Generate MCV slot entry */</comment>
		<if_stmt><if>if <condition>(<expr><name>num_mcv</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_context</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>mcv_values</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>float4</name>	   <modifier>*</modifier></type><name>mcv_freqs</name></decl>;</decl_stmt>

			<comment type="block">/* Must copy the target values into anl_context */</comment>
			<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>anl_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>mcv_values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_mcv</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>mcv_freqs</name> <operator>=</operator> <operator>(</operator><name>float4</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_mcv</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>float4</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_mcv</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name><name>mcv_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name><name>track</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>first</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>,
										  <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>,
										  <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>mcv_freqs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>track</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>samplerows</name></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stakind</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>STATISTIC_KIND_MCV</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>staop</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name><name>mystats</name><operator>-&gt;</operator><name>eqopr</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanumbers</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>mcv_freqs</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>numnumbers</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>num_mcv</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stavalues</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>mcv_values</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>numvalues</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>num_mcv</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Accept the defaults for stats-&gt;statypid and others. They have
			 * been set before we were called (see vacuum.h)
			 */</comment>
			<expr_stmt><expr><name>slot_idx</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Generate a histogram slot entry if there are at least two distinct
		 * values not accounted for in the MCV list.  (This ensures the
		 * histogram won't collapse to empty or a singleton.)
		 */</comment>
		<expr_stmt><expr><name>num_hist</name> <operator>=</operator> <name>ndistinct</name> <operator>-</operator> <name>num_mcv</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>num_hist</name> <operator>&gt;</operator> <name>num_bins</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>num_hist</name> <operator>=</operator> <name>num_bins</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>num_hist</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_context</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>hist_values</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>nvals</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>pos</name></decl>,
						<decl><type ref="prev"/><name>posfrac</name></decl>,
						<decl><type ref="prev"/><name>delta</name></decl>,
						<decl><type ref="prev"/><name>deltafrac</name></decl>;</decl_stmt>

			<comment type="block">/* Sort the MCV items into position order to speed next loop */</comment>
			<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>track</name></expr></argument>, <argument><expr><name>num_mcv</name></expr></argument>,
				  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScalarMCVItem</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>compare_mcvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Collapse out the MCV items from the values[] array.
			 *
			 * Note we destroy the values[] array here... but we don't need it
			 * for anything more.  We do, however, still need values_cnt.
			 * nvals will be the number of remaining entries in values[].
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>num_mcv</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>src</name></decl>,
							<decl><type ref="prev"/><name>dest</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>src</name> <operator>=</operator> <name>dest</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* index of next interesting MCV item */</comment>
				<while>while <condition>(<expr><name>src</name> <operator>&lt;</operator> <name>values_cnt</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>ncopy</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <name>num_mcv</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>int</name></type>			<name>first</name> <init>= <expr><name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>first</name></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&gt;=</operator> <name>first</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* advance past this MCV item */</comment>
							<expr_stmt><expr><name>src</name> <operator>=</operator> <name>first</name> <operator>+</operator> <name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>count</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
							<continue>continue;</continue>
						</block_content>}</block></if></if_stmt>
						<expr_stmt><expr><name>ncopy</name> <operator>=</operator> <name>first</name> <operator>-</operator> <name>src</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>ncopy</name> <operator>=</operator> <name>values_cnt</name> <operator>-</operator> <name>src</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>values</name><index>[<expr><name>dest</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>values</name><index>[<expr><name>src</name></expr>]</index></name></expr></argument>,
							<argument><expr><name>ncopy</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ScalarItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>src</name> <operator>+=</operator> <name>ncopy</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>dest</name> <operator>+=</operator> <name>ncopy</name></expr>;</expr_stmt>
				</block_content>}</block></while>
				<expr_stmt><expr><name>nvals</name> <operator>=</operator> <name>dest</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>nvals</name> <operator>=</operator> <name>values_cnt</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nvals</name> <operator>&gt;=</operator> <name>num_hist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Must copy the target values into anl_context */</comment>
			<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>anl_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>hist_values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_hist</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * The object of this loop is to copy the first and last values[]
			 * entries along with evenly-spaced values in between.  So the
			 * i'th value is values[(i * (nvals - 1)) / (num_hist - 1)].  But
			 * computing that subscript directly risks integer overflow when
			 * the stats target is more than a couple thousand.  Instead we
			 * add (nvals - 1) / (num_hist - 1) to pos at each step, tracking
			 * the integral and fractional parts of the sum separately.
			 */</comment>
			<expr_stmt><expr><name>delta</name> <operator>=</operator> <operator>(</operator><name>nvals</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><name>num_hist</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>deltafrac</name> <operator>=</operator> <operator>(</operator><name>nvals</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <operator>(</operator><name>num_hist</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>pos</name> <operator>=</operator> <name>posfrac</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_hist</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name><name>hist_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>pos</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>,
										   <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>,
										   <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>delta</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>posfrac</name> <operator>+=</operator> <name>deltafrac</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>posfrac</name> <operator>&gt;=</operator> <operator>(</operator><name>num_hist</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* fractional part exceeds 1, carry to integer part */</comment>
					<expr_stmt><expr><name>pos</name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name>posfrac</name> <operator>-=</operator> <operator>(</operator><name>num_hist</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stakind</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>STATISTIC_KIND_HISTOGRAM</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>staop</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name><name>mystats</name><operator>-&gt;</operator><name>ltopr</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stavalues</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>hist_values</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>numvalues</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>num_hist</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Accept the defaults for stats-&gt;statypid and others. They have
			 * been set before we were called (see vacuum.h)
			 */</comment>
			<expr_stmt><expr><name>slot_idx</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Generate a correlation entry if there are multiple values */</comment>
		<if_stmt><if>if <condition>(<expr><name>values_cnt</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_context</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>float4</name>	   <modifier>*</modifier></type><name>corrs</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>corr_xsum</name></decl>,
						<decl><type ref="prev"/><name>corr_x2sum</name></decl>;</decl_stmt>

			<comment type="block">/* Must copy the target values into anl_context */</comment>
			<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>anl_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>corrs</name> <operator>=</operator> <operator>(</operator><name>float4</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>float4</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*----------
			 * Since we know the x and y value sets are both
			 *		0, 1, ..., values_cnt-1
			 * we have sum(x) = sum(y) =
			 *		(values_cnt-1)*values_cnt / 2
			 * and sum(x^2) = sum(y^2) =
			 *		(values_cnt-1)*values_cnt*(2*values_cnt-1) / 6.
			 *----------
			 */</comment>
			<expr_stmt><expr><name>corr_xsum</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><name>values_cnt</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>*</operator>
				<operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>values_cnt</name><operator>)</operator> <operator>/</operator> <literal type="number">2.0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>corr_x2sum</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><name>values_cnt</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>*</operator>
				<operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>values_cnt</name><operator>)</operator> <operator>*</operator> <operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><literal type="number">2</literal> <operator>*</operator> <name>values_cnt</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">6.0</literal></expr>;</expr_stmt>

			<comment type="block">/* And the correlation coefficient reduces to */</comment>
			<expr_stmt><expr><name><name>corrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>values_cnt</name> <operator>*</operator> <name>corr_xysum</name> <operator>-</operator> <name>corr_xsum</name> <operator>*</operator> <name>corr_xsum</name><operator>)</operator> <operator>/</operator>
				<operator>(</operator><name>values_cnt</name> <operator>*</operator> <name>corr_x2sum</name> <operator>-</operator> <name>corr_xsum</name> <operator>*</operator> <name>corr_xsum</name><operator>)</operator></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stakind</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>STATISTIC_KIND_CORRELATION</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>staop</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name><name>mystats</name><operator>-&gt;</operator><name>ltopr</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanumbers</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>corrs</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>numnumbers</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>slot_idx</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>nonnull_cnt</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We found some non-null values, but they were all too wide */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nonnull_cnt</name> <operator>==</operator> <name>toowide_cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stats_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<comment type="block">/* Do the simple null-frac and width stats */</comment>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>null_cnt</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>samplerows</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>is_varwidth</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <name>total_width</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>nonnull_cnt</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<comment type="block">/* Assume all too-wide values are distinct, so it's a unique column */</comment>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1.0</literal> <operator>*</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>null_cnt</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We found only nulls; assume the column is entirely null */</comment>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stats_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>is_varwidth</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* "unknown" */</comment>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>	<comment type="block">/* "unknown" */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We don't need to bother cleaning up any of our temporary palloc's */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * qsort_arg comparator for sorting ScalarItems
 *
 * Aside from sorting the items, we update the tupnoLink[] array
 * whenever two ScalarItems are found to contain equal datums.  The array
 * is indexed by tupno; for each ScalarItem, it contains the highest
 * tupno that that item's datum has been found to be equal to.  This allows
 * us to avoid additional comparisons in compute_scalar_stats().
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compare_scalars</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>da</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ScalarItem</name> <operator>*</operator><operator>)</operator> <name>a</name><operator>)</operator><operator>-&gt;</operator><name>value</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ta</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ScalarItem</name> <operator>*</operator><operator>)</operator> <name>a</name><operator>)</operator><operator>-&gt;</operator><name>tupno</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>db</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ScalarItem</name> <operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator><operator>-&gt;</operator><name>value</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tb</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ScalarItem</name> <operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator><operator>-&gt;</operator><name>tupno</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CompareScalarsContext</name> <modifier>*</modifier></type><name>cxt</name> <init>= <expr><operator>(</operator><name>CompareScalarsContext</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>compare</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>compare</name> <operator>=</operator> <call><name>ApplySortComparator</name><argument_list>(<argument><expr><name>da</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>ssup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>compare</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>compare</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The two datums are equal, so update cxt-&gt;tupnoLink[].
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>tupnoLink</name><index>[<expr><name>ta</name></expr>]</index></name> <operator>&lt;</operator> <name>tb</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>tupnoLink</name><index>[<expr><name>ta</name></expr>]</index></name> <operator>=</operator> <name>tb</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>tupnoLink</name><index>[<expr><name>tb</name></expr>]</index></name> <operator>&lt;</operator> <name>ta</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>tupnoLink</name><index>[<expr><name>tb</name></expr>]</index></name> <operator>=</operator> <name>ta</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * For equal datums, sort by tupno
	 */</comment>
	<return>return <expr><name>ta</name> <operator>-</operator> <name>tb</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * qsort comparator for sorting ScalarMCVItems by position
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compare_mcvs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>da</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ScalarMCVItem</name> <operator>*</operator><operator>)</operator> <name>a</name><operator>)</operator><operator>-&gt;</operator><name>first</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>db</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ScalarMCVItem</name> <operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator><operator>-&gt;</operator><name>first</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>da</name> <operator>-</operator> <name>db</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Analyze the list of common values in the sample and decide how many are
 * worth storing in the table's MCV list.
 *
 * mcv_counts is assumed to be a list of the counts of the most common values
 * seen in the sample, starting with the most common.  The return value is the
 * number that are significantly more common than the values not in the list,
 * and which are therefore deemed worth storing in the table's MCV list.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>analyze_mcv_list</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>mcv_counts</name></decl></parameter>,
				 <parameter><decl><type><name>int</name></type> <name>num_mcv</name></decl></parameter>,
				 <parameter><decl><type><name>double</name></type> <name>stadistinct</name></decl></parameter>,
				 <parameter><decl><type><name>double</name></type> <name>stanullfrac</name></decl></parameter>,
				 <parameter><decl><type><name>int</name></type> <name>samplerows</name></decl></parameter>,
				 <parameter><decl><type><name>double</name></type> <name>totalrows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>ndistinct_table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>sumcount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the entire table was sampled, keep the whole list.  This also
	 * protects us against division by zero in the code below.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>samplerows</name> <operator>==</operator> <name>totalrows</name> <operator>||</operator> <name>totalrows</name> <operator>&lt;=</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>num_mcv</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Re-extract the estimated number of distinct nonnull values in table */</comment>
	<expr_stmt><expr><name>ndistinct_table</name> <operator>=</operator> <name>stadistinct</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ndistinct_table</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ndistinct_table</name> <operator>=</operator> <operator>-</operator><name>ndistinct_table</name> <operator>*</operator> <name>totalrows</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Exclude the least common values from the MCV list, if they are not
	 * significantly more common than the estimated selectivity they would
	 * have if they weren't in the list.  All non-MCV values are assumed to be
	 * equally common, after taking into account the frequencies of all the
	 * the values in the MCV list and the number of nulls (c.f. eqsel()).
	 *
	 * Here sumcount tracks the total count of all but the last (least common)
	 * value in the MCV list, allowing us to determine the effect of excluding
	 * that value from the list.
	 *
	 * Note that we deliberately do this by removing values from the full
	 * list, rather than starting with an empty list and adding values,
	 * because the latter approach can fail to add any values if all the most
	 * common values have around the same frequency and make up the majority
	 * of the table, so that the overall average frequency of all values is
	 * roughly the same as that of the common values.  This would lead to any
	 * uncommon values being significantly overestimated.
	 */</comment>
	<expr_stmt><expr><name>sumcount</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_mcv</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sumcount</name> <operator>+=</operator> <name><name>mcv_counts</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

	<while>while <condition>(<expr><name>num_mcv</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>selec</name></decl>,
					<decl><type ref="prev"/><name>otherdistinct</name></decl>,
					<decl><type ref="prev"/><name>N</name></decl>,
					<decl><type ref="prev"/><name>n</name></decl>,
					<decl><type ref="prev"/><name>K</name></decl>,
					<decl><type ref="prev"/><name>variance</name></decl>,
					<decl><type ref="prev"/><name>stddev</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Estimated selectivity the least common value would have if it
		 * wasn't in the MCV list (c.f. eqsel()).
		 */</comment>
		<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>-</operator> <name>sumcount</name> <operator>/</operator> <name>samplerows</name> <operator>-</operator> <name>stanullfrac</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>selec</name> <operator>&lt;</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>selec</name> <operator>&gt;</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>otherdistinct</name> <operator>=</operator> <name>ndistinct_table</name> <operator>-</operator> <operator>(</operator><name>num_mcv</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>otherdistinct</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>selec</name> <operator>/=</operator> <name>otherdistinct</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If the value is kept in the MCV list, its population frequency is
		 * assumed to equal its sample frequency.  We use the lower end of a
		 * textbook continuity-corrected Wald-type confidence interval to
		 * determine if that is significantly more common than the non-MCV
		 * frequency --- specifically we assume the population frequency is
		 * highly likely to be within around 2 standard errors of the sample
		 * frequency, which equates to an interval of 2 standard deviations
		 * either side of the sample count, plus an additional 0.5 for the
		 * continuity correction.  Since we are sampling without replacement,
		 * this is a hypergeometric distribution.
		 *
		 * XXX: Empirically, this approach seems to work quite well, but it
		 * may be worth considering more advanced techniques for estimating
		 * the confidence interval of the hypergeometric distribution.
		 */</comment>
		<expr_stmt><expr><name>N</name> <operator>=</operator> <name>totalrows</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <name>samplerows</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>K</name> <operator>=</operator> <name>N</name> <operator>*</operator> <name><name>mcv_counts</name><index>[<expr><name>num_mcv</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>/</operator> <name>n</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>variance</name> <operator>=</operator> <name>n</name> <operator>*</operator> <name>K</name> <operator>*</operator> <operator>(</operator><name>N</name> <operator>-</operator> <name>K</name><operator>)</operator> <operator>*</operator> <operator>(</operator><name>N</name> <operator>-</operator> <name>n</name><operator>)</operator> <operator>/</operator> <operator>(</operator><name>N</name> <operator>*</operator> <name>N</name> <operator>*</operator> <operator>(</operator><name>N</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>stddev</name> <operator>=</operator> <call><name>sqrt</name><argument_list>(<argument><expr><name>variance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>mcv_counts</name><index>[<expr><name>num_mcv</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&gt;</operator> <name>selec</name> <operator>*</operator> <name>samplerows</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>stddev</name> <operator>+</operator> <literal type="number">0.5</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The value is significantly more common than the non-MCV
			 * selectivity would suggest.  Keep it, and all the other more
			 * common values in the list.
			 */</comment>
			<break>break;</break>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Discard this value and consider the next least common value */</comment>
			<expr_stmt><expr><name>num_mcv</name><operator>--</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>num_mcv</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>sumcount</name> <operator>-=</operator> <name><name>mcv_counts</name><index>[<expr><name>num_mcv</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>num_mcv</name></expr>;</return>
</block_content>}</block></function>
</unit>
