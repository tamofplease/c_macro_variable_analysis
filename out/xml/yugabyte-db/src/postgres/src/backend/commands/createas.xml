<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/commands/createas.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * createas.c
 *	  Execution of CREATE TABLE ... AS, a/k/a SELECT INTO.
 *	  Since CREATE MATERIALIZED VIEW shares syntax and most behaviors,
 *	  we implement that here, too.
 *
 * We implement this by diverting the query's normal output to a
 * specialized DestReceiver type.
 *
 * Formerly, CTAS was implemented as a variant of SELECT, which led
 * to assorted legacy behaviors that we still try to preserve, notably that
 * we must return a tuples-processed count in the completionTag.  (We no
 * longer do that for CTAS ... WITH NO DATA, however.)
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/commands/createas.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/reloptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/toasting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/createas.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/matview.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/prepare.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/view.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_clause.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteHandler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rls.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>

<comment type="block">/*  YB includes. */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/ybcModifyTable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_yb_utils.h"</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>DestReceiver</name></type> <name>pub</name></decl>;</decl_stmt>			<comment type="block">/* publicly-known function pointers */</comment>
	<decl_stmt><decl><type><name>IntoClause</name> <modifier>*</modifier></type><name>into</name></decl>;</decl_stmt>			<comment type="block">/* target relation specification */</comment>
	<comment type="block">/* These fields are filled by intorel_startup: */</comment>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>			<comment type="block">/* relation to write to */</comment>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>reladdr</name></decl>;</decl_stmt>		<comment type="block">/* address of rel, for ExecCreateTableAs */</comment>
	<decl_stmt><decl><type><name>CommandId</name></type>	<name>output_cid</name></decl>;</decl_stmt>		<comment type="block">/* cmin to insert in output tuples */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>hi_options</name></decl>;</decl_stmt>		<comment type="block">/* heap_insert performance options */</comment>
	<decl_stmt><decl><type><name>BulkInsertState</name></type> <name>bistate</name></decl>;</decl_stmt>	<comment type="block">/* bulk insert state */</comment>
}</block></struct></type> <name>DR_intorel</name>;</typedef>

<comment type="block">/* utility functions for CTAS definition creation */</comment>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>create_ctas_internal</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>attrList</name></decl></parameter>, <parameter><decl><type><name>IntoClause</name> <modifier>*</modifier></type><name>into</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>create_ctas_nodata</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>IntoClause</name> <modifier>*</modifier></type><name>into</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* DestReceiver routines for collecting data */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>intorel_startup</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>operation</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>typeinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>intorel_receive</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>intorel_shutdown</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>intorel_destroy</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * create_ctas_internal
 *
 * Internal utility used for the creation of the definition of a relation
 * created via CREATE TABLE AS or a materialized view.  Caller needs to
 * provide a list of attributes (ColumnDef nodes).
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>create_ctas_internal</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>attrList</name></decl></parameter>, <parameter><decl><type><name>IntoClause</name> <modifier>*</modifier></type><name>into</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>create</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CreateStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_matview</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>relkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>toast_options</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name><name>validnsps</name><index>[]</index></name> <init>= <expr><name>HEAP_RELOPT_NAMESPACES</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>intoRelationAddr</name></decl>;</decl_stmt>

	<comment type="block">/* This code supports both CREATE TABLE AS and CREATE MATERIALIZED VIEW */</comment>
	<expr_stmt><expr><name>is_matview</name> <operator>=</operator> <operator>(</operator><name><name>into</name><operator>-&gt;</operator><name>viewQuery</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>relkind</name> <operator>=</operator> <ternary><condition><expr><name>is_matview</name></expr> ?</condition><then> <expr><name>RELKIND_MATVIEW</name></expr> </then><else>: <expr><name>RELKIND_RELATION</name></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create the target relation by faking up a CREATE TABLE parsetree and
	 * passing it to DefineRelation.
	 */</comment>
	<expr_stmt><expr><name><name>create</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name><name>into</name><operator>-&gt;</operator><name>rel</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>create</name><operator>-&gt;</operator><name>tableElts</name></name> <operator>=</operator> <name>attrList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>create</name><operator>-&gt;</operator><name>inhRelations</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>create</name><operator>-&gt;</operator><name>ofTypename</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>create</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>create</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name><name>into</name><operator>-&gt;</operator><name>options</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>create</name><operator>-&gt;</operator><name>oncommit</name></name> <operator>=</operator> <name><name>into</name><operator>-&gt;</operator><name>onCommit</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>create</name><operator>-&gt;</operator><name>tablespacename</name></name> <operator>=</operator> <name><name>into</name><operator>-&gt;</operator><name>tableSpaceName</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>create</name><operator>-&gt;</operator><name>if_not_exists</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create the relation.  (This will error out if there's an existing view,
	 * so we don't need more code to complain if "replace" is false.)
	 */</comment>
	<expr_stmt><expr><name>intoRelationAddr</name> <operator>=</operator> <call><name>DefineRelation</name><argument_list>(<argument><expr><name>create</name></expr></argument>, <argument><expr><name>relkind</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* TOAST tables are not needed in YugaByte database */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If necessary, create a TOAST table for the target table.  Note that
		 * NewRelationCreateToastTable ends with CommandCounterIncrement(), so
		 * that the TOAST table will be visible for insertion.
		 */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* parse and validate reloptions for the toast table */</comment>
		<expr_stmt><expr><name>toast_options</name> <operator>=</operator> <call><name>transformRelOptions</name><argument_list>(<argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
		                                    <argument><expr><name><name>create</name><operator>-&gt;</operator><name>options</name></name></expr></argument>,
		                                    <argument><expr><literal type="string">"toast"</literal></expr></argument>,
		                                    <argument><expr><name>validnsps</name></expr></argument>,
		                                    <argument><expr><name>true</name></expr></argument>,
		                                    <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>heap_reloptions</name><argument_list>(<argument><expr><name>RELKIND_TOASTVALUE</name></expr></argument>, <argument><expr><name>toast_options</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>NewRelationCreateToastTable</name><argument_list>(<argument><expr><name><name>intoRelationAddr</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><name>toast_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Create the "view" part of a materialized view. */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_matview</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* StoreViewQuery scribbles on tree, so make a copy */</comment>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>into</name><operator>-&gt;</operator><name>viewQuery</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>StoreViewQuery</name><argument_list>(<argument><expr><name><name>intoRelationAddr</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>intoRelationAddr</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * create_ctas_nodata
 *
 * Create CTAS or materialized view when WITH NO DATA is used, starting from
 * the targetlist of the SELECT or view definition.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>create_ctas_nodata</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>IntoClause</name> <modifier>*</modifier></type><name>into</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>attrList</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>t</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Build list of ColumnDefs from non-junk elements of the tlist.  If a
	 * column name list was specified in CREATE TABLE AS, override the column
	 * names in the query.  (Too few column names are OK, too many are not.)
	 */</comment>
	<expr_stmt><expr><name>attrList</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>into</name><operator>-&gt;</operator><name>colNames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>t</argument>, <argument>tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>col</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>lc</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>colname</name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resname</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>col</name> <operator>=</operator> <call><name>makeColumnDef</name><argument_list>(<argument><expr><name>colname</name></expr></argument>,
								<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * It's possible that the column is of a collatable type but the
			 * collation could not be resolved, so double-check.  (We must
			 * check this here because DefineRelation would adopt the type's
			 * default collation rather than complaining.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>col</name><operator>-&gt;</operator><name>collOid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>type_is_collatable</name><argument_list>(<argument><expr><name><name>col</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>typeOid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDETERMINATE_COLLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no collation was derived for column \"%s\" with collatable type %s"</literal></expr></argument>,
								<argument><expr><name><name>col</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>,
								<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>col</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>typeOid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use the COLLATE clause to set the collation explicitly."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>attrList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>attrList</name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>lc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too many column names were specified"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Create the relation definition using the ColumnDef list */</comment>
	<return>return <expr><call><name>create_ctas_internal</name><argument_list>(<argument><expr><name>attrList</name></expr></argument>, <argument><expr><name>into</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExecCreateTableAs -- execute a CREATE TABLE AS command
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>ExecCreateTableAs</name><parameter_list>(<parameter><decl><type><name>CreateTableAsStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
				  <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>, <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
				  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IntoClause</name> <modifier>*</modifier></type><name>into</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>into</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_matview</name> <init>= <expr><operator>(</operator><name><name>into</name><operator>-&gt;</operator><name>viewQuery</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>save_userid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_sec_context</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_nestlevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rewritten</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QueryDesc</name>  <modifier>*</modifier></type><name>queryDesc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>if_not_exists</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>nspid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>oldrelid</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>nspid</name> <operator>=</operator> <call><name>RangeVarGetCreationNamespace</name><argument_list>(<argument><expr><name><name>into</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>oldrelid</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name><name>into</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>nspid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>oldrelid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The relation exists and IF NOT EXISTS has been specified.
			 *
			 * If we are in an extension script, insist that the pre-existing
			 * object be a member of the extension, to avoid security risks.
			 */</comment>
			<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>oldrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>checkMembershipInCurrentExtension</name><argument_list>(<argument><expr><operator>&amp;</operator><name>address</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* OK to skip */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" already exists, skipping"</literal></expr></argument>,
							<argument><expr><name><name>into</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>InvalidObjectAddress</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Create the tuple receiver object and insert info it will need
	 */</comment>
	<expr_stmt><expr><name>dest</name> <operator>=</operator> <call><name>CreateIntoRelDestReceiver</name><argument_list>(<argument><expr><name>into</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The contained Query could be a SELECT, or an EXECUTE utility command.
	 * If the latter, we just pass it off to ExecuteQuery.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name> <operator>&amp;&amp;</operator>
		<call><name>IsA</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>, <argument><expr><name>ExecuteStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExecuteStmt</name> <modifier>*</modifier></type><name>estmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ExecuteStmt</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_matview</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* excluded by syntax */</comment>
		<expr_stmt><expr><call><name>ExecuteQuery</name><argument_list>(<argument><expr><name>estmt</name></expr></argument>, <argument><expr><name>into</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* get object address that intorel_startup saved for us */</comment>
		<expr_stmt><expr><name>address</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>DR_intorel</name> <operator>*</operator><operator>)</operator> <name>dest</name><operator>)</operator><operator>-&gt;</operator><name>reladdr</name></expr>;</expr_stmt>

		<return>return <expr><name>address</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For materialized views, lock down security-restricted operations and
	 * arrange to make GUC variable changes local to this command.  This is
	 * not necessary for security, but this keeps the behavior similar to
	 * REFRESH MATERIALIZED VIEW.  Otherwise, one could create a materialized
	 * view not possible to refresh.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_matview</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>GetUserIdAndSecContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>save_userid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_sec_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name>save_userid</name></expr></argument>,
							   <argument><expr><name>save_sec_context</name> <operator>|</operator> <name>SECURITY_RESTRICTED_OPERATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>save_nestlevel</name> <operator>=</operator> <call><name>NewGUCNestLevel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>into</name><operator>-&gt;</operator><name>skipData</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If WITH NO DATA was specified, do not go through the rewriter,
		 * planner and executor.  Just define the relation using a code path
		 * similar to CREATE VIEW.  This avoids dump/restore problems stemming
		 * from running the planner before all dependencies are set up.
		 */</comment>
		<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>create_ctas_nodata</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>into</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Parse analysis was done already, but we still have to run the rule
		 * rewriter.  We do not do AcquireRewriteLocks: we assume the query
		 * either came straight from the parser, or suitable locks were
		 * acquired by plancache.c.
		 *
		 * Because the rewriter and planner tend to scribble on the input, we
		 * make a preliminary copy of the source querytree.  This prevents
		 * problems in the case that CTAS is in a portal or plpgsql function
		 * and is executed repeatedly.  (See also the same hack in EXPLAIN and
		 * PREPARE.)
		 */</comment>
		<expr_stmt><expr><name>rewritten</name> <operator>=</operator> <call><name>QueryRewrite</name><argument_list>(<argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* SELECT should never rewrite to more or less than one SELECT query */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>rewritten</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected rewrite result for %s"</literal></expr></argument>,
				 <argument><expr><ternary><condition><expr><name>is_matview</name></expr> ?</condition><then> <expr><literal type="string">"CREATE MATERIALIZED VIEW"</literal></expr> </then><else>:
				 <expr><literal type="string">"CREATE TABLE AS SELECT"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name>rewritten</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* plan the query */</comment>
		<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>pg_plan_query</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>CURSOR_OPT_PARALLEL_OK</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Use a snapshot with an updated command ID to ensure this query sees
		 * results of any previously executed queries.  (This could only
		 * matter if the planner executed an allegedly-stable function that
		 * changed the database contents, but let's do it anyway to be
		 * parallel to the EXPLAIN code path.)
		 */</comment>
		<expr_stmt><expr><call><name>PushCopiedSnapshot</name><argument_list>(<argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UpdateActiveSnapshotCommandId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Create a QueryDesc, redirecting output to our tuple receiver */</comment>
		<expr_stmt><expr><name>queryDesc</name> <operator>=</operator> <call><name>CreateQueryDesc</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
									<argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>InvalidSnapshot</name></expr></argument>,
									<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* call ExecutorStart to prepare the plan for execution */</comment>
		<expr_stmt><expr><call><name>ExecutorStart</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><call><name>GetIntoRelEFlags</name><argument_list>(<argument><expr><name>into</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* run the plan to completion */</comment>
		<expr_stmt><expr><call><name>ExecutorRun</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* save the rowcount if we're given a completionTag to fill */</comment>
		<if_stmt><if>if <condition>(<expr><name>completionTag</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>, <argument><expr><name>COMPLETION_TAG_BUFSIZE</name></expr></argument>,
					 <argument><expr><literal type="string">"SELECT "</literal> <name>UINT64_FORMAT</name></expr></argument>,
					 <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* get object address that intorel_startup saved for us */</comment>
		<expr_stmt><expr><name>address</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>DR_intorel</name> <operator>*</operator><operator>)</operator> <name>dest</name><operator>)</operator><operator>-&gt;</operator><name>reladdr</name></expr>;</expr_stmt>

		<comment type="block">/* and clean up */</comment>
		<expr_stmt><expr><call><name>ExecutorFinish</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecutorEnd</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>FreeQueryDesc</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_matview</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Roll back any GUC changes */</comment>
		<expr_stmt><expr><call><name>AtEOXact_GUC</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>save_nestlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Restore userid and security context */</comment>
		<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name>save_userid</name></expr></argument>, <argument><expr><name>save_sec_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetIntoRelEFlags --- compute executor flags needed for CREATE TABLE AS
 *
 * This is exported because EXPLAIN and PREPARE need it too.  (Note: those
 * callers still need to deal explicitly with the skipData flag; since they
 * use different methods for suppressing execution, it doesn't seem worth
 * trying to encapsulate that part.)
 */</comment>
<function><type><name>int</name></type>
<name>GetIntoRelEFlags</name><parameter_list>(<parameter><decl><type><name>IntoClause</name> <modifier>*</modifier></type><name>intoClause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>flags</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We need to tell the executor whether it has to produce OIDs or not,
	 * because it doesn't have enough information to do so itself (since we
	 * can't build the target relation until after ExecutorStart).
	 *
	 * Disallow the OIDS option for materialized views.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>interpretOidsOption</name><argument_list>(<argument><expr><name><name>intoClause</name><operator>-&gt;</operator><name>options</name></name></expr></argument>,
							<argument><expr><operator>(</operator><name><name>intoClause</name><operator>-&gt;</operator><name>viewQuery</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>EXEC_FLAG_WITH_OIDS</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>EXEC_FLAG_WITHOUT_OIDS</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>intoClause</name><operator>-&gt;</operator><name>skipData</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>EXEC_FLAG_WITH_NO_DATA</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>flags</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CreateIntoRelDestReceiver -- create a suitable DestReceiver object
 *
 * intoClause will be NULL if called from CreateDestReceiver(), in which
 * case it has to be provided later.  However, it is convenient to allow
 * self-&gt;into to be filled in immediately for other callers.
 */</comment>
<function><type><name>DestReceiver</name> <modifier>*</modifier></type>
<name>CreateIntoRelDestReceiver</name><parameter_list>(<parameter><decl><type><name>IntoClause</name> <modifier>*</modifier></type><name>intoClause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DR_intorel</name> <modifier>*</modifier></type><name>self</name> <init>= <expr><operator>(</operator><name>DR_intorel</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DR_intorel</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>receiveSlot</name></name> <operator>=</operator> <name>intorel_receive</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>rStartup</name></name> <operator>=</operator> <name>intorel_startup</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>rShutdown</name></name> <operator>=</operator> <name>intorel_shutdown</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>rDestroy</name></name> <operator>=</operator> <name>intorel_destroy</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>mydest</name></name> <operator>=</operator> <name>DestIntoRel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>into</name></name> <operator>=</operator> <name>intoClause</name></expr>;</expr_stmt>
	<comment type="block">/* other private fields will be set during intorel_startup */</comment>

	<return>return <expr><operator>(</operator><name>DestReceiver</name> <operator>*</operator><operator>)</operator> <name>self</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * intorel_startup --- executor startup
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>intorel_startup</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>operation</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>typeinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DR_intorel</name> <modifier>*</modifier></type><name>myState</name> <init>= <expr><operator>(</operator><name>DR_intorel</name> <operator>*</operator><operator>)</operator> <name>self</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IntoClause</name> <modifier>*</modifier></type><name>into</name> <init>= <expr><name><name>myState</name><operator>-&gt;</operator><name>into</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_matview</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>relkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>attrList</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>intoRelationAddr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>intoRelationDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>into</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* else somebody forgot to set it */</comment>

	<comment type="block">/* This code supports both CREATE TABLE AS and CREATE MATERIALIZED VIEW */</comment>
	<expr_stmt><expr><name>is_matview</name> <operator>=</operator> <operator>(</operator><name><name>into</name><operator>-&gt;</operator><name>viewQuery</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>relkind</name> <operator>=</operator> <ternary><condition><expr><name>is_matview</name></expr> ?</condition><then> <expr><name>RELKIND_MATVIEW</name></expr> </then><else>: <expr><name>RELKIND_RELATION</name></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build column definitions using "pre-cooked" type and collation info. If
	 * a column name list was specified in CREATE TABLE AS, override the
	 * column names derived from the query.  (Too few column names are OK, too
	 * many are not.)
	 */</comment>
	<expr_stmt><expr><name>attrList</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>into</name><operator>-&gt;</operator><name>colNames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>attnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attnum</name> <operator>&lt;</operator> <name><name>typeinfo</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attribute</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>typeinfo</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>col</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>lc</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>col</name> <operator>=</operator> <call><name>makeColumnDef</name><argument_list>(<argument><expr><name>colname</name></expr></argument>,
							<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
							<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>,
							<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * It's possible that the column is of a collatable type but the
		 * collation could not be resolved, so double-check.  (We must check
		 * this here because DefineRelation would adopt the type's default
		 * collation rather than complaining.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>col</name><operator>-&gt;</operator><name>collOid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>type_is_collatable</name><argument_list>(<argument><expr><name><name>col</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>typeOid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDETERMINATE_COLLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no collation was derived for column \"%s\" with collatable type %s"</literal></expr></argument>,
							<argument><expr><name><name>col</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>col</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>typeOid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use the COLLATE clause to set the collation explicitly."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>attrList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>attrList</name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>lc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too many column names were specified"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Actually create the target table
	 */</comment>
	<expr_stmt><expr><name>intoRelationAddr</name> <operator>=</operator> <call><name>create_ctas_internal</name><argument_list>(<argument><expr><name>attrList</name></expr></argument>, <argument><expr><name>into</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Finally we can open the target table
	 */</comment>
	<expr_stmt><expr><name>intoRelationDesc</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>intoRelationAddr</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check INSERT permission on the constructed table.
	 *
	 * XXX: It would arguably make sense to skip this check if into-&gt;skipData
	 * is true.
	 */</comment>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_RELATION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name><name>intoRelationAddr</name><operator>.</operator><name>objectId</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name>relkind</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <name>ACL_INSERT</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>attnum</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>attnum</name> <operator>&lt;=</operator> <name><name>intoRelationDesc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>insertedCols</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>insertedCols</name></name></expr></argument>,
										   <argument><expr><name>attnum</name> <operator>-</operator> <call><name>YBGetFirstLowInvalidAttributeNumber</name><argument_list>(<argument><expr><name>intoRelationDesc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>ExecCheckRTPerms</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure the constructed table does not have RLS enabled.
	 *
	 * check_enable_rls() will ereport(ERROR) itself if the user has requested
	 * something invalid, and otherwise will return RLS_ENABLED if RLS should
	 * be enabled here.  We don't actually support that currently, so throw
	 * our own ereport(ERROR) if that happens.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>check_enable_rls</name><argument_list>(<argument><expr><name><name>intoRelationAddr</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RLS_ENABLED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"policies not yet implemented for this command"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Tentatively mark the target as populated, if it's a matview and we're
	 * going to fill it; otherwise, no change needed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_matview</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>into</name><operator>-&gt;</operator><name>skipData</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetMatViewPopulatedState</name><argument_list>(<argument><expr><name>intoRelationDesc</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Fill private fields of myState for use by later routines
	 */</comment>
	<expr_stmt><expr><name><name>myState</name><operator>-&gt;</operator><name>rel</name></name> <operator>=</operator> <name>intoRelationDesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myState</name><operator>-&gt;</operator><name>reladdr</name></name> <operator>=</operator> <name>intoRelationAddr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myState</name><operator>-&gt;</operator><name>output_cid</name></name> <operator>=</operator> <call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We can skip WAL-logging the insertions, unless PITR or streaming
	 * replication is in use. We can skip the FSM in any case.
	 */</comment>
	<expr_stmt><expr><name><name>myState</name><operator>-&gt;</operator><name>hi_options</name></name> <operator>=</operator> <name>HEAP_INSERT_SKIP_FSM</name> <operator>|</operator>
		<operator>(</operator><ternary><condition><expr><call><name>XLogIsNeeded</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>HEAP_INSERT_SKIP_WAL</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myState</name><operator>-&gt;</operator><name>bistate</name></name> <operator>=</operator> <call><name>GetBulkInsertState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Not using WAL requires smgr_targblock be initially invalid */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationGetTargetBlock</name><argument_list>(<argument><expr><name>intoRelationDesc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidBlockNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * intorel_receive --- receive one tuple
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>intorel_receive</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DR_intorel</name> <modifier>*</modifier></type><name>myState</name> <init>= <expr><operator>(</operator><name>DR_intorel</name> <operator>*</operator><operator>)</operator> <name>self</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * get the heap tuple out of the tuple table slot, making sure we have a
	 * writable copy
	 */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * force assignment of new OID (see comments in ExecInsert)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>myState</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>HeapTupleSetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * if we are creating and inserting into a temporary table,
	 * we must use PG transaction codepaths as well
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>myState</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name>
			<operator>&amp;&amp;</operator> <call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetTxnWithPGRel</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsYBRelation</name><argument_list>(<argument><expr><name><name>myState</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>YBCExecuteInsert</name><argument_list>(<argument><expr><name><name>myState</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>,
						 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>myState</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>tuple</name></expr></argument>,
						 <argument><expr><name>ONCONFLICT_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>heap_insert</name><argument_list>(<argument><expr><name><name>myState</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>,
					<argument><expr><name>tuple</name></expr></argument>,
					<argument><expr><name><name>myState</name><operator>-&gt;</operator><name>output_cid</name></name></expr></argument>,
					<argument><expr><name><name>myState</name><operator>-&gt;</operator><name>hi_options</name></name></expr></argument>,
					<argument><expr><name><name>myState</name><operator>-&gt;</operator><name>bistate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* We know this is a newly created relation, so there are no indexes */</comment>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * intorel_shutdown --- executor end
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>intorel_shutdown</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DR_intorel</name> <modifier>*</modifier></type><name>myState</name> <init>= <expr><operator>(</operator><name>DR_intorel</name> <operator>*</operator><operator>)</operator> <name>self</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>FreeBulkInsertState</name><argument_list>(<argument><expr><name><name>myState</name><operator>-&gt;</operator><name>bistate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If we skipped using WAL, must heap_sync before commit */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>myState</name><operator>-&gt;</operator><name>hi_options</name></name> <operator>&amp;</operator> <name>HEAP_INSERT_SKIP_WAL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_sync</name><argument_list>(<argument><expr><name><name>myState</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* close rel, but keep lock until commit */</comment>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name><name>myState</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myState</name><operator>-&gt;</operator><name>rel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * intorel_destroy --- release DestReceiver object
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>intorel_destroy</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
