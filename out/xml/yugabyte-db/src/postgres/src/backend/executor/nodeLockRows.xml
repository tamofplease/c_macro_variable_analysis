<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/executor/nodeLockRows.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nodeLockRows.c
 *	  Routines to handle FOR UPDATE/FOR SHARE row locking
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/executor/nodeLockRows.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<comment type="block">/*
 * INTERFACE ROUTINES
 *		ExecLockRows		- fetch locked rows
 *		ExecInitLockRows	- initialize node and subnodes..
 *		ExecEndLockRows		- shutdown node and subnodes
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/yb_scan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeLockRows.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/fdwapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>


<comment type="block">/* ----------------------------------------------------------------
 *		ExecLockRows
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>			<comment type="block">/* return: a tuple or NULL */</comment>
<name>ExecLockRows</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LockRowsState</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>LockRowsState</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>outerPlan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>epq_needed</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * get information from the node
	 */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>outerPlan</name> <operator>=</operator> <call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get next tuple from subplan, if any.
	 */</comment>
<label><name>lnext</name>:</label>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>outerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>n_yb_relations</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>n_relations</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>node-&gt;lr_arowMarks</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExecAuxRowMark</name> <modifier>*</modifier></type><name>aerm</name> <init>= <expr><operator>(</operator><name>ExecAuxRowMark</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExecRowMark</name> <modifier>*</modifier></type><name>erm</name> <init>= <expr><name><name>aerm</name><operator>-&gt;</operator><name>rowmark</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsYBBackedRelation</name><argument_list>(<argument><expr><name><name>erm</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>n_yb_relations</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>n_relations</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>n_yb_relations</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>n_yb_relations</name> <operator>!=</operator> <name>n_relations</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Mixing Yugabyte relations and not Yugabyte relations with "</literal>
						<literal type="string">"row locks is not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>n_yb_relations</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>XactIsoLevel</name> <operator>==</operator> <name>XACT_SERIALIZABLE</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * For YB relations, we don't lock tuples using this node in SERIALIZABLE level. Instead we take
		 * predicate locks by setting the row mark in read requests sent to txn participants.
		 */</comment>
		<return>return <expr><name>slot</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* We don't need EvalPlanQual unless we get updated tuple version(s) */</comment>
	<expr_stmt><expr><name>epq_needed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Attempt to lock the source tuple(s).  (Note we only have locking
	 * rowmarks in lr_arowMarks.)
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>node-&gt;lr_arowMarks</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExecAuxRowMark</name> <modifier>*</modifier></type><name>aerm</name> <init>= <expr><operator>(</operator><name>ExecAuxRowMark</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExecRowMark</name> <modifier>*</modifier></type><name>erm</name> <init>= <expr><name><name>aerm</name><operator>-&gt;</operator><name>rowmark</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name>  <modifier>*</modifier></type><name>testTuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapUpdateFailureData</name></type> <name>hufd</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LockTupleMode</name></type> <name>lockmode</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HTSU_Result</name></type> <name>test</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>copyTuple</name></decl>;</decl_stmt>

		<comment type="block">/* clear any leftover test tuple for this rel */</comment>
		<expr_stmt><expr><name>testTuple</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>lr_curtuples</name><index>[<expr><name><name>erm</name><operator>-&gt;</operator><name>rti</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>testTuple</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><operator>*</operator><name>testTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>testTuple</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/* if child rel, must check whether it produced this row */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>erm</name><operator>-&gt;</operator><name>rti</name></name> <operator>!=</operator> <name><name>erm</name><operator>-&gt;</operator><name>prti</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>tableoid</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>ExecGetJunkAttribute</name><argument_list>(<argument><expr><name>slot</name></expr></argument>,
										 <argument><expr><name><name>aerm</name><operator>-&gt;</operator><name>toidAttNo</name></name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* shouldn't ever get a null result... */</comment>
			<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"tableoid is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>tableoid</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>erm</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>tableoid</name> <operator>!=</operator> <name><name>erm</name><operator>-&gt;</operator><name>relid</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* this child is inactive right now */</comment>
				<expr_stmt><expr><name><name>erm</name><operator>-&gt;</operator><name>ermActive</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>erm</name><operator>-&gt;</operator><name>curCtid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>erm</name><operator>-&gt;</operator><name>ermActive</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/* fetch the tuple's ctid */</comment>
		<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>ExecGetJunkAttribute</name><argument_list>(<argument><expr><name>slot</name></expr></argument>,
									 <argument><expr><name><name>aerm</name><operator>-&gt;</operator><name>ctidAttNo</name></name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* shouldn't ever get a null result... */</comment>
		<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ctid is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* requests for foreign tables must be passed to their FDW */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>erm</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FdwRoutine</name> <modifier>*</modifier></type><name>fdwroutine</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>updated</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>fdwroutine</name> <operator>=</operator> <call><name>GetFdwRoutineForRelation</name><argument_list>(<argument><expr><name><name>erm</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* this should have been checked already, but let's be safe */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>RefetchForeignRow</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot lock rows in foreign table \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>erm</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>copyTuple</name> <operator>=</operator> <call><name><name>fdwroutine</name><operator>-&gt;</operator><name>RefetchForeignRow</name></name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
													  <argument><expr><name>erm</name></expr></argument>,
													  <argument><expr><name>datum</name></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name>updated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>copyTuple</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* couldn't get the lock, so skip this row */</comment>
				<goto>goto <name>lnext</name>;</goto>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* save locked tuple for possible EvalPlanQual testing below */</comment>
			<expr_stmt><expr><operator>*</operator><name>testTuple</name> <operator>=</operator> <name>copyTuple</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * if FDW says tuple was updated before getting locked, we need to
			 * perform EPQ testing to see if quals are still satisfied
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>updated</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>epq_needed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* okay, try to lock the tuple */</comment>
		<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>t_self</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>ItemPointer</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name><name>erm</name><operator>-&gt;</operator><name>markType</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>ROW_MARK_EXCLUSIVE</name></expr>:</case>
				<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name>LockTupleExclusive</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>ROW_MARK_NOKEYEXCLUSIVE</name></expr>:</case>
				<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name>LockTupleNoKeyExclusive</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>ROW_MARK_SHARE</name></expr>:</case>
				<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name>LockTupleShare</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>ROW_MARK_KEYSHARE</name></expr>:</case>
				<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name>LockTupleKeyShare</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported rowmark type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name>LockTupleNoKeyExclusive</name></expr>;</expr_stmt> <comment type="block">/* keep compiler quiet */</comment>
				<break>break;</break>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><call><name>IsYBBackedRelation</name><argument_list>(<argument><expr><name><name>erm</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>test</name> <operator>=</operator> <call><name>YBCLockTuple</name><argument_list>(<argument><expr><name><name>erm</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>datum</name></expr></argument>, <argument><expr><name><name>erm</name><operator>-&gt;</operator><name>markType</name></name></expr></argument>, <argument><expr><name><name>erm</name><operator>-&gt;</operator><name>waitPolicy</name></name></expr></argument>,
													<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else <block>{<block_content>
			<expr_stmt><expr><name>test</name> <operator>=</operator> <call><name>heap_lock_tuple</name><argument_list>(<argument><expr><name><name>erm</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tuple</name></expr></argument>,
							   <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name></expr></argument>,
							   <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name><name>erm</name><operator>-&gt;</operator><name>waitPolicy</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hufd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<switch>switch <condition>(<expr><name>test</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>HeapTupleWouldBlock</name></expr>:</case>
				<comment type="block">/* couldn't lock tuple in SKIP LOCKED mode */</comment>
				<goto>goto <name>lnext</name>;</goto>

			<case>case <expr><name>HeapTupleSelfUpdated</name></expr>:</case>

				<comment type="block">/*
				* The target tuple was already updated or deleted by the
				* current command, or by a later command in the current
				* transaction.  We *must* ignore the tuple in the former
				* case, so as to avoid the "Halloween problem" of repeated
				* update attempts.  In the latter case it might be sensible
				* to fetch the updated tuple instead, but doing so would
				* require changing heap_update and heap_delete to not
				* complain about updating "invisible" tuples, which seems
				* pretty scary (heap_lock_tuple will not complain, but few
				* callers expect HeapTupleInvisible, and we're not one of
				* them).  So for now, treat the tuple as deleted and do not
				* process.
				*/</comment>
				<goto>goto <name>lnext</name>;</goto>

			<case>case <expr><name>HeapTupleMayBeUpdated</name></expr>:</case>
				<comment type="block">/* got the lock successfully */</comment>
				<break>break;</break>

			<case>case <expr><name>HeapTupleUpdated</name></expr>:</case>
				<comment type="block">/*
				 * TODO(Piyush): If handling using EvalPlanQual for READ COMMITTED in future, replace true
				 * with IsolationUsesXactSnapshot().
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>true</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>erm</name><operator>-&gt;</operator><name>waitPolicy</name></name> <operator>==</operator> <name>LockWaitError</name></expr>)</condition>
					<block>{<block_content>
						<comment type="line">// In case the user has specified NOWAIT, the intention is to error out immediately. If</comment>
						<comment type="line">// we raise TransactionErrorCode::kConflict, the statement might be retried by our</comment>
						<comment type="line">// retry logic in yb_attempt_to_restart_on_error().</comment>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_LOCK_NOT_AVAILABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not obtain lock on row in relation \"%s\""</literal></expr></argument>,
											<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>erm</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not serialize access due to concurrent update"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>yb_txn_errcode</name><argument_list>(<argument><expr><call><name>YBCGetTxnConflictErrorCode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>ItemPointerIndicatesMovedPartitions</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hufd</name><operator>.</operator><name>ctid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tuple to be locked was already moved to another partition due to "</literal>
											<literal type="string">"concurrent update"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>ItemPointerEquals</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hufd</name><operator>.</operator><name>ctid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>.</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Tuple was deleted, so don't return it */</comment>
					<goto>goto <name>lnext</name>;</goto>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* updated, so fetch and lock the updated version */</comment>
				<expr_stmt><expr><name>copyTuple</name> <operator>=</operator> <call><name>EvalPlanQualFetch</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>erm</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
												<argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name><name>erm</name><operator>-&gt;</operator><name>waitPolicy</name></name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name><name>hufd</name><operator>.</operator><name>ctid</name></name></expr></argument>, <argument><expr><name><name>hufd</name><operator>.</operator><name>xmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>copyTuple</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					* Tuple was deleted; or it's locked and we're under SKIP
					* LOCKED policy, so don't return it
					*/</comment>
					<goto>goto <name>lnext</name>;</goto>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* remember the actually locked tuple's TID */</comment>
				<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>t_self</name></name> <operator>=</operator> <name><name>copyTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr>;</expr_stmt>

				<comment type="block">/* Save locked tuple for EvalPlanQual testing below */</comment>
				<expr_stmt><expr><operator>*</operator><name>testTuple</name> <operator>=</operator> <name>copyTuple</name></expr>;</expr_stmt>

				<comment type="block">/* Remember we need to do EPQ testing */</comment>
				<expr_stmt><expr><name>epq_needed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<comment type="block">/* Continue loop until we have all target tuples */</comment>
				<break>break;</break>

			<case>case <expr><name>HeapTupleInvisible</name></expr>:</case>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"attempted to lock invisible tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized heap_lock_tuple status: %u"</literal></expr></argument>,
					<argument><expr><name>test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsYBBackedRelation</name><argument_list>(<argument><expr><name><name>erm</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Remember locked tuple's TID for EPQ testing and WHERE CURRENT OF */</comment>
			<expr_stmt><expr><name><name>erm</name><operator>-&gt;</operator><name>curCtid</name></name> <operator>=</operator> <name><name>tuple</name><operator>.</operator><name>t_self</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If we need to do EvalPlanQual testing, do so.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>epq_needed</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Initialize EPQ machinery */</comment>
		<expr_stmt><expr><call><name>EvalPlanQualBegin</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>lr_epqstate</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Transfer any already-fetched tuples into the EPQ state, and fetch a
		 * copy of any rows that were successfully locked without any update
		 * having occurred.  (We do this in a separate pass so as to avoid
		 * overhead in the common case where there are no concurrent updates.)
		 * Make sure any inactive child rels have NULL test tuples in EPQ.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>node-&gt;lr_arowMarks</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ExecAuxRowMark</name> <modifier>*</modifier></type><name>aerm</name> <init>= <expr><operator>(</operator><name>ExecAuxRowMark</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ExecRowMark</name> <modifier>*</modifier></type><name>erm</name> <init>= <expr><name><name>aerm</name><operator>-&gt;</operator><name>rowmark</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>

			<comment type="block">/* skip non-active child tables, but clear their test tuples */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>erm</name><operator>-&gt;</operator><name>ermActive</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>erm</name><operator>-&gt;</operator><name>rti</name></name> <operator>!=</operator> <name><name>erm</name><operator>-&gt;</operator><name>prti</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* check it's child table */</comment>
				<expr_stmt><expr><call><name>EvalPlanQualSetTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>lr_epqstate</name></name></expr></argument>, <argument><expr><name><name>erm</name><operator>-&gt;</operator><name>rti</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* was tuple updated and fetched above? */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>lr_curtuples</name><index>[<expr><name><name>erm</name><operator>-&gt;</operator><name>rti</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* yes, so set it as the EPQ test tuple for this rel */</comment>
				<expr_stmt><expr><call><name>EvalPlanQualSetTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>lr_epqstate</name></name></expr></argument>,
									 <argument><expr><name><name>erm</name><operator>-&gt;</operator><name>rti</name></name></expr></argument>,
									 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>lr_curtuples</name><index>[<expr><name><name>erm</name><operator>-&gt;</operator><name>rti</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* freeing this tuple is now the responsibility of EPQ */</comment>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>lr_curtuples</name><index>[<expr><name><name>erm</name><operator>-&gt;</operator><name>rti</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* foreign tables should have been fetched above */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>erm</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>erm</name><operator>-&gt;</operator><name>curCtid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* okay, fetch the tuple */</comment>
			<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>t_self</name></name> <operator>=</operator> <name><name>erm</name><operator>-&gt;</operator><name>curCtid</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>heap_fetch</name><argument_list>(<argument><expr><name><name>erm</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>SnapshotAny</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>,
							<argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to fetch tuple for EvalPlanQual recheck"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* successful, copy and store tuple */</comment>
			<expr_stmt><expr><call><name>EvalPlanQualSetTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>lr_epqstate</name></name></expr></argument>, <argument><expr><name><name>erm</name><operator>-&gt;</operator><name>rti</name></name></expr></argument>,
								 <argument><expr><call><name>heap_copytuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Now fetch any non-locked source rows --- the EPQ logic knows how to
		 * do that.
		 */</comment>
		<expr_stmt><expr><call><name>EvalPlanQualSetSlot</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>lr_epqstate</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>EvalPlanQualFetchRowMarks</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>lr_epqstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * And finally we can re-evaluate the tuple.
		 */</comment>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>EvalPlanQualNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>lr_epqstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Updated tuple fails qual, so ignore it and go on */</comment>
			<goto>goto <name>lnext</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Got all locks, so return the current tuple */</comment>
	<return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecInitLockRows
 *
 *		This initializes the LockRows node state structures and
 *		the node's subplan.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>LockRowsState</name> <modifier>*</modifier></type>
<name>ExecInitLockRows</name><parameter_list>(<parameter><decl><type><name>LockRows</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LockRowsState</name> <modifier>*</modifier></type><name>lrstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>outerPlan</name> <init>= <expr><call><name>outerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>epq_arowmarks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* check for unsupported flags */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <name>EXEC_FLAG_MARK</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * create state structure
	 */</comment>
	<expr_stmt><expr><name>lrstate</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>LockRowsState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lrstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lrstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lrstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ExecProcNode</name></name> <operator>=</operator> <name>ExecLockRows</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Miscellaneous initialization
	 *
	 * LockRows nodes never call ExecQual or ExecProject, therefore no
	 * ExprContext is needed.
	 */</comment>

	<comment type="block">/*
	 * Initialize result type.
	 */</comment>
	<expr_stmt><expr><call><name>ExecInitResultTypeTL</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lrstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * then initialize outer plan
	 */</comment>
	<expr_stmt><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>lrstate</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><name>outerPlan</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * LockRows nodes do no projections, so initialize projection info for
	 * this node appropriately
	 */</comment>
	<expr_stmt><expr><name><name>lrstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create workspace in which we can remember per-RTE locked tuples
	 */</comment>
	<expr_stmt><expr><name><name>lrstate</name><operator>-&gt;</operator><name>lr_ntables</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lrstate</name><operator>-&gt;</operator><name>lr_curtuples</name></name> <operator>=</operator> <operator>(</operator><name>HeapTuple</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><name><name>lrstate</name><operator>-&gt;</operator><name>lr_ntables</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HeapTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Locate the ExecRowMark(s) that this node is responsible for, and
	 * construct ExecAuxRowMarks for them.  (InitPlan should already have
	 * built the global list of ExecRowMarks.)
	 */</comment>
	<expr_stmt><expr><name><name>lrstate</name><operator>-&gt;</operator><name>lr_arowMarks</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>epq_arowmarks</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>node-&gt;rowMarks</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlanRowMark</name> <modifier>*</modifier></type><name>rc</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>PlanRowMark</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExecRowMark</name> <modifier>*</modifier></type><name>erm</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExecAuxRowMark</name> <modifier>*</modifier></type><name>aerm</name></decl>;</decl_stmt>

		<comment type="block">/* ignore "parent" rowmarks; they are irrelevant at runtime */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>isParent</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* safety check on size of lr_curtuples array */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>rti</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>rc</name><operator>-&gt;</operator><name>rti</name></name> <operator>&lt;=</operator> <name><name>lrstate</name><operator>-&gt;</operator><name>lr_ntables</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* find ExecRowMark and build ExecAuxRowMark */</comment>
		<expr_stmt><expr><name>erm</name> <operator>=</operator> <call><name>ExecFindRowMark</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>rc</name><operator>-&gt;</operator><name>rti</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>aerm</name> <operator>=</operator> <call><name>ExecBuildAuxRowMark</name><argument_list>(<argument><expr><name>erm</name></expr></argument>, <argument><expr><name><name>outerPlan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Only locking rowmarks go into our own list.  Non-locking marks are
		 * passed off to the EvalPlanQual machinery.  This is because we don't
		 * want to bother fetching non-locked rows unless we actually have to
		 * do an EPQ recheck.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RowMarkRequiresRowShareLock</name><argument_list>(<argument><expr><name><name>erm</name><operator>-&gt;</operator><name>markType</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>lrstate</name><operator>-&gt;</operator><name>lr_arowMarks</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>lrstate</name><operator>-&gt;</operator><name>lr_arowMarks</name></name></expr></argument>, <argument><expr><name>aerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>epq_arowmarks</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>epq_arowmarks</name></expr></argument>, <argument><expr><name>aerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Now we have the info needed to set up EPQ state */</comment>
	<expr_stmt><expr><call><name>EvalPlanQualInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lrstate</name><operator>-&gt;</operator><name>lr_epqstate</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>,
					 <argument><expr><name>outerPlan</name></expr></argument>, <argument><expr><name>epq_arowmarks</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>epqParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>lrstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecEndLockRows
 *
 *		This shuts down the subplan and frees resources allocated
 *		to this node.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecEndLockRows</name><parameter_list>(<parameter><decl><type><name>LockRowsState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>EvalPlanQualEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>lr_epqstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>ExecReScanLockRows</name><parameter_list>(<parameter><decl><type><name>LockRowsState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * if chgParam of subnode is not null then plan will be re-scanned by
	 * first ExecProcNode.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>lefttree</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>lefttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
</unit>
