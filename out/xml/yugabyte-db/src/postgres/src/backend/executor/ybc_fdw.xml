<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/executor/ybc_fdw.c"><comment type="block">/*--------------------------------------------------------------------------------------------------
 *
 * ybc_fdw.c
 *		  Foreign-data wrapper for YugabyteDB.
 *
 * Copyright (c) YugaByte, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied.  See the License for the specific language governing permissions and limitations
 * under the License.
 *
 * IDENTIFICATION
 *		  src/backend/executor/ybc_fdw.c
 *
 *--------------------------------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<comment type="block">/*  TODO see which includes of this block are still needed. */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/reloptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_foreign_table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/copy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/explain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/vacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/fdwapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/foreign.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/paths.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/restrictinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/var.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/sampling.h"</cpp:file></cpp:include>

<comment type="block">/*  YB includes. */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/yb_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"yb/yql/pggate/ybc_pggate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_yb_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/yb_scan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/ybcExpr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/ybc_fdw.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resowner_private.h"</cpp:file></cpp:include>

<comment type="block">/* -------------------------------------------------------------------------- */</comment>
<comment type="block">/*  Planner/Optimizer functions */</comment>

<typedef>typedef <type><struct>struct <name>YbFdwPlanState</name>
<block>{
	<comment type="block">/* Bitmap of attribute (column) numbers that we need to fetch from YB. */</comment>
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>target_attrs</name></decl>;</decl_stmt>

}</block></struct></type> <name>YbFdwPlanState</name>;</typedef>

<comment type="block">/*
 * ybcGetForeignRelSize
 *		Obtain relation size estimates for a foreign table
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ybcGetForeignRelSize</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>,
					 <parameter><decl><type><name>Oid</name></type> <name>foreigntableid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>YbFdwPlanState</name>		<modifier>*</modifier></type><name>ybc_plan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>ybc_plan</name> <operator>=</operator> <operator>(</operator><name>YbFdwPlanState</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>YbFdwPlanState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set the estimate for the total number of rows (tuples) in this table. */</comment>
	<if_stmt><if>if <condition>(<expr><name>yb_enable_optimizer_statistics</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>set_baserel_size_estimates</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>baserel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>baserel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator> <name>YBC_DEFAULT_NUM_ROWS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		* Initialize the estimate for the number of rows returned by this query.
		* This does not yet take into account the restriction clauses, but it will
		* be updated later by ybcIndexCostEstimate once it inspects the clauses.
		*/</comment>
		<expr_stmt><expr><name><name>baserel</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name><name>baserel</name><operator>-&gt;</operator><name>tuples</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>baserel</name><operator>-&gt;</operator><name>fdw_private</name></name> <operator>=</operator> <name>ybc_plan</name></expr>;</expr_stmt>


	<comment type="block">/*
	 * Test any indexes of rel for applicability also.
	 */</comment>
	<expr_stmt><expr><call><name>check_index_predicates</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ybcGetForeignPaths
 *		Create possible access paths for a scan on the foreign table, which is
 *      the full table scan plus available index paths (including the  primary key
 *      scan path if any).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ybcGetForeignPaths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
				   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>,
				   <parameter><decl><type><name>Oid</name></type> <name>foreigntableid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cost</name></type> <name>startup_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type> <name>total_cost</name></decl>;</decl_stmt>

	<comment type="block">/* Estimate costs */</comment>
	<expr_stmt><expr><call><name>ybcCostEstimate</name><argument_list>(<argument><expr><name>baserel</name></expr></argument>, <argument><expr><name>YBC_FULL_SCAN_SELECTIVITY</name></expr></argument>,
					<argument><expr><name>false</name></expr></argument> <comment type="block">/* is_backwards scan */</comment>,
					<argument><expr><name>true</name></expr></argument> <comment type="block">/* is_seq_scan */</comment>,
					<argument><expr><name>false</name></expr></argument> <comment type="block">/* is_uncovered_idx_scan */</comment>,
					<argument><expr><operator>&amp;</operator><name>startup_cost</name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name>total_cost</name></expr></argument>,
					<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>reltablespace</name></name></expr></argument> <comment type="block">/* index_tablespace_oid */</comment>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create a ForeignPath node and it as the scan path */</comment>
	<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>baserel</name></expr></argument>,
			 <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_foreignscan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											  <argument><expr><name>baserel</name></expr></argument>,
											  <argument><expr><name>NULL</name></expr></argument>, <comment type="block">/* default pathtarget */</comment>
											  <argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
											  <argument><expr><name>startup_cost</name></expr></argument>,
											  <argument><expr><name>total_cost</name></expr></argument>,
											  <argument><expr><name>NIL</name></expr></argument>,  <comment type="block">/* no pathkeys */</comment>
											  <argument><expr><name>NULL</name></expr></argument>, <comment type="block">/* no outer rel either */</comment>
											  <argument><expr><name>NULL</name></expr></argument>, <comment type="block">/* no extra plan */</comment>
											  <argument><expr><name>NULL</name></expr></argument>  <comment type="block">/* no options yet */</comment> )</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add primary key and secondary index paths also */</comment>
	<expr_stmt><expr><call><name>create_index_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ybcGetForeignPlan
 *		Create a ForeignScan plan node for scanning the foreign table
 */</comment>
<function><type><specifier>static</specifier> <name>ForeignScan</name> <modifier>*</modifier></type>
<name>ybcGetForeignPlan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
				  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>,
				  <parameter><decl><type><name>Oid</name></type> <name>foreigntableid</name></decl></parameter>,
				  <parameter><decl><type><name>ForeignPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>,
				  <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>outer_plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>YbFdwPlanState</name> <modifier>*</modifier></type><name>yb_plan_state</name> <init>= <expr><operator>(</operator><name>YbFdwPlanState</name> <operator>*</operator><operator>)</operator> <name><name>baserel</name><operator>-&gt;</operator><name>fdw_private</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>			<name>scan_relid</name> <init>= <expr><name><name>baserel</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>		   <modifier>*</modifier></type><name>local_clauses</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>		   <modifier>*</modifier></type><name>remote_clauses</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>		   <modifier>*</modifier></type><name>remote_params</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>	   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>scan_clauses</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Split the expressions in the scan_clauses onto two lists:
	 * - remote_clauses gets supported expressions to push down to DocDB, and
	 * - local_clauses gets remaining to evaluate upon returned rows.
	 * The remote_params list contains data type details of the columns
	 * referenced by the expressions in the remote_clauses list. DocDB needs it
	 * to convert row values to Datum/isnull pairs consumable by Postgres
	 * functions.
	 * The remote_clauses and remote_params lists are sent with the protobuf
	 * read request.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>scan_clauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>params</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>YbCanPushdownExpr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>params</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>remote_clauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>remote_clauses</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>remote_params</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>remote_params</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>local_clauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>local_clauses</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Get the target columns that need to be retrieved from DocDB */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>baserel-&gt;reltarget-&gt;exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>pull_varattnos_min_attr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>,
								<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name><name>yb_plan_state</name><operator>-&gt;</operator><name>target_attrs</name></name></expr></argument>,
								<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>min_attr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Get the target columns that are needed to evaluate local clauses */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>local_clauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>pull_varattnos_min_attr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>,
								<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name><name>yb_plan_state</name><operator>-&gt;</operator><name>target_attrs</name></name></expr></argument>,
								<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>min_attr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Set scan targets. */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>target_attrs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>wholerow</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>AttrNumber</name></type> <name>attnum</name> <init>= <expr><name><name>baserel</name><operator>-&gt;</operator><name>min_attr</name></name></expr></init></decl>;</init> <condition><expr><name>attnum</name> <operator>&lt;=</operator> <name><name>baserel</name><operator>-&gt;</operator><name>max_attr</name></name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>bms_idx</name> <init>= <expr><name>attnum</name> <operator>-</operator> <name><name>baserel</name><operator>-&gt;</operator><name>min_attr</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>wholerow</name> <operator>||</operator> <call><name>bms_is_member</name><argument_list>(<argument><expr><name>bms_idx</name></expr></argument>, <argument><expr><name><name>yb_plan_state</name><operator>-&gt;</operator><name>target_attrs</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<switch>switch <condition>(<expr><name>attnum</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>InvalidAttrNumber</name></expr>:</case>
					<comment type="block">/*
					 * Postgres repurposes InvalidAttrNumber to represent the "wholerow"
					 * junk attribute.
					 */</comment>
					<expr_stmt><expr><name>wholerow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>SelfItemPointerAttributeNumber</name></expr>:</case>
				<case>case <expr><name>MinTransactionIdAttributeNumber</name></expr>:</case>
				<case>case <expr><name>MinCommandIdAttributeNumber</name></expr>:</case>
				<case>case <expr><name>MaxTransactionIdAttributeNumber</name></expr>:</case>
				<case>case <expr><name>MaxCommandIdAttributeNumber</name></expr>:</case>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(
							        <argument><expr><literal type="string">"System column with id %d is not supported yet"</literal></expr></argument>,
							        <argument><expr><name>attnum</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>TableOidAttributeNumber</name></expr>:</case>
					<comment type="block">/* Nothing to do in YugaByte: Postgres will handle this. */</comment>
					<break>break;</break>
				<case>case <expr><name>ObjectIdAttributeNumber</name></expr>:</case>
				<case>case <expr><name>YBTupleIdAttributeNumber</name></expr>:</case>
				<default>default:</default> <comment type="block">/* Regular column: attrNum &gt; 0*/</comment>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>target_attrs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>target_attrs</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
			</block_content>}</block></switch>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Create the ForeignScan node */</comment>
	<return>return <expr><call><name>make_foreignscan</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,           <comment type="block">/* local target list */</comment>
							<argument><expr><name>local_clauses</name></expr></argument>,   <comment type="block">/* local qual */</comment>
							<argument><expr><name>scan_relid</name></expr></argument>,
							<argument><expr><name>target_attrs</name></expr></argument>,    <comment type="block">/* referenced attributes */</comment>
							<argument><expr><name>remote_params</name></expr></argument>,   <comment type="block">/* fdw_private data (attribute types) */</comment>
							<argument><expr><name>NIL</name></expr></argument>,             <comment type="block">/* remote target list (none for now) */</comment>
							<argument><expr><name>remote_clauses</name></expr></argument>,  <comment type="block">/* remote qual */</comment>
							<argument><expr><name>outer_plan</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ------------------------------------------------------------------------- */</comment>
<comment type="block">/*  Scanning functions */</comment>

<comment type="block">/*
 * FDW-specific information for ForeignScanState.fdw_state.
 */</comment>
<typedef>typedef <type><struct>struct <name>YbFdwExecState</name>
<block>{
	<comment type="block">/* The handle for the internal YB Select statement. */</comment>
	<decl_stmt><decl><type><name>YBCPgStatement</name></type>	<name>handle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YBCPgExecParameters</name> <modifier>*</modifier></type><name>exec_params</name></decl>;</decl_stmt> <comment type="block">/* execution control parameters for YugaByte */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_exec_done</name></decl>;</decl_stmt> <comment type="block">/* Each statement should be executed exactly one time */</comment>
}</block></struct></type> <name>YbFdwExecState</name>;</typedef>

<comment type="block">/*
 * ybcBeginForeignScan
 *		Initiate access to the Yugabyte by allocating a Select handle.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ybcBeginForeignScan</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>      <modifier>*</modifier></type><name>estate</name>      <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>    <name>relation</name>     <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>YbFdwExecState</name> <modifier>*</modifier></type><name>ybc_state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Do nothing in EXPLAIN (no ANALYZE) case.  node-&gt;fdw_state stays NULL. */</comment>
	<if_stmt><if>if <condition>(<expr><name>eflags</name> <operator>&amp;</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Allocate and initialize YB scan state. */</comment>
	<expr_stmt><expr><name>ybc_state</name> <operator>=</operator> <operator>(</operator><name>YbFdwExecState</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>YbFdwExecState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fdw_state</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>ybc_state</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgNewSelect</name><argument_list>(<argument><expr><call><name>YBCGetDatabaseOid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><call><name>YbGetStorageRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* prepare_params */</comment>,
								  <argument><expr><call><name>YBCIsRegionLocal</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name><name>ybc_state</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ybc_state</name><operator>-&gt;</operator><name>exec_params</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>estate</name><operator>-&gt;</operator><name>yb_exec_params</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ybc_state</name><operator>-&gt;</operator><name>exec_params</name><operator>-&gt;</operator><name>rowmark</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>YBReadFromFollowersEnabled</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Doing read from followers"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>XactIsoLevel</name> <operator>==</operator> <name>XACT_SERIALIZABLE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * In case of SERIALIZABLE isolation level we have to take predicate locks to disallow
		 * INSERTion of new rows that satisfy the query predicate. So, we set the rowmark on all
		 * read requests sent to tserver instead of locking each tuple one by one in LockRows node.
		 */</comment>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>estate-&gt;es_rowMarks</argument>)</argument_list></macro> <block>{<block_content>
			<decl_stmt><decl><type><name>ExecRowMark</name> <modifier>*</modifier></type><name>erm</name> <init>= <expr><operator>(</operator><name>ExecRowMark</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<comment type="line">// Do not propagate non-row-locking row marks.</comment>
			<if_stmt><if>if <condition>(<expr><name><name>erm</name><operator>-&gt;</operator><name>markType</name></name> <operator>!=</operator> <name>ROW_MARK_REFERENCE</name> <operator>&amp;&amp;</operator> <name><name>erm</name><operator>-&gt;</operator><name>markType</name></name> <operator>!=</operator> <name>ROW_MARK_COPY</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>ybc_state</name><operator>-&gt;</operator><name>exec_params</name><operator>-&gt;</operator><name>rowmark</name></name> <operator>=</operator> <name><name>erm</name><operator>-&gt;</operator><name>markType</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>YBUpdateRowLockPolicyForSerializable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ybc_state</name><operator>-&gt;</operator><name>exec_params</name><operator>-&gt;</operator><name>wait_policy</name></name></expr></argument>, <argument><expr><name><name>erm</name><operator>-&gt;</operator><name>waitPolicy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>ybc_state</name><operator>-&gt;</operator><name>is_exec_done</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>YbSetCatalogCacheVersion</name><argument_list>(<argument><expr><name><name>ybc_state</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><call><name>YbGetCatalogCacheVersion</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ybSetupScanTargets
 *		Add the target expressions to the DocDB statement.
 *		Currently target are either all column references or all aggregates.
 *		We do not push down target expressions yet.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ybcSetupScanTargets</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignScan</name> <modifier>*</modifier></type><name>foreignScan</name> <init>= <expr><operator>(</operator><name>ForeignScan</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YbFdwExecState</name> <modifier>*</modifier></type><name>ybc_state</name> <init>= <expr><operator>(</operator><name>YbFdwExecState</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>fdw_state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Planning function above should ensure target list is set */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>target_attrs</name> <init>= <expr><name><name>foreignScan</name><operator>-&gt;</operator><name>fdw_exprs</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>=
		<expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Set scan targets. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>yb_fdw_aggs</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Set non-aggregate column targets. */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>has_targets</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>target_attrs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* For regular (non-system) attribute check if they were deleted */</comment>
			<decl_stmt><decl><type><name>Oid</name></type>   <name>attr_typid</name>  <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>   <name>attr_collation</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type> <name>attr_typmod</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>resno</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl>;</decl_stmt>
				<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>resno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Ignore dropped attributes */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
				<block>{<block_content>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>attr_typid</name>  <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>attr_typmod</name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>attr_collation</name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>attcollation</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>YBCPgTypeAttrs</name></type> <name>type_attrs</name> <init>= <expr><block>{<expr><name>attr_typmod</name></expr>}</block></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>YBCPgExpr</name></type>      <name>expr</name>       <init>= <expr><call><name>YBCNewColumnRef</name><argument_list>(<argument><expr><name><name>ybc_state</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>,
														<argument><expr><name><name>target</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>,
														<argument><expr><name>attr_typid</name></expr></argument>,
														<argument><expr><name>attr_collation</name></expr></argument>,
														<argument><expr><operator>&amp;</operator><name>type_attrs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlAppendTarget</name><argument_list>(<argument><expr><name><name>ybc_state</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>has_targets</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * We can have no target columns at this point for e.g. a count(*). For now
		 * we request the first non-dropped column in that case.
		 * TODO look into handling this on YugaByte side.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>has_targets</name></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><decl><type><name>int16_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<comment type="block">/* Ignore dropped attributes */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition>
				<block>{<block_content>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<decl_stmt><decl><type><name>YBCPgTypeAttrs</name></type> <name>type_attrs</name> <init>= <expr><block>{ <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypmod</name></expr> }</block></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>YBCPgExpr</name></type>      <name>expr</name>       <init>= <expr><call><name>YBCNewColumnRef</name><argument_list>(<argument><expr><name><name>ybc_state</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>,
															<argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
															<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr></argument>,
															<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attcollation</name></expr></argument>,
															<argument><expr><operator>&amp;</operator><name>type_attrs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlAppendTarget</name><argument_list>(<argument><expr><name><name>ybc_state</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Set aggregate scan targets. */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>node-&gt;yb_fdw_aggs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggref</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>Aggref</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>func_name</name> <init>= <expr><call><name>get_func_name</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc_arg</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>YBCPgExpr</name></type> <name>op_handle</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>YBCPgTypeEntity</name> <modifier>*</modifier></type><name>type_entity</name></decl>;</decl_stmt>

			<comment type="block">/* Get type entity for the operator from the aggref. */</comment>
			<expr_stmt><expr><name>type_entity</name> <operator>=</operator> <call><name>YbDataTypeFromOidMod</name><argument_list>(<argument><expr><name>InvalidAttrNumber</name></expr></argument>, <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggtranstype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Create operator. */</comment>
			<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgNewOperator</name><argument_list>(<argument><expr><name><name>ybc_state</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><name>func_name</name></expr></argument>, <argument><expr><name>type_entity</name></expr></argument>, <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggcollid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op_handle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Handle arguments. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>aggref</name><operator>-&gt;</operator><name>aggstar</name></name></expr>)</condition> <block>{<block_content>
				<comment type="block">/*
				 * Add dummy argument for COUNT(*) case, turning it into COUNT(0).
				 * We don't use a column reference as we want to count rows
				 * even if all column values are NULL.
				 */</comment>
				<decl_stmt><decl><type><name>YBCPgExpr</name></type> <name>const_handle</name></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgNewConstant</name><argument_list>(<argument><expr><name><name>ybc_state</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>,
								 <argument><expr><name>type_entity</name></expr></argument>,
								 <argument><expr><name>false</name></expr></argument> <comment type="block">/* collate_is_valid_non_c */</comment>,
								 <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* collation_sortkey */</comment>,
								 <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* datum */</comment>,
								 <argument><expr><name>false</name></expr></argument> <comment type="block">/* is_null */</comment>,
								 <argument><expr><operator>&amp;</operator><name>const_handle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgOperatorAppendArg</name><argument_list>(<argument><expr><name>op_handle</name></expr></argument>, <argument><expr><name>const_handle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if> <else>else <block>{<block_content>
				<comment type="block">/* Add aggregate arguments to operator. */</comment>
				<macro><name>foreach</name><argument_list>(<argument>lc_arg</argument>, <argument>aggref-&gt;args</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name>lc_arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Const</name><modifier>*</modifier></type> <name>const_node</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<comment type="block">/* Already checked by yb_agg_pushdown_supported */</comment>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>const_node</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>||</operator> <name><name>const_node</name><operator>-&gt;</operator><name>constbyval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<decl_stmt><decl><type><name>YBCPgExpr</name></type> <name>const_handle</name></decl>;</decl_stmt>
						<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgNewConstant</name><argument_list>(<argument><expr><name><name>ybc_state</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>,
										 <argument><expr><name>type_entity</name></expr></argument>,
										 <argument><expr><name>false</name></expr></argument> <comment type="block">/* collate_is_valid_non_c */</comment>,
										 <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* collation_sortkey */</comment>,
										 <argument><expr><name><name>const_node</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>,
										 <argument><expr><name><name>const_node</name><operator>-&gt;</operator><name>constisnull</name></name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>const_handle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgOperatorAppendArg</name><argument_list>(<argument><expr><name>op_handle</name></expr></argument>, <argument><expr><name>const_handle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * Use original attribute number (varoattno) instead of projected one (varattno)
						 * as projection is disabled for tuples produced by pushed down operators.
						 */</comment>
						<decl_stmt><decl><type><name>int</name></type> <name>attno</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>varoattno</name></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>YBCPgTypeAttrs</name></type> <name>type_attrs</name> <init>= <expr><block>{<expr><name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>}</block></expr></init></decl>;</decl_stmt>

						<decl_stmt><decl><type><name>YBCPgExpr</name></type> <name>arg</name> <init>= <expr><call><name>YBCNewColumnRef</name><argument_list>(<argument><expr><name><name>ybc_state</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>,
														<argument><expr><name>attno</name></expr></argument>,
														<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
														<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>,
														<argument><expr><operator>&amp;</operator><name>type_attrs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgOperatorAppendArg</name><argument_list>(<argument><expr><name>op_handle</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* Should never happen. */</comment>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported aggregate function argument type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* Add aggregate operator as scan target. */</comment>
			<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlAppendTarget</name><argument_list>(<argument><expr><name><name>ybc_state</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><name>op_handle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Setup the scan slot based on new tuple descriptor for the given targets. This is a dummy
		 * tupledesc that only includes the number of attributes.
		 */</comment>
		<decl_stmt><decl><type><name>TupleDesc</name></type> <name>target_tupdesc</name> <init>= <expr><call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>yb_fdw_aggs</name></name></expr></argument>)</argument_list></call></expr></argument>,
														   <argument><expr><name>false</name></expr></argument> <comment type="block">/* hasoid */</comment>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ExecInitScanTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>, <argument><expr><name>target_tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Consider the example "SELECT COUNT(oid) FROM pg_type", Postgres would have to do a
		 * sequential scan to fetch the system column oid. Here YSQL does pushdown so what's
		 * fetched from a tablet is the result of count(oid), which is not even a column, let
		 * alone a system column. Clear fsSystemCol because no system column is needed.
		 */</comment>
		<expr_stmt><expr><name><name>foreignScan</name><operator>-&gt;</operator><name>fsSystemCol</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ybSetupScanQual
 *		Add the pushable qual expressions to the DocDB statement.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ybSetupScanQual</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignScan</name> <modifier>*</modifier></type><name>foreignScan</name> <init>= <expr><operator>(</operator><name>ForeignScan</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YbFdwExecState</name> <modifier>*</modifier></type><name>yb_state</name> <init>= <expr><operator>(</operator><name>YbFdwExecState</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>fdw_state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>qual</name> <init>= <expr><name><name>foreignScan</name><operator>-&gt;</operator><name>fdw_recheck_quals</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>=
		<expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>qual</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/*
		 * Some expressions may be parametrized, obviously remote end can not
		 * acccess the estate to get parameter values, so param references
		 * are replaced with constant expressions.
		 */</comment>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>YbExprInstantiateParams</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Create new PgExpr wrapper for the expression */</comment>
		<decl_stmt><decl><type><name>YBCPgExpr</name></type> <name>yb_expr</name> <init>= <expr><call><name>YBCNewEvalExprCall</name><argument_list>(<argument><expr><name><name>yb_state</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* Add the PgExpr to the statement */</comment>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YbPgDmlAppendQual</name><argument_list>(<argument><expr><name><name>yb_state</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><name>yb_expr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ybSetupScanColumnRefs
 *		Add the column references to the DocDB statement.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ybSetupScanColumnRefs</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ForeignScan</name> <modifier>*</modifier></type><name>foreignScan</name> <init>= <expr><operator>(</operator><name>ForeignScan</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YbFdwExecState</name> <modifier>*</modifier></type><name>yb_state</name> <init>= <expr><operator>(</operator><name>YbFdwExecState</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>fdw_state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>params</name> <init>= <expr><name><name>foreignScan</name><operator>-&gt;</operator><name>fdw_private</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>=
		<expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>params</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>YbExprParamDesc</name> <modifier>*</modifier></type><name>param</name> <init>= <expr><operator>(</operator><name>YbExprParamDesc</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>YBCPgTypeAttrs</name></type> <name>type_attrs</name> <init>= <expr><block>{ <expr><name><name>param</name><operator>-&gt;</operator><name>typmod</name></name></expr> }</block></expr></init></decl>;</decl_stmt>
		<comment type="block">/* Create new PgExpr wrapper for the column reference */</comment>
		<decl_stmt><decl><type><name>YBCPgExpr</name></type> <name>yb_expr</name> <init>= <expr><call><name>YBCNewColumnRef</name><argument_list>(<argument><expr><name><name>yb_state</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>,
											<argument><expr><name><name>param</name><operator>-&gt;</operator><name>attno</name></name></expr></argument>,
											<argument><expr><name><name>param</name><operator>-&gt;</operator><name>typid</name></name></expr></argument>,
											<argument><expr><name><name>param</name><operator>-&gt;</operator><name>collid</name></name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>type_attrs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* Add the PgExpr to the statement */</comment>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YbPgDmlAppendColumnRef</name><argument_list>(<argument><expr><name><name>yb_state</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><name>yb_expr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ybcIterateForeignScan
 *		Read next record from the data file and store it into the
 *		ScanTupleSlot as a virtual tuple
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ybcIterateForeignScan</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>YbFdwExecState</name> <modifier>*</modifier></type><name>ybc_state</name> <init>= <expr><operator>(</operator><name>YbFdwExecState</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>fdw_state</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Execute the select statement one time.
	 * TODO(neil) Check whether YugaByte PgGate should combine Exec() and Fetch() into one function.
	 * - The first fetch from YugaByte PgGate requires a number of operations including allocating
	 *   operators and protobufs. These operations are done by YBCPgExecSelect() function.
	 * - The subsequent fetches don't need to setup the query with these operations again.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ybc_state</name><operator>-&gt;</operator><name>is_exec_done</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ybcSetupScanTargets</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ybSetupScanQual</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ybSetupScanColumnRefs</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgExecSelect</name><argument_list>(<argument><expr><name><name>ybc_state</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><name><name>ybc_state</name><operator>-&gt;</operator><name>exec_params</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ybc_state</name><operator>-&gt;</operator><name>is_exec_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If function forms a heap tuple, the ForeignNext function will set proper
	 * t_tableOid value there, so do not bother passing valid relid now.
	 */</comment>
	<return>return <expr><call><name>ybFetchNext</name><argument_list>(<argument><expr><name><name>ybc_state</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>,
					   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr></argument>,
					   <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ybcFreeStatementObject</name><parameter_list>(<parameter><decl><type><name>YbFdwExecState</name><modifier>*</modifier></type> <name>yb_fdw_exec_state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* If yb_fdw_exec_state is NULL, we are in EXPLAIN; nothing to do */</comment>
	<if_stmt><if>if <condition>(<expr><name>yb_fdw_exec_state</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>yb_fdw_exec_state</name><operator>-&gt;</operator><name>handle</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>YBCPgDeleteStatement</name><argument_list>(<argument><expr><name><name>yb_fdw_exec_state</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>yb_fdw_exec_state</name><operator>-&gt;</operator><name>handle</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>yb_fdw_exec_state</name><operator>-&gt;</operator><name>exec_params</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>yb_fdw_exec_state</name><operator>-&gt;</operator><name>is_exec_done</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * fileReScanForeignScan
 *		Rescan table, possibly with new parameters
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ybcReScanForeignScan</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>YbFdwExecState</name> <modifier>*</modifier></type><name>ybc_state</name> <init>= <expr><operator>(</operator><name>YbFdwExecState</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>fdw_state</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Clear (delete) the previous select */</comment>
	<expr_stmt><expr><call><name>ybcFreeStatementObject</name><argument_list>(<argument><expr><name>ybc_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Re-allocate and execute the select. */</comment>
	<expr_stmt><expr><call><name>ybcBeginForeignScan</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* eflags */</comment>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ybcEndForeignScan
 *		Finish scanning foreign table and dispose objects used for this scan
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ybcEndForeignScan</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>YbFdwExecState</name> <modifier>*</modifier></type><name>ybc_state</name> <init>= <expr><operator>(</operator><name>YbFdwExecState</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>fdw_state</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ybcFreeStatementObject</name><argument_list>(<argument><expr><name>ybc_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ybcExplainForeignScan
 *		Produce extra output for EXPLAIN of a ForeignScan on a foreign table
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ybcExplainForeignScan</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>yb_fdw_aggs</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExplainPropertyBool</name><argument_list>(<argument><expr><literal type="string">"Partial Aggregate"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>YbExecUpdateInstrumentForeignScan</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
								  <parameter><decl><type><name>Instrumentation</name> <modifier>*</modifier></type><name>instr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>YbFdwExecState</name> <modifier>*</modifier></type><name>ybc_state</name> <init>= <expr><operator>(</operator><name>YbFdwExecState</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>fdw_state</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>ybc_state</name><operator>-&gt;</operator><name>handle</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>YbUpdateReadRpcStats</name><argument_list>(<argument><expr><name><name>ybc_state</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>instr</name><operator>-&gt;</operator><name>yb_read_rpcs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>instr</name><operator>-&gt;</operator><name>yb_tbl_read_rpcs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ------------------------------------------------------------------------- */</comment>
<comment type="block">/*  FDW declaration */</comment>

<comment type="block">/*
 * Foreign-data wrapper handler function: return a struct with pointers
 * to YugaByte callback routines.
 */</comment>
<function><type><name>Datum</name></type>
<name>ybc_fdw_handler</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FdwRoutine</name> <modifier>*</modifier></type><name>fdwroutine</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>FdwRoutine</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignRelSize</name></name>  <operator>=</operator> <name>ybcGetForeignRelSize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignPaths</name></name>    <operator>=</operator> <name>ybcGetForeignPaths</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignPlan</name></name>     <operator>=</operator> <name>ybcGetForeignPlan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>BeginForeignScan</name></name>   <operator>=</operator> <name>ybcBeginForeignScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>IterateForeignScan</name></name> <operator>=</operator> <name>ybcIterateForeignScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>ReScanForeignScan</name></name>  <operator>=</operator> <name>ybcReScanForeignScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>EndForeignScan</name></name>     <operator>=</operator> <name>ybcEndForeignScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>ExplainForeignScan</name></name> <operator>=</operator> <name>ybcExplainForeignScan</name></expr>;</expr_stmt>

	<comment type="block">/* TODO: These are optional but we should support them eventually. */</comment>
	<comment type="block">/* fdwroutine-&gt;AnalyzeForeignTable = ybcAnalyzeForeignTable; */</comment>
	<comment type="block">/* fdwroutine-&gt;IsForeignScanParallelSafe = ybcIsForeignScanParallelSafe; */</comment>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>fdwroutine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
