<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/executor/ybcModifyTable.c"><comment type="block">/*--------------------------------------------------------------------------------------------------
 *
 * ybcModifyTable.c
 *        YB routines to stmt_handle ModifyTable nodes.
 *
 * Copyright (c) YugaByte, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied.  See the License for the specific language governing permissions and limitations
 * under the License.
 *
 * IDENTIFICATION
 *        src/backend/executor/ybcModifyTable.c
 *
 *--------------------------------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/yb_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/execnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/tuptable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/ybcExpr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/ybcModifyTable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_attribute.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_database.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/yb_catalog_version.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/catcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/tuptable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/ybcExpr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/ybcplan.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"yb/yql/pggate/ybc_pggate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_yb_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/yb_scan.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;execinfo.h&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>bool</name></type> <name>yb_disable_transactional_writes</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>yb_enable_upsert_mode</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Hack to ensure that the next CommandCounterIncrement() will call
 * CommandEndInvalidationMessages(). The result of this call is not
 * needed on the yb side, however the side effects are.
 */</comment>
<function><type><name>void</name></type> <name>MarkCurrentCommandUsed</name><parameter_list>()</parameter_list> <block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns whether relation is capable of single row execution.
 */</comment>
<function><type><name>bool</name></type> <name>YBCIsSingleRowTxnCapableRel</name><parameter_list>(<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>has_triggers</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>numtriggers</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>has_indices</name> <init>= <expr><call><name>YBCRelInfoHasSecondaryIndices</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><operator>!</operator><name>has_indices</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_triggers</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the ybctid from a YB scan slot for UPDATE/DELETE.
 */</comment>
<function><type><name>Datum</name></type> <name>YBCGetYBTupleIdFromSlot</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Look for ybctid in the tuple first if the slot contains a tuple packed with ybctid.
	 * Otherwise, look for it in the attribute list as a junk attribute.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name><operator>-&gt;</operator><name>t_ybctid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name><operator>-&gt;</operator><name>t_ybctid</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name></expr>;</condition> <incr><expr><name>idx</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"ybctid"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>idx</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>==</operator> <name>BYTEAOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the ybctid from a tuple.
 *
 * Note that if the relation has a DocDB RowId attribute, this will generate a new RowId value
 * meaning the ybctid will be unique. Therefore you should only use this if the relation has
 * a primary key or you're doing an insert.
 */</comment>
<function><type><name>Datum</name></type> <name>YBCGetYBTupleIdFromTuple</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
							   <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
							   <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>dboid</name> <init>= <expr><call><name>YBCGetDatabaseOid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YBCPgTableDesc</name></type> <name>ybc_table_desc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgGetTableDesc</name><argument_list>(<argument><expr><name>dboid</name></expr></argument>, <argument><expr><call><name>YbGetStorageRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>ybc_table_desc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>pkey</name>    <init>= <expr><call><name>YBGetTableFullPrimaryKeyBms</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>minattr</name> <init>= <expr><name>YBSystemFirstLowInvalidAttributeNumber</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YBCPgYBTupleIdDescriptor</name> <modifier>*</modifier></type><name>descr</name> <init>= <expr><call><name>YBCCreateYBTupleIdDescriptor</name><argument_list>(
		<argument><expr><name>dboid</name></expr></argument>, <argument><expr><call><name>YbGetStorageRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name>pkey</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YBCPgAttrValueDescriptor</name> <modifier>*</modifier></type><name>next_attr</name> <init>= <expr><name><name>descr</name><operator>-&gt;</operator><name>attrs</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>col</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>col</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>pkey</name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>AttrNumber</name></type> <name>attnum</name> <init>= <expr><name>col</name> <operator>+</operator> <name>minattr</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>next_attr</name><operator>-&gt;</operator><name>attr_num</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
		<comment type="block">/*
		 * Don't need to fill in for the DocDB RowId column, however we still
		 * need to add the column to the statement to construct the ybctid.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>!=</operator> <name>YBRowIdAttributeNumber</name></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>	<name>type_id</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then>
					<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr> </then><else>: <expr><name>InvalidOid</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>next_attr</name><operator>-&gt;</operator><name>type_entity</name></name> <operator>=</operator> <call><name>YbDataTypeFromOidMod</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>type_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>next_attr</name><operator>-&gt;</operator><name>collation_id</name></name> <operator>=</operator> <call><name>ybc_get_attcollation</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>next_attr</name><operator>-&gt;</operator><name>datum</name></name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>next_attr</name><operator>-&gt;</operator><name>is_null</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><name><name>next_attr</name><operator>-&gt;</operator><name>datum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>next_attr</name><operator>-&gt;</operator><name>is_null</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>next_attr</name><operator>-&gt;</operator><name>type_entity</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>next_attr</name><operator>-&gt;</operator><name>collation_id</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<decl_stmt><decl><type><name>YBCPgColumnInfo</name></type> <name>column_info</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>HandleYBTableDescStatus</name><argument_list>(<argument><expr><call><name>YBCPgGetColumnInfo</name><argument_list>(<argument><expr><name>ybc_table_desc</name></expr></argument>,
												   <argument><expr><name>attnum</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>column_info</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ybc_table_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>YBSetupAttrCollationInfo</name><argument_list>(<argument><expr><name>next_attr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>column_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>++</operator><name>next_attr</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>pkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>tuple_id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgBuildYBTupleId</name><argument_list>(<argument><expr><name>descr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tuple_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator><name>tuple_id</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Bind ybctid to the statement.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>YBCBindTupleId</name><parameter_list>(<parameter><decl><type><name>YBCPgStatement</name></type> <name>pg_stmt</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>tuple_id</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>YBCPgExpr</name></type> <name>ybc_expr</name> <init>= <expr><call><name>YBCNewConstant</name><argument_list>(<argument><expr><name>pg_stmt</name></expr></argument>, <argument><expr><name>BYTEAOID</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>tuple_id</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument> <comment type="block">/* is_null */</comment>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlBindColumn</name><argument_list>(<argument><expr><name>pg_stmt</name></expr></argument>, <argument><expr><name>YBTupleIdAttributeNumber</name></expr></argument>, <argument><expr><name>ybc_expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Utility method to execute a prepared write statement.
 * Will handle the case if the write changes the system catalogs meaning
 * we need to increment the catalog versions accordingly.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>YBCExecWriteStmt</name><parameter_list>(<parameter><decl><type><name>YBCPgStatement</name></type> <name>ybc_stmt</name></decl></parameter>,
							 <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
							 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>rows_affected_count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>YbSetCatalogCacheVersion</name><argument_list>(<argument><expr><name>ybc_stmt</name></expr></argument>, <argument><expr><call><name>YbGetCatalogCacheVersion</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>is_syscatalog_version_inc</name> <init>= <expr><call><name>YbMarkStatementIfCatalogVersionIncrement</name><argument_list>(<argument><expr><name>ybc_stmt</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Execute the insert. */</comment>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlExecWriteOp</name><argument_list>(<argument><expr><name>ybc_stmt</name></expr></argument>, <argument><expr><name>rows_affected_count</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Optimization to increment the catalog version for the local cache as
	 * this backend is already aware of this change and should update its
	 * catalog caches accordingly (without needing to ask the master).
	 * Note that, since the master catalog version should have been identically
	 * incremented, it will continue to match with the local cache version if
	 * and only if no other master changes occurred in the meantime (i.e. from
	 * other backends).
	 * If changes occurred, then a cache refresh will be needed as usual.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_syscatalog_version_inc</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// TODO(shane) also update the shared memory catalog version here.</comment>
		<expr_stmt><expr><call><name>YbUpdateCatalogCacheVersion</name><argument_list>(<argument><expr><call><name>YbGetCatalogCacheVersion</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Utility method to insert a tuple into the relation's backing YugaByte table.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type> <name>YBCExecuteInsertInternal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>dboid</name></decl></parameter>,
                                    <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
                                    <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>,
                                    <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
                                    <parameter><decl><type><name>bool</name></type> <name>is_single_row_txn</name></decl></parameter>,
                                    <parameter><decl><type><name>OnConflictAction</name></type> <name>onConflictAction</name></decl></parameter>,
                                    <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>ybctid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name>    <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>     <name>minattr</name>  <init>= <expr><call><name>YBGetFirstLowInvalidAttributeNumber</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>            <name>natts</name>    <init>= <expr><call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>      <modifier>*</modifier></type><name>pkey</name>    <init>= <expr><call><name>YBGetTablePrimaryKeyBms</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YBCPgStatement</name></type> <name>insert_stmt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>           <name>is_null</name>  <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Generate a new oid for this row if needed */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>HeapTupleSetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>GetNewOid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Create the INSERT request and add the values from the tuple. */</comment>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgNewInsert</name><argument_list>(<argument><expr><name>dboid</name></expr></argument>,
	                              <argument><expr><call><name>YbGetStorageRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
	                              <argument><expr><name>is_single_row_txn</name></expr></argument>,
	                              <argument><expr><call><name>YBCIsRegionLocal</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
	                              <argument><expr><operator>&amp;</operator><name>insert_stmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get the ybctid for the tuple and bind to statement */</comment>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_ybctid</name></name> <operator>=</operator>
		<ternary><condition><expr><name>ybctid</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ybctid</name> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>*</operator><name>ybctid</name></expr>
		                               </then><else>: <expr><call><name>YBCGetYBTupleIdFromTuple</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>YBCBindTupleId</name><argument_list>(<argument><expr><name>insert_stmt</name></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_ybctid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ybctid</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>ybctid</name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_ybctid</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><decl><type><name>AttrNumber</name></type> <name>attnum</name> <init>= <expr><name>minattr</name></expr></init></decl>;</init> <condition><expr><name>attnum</name> <operator>&lt;=</operator> <name>natts</name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* Skip virtual (system) and dropped columns */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsRealYBColumn</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Oid</name></type>   <name>type_id</name> <init>= <expr><call><name>GetTypeId</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/*
		 * Postgres does not populate the column collation in tupleDesc but
		 * we must use the column collation in order to correctly compute the
		 * collation sortkey which later can be stored in DocDB. For example,
		 *   create table foo(id text collate "en-US-x-icu" primary key);
		 *   insert into foo values (1024);
		 *   insert into foo values ('2048' collate "C");
		 * Postgres will convert the integer 1024 to a text constant '1024'
		 * with the default collation. The text constant '2048' will retain
		 * its explicit collate "C". In both cases, in order to correctly
		 * compute collation sortkey, we must use the column collation
		 * "en-US-x-icu". When those two text constants are stored in the
		 * column, they will have the column collation when read out later.
		 * Postgres could have also converted both collations to the column
		 * collation but it appears that collation is not part of a type.
		 */</comment>
		<decl_stmt><decl><type><name>Oid</name></type>   <name>collation_id</name> <init>= <expr><call><name>YBEncodingCollation</name><argument_list>(<argument><expr><name>insert_stmt</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>,
			<argument><expr><call><name>ybc_get_attcollation</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>datum</name>   <init>= <expr><call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Check not-null constraint on primary key early */</comment>
		<if_stmt><if>if <condition>(<expr><name>is_null</name> <operator>&amp;&amp;</operator> <call><name>bms_is_member</name><argument_list>(<argument><expr><name>attnum</name> <operator>-</operator> <name>minattr</name></expr></argument>, <argument><expr><name>pkey</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NOT_NULL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(
					        <argument><expr><literal type="string">"Missing/null value for primary key column"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Add the column value to the insert request */</comment>
		<decl_stmt><decl><type><name>YBCPgExpr</name></type> <name>ybc_expr</name> <init>= <expr><call><name>YBCNewConstant</name><argument_list>(<argument><expr><name>insert_stmt</name></expr></argument>, <argument><expr><name>type_id</name></expr></argument>, <argument><expr><name>collation_id</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>, <argument><expr><name>is_null</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlBindColumn</name><argument_list>(<argument><expr><name>insert_stmt</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>ybc_expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * For system tables, mark tuple for invalidation from system caches
	 * at next command boundary.
	 *
	 * Do this now so if there is an error with insert we will re-query to get
	 * the correct state from the master.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsCatalogRelation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MarkCurrentCommandUsed</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CacheInvalidateHeapTuple</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>onConflictAction</name> <operator>==</operator> <name>ONCONFLICT_YB_REPLACE</name> <operator>||</operator> <name>yb_enable_upsert_mode</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgInsertStmtSetUpsertMode</name><argument_list>(<argument><expr><name>insert_stmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Execute the insert */</comment>
	<expr_stmt><expr><call><name>YBCExecWriteStmt</name><argument_list>(<argument><expr><name>insert_stmt</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* rows_affected_count */</comment>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Cleanup. */</comment>
	<expr_stmt><expr><call><name>YBCPgDeleteStatement</name><argument_list>(<argument><expr><name>insert_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Add row into foreign key cache */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_single_row_txn</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>YBCPgAddIntoForeignKeyReferenceCache</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_ybctid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Oid</name></type> <name>YBCExecuteInsert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
                     <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>,
                     <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
                     <parameter><decl><type><name>OnConflictAction</name></type> <name>onConflictAction</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>YBCExecuteInsertForDb</name><argument_list>(<argument><expr><call><name>YBCGetDatabaseOid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
	                             <argument><expr><name>rel</name></expr></argument>,
	                             <argument><expr><name>tupleDesc</name></expr></argument>,
	                             <argument><expr><name>tuple</name></expr></argument>,
	                             <argument><expr><name>onConflictAction</name></expr></argument>,
	                             <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* ybctid */</comment>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Oid</name></type> <name>YBCExecuteInsertForDb</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>dboid</name></decl></parameter>,
                          <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
                          <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>,
                          <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
                          <parameter><decl><type><name>OnConflictAction</name></type> <name>onConflictAction</name></decl></parameter>,
                          <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>ybctid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>non_transactional</name> <init>= <expr><operator>!</operator><call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>yb_disable_transactional_writes</name></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>YBCExecuteInsertInternal</name><argument_list>(<argument><expr><name>dboid</name></expr></argument>,
	                                <argument><expr><name>rel</name></expr></argument>,
	                                <argument><expr><name>tupleDesc</name></expr></argument>,
	                                <argument><expr><name>tuple</name></expr></argument>,
	                                <argument><expr><name>non_transactional</name></expr></argument>,
	                                <argument><expr><name>onConflictAction</name></expr></argument>,
	                                <argument><expr><name>ybctid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Oid</name></type> <name>YBCExecuteNonTxnInsert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
                           <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>,
                           <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
                           <parameter><decl><type><name>OnConflictAction</name></type> <name>onConflictAction</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>YBCExecuteNonTxnInsertForDb</name><argument_list>(<argument><expr><call><name>YBCGetDatabaseOid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
	                                   <argument><expr><name>rel</name></expr></argument>,
	                                   <argument><expr><name>tupleDesc</name></expr></argument>,
	                                   <argument><expr><name>tuple</name></expr></argument>,
	                                   <argument><expr><name>onConflictAction</name></expr></argument>,
	                                   <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* ybctid */</comment>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Oid</name></type> <name>YBCExecuteNonTxnInsertForDb</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>dboid</name></decl></parameter>,
                                <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
                                <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>,
                                <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
                                <parameter><decl><type><name>OnConflictAction</name></type> <name>onConflictAction</name></decl></parameter>,
                                <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>ybctid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>YBCExecuteInsertInternal</name><argument_list>(<argument><expr><name>dboid</name></expr></argument>,
	                                <argument><expr><name>rel</name></expr></argument>,
	                                <argument><expr><name>tupleDesc</name></expr></argument>,
	                                <argument><expr><name>tuple</name></expr></argument>,
	                                <argument><expr><name>true</name></expr></argument> <comment type="block">/* is_single_row_txn */</comment>,
	                                <argument><expr><name>onConflictAction</name></expr></argument>,
	                                <argument><expr><name>ybctid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Oid</name></type> <name>YBCHeapInsert</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
                  <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
                  <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>dboid</name> <init>= <expr><call><name>YBCGetDatabaseOid</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>YBCHeapInsertForDb</name><argument_list>(<argument><expr><name>dboid</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* ybctid */</comment>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Oid</name></type> <name>YBCHeapInsertForDb</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>dboid</name></decl></parameter>,
                       <parameter><decl><type><name>TupleTableSlot</name><modifier>*</modifier></type> <name>slot</name></decl></parameter>,
                       <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
                       <parameter><decl><type><name>EState</name><modifier>*</modifier></type> <name>estate</name></decl></parameter>,
                       <parameter><decl><type><name>Datum</name><modifier>*</modifier></type> <name>ybctid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * get information on the (current) result relation
	 */</comment>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>resultRelationDesc</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>yb_es_is_single_row_modify_txn</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Try to execute the statement as a single row transaction (rather
		 * than a distributed transaction) if it is safe to do so.
		 * I.e. if we are in a single-statement transaction that targets a
		 * single row (i.e. single-row-modify txn), and there are no indices
		 * or triggers on the target table.
		 */</comment>
		<return>return <expr><call><name>YBCExecuteNonTxnInsertForDb</name><argument_list>(<argument><expr><name>dboid</name></expr></argument>,
		                                   <argument><expr><name>resultRelationDesc</name></expr></argument>,
		                                   <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>,
		                                   <argument><expr><name>tuple</name></expr></argument>,
		                                   <argument><expr><name>ONCONFLICT_NONE</name></expr></argument>,
		                                   <argument><expr><name>ybctid</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><call><name>YBCExecuteInsertForDb</name><argument_list>(<argument><expr><name>dboid</name></expr></argument>,
		                             <argument><expr><name>resultRelationDesc</name></expr></argument>,
		                             <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>,
		                             <argument><expr><name>tuple</name></expr></argument>,
		                             <argument><expr><name>ONCONFLICT_NONE</name></expr></argument>,
		                             <argument><expr><name>ybctid</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>YBCPgYBTupleIdDescriptor</name><modifier>*</modifier></type>
<name>YBCBuildNonNullUniqueIndexYBTupleId</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>unique_index</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>dboid</name> <init>= <expr><call><name>YBCGetDatabaseOid</name><argument_list>(<argument><expr><name>unique_index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>unique_index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YBCPgTableDesc</name></type> <name>ybc_table_desc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgGetTableDesc</name><argument_list>(<argument><expr><name>dboid</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ybc_table_desc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>unique_index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nattrs</name> <init>= <expr><call><name>IndexRelationGetNumberOfKeyAttributes</name><argument_list>(<argument><expr><name>unique_index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YBCPgYBTupleIdDescriptor</name><modifier>*</modifier></type> <name>result</name> <init>= <expr><call><name>YBCCreateYBTupleIdDescriptor</name><argument_list>(<argument><expr><name>dboid</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>nattrs</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YBCPgAttrValueDescriptor</name> <modifier>*</modifier></type><name>next_attr</name> <init>= <expr><name><name>result</name><operator>-&gt;</operator><name>attrs</name></name></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>AttrNumber</name></type> <name>attnum</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>attnum</name> <operator>&lt;=</operator> <name>nattrs</name></expr>;</condition> <incr><expr><operator>++</operator><name>attnum</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>type_id</name> <init>= <expr><call><name>GetTypeId</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>next_attr</name><operator>-&gt;</operator><name>type_entity</name></name> <operator>=</operator> <call><name>YbDataTypeFromOidMod</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>type_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>next_attr</name><operator>-&gt;</operator><name>collation_id</name></name> <operator>=</operator> <call><name>ybc_get_attcollation</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>next_attr</name><operator>-&gt;</operator><name>attr_num</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>next_attr</name><operator>-&gt;</operator><name>datum</name></name> <operator>=</operator> <name><name>values</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>next_attr</name><operator>-&gt;</operator><name>is_null</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>YBCPgColumnInfo</name></type> <name>column_info</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>HandleYBTableDescStatus</name><argument_list>(<argument><expr><call><name>YBCPgGetColumnInfo</name><argument_list>(<argument><expr><name>ybc_table_desc</name></expr></argument>,
												   <argument><expr><name>attnum</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>column_info</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ybc_table_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>YBSetupAttrCollationInfo</name><argument_list>(<argument><expr><name>next_attr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>column_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>++</operator><name>next_attr</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>YBCFillUniqueIndexNullAttribute</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>YBCForeignKeyReferenceCacheDeleteIndex</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnulls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Only unique index can be used in foreign key constraints */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisprimary</name></name> <operator>&amp;&amp;</operator> <name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisunique</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nattrs</name> <init>= <expr><call><name>IndexRelationGetNumberOfKeyAttributes</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/*
		 * Index with at least one NULL value can't be referenced by foreign key constraint,
		 * and can't be stored in cache, so ignore it.
		 */</comment>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nattrs</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><name><name>isnulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt></block_content></block></for>

		<decl_stmt><decl><type><name>YBCPgYBTupleIdDescriptor</name><modifier>*</modifier></type> <name>descr</name> <init>= <expr><call><name>YBCBuildNonNullUniqueIndexYBTupleId</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgForeignKeyReferenceCacheDelete</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>YBCExecuteInsertIndex</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>,
						   <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>,
						   <parameter><decl><type><name>Datum</name></type> <name>ybctid</name></decl></parameter>,
						   <parameter><decl><type><specifier>const</specifier> <name>uint64_t</name> <modifier>*</modifier></type><name>backfill_write_time</name></decl></parameter>,
						   <parameter><decl><type><name>yb_bind_for_write_function</name></type> <name>callback</name></decl></parameter>,
						   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>indexstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>YBCExecuteInsertIndexForDb</name><argument_list>(<argument><expr><call><name>YBCGetDatabaseOid</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>index</name></expr></argument>,
							   <argument><expr><name>values</name></expr></argument>,
							   <argument><expr><name>isnull</name></expr></argument>,
							   <argument><expr><name>ybctid</name></expr></argument>,
							   <argument><expr><name>backfill_write_time</name></expr></argument>,
							   <argument><expr><name>callback</name></expr></argument>,
							   <argument><expr><name>indexstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>YBCExecuteInsertIndexForDb</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>dboid</name></decl></parameter>,
								<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>,
								<parameter><decl><type><name>Datum</name><modifier>*</modifier></type> <name>values</name></decl></parameter>,
								<parameter><decl><type><name>bool</name><modifier>*</modifier></type> <name>isnull</name></decl></parameter>,
								<parameter><decl><type><name>Datum</name></type> <name>ybctid</name></decl></parameter>,
								<parameter><decl><type><specifier>const</specifier> <name>uint64_t</name><modifier>*</modifier></type> <name>backfill_write_time</name></decl></parameter>,
								<parameter><decl><type><name>yb_bind_for_write_function</name></type> <name>callback</name></decl></parameter>,
								<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>indexstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ybctid</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name>    <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YBCPgStatement</name></type> <name>insert_stmt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Create the INSERT request and add the values from the tuple. */</comment>
	<comment type="block">/*
	 * TODO(jason): rename `is_single_row_txn` to something like
	 * `non_distributed_txn` when closing issue #4906.
	 */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>is_backfill</name> <init>= <expr><operator>(</operator><name>backfill_write_time</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>is_non_distributed_txn_write</name> <init>=
		<expr><name>is_backfill</name> <operator>||</operator> <operator>(</operator><operator>!</operator><call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>yb_disable_transactional_writes</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgNewInsert</name><argument_list>(<argument><expr><name>dboid</name></expr></argument>,
								  <argument><expr><name>relid</name></expr></argument>,
								  <argument><expr><name>is_non_distributed_txn_write</name></expr></argument>,
								  <argument><expr><call><name>YBCIsRegionLocal</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>insert_stmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>callback</name><argument_list>(<argument><expr><name>insert_stmt</name></expr></argument>, <argument><expr><name>indexstate</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>,
			 <argument><expr><call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><name>ybctid</name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* ybctid_as_value */</comment>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For non-unique indexes the primary-key component (base tuple id) already
	 * guarantees uniqueness, so no need to read and check it in DocDB.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisunique</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgInsertStmtSetUpsertMode</name><argument_list>(<argument><expr><name>insert_stmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_backfill</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgInsertStmtSetIsBackfill</name><argument_list>(<argument><expr><name>insert_stmt</name></expr></argument>,
													<argument><expr><name>true</name></expr></argument> <comment type="block">/* is_backfill */</comment>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		 * For index backfill, set write hybrid time to a time in the past.
		 * This is to guarantee that backfilled writes are temporally before
		 * any online writes.
		 */</comment>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgInsertStmtSetWriteTime</name><argument_list>(<argument><expr><name>insert_stmt</name></expr></argument>,
												   <argument><expr><operator>*</operator><name>backfill_write_time</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Execute the insert and clean up. */</comment>
	<expr_stmt><expr><call><name>YBCExecWriteStmt</name><argument_list>(<argument><expr><name>insert_stmt</name></expr></argument>,
					 <argument><expr><name>index</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* rows_affected_count */</comment>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Cleanup. */</comment>
	<expr_stmt><expr><call><name>YBCPgDeleteStatement</name><argument_list>(<argument><expr><name>insert_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>YBCExecuteDelete</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
					  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>returning_columns</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>target_tuple_fetched</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>is_single_row_txn</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>changingPart</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>		<name>tupleDesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>				<name>dboid</name> <init>= <expr><call><name>YBCGetDatabaseOid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>				<name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YBCPgStatement</name></type>	<name>delete_stmt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>			<name>ybctid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>	   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* is_single_row_txn always implies target tuple wasn't fetched. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_single_row_txn</name> <operator>||</operator> <operator>!</operator><name>target_tuple_fetched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create DELETE request. */</comment>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgNewDelete</name><argument_list>(<argument><expr><name>dboid</name></expr></argument>,
								  <argument><expr><call><name>YbGetStorageRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>is_single_row_txn</name></expr></argument>,
								  <argument><expr><call><name>YBCIsRegionLocal</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>delete_stmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Look for ybctid. Raise error if ybctid is not found.
	 *
	 * Retrieve ybctid from the slot if possible, otherwise generate it
	 * from tuple values.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>target_tuple_fetched</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ybctid</name> <operator>=</operator> <call><name>YBCGetYBTupleIdFromSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>ybctid</name> <operator>=</operator> <call><name>YBCGetYBTupleIdFromTuple</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ybctid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(
					<argument><expr><literal type="string">"Missing column ybctid in DELETE request to YugaByte database"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Bind ybctid to identify the current row. */</comment>
	<decl_stmt><decl><type><name>YBCPgExpr</name></type> <name>ybctid_expr</name> <init>= <expr><call><name>YBCNewConstant</name><argument_list>(<argument><expr><name>delete_stmt</name></expr></argument>, <argument><expr><name>BYTEAOID</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>ybctid</name></expr></argument>,
										   <argument><expr><name>false</name></expr></argument> <comment type="block">/* is_null */</comment>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlBindColumn</name><argument_list>(<argument><expr><name>delete_stmt</name></expr></argument>, <argument><expr><name>YBTupleIdAttributeNumber</name></expr></argument>, <argument><expr><name>ybctid_expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Delete row from foreign key cache */</comment>
	<expr_stmt><expr><call><name>YBCPgDeleteFromForeignKeyReferenceCache</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>ybctid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Execute the statement. */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>rows_affected_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * TODO (deepthi): Remove this hacky fix once #9592 is fixed
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>changingPart</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * This delete is part of the DELETE+INSERT done while UPDATing the
		 * partition key of a row such that it moves from one partition to
		 * another. Only if the DELETE actually removes a row, should the
		 * corresponding INSERT take place. In case of #9592 we cannot assume
		 * that a non-single row transaction always deleted an existing
		 * value. Hence until #9592 is fixed, if the delete is part of moving
		 * a row across partitions, pass &amp;rows_affected_count even if this
		 * is not a single row transaction.
		 */</comment>
		<expr_stmt><expr><call><name>YBCExecWriteStmt</name><argument_list>(<argument><expr><name>delete_stmt</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rows_affected_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Cleanup. */</comment>
		<expr_stmt><expr><call><name>YBCPgDeleteStatement</name><argument_list>(<argument><expr><name>delete_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>rows_affected_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Instruct DocDB to return data from the columns required to evaluate
	 * returning clause expressions.
	 */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>returning_columns</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>YbExprParamDesc</name> <modifier>*</modifier></type><name>colref</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>YbExprParamDesc</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>YBCPgTypeAttrs</name></type> <name>type_attrs</name> <init>= <expr><block>{ <expr><name><name>colref</name><operator>-&gt;</operator><name>typmod</name></name></expr> }</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>YBCPgExpr</name></type> <name>yb_expr</name> <init>= <expr><call><name>YBCNewColumnRef</name><argument_list>(<argument><expr><name>delete_stmt</name></expr></argument>,
											<argument><expr><name><name>colref</name><operator>-&gt;</operator><name>attno</name></name></expr></argument>,
											<argument><expr><name><name>colref</name><operator>-&gt;</operator><name>typid</name></name></expr></argument>,
											<argument><expr><name><name>colref</name><operator>-&gt;</operator><name>collid</name></name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>type_attrs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlAppendTarget</name><argument_list>(<argument><expr><name>delete_stmt</name></expr></argument>, <argument><expr><name>yb_expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * For system tables, mark tuple for invalidation from system caches
	 * at next command boundary.
	 *
	 * Do this now so if there is an error with delete we will re-query to get
	 * the correct state from the master.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsCatalogRelation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MarkCurrentCommandUsed</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CacheInvalidateHeapTuple</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * We do not know what tuple to invalidate, and thus we have
			 * to invalidate the whole relation.
			 * This is a usual case when tuple is deleted due to an explicit
			 * DML, like DELETE FROM pg_xxx.
			 */</comment>
			<expr_stmt><expr><call><name>CacheInvalidateCatalog</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>YBCExecWriteStmt</name><argument_list>(<argument><expr><name>delete_stmt</name></expr></argument>,
					 <argument><expr><name>rel</name></expr></argument>,
					 <argument><expr><ternary><condition><expr><name>target_tuple_fetched</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>&amp;</operator><name>rows_affected_count</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fetch values of the columns required to evaluate returning clause
	 * expressions. They are put into the slot Postgres uses to evaluate
	 * the RETURNING clause later on.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>returning_columns</name> <operator>&amp;&amp;</operator> <name>rows_affected_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>			<name>has_data</name>   <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>YBCPgSysColumns</name></type>	<name>syscols</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * TODO Currently all delete requests sent to DocDB have ybctid and
		 * hence affect at most one row. It does not have to be that way,
		 * if the WHERE expressions all are pushed down, DocDB can iterate over
		 * the table and delete the rows satisfying the condition.
		 * Once implemented, there will be the case when we need to fetch
		 * multiple rows here. The problem is that by protocol ExecuteDelete
		 * returns one tuple at a time, and getting called again.
		 * That problem can be addressed by storing fetch state with the
		 * statement state and shortcut to emitting another tuple when the
		 * function is called again.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rows_affected_count</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlFetch</name><argument_list>(<argument><expr><name>delete_stmt</name></expr></argument>,
									 <argument><expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>,
									 <argument><expr><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>,
									 <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>syscols</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>has_data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>has_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		 * The YBCPgDmlFetch function does not necessarily fetch all the
		 * attributes, only those we requested. This is planner's responsibility
		 * to ensure that returning_columns contains all the
		 * attributes that may be referenced during subsequent evaluations.
		 */</comment>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isempty</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * The Result is getting dummy TLEs in place of missing attributes,
		 * so we should fix the tuple table slot's descriptor before
		 * the RETURNING clause expressions are evaluated.
		 */</comment>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name> <operator>=</operator> <call><name>CreateTupleDescCopyConstr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Cleanup. */</comment>
	<expr_stmt><expr><call><name>YBCPgDeleteStatement</name><argument_list>(<argument><expr><name>delete_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>target_tuple_fetched</name> <operator>||</operator> <name>rows_affected_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>YBCExecuteDeleteIndex</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>,
						   <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>,
						   <parameter><decl><type><name>Datum</name></type> <name>ybctid</name></decl></parameter>,
						   <parameter><decl><type><name>yb_bind_for_write_function</name></type> <name>callback</name></decl></parameter>,
						   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>indexstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type>            <name>dboid</name>    <init>= <expr><call><name>YBCGetDatabaseOid</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name>    <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YBCPgStatement</name></type> <name>delete_stmt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Create the DELETE request and add the values from the tuple. */</comment>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgNewDelete</name><argument_list>(<argument><expr><name>dboid</name></expr></argument>,
								  <argument><expr><name>relid</name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument> <comment type="block">/* is_single_row_txn */</comment>,
								  <argument><expr><call><name>YBCIsRegionLocal</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>delete_stmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>callback</name><argument_list>(<argument><expr><name>delete_stmt</name></expr></argument>, <argument><expr><name>indexstate</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>,
			 <argument><expr><call><name>IndexRelationGetNumberOfKeyAttributes</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><name>ybctid</name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* ybctid_as_value */</comment>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>YBCForeignKeyReferenceCacheDeleteIndex</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If index backfill hasn't finished yet, deletes to the index should be
	 * persisted.  Normally, deletes aren't persisted when they can be
	 * optimized out, but that breaks correctness if there's a pending
	 * backfill.
	 * TODO(jason): consider issue #6812.  We may be able to avoid persisting
	 * deletes when indisready is false.
	 * TODO(jason): consider how this will unnecessarily cause deletes to be
	 * persisted when online dropping an index (issue #4936).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><call><name>YBCGetGFlags</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>ysql_disable_index_backfill</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisvalid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDeleteStmtSetIsPersistNeeded</name><argument_list>(<argument><expr><name>delete_stmt</name></expr></argument>,
														 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>YBCExecWriteStmt</name><argument_list>(<argument><expr><name>delete_stmt</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* rows_affected_count */</comment>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>YBCPgDeleteStatement</name><argument_list>(<argument><expr><name>delete_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>YBCExecuteUpdate</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
					  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
					  <parameter><decl><type><name>HeapTuple</name></type> <name>oldtuple</name></decl></parameter>,
					  <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
					  <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
					  <parameter><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>mt_plan</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>target_tuple_fetched</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>is_single_row_txn</name></decl></parameter>,
					  <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>updatedCols</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>canSetTag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// The input heap tuple's descriptor</comment>
	<decl_stmt><decl><type><name>TupleDesc</name></type>		<name>inputTupleDesc</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></init></decl>;</decl_stmt>
	<comment type="line">// The target table tuple's descriptor</comment>
	<decl_stmt><decl><type><name>TupleDesc</name></type>		<name>outputTupleDesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>				<name>dboid</name> <init>= <expr><call><name>YBCGetDatabaseOid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>				<name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YBCPgStatement</name></type>	<name>update_stmt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>			<name>ybctid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>	   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* is_single_row_txn always implies target tuple wasn't fetched. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_single_row_txn</name> <operator>||</operator> <operator>!</operator><name>target_tuple_fetched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create update statement. */</comment>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgNewUpdate</name><argument_list>(<argument><expr><name>dboid</name></expr></argument>,
								  <argument><expr><name>relid</name></expr></argument>,
								  <argument><expr><name>is_single_row_txn</name></expr></argument>,
								  <argument><expr><call><name>YBCIsRegionLocal</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>update_stmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Look for ybctid. Raise error if ybctid is not found.
	 *
	 * Retrieve ybctid from the slot if possible, otherwise generate it
	 * from tuple values.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>target_tuple_fetched</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ybctid</name> <operator>=</operator> <call><name>YBCGetYBTupleIdFromSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>ybctid</name> <operator>=</operator> <call><name>YBCGetYBTupleIdFromTuple</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>inputTupleDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ybctid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(
					<argument><expr><literal type="string">"Missing column ybctid in UPDATE request to YugaByte database"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>YBCBindTupleId</name><argument_list>(<argument><expr><name>update_stmt</name></expr></argument>, <argument><expr><name>ybctid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Assign new values to the updated columns for the current row. */</comment>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>minattr</name>		<init>= <expr><call><name>YBGetFirstLowInvalidAttributeNumber</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>whole_row</name>	<init>= <expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>InvalidAttrNumber</name></expr></argument>, <argument><expr><name>updatedCols</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>pushdown_lc</name>	<init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name><name>mt_plan</name><operator>-&gt;</operator><name>ybPushdownTlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier><name>pkey</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name> <init>= <expr><call><name>YBGetTablePrimaryKeyBms</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name><name>outputTupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>idx</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FormData_pg_attribute</name> <modifier>*</modifier></type><name>att_desc</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>outputTupleDesc</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>AttrNumber</name></type> <name>attnum</name> <init>= <expr><name><name>att_desc</name><operator>-&gt;</operator><name>attnum</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32_t</name></type> <name>type_id</name> <init>= <expr><name><name>att_desc</name><operator>-&gt;</operator><name>atttypid</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Skip virtual (system) and dropped columns */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsRealYBColumn</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>whole_row</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>attnum</name> <operator>-</operator> <name>minattr</name></expr></argument>, <argument><expr><name>updatedCols</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Regular updates should not mention primary key columns, as they are
		 * supposed to go through YBCExecuteUpdateReplace routine.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>attnum</name> <operator>-</operator> <name>minattr</name></expr></argument>, <argument><expr><name>pkey</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Assign this attr's value, handle expression pushdown if needed. */</comment>
		<if_stmt><if>if <condition>(<expr><name>pushdown_lc</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>pushdown_lc</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>resno</name> <operator>==</operator> <name>attnum</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>pushdown_lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>YbExprInstantiateParams</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>YBCPgExpr</name></type> <name>ybc_expr</name> <init>= <expr><call><name>YBCNewEvalExprCall</name><argument_list>(<argument><expr><name>update_stmt</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlAssignColumn</name><argument_list>(<argument><expr><name>update_stmt</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>ybc_expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pushdown_lc</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>pushdown_lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>is_null</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type> <name>d</name> <init>= <expr><call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>inputTupleDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<comment type="block">/*
			 * For system relations, since we assign values to non-primary-key
			 * columns only, pass InvalidOid as collation_id to skip computing
			 * collation sortkeys.
			 */</comment>
			<decl_stmt><decl><type><name>Oid</name></type> <name>collation_id</name> <init>= <expr><ternary><condition><expr><call><name>IsCatalogRelation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>
				?</condition><then> <expr><name>InvalidOid</name></expr>
				</then><else>: <expr><call><name>YBEncodingCollation</name><argument_list>(<argument><expr><name>update_stmt</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name><name>att_desc</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>YBCPgExpr</name></type> <name>ybc_expr</name> <init>= <expr><call><name>YBCNewConstant</name><argument_list>(<argument><expr><name>update_stmt</name></expr></argument>, <argument><expr><name>type_id</name></expr></argument>, <argument><expr><name>collation_id</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>is_null</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlAssignColumn</name><argument_list>(<argument><expr><name>update_stmt</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>ybc_expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Instruct DocDB to return data from the columns required to evaluate
	 * returning clause expressions.
	 */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>mt_plan-&gt;ybReturningColumns</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>YbExprParamDesc</name> <modifier>*</modifier></type><name>colref</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>YbExprParamDesc</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>YBCPgTypeAttrs</name></type> <name>type_attrs</name> <init>= <expr><block>{ <expr><name><name>colref</name><operator>-&gt;</operator><name>typmod</name></name></expr>}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>YBCPgExpr</name></type> <name>yb_expr</name> <init>= <expr><call><name>YBCNewColumnRef</name><argument_list>(<argument><expr><name>update_stmt</name></expr></argument>,
											<argument><expr><name><name>colref</name><operator>-&gt;</operator><name>attno</name></name></expr></argument>,
											<argument><expr><name><name>colref</name><operator>-&gt;</operator><name>typid</name></name></expr></argument>,
											<argument><expr><name><name>colref</name><operator>-&gt;</operator><name>collid</name></name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>type_attrs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlAppendTarget</name><argument_list>(<argument><expr><name>update_stmt</name></expr></argument>, <argument><expr><name>yb_expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Column references to prepare data to evaluate pushed down expressions */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>mt_plan-&gt;ybColumnRefs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>YbExprParamDesc</name> <modifier>*</modifier></type><name>colref</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>YbExprParamDesc</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>YBCPgTypeAttrs</name></type> <name>type_attrs</name> <init>= <expr><block>{ <expr><name><name>colref</name><operator>-&gt;</operator><name>typmod</name></name></expr> }</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>YBCPgExpr</name></type> <name>yb_expr</name> <init>= <expr><call><name>YBCNewColumnRef</name><argument_list>(<argument><expr><name>update_stmt</name></expr></argument>,
											<argument><expr><name><name>colref</name><operator>-&gt;</operator><name>attno</name></name></expr></argument>,
											<argument><expr><name><name>colref</name><operator>-&gt;</operator><name>typid</name></name></expr></argument>,
											<argument><expr><name><name>colref</name><operator>-&gt;</operator><name>collid</name></name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>type_attrs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YbPgDmlAppendColumnRef</name><argument_list>(<argument><expr><name>update_stmt</name></expr></argument>, <argument><expr><name>yb_expr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Execute the statement. */</comment>

	<comment type="block">/*
	 * If target tuple wasn't fetched, ybctid is constructed from values extracted
	 * from the where clause, so there is no guarantee that row exists and we
	 * need to retrieve this from the DocDB.
	 * Otherwise the ybctid was obtained from DocDB, and it is known beforehand
	 * thet row exists and will be affected by the operation.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>rows_affected_count</name> <init>= <expr><ternary><condition><expr><name>target_tuple_fetched</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check if the statement can be batched.
	 *
	 * In general, it can not if we need any information from the response to
	 * finish update processing.
	 *
	 * A number of thing are to be done after the modification is applied:
	 * increment the number of rows afecteded by the statement; update the
	 * secondary indexes, run after row update triggers, evaluate the returning
	 * clause.
	 *
	 * If the statement has fetched target tuple, we already have the
	 * information: as explained above, number of rows affected is 1, and the
	 * tuple needed to accomplish the rest of the tasks is the one that has been
	 * emitted by the subplan.
	 *
	 * But if the statement did not fetch target tuple, we can only batch if the
	 * statement does not change the number of rows affected (the case if the
	 * canSetTag flag is false) AND the statement updates no indexed columns AND
	 * table has no AFTER ROW UPDATE triggers AND there is no RETURNING clause.
	 *
	 * Currently we always fetch target tuple if the statement affects
	 * indexed columns or table has AFTER ROW UPDATE triggers, so only
	 * the first and the last conditions are checked here.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>can_batch_update</name> <init>= <expr><name>target_tuple_fetched</name> <operator>||</operator>
		<operator>(</operator><operator>!</operator><name>canSetTag</name> <operator>&amp;&amp;</operator> <name>estate</name> <operator>&amp;&amp;</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name><operator>-&gt;</operator><name>ri_returningList</name></name> <operator>==</operator> <name>NIL</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * For system tables, mark tuple pair for invalidation from system caches
	 * at next command boundary.
	 *
	 * Some system updates are marked as in-place update (i.e. overwrite), for
	 * them we will invalidate the new tuple at next command boundary instead.
	 * See heap_inplace_update().
	 *
	 * Do these now so if there is an error with update we will re-query to get
	 * the correct state from the master.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsCatalogRelation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MarkCurrentCommandUsed</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>oldtuple</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CacheInvalidateHeapTuple</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>oldtuple</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * We do not know what tuple to invalidate, and thus we have
			 * to invalidate the whole relation.
			 * This is a sometimes the case when tuple is updated due to an explicit
			 * DML, like UPDATE pg_xxx SET ...
			 */</comment>
			<expr_stmt><expr><call><name>CacheInvalidateCatalog</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If update batching is allowed, then ignore rows_affected_count. */</comment>
	<expr_stmt><expr><call><name>YBCExecWriteStmt</name><argument_list>(<argument><expr><name>update_stmt</name></expr></argument>,
					 <argument><expr><name>rel</name></expr></argument>,
					 <argument><expr><ternary><condition><expr><name>can_batch_update</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>&amp;</operator><name>rows_affected_count</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fetch values of the columns required to evaluate returning clause
	 * expressions. They are put into the slot Postgres uses to evaluate
	 * the RETURNING clause later on.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>mt_plan</name><operator>-&gt;</operator><name>ybReturningColumns</name></name> <operator>&amp;&amp;</operator> <name>rows_affected_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name>		   <modifier>*</modifier></type><name>values</name>    <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name>		   <modifier>*</modifier></type><name>isnull</name>    <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>			<name>has_data</name>   <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>YBCPgSysColumns</name></type>	<name>syscols</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * TODO Currently all update requests sent to DocDB have ybctid and
		 * hence affect at most one row. It does not have to be that way,
		 * if the SET and WHERE expressions all are pushed down, DocDB can
		 * iterate over the table and update the rows satisfying the condition.
		 * Once implemented, there will be the case when we need to fetch
		 * multiple rows here. The problem is that by protocol ExecuteUpdate
		 * returns one tuple at a time, and getting called again.
		 * That problem can be addressed by storing fetch state with the
		 * statement state and shortcut to emitting another tuple when the
		 * function is called again.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rows_affected_count</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlFetch</name><argument_list>(<argument><expr><name>update_stmt</name></expr></argument>,
									 <argument><expr><name><name>outputTupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>,
								 	 <argument><expr><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator> <name>values</name></expr></argument>,
									 <argument><expr><name>isnull</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>syscols</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>has_data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>has_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		 * The YBCPgDmlFetch function does not necessarily fetch all the
		 * attributes, only those we requested. This is planner's responsibility
		 * to ensure that mt_plan-&gt;ybReturningColumns contains all the
		 * attributes that may be referenced during subsequent evaluations.
		 */</comment>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>=</operator> <name><name>outputTupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isempty</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * The Result is getting dummy TLEs in place of missing attributes,
		 * so we should fix the tuple table slot's descriptor before
		 * the RETURNING clause expressions are evaluated.
		 */</comment>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name> <operator>=</operator> <call><name>CreateTupleDescCopyConstr</name><argument_list>(<argument><expr><name>outputTupleDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Cleanup. */</comment>
	<expr_stmt><expr><call><name>YBCPgDeleteStatement</name><argument_list>(<argument><expr><name>update_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the relation has indexes, save the ybctid to insert the updated row into the indexes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>YBRelHasSecondaryIndices</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_ybctid</name></name> <operator>=</operator> <name>ybctid</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * For batched statements rows_affected_count remains at its initial value:
	 * 0 if a single row statement, 1 otherwise.
	 * Former would effectively break further evaluation, so there should be no
	 * secondary indexes, after row update triggers, nor returning clause.
	 */</comment>
	<return>return <expr><name>rows_affected_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>Oid</name></type> <name>YBCExecuteUpdateReplace</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
							<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
							<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>YBCExecuteDelete</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
					 <argument><expr><name>slot</name></expr></argument>,
					 <argument><expr><name>NIL</name></expr></argument> <comment type="block">/* returning_columns */</comment>,
					 <argument><expr><name>true</name></expr></argument> <comment type="block">/* target_tuple_fetched */</comment>,
					 <argument><expr><name>false</name></expr></argument> <comment type="block">/* is_single_row_txn */</comment>,
					 <argument><expr><name>false</name></expr></argument> <comment type="block">/* changingPart */</comment>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>YBCExecuteInsert</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
							<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>tuple</name></expr></argument>,
							<argument><expr><name>ONCONFLICT_NONE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>YBCDeleteSysCatalogTuple</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>            <name>dboid</name>       <init>= <expr><call><name>YBCGetDatabaseOid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name>       <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YBCPgStatement</name></type> <name>delete_stmt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tuple</name><operator>-&gt;</operator><name>t_ybctid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
		        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(
				        <argument><expr><literal type="string">"Missing column ybctid in DELETE request to YugaByte database"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Prepare DELETE statement. */</comment>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgNewDelete</name><argument_list>(<argument><expr><name>dboid</name></expr></argument>,
								  <argument><expr><name>relid</name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument> <comment type="block">/* is_single_row_txn */</comment>,
								  <argument><expr><call><name>YBCIsRegionLocal</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>delete_stmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Bind ybctid to identify the current row. */</comment>
	<decl_stmt><decl><type><name>YBCPgExpr</name></type> <name>ybctid_expr</name> <init>= <expr><call><name>YBCNewConstant</name><argument_list>(<argument><expr><name>delete_stmt</name></expr></argument>, <argument><expr><name>BYTEAOID</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_ybctid</name></name></expr></argument>,
										   <argument><expr><name>false</name></expr></argument> <comment type="block">/* is_null */</comment>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Delete row from foreign key cache */</comment>
	<expr_stmt><expr><call><name>YBCPgDeleteFromForeignKeyReferenceCache</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_ybctid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlBindColumn</name><argument_list>(<argument><expr><name>delete_stmt</name></expr></argument>, <argument><expr><name>YBTupleIdAttributeNumber</name></expr></argument>, <argument><expr><name>ybctid_expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Mark tuple for invalidation from system caches at next command
	 * boundary. Do this now so if there is an error with delete we will
	 * re-query to get the correct state from the master.
	 */</comment>
	<expr_stmt><expr><call><name>MarkCurrentCommandUsed</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CacheInvalidateHeapTuple</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>YBCExecWriteStmt</name><argument_list>(<argument><expr><name>delete_stmt</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* rows_affected_count */</comment>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Cleanup. */</comment>
	<expr_stmt><expr><call><name>YBCPgDeleteStatement</name><argument_list>(<argument><expr><name>delete_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>YBCUpdateSysCatalogTuple</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>oldtuple</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>YBCUpdateSysCatalogTupleForDb</name><argument_list>(<argument><expr><call><name>YBCGetDatabaseOid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>oldtuple</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>YBCUpdateSysCatalogTupleForDb</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>dboid</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>oldtuple</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>            <name>relid</name>       <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>      <name>tupleDesc</name>   <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>            <name>natts</name>       <init>= <expr><call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YBCPgStatement</name></type> <name>update_stmt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Create update statement. */</comment>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgNewUpdate</name><argument_list>(<argument><expr><name>dboid</name></expr></argument>,
								  <argument><expr><name>relid</name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument> <comment type="block">/* is_single_row_txn */</comment>,
								  <argument><expr><call><name>YBCIsRegionLocal</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>update_stmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>minattr</name> <init>= <expr><call><name>YBGetFirstLowInvalidAttributeNumber</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>pkey</name>   <init>= <expr><call><name>YBGetTablePrimaryKeyBms</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Bind the ybctid to the statement. */</comment>
	<expr_stmt><expr><call><name>YBCBindTupleId</name><argument_list>(<argument><expr><name>update_stmt</name></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_ybctid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Assign values to the non-primary-key columns to update the current row. */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>idx</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrNumber</name></type> <name>attnum</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attnum</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Skip primary-key columns */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>attnum</name> <operator>-</operator> <name>minattr</name></expr></argument>, <argument><expr><name>pkey</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>is_null</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>d</name> <init>= <expr><call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/*
		 * Since we are assign values to non-primary-key columns, pass InvalidOid as
		 * collation_id to skip computing collation sortkeys.
		 */</comment>
		<decl_stmt><decl><type><name>YBCPgExpr</name></type> <name>ybc_expr</name> <init>= <expr><call><name>YBCNewConstant</name><argument_list>(
			<argument><expr><name>update_stmt</name></expr></argument>, <argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument> <comment type="block">/* collation_id */</comment>,
			<argument><expr><name>d</name></expr></argument>, <argument><expr><name>is_null</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlAssignColumn</name><argument_list>(<argument><expr><name>update_stmt</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>ybc_expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Mark old tuple for invalidation from system caches at next command
	 * boundary, and mark the new tuple for invalidation in case we abort.
	 * In case when there is no old tuple, we will invalidate with the
	 * new tuple at next command boundary instead. Do these now so if there
	 * is an error with update we will re-query to get the correct state
	 * from the master.
	 */</comment>
	<expr_stmt><expr><call><name>MarkCurrentCommandUsed</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>oldtuple</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CacheInvalidateHeapTuple</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>oldtuple</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CacheInvalidateHeapTuple</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Execute the statement and clean up */</comment>
	<expr_stmt><expr><call><name>YBCExecWriteStmt</name><argument_list>(<argument><expr><name>update_stmt</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* rows_affected_count */</comment>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Cleanup. */</comment>
	<expr_stmt><expr><call><name>YBCPgDeleteStatement</name><argument_list>(<argument><expr><name>update_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><empty_stmt>;</empty_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>YBCRelInfoHasSecondaryIndices</name><parameter_list>(<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumIndices</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator>
			<operator>(</operator><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumIndices</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
			 <operator>!</operator><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_IndexRelationDescs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>rd_index</name><operator>-&gt;</operator><name>indisprimary</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
</unit>
