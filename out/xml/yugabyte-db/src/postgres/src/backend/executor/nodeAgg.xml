<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/executor/nodeAgg.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nodeAgg.c
 *	  Routines to handle aggregate nodes.
 *
 *	  ExecAgg normally evaluates each aggregate in the following steps:
 *
 *		 transvalue = initcond
 *		 foreach input_tuple do
 *			transvalue = transfunc(transvalue, input_value(s))
 *		 result = finalfunc(transvalue, direct_argument(s))
 *
 *	  If a finalfunc is not supplied then the result is just the ending
 *	  value of transvalue.
 *
 *	  Other behaviors can be selected by the "aggsplit" mode, which exists
 *	  to support partial aggregation.  It is possible to:
 *	  * Skip running the finalfunc, so that the output is always the
 *	  final transvalue state.
 *	  * Substitute the combinefunc for the transfunc, so that transvalue
 *	  states (propagated up from a child partial-aggregation step) are merged
 *	  rather than processing raw input rows.  (The statements below about
 *	  the transfunc apply equally to the combinefunc, when it's selected.)
 *	  * Apply the serializefunc to the output values (this only makes sense
 *	  when skipping the finalfunc, since the serializefunc works on the
 *	  transvalue data type).
 *	  * Apply the deserializefunc to the input values (this only makes sense
 *	  when using the combinefunc, for similar reasons).
 *	  It is the planner's responsibility to connect up Agg nodes using these
 *	  alternate behaviors in a way that makes sense, with partial aggregation
 *	  results being fed to nodes that expect them.
 *
 *	  If a normal aggregate call specifies DISTINCT or ORDER BY, we sort the
 *	  input tuples and eliminate duplicates (if required) before performing
 *	  the above-depicted process.  (However, we don't do that for ordered-set
 *	  aggregates; their "ORDER BY" inputs are ordinary aggregate arguments
 *	  so far as this module is concerned.)	Note that partial aggregation
 *	  is not supported in these cases, since we couldn't ensure global
 *	  ordering or distinctness of the inputs.
 *
 *	  If transfunc is marked "strict" in pg_proc and initcond is NULL,
 *	  then the first non-NULL input_value is assigned directly to transvalue,
 *	  and transfunc isn't applied until the second non-NULL input_value.
 *	  The agg's first input type and transtype must be the same in this case!
 *
 *	  If transfunc is marked "strict" then NULL input_values are skipped,
 *	  keeping the previous transvalue.  If transfunc is not strict then it
 *	  is called for every input tuple and must deal with NULL initcond
 *	  or NULL input_values for itself.
 *
 *	  If finalfunc is marked "strict" then it is not called when the
 *	  ending transvalue is NULL, instead a NULL result is created
 *	  automatically (this is just the usual handling of strict functions,
 *	  of course).  A non-strict finalfunc can make its own choice of
 *	  what to return for a NULL ending transvalue.
 *
 *	  Ordered-set aggregates are treated specially in one other way: we
 *	  evaluate any "direct" arguments and pass them to the finalfunc along
 *	  with the transition value.
 *
 *	  A finalfunc can have additional arguments beyond the transvalue and
 *	  any "direct" arguments, corresponding to the input arguments of the
 *	  aggregate.  These are always just passed as NULL.  Such arguments may be
 *	  needed to allow resolution of a polymorphic aggregate's result type.
 *
 *	  We compute aggregate input expressions and run the transition functions
 *	  in a temporary econtext (aggstate-&gt;tmpcontext).  This is reset at least
 *	  once per input tuple, so when the transvalue datatype is
 *	  pass-by-reference, we have to be careful to copy it into a longer-lived
 *	  memory context, and free the prior value to avoid memory leakage.  We
 *	  store transvalues in another set of econtexts, aggstate-&gt;aggcontexts
 *	  (one per grouping set, see below), which are also used for the hashtable
 *	  structures in AGG_HASHED mode.  These econtexts are rescanned, not just
 *	  reset, at group boundaries so that aggregate transition functions can
 *	  register shutdown callbacks via AggRegisterCallback.
 *
 *	  The node's regular econtext (aggstate-&gt;ss.ps.ps_ExprContext) is used to
 *	  run finalize functions and compute the output tuple; this context can be
 *	  reset once per output tuple.
 *
 *	  The executor's AggState node is passed as the fmgr "context" value in
 *	  all transfunc and finalfunc calls.  It is not recommended that the
 *	  transition functions look at the AggState node directly, but they can
 *	  use AggCheckCallContext() to verify that they are being called by
 *	  nodeAgg.c (and not as ordinary SQL functions).  The main reason a
 *	  transition function might want to know this is so that it can avoid
 *	  palloc'ing a fixed-size pass-by-ref transition value on every call:
 *	  it can instead just scribble on and return its left input.  Ordinarily
 *	  it is completely forbidden for functions to modify pass-by-ref inputs,
 *	  but in the aggregate case we know the left input is either the initial
 *	  transition value or a previous function result, and in either case its
 *	  value need not be preserved.  See int8inc() for an example.  Notice that
 *	  the EEOP_AGG_PLAIN_TRANS step is coded to avoid a data copy step when
 *	  the previous transition value pointer is returned.  It is also possible
 *	  to avoid repeated data copying when the transition value is an expanded
 *	  object: to do that, the transition function must take care to return
 *	  an expanded object that is in a child context of the memory context
 *	  returned by AggCheckCallContext().  Also, some transition functions want
 *	  to store working state in addition to the nominal transition value; they
 *	  can use the memory context returned by AggCheckCallContext() to do that.
 *
 *	  Note: AggCheckCallContext() is available as of PostgreSQL 9.0.  The
 *	  AggState is available as context in earlier releases (back to 8.1),
 *	  but direct examination of the node is needed to use it before 9.0.
 *
 *	  As of 9.4, aggregate transition functions can also use AggGetAggref()
 *	  to get hold of the Aggref expression node for their aggregate call.
 *	  This is mainly intended for ordered-set aggregates, which are not
 *	  supported as window functions.  (A regular aggregate function would
 *	  need some fallback logic to use this, since there's no Aggref node
 *	  for a window function.)
 *
 *	  Grouping sets:
 *
 *	  A list of grouping sets which is structurally equivalent to a ROLLUP
 *	  clause (e.g. (a,b,c), (a,b), (a)) can be processed in a single pass over
 *	  ordered data.  We do this by keeping a separate set of transition values
 *	  for each grouping set being concurrently processed; for each input tuple
 *	  we update them all, and on group boundaries we reset those states
 *	  (starting at the front of the list) whose grouping values have changed
 *	  (the list of grouping sets is ordered from most specific to least
 *	  specific).
 *
 *	  Where more complex grouping sets are used, we break them down into
 *	  "phases", where each phase has a different sort order (except phase 0
 *	  which is reserved for hashing).  During each phase but the last, the
 *	  input tuples are additionally stored in a tuplesort which is keyed to the
 *	  next phase's sort order; during each phase but the first, the input
 *	  tuples are drawn from the previously sorted data.  (The sorting of the
 *	  data for the first phase is handled by the planner, as it might be
 *	  satisfied by underlying nodes.)
 *
 *	  Hashing can be mixed with sorted grouping.  To do this, we have an
 *	  AGG_MIXED strategy that populates the hashtables during the first sorted
 *	  phase, and switches to reading them out after completing all sort phases.
 *	  We can also support AGG_HASHED with multiple hash tables and no sorting
 *	  at all.
 *
 *	  From the perspective of aggregate transition and final functions, the
 *	  only issue regarding grouping sets is this: a single call site (flinfo)
 *	  of an aggregate function may be used for updating several different
 *	  transition values in turn. So the function must not cache in the flinfo
 *	  anything which logically belongs as part of the transition value (most
 *	  importantly, the memory context in which the transition value exists).
 *	  The support API functions (AggCheckCallContext, AggRegisterCallback) are
 *	  sensitive to the grouping set for which the aggregate function is
 *	  currently being called.
 *
 *	  Plan structure:
 *
 *	  What we get from the planner is actually one "real" Agg node which is
 *	  part of the plan tree proper, but which optionally has an additional list
 *	  of Agg nodes hung off the side via the "chain" field.  This is because an
 *	  Agg node happens to be a convenient representation of all the data we
 *	  need for grouping sets.
 *
 *	  For many purposes, we treat the "real" node as if it were just the first
 *	  node in the chain.  The chain must be ordered such that hashed entries
 *	  come before sorted/plain entries; the real node is marked AGG_MIXED if
 *	  there are both types present (in which case the real node describes one
 *	  of the hashed groupings, other AGG_HASHED nodes may optionally follow in
 *	  the chain, followed in turn by AGG_SORTED or (one) AGG_PLAIN node).  If
 *	  the real node is marked AGG_HASHED or AGG_SORTED, then all the chained
 *	  nodes must be of the same type; if it is AGG_PLAIN, there can be no
 *	  chained nodes.
 *
 *	  We collect all hashed nodes into a single "phase", numbered 0, and create
 *	  a sorted phase (numbered 1..n) for each AGG_SORTED or AGG_PLAIN node.
 *	  Phase 0 is allocated even if there are no hashes, but remains unused in
 *	  that case.
 *
 *	  AGG_HASHED nodes actually refer to only a single grouping set each,
 *	  because for each hashed grouping we need a separate grpColIdx and
 *	  numGroups estimate.  AGG_SORTED nodes represent a "rollup", a list of
 *	  grouping sets that share a sort order.  Each AGG_SORTED node other than
 *	  the first one has an associated Sort node which describes the sort order
 *	  to be used; the first sorted node takes its input from the outer subtree,
 *	  which the planner has already arranged to provide ordered data.
 *
 *	  Memory and ExprContext usage:
 *
 *	  Because we're accumulating aggregate values across input rows, we need to
 *	  use more memory contexts than just simple input/output tuple contexts.
 *	  In fact, for a rollup, we need a separate context for each grouping set
 *	  so that we can reset the inner (finer-grained) aggregates on their group
 *	  boundaries while continuing to accumulate values for outer
 *	  (coarser-grained) groupings.  On top of this, we might be simultaneously
 *	  populating hashtables; however, we only need one context for all the
 *	  hashtables.
 *
 *	  So we create an array, aggcontexts, with an ExprContext for each grouping
 *	  set in the largest rollup that we're going to process, and use the
 *	  per-tuple memory context of those ExprContexts to store the aggregate
 *	  transition values.  hashcontext is the single context created to support
 *	  all hash tables.
 *
 *    Transition / Combine function invocation:
 *
 *    For performance reasons transition functions, including combine
 *    functions, aren't invoked one-by-one from nodeAgg.c after computing
 *    arguments using the expression evaluation engine. Instead
 *    ExecBuildAggTrans() builds one large expression that does both argument
 *    evaluation and transition function invocation. That avoids performance
 *    issues due to repeated uses of expression evaluation, complications due
 *    to filter expressions having to be evaluated early, and allows to JIT
 *    the entire expression into one native function.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/executor/nodeAgg.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaccess.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_aggregate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/yb_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeAgg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_agg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tuplesort.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>select_current_set</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>setno</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_hash</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>initialize_phase</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>newphase</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>fetch_input_tuple</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>initialize_aggregates</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
					  <parameter><decl><type><name>AggStatePerGroup</name> <modifier>*</modifier></type><name>pergroups</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>numReset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>advance_transition_function</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
							<parameter><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name></decl></parameter>,
							<parameter><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>advance_aggregates</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>process_ordered_aggregate_single</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
								 <parameter><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name></decl></parameter>,
								 <parameter><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>process_ordered_aggregate_multi</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
								<parameter><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name></decl></parameter>,
								<parameter><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>finalize_aggregate</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
				   <parameter><decl><type><name>AggStatePerAgg</name></type> <name>peragg</name></decl></parameter>,
				   <parameter><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name></decl></parameter>,
				   <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>resultVal</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>resultIsNull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>finalize_partialaggregate</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
						  <parameter><decl><type><name>AggStatePerAgg</name></type> <name>peragg</name></decl></parameter>,
						  <parameter><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name></decl></parameter>,
						  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>resultVal</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>resultIsNull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>prepare_projection_slot</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
						<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>currentSet</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>finalize_aggregates</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
					<parameter><decl><type><name>AggStatePerAgg</name></type> <name>peragg</name></decl></parameter>,
					<parameter><decl><type><name>AggStatePerGroup</name></type> <name>pergroup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>project_aggregates</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>find_unaggregated_cols</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>find_unaggregated_cols_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier><modifier>*</modifier></type><name>colnos</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>build_hash_table</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleHashEntryData</name> <modifier>*</modifier></type><name>lookup_hash_entry</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>lookup_hash_entries</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>agg_retrieve_direct</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>agg_fill_hash_table</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>agg_retrieve_hash_table</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>GetAggInitVal</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>textInitVal</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>transtype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>build_pertrans_for_aggref</name><parameter_list>(<parameter><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name></decl></parameter>,
						  <parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
						  <parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggref</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>aggtransfn</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>aggtranstype</name></decl></parameter>,
						  <parameter><decl><type><name>Oid</name></type> <name>aggserialfn</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>aggdeserialfn</name></decl></parameter>,
						  <parameter><decl><type><name>Datum</name></type> <name>initValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>initValueIsNull</name></decl></parameter>,
						  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>inputTypes</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numArguments</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>find_compatible_peragg</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>newagg</name></decl></parameter>, <parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>lastaggno</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>same_input_transnos</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>find_compatible_pertrans</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>, <parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>newagg</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>shareable</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>aggtransfn</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>aggtranstype</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>aggserialfn</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>aggdeserialfn</name></decl></parameter>,
						 <parameter><decl><type><name>Datum</name></type> <name>initValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>initValueIsNull</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>transnos</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>yb_agg_pushdown_supported</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>yb_agg_pushdown</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Select the current grouping set; affects current_set and
 * curaggcontext.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>select_current_set</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>setno</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* when changing this, also adapt ExecInterpExpr() and friends */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_hash</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curaggcontext</name></name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>hashcontext</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curaggcontext</name></name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>aggcontexts</name><index>[<expr><name>setno</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name> <operator>=</operator> <name>setno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Switch to phase "newphase", which must either be 0 or 1 (to reset) or
 * current_phase + 1. Juggle the tuplesorts accordingly.
 *
 * Phase 0 is for hashing, which we currently handle last in the AGG_MIXED
 * case, so when entering phase 0, all we need to do is drop open sorts.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initialize_phase</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>newphase</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newphase</name> <operator>&lt;=</operator> <literal type="number">1</literal> <operator>||</operator> <name>newphase</name> <operator>==</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>current_phase</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Whatever the previous state, we're now done with whatever input
	 * tuplesort was in use.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>sort_in</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>tuplesort_end</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>sort_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>sort_in</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>newphase</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Discard any existing output tuplesort.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>sort_out</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>tuplesort_end</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>sort_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>sort_out</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * The old output tuplesort becomes the new input one, and this is the
		 * right time to actually sort it.
		 */</comment>
		<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>sort_in</name></name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>sort_out</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>sort_out</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>sort_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>tuplesort_performsort</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>sort_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If this isn't the last phase, we need to sort appropriately for the
	 * next phase in sequence.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>newphase</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>newphase</name> <operator>&lt;</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>numphases</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Sort</name>	   <modifier>*</modifier></type><name>sortnode</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>phases</name><index>[<expr><name>newphase</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>sortnode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>outerNode</name> <init>= <expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name> <init>= <expr><call><name>ExecGetResultType</name><argument_list>(<argument><expr><name>outerNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>sort_out</name></name> <operator>=</operator> <call><name>tuplesort_begin_heap</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>,
												  <argument><expr><name><name>sortnode</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>,
												  <argument><expr><name><name>sortnode</name><operator>-&gt;</operator><name>sortColIdx</name></name></expr></argument>,
												  <argument><expr><name><name>sortnode</name><operator>-&gt;</operator><name>sortOperators</name></name></expr></argument>,
												  <argument><expr><name><name>sortnode</name><operator>-&gt;</operator><name>collations</name></name></expr></argument>,
												  <argument><expr><name><name>sortnode</name><operator>-&gt;</operator><name>nullsFirst</name></name></expr></argument>,
												  <argument><expr><name>work_mem</name></expr></argument>,
												  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_phase</name></name> <operator>=</operator> <name>newphase</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>phase</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>phases</name><index>[<expr><name>newphase</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch a tuple from either the outer plan (for phase 1) or from the sorter
 * populated by the previous phase.  Copy it to the sorter for the next phase
 * if any.
 *
 * Callers cannot rely on memory for tuple in returned slot remaining valid
 * past any subsequently fetched tuple.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>fetch_input_tuple</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>sort_in</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* make sure we check for interrupts in either path through here */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplesort_gettupleslot</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>sort_in</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>sort_slot</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>sort_slot</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>sort_out</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tuplesort_puttupleslot</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>sort_out</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * (Re)Initialize an individual aggregate.
 *
 * This function handles only one grouping set, already set in
 * aggstate-&gt;current_set.
 *
 * When called, GetCurrentMemoryContext() should be the per-query context.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initialize_aggregate</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>, <parameter><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name></decl></parameter>,
					 <parameter><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Start a fresh sort operation for each DISTINCT/ORDER BY aggregate.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>numSortCols</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * In case of rescan, maybe there could be an uncompleted sort
		 * operation?  Clean it up if so.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>tuplesort_end</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


		<comment type="block">/*
		 * We use a plain Datum sorter when there's a single input column;
		 * otherwise sort the full tuple.  (See comments for
		 * process_ordered_aggregate_single.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>numInputs</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortdesc</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name></expr>]</index></name> <operator>=</operator>
				<call><name>tuplesort_begin_datum</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
									  <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortOperators</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
									  <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortCollations</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
									  <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortNullsFirst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
									  <argument><expr><name>work_mem</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name></expr>]</index></name> <operator>=</operator>
				<call><name>tuplesort_begin_heap</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortdesc</name></name></expr></argument>,
									 <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>numSortCols</name></name></expr></argument>,
									 <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortColIdx</name></name></expr></argument>,
									 <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortOperators</name></name></expr></argument>,
									 <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortCollations</name></name></expr></argument>,
									 <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortNullsFirst</name></name></expr></argument>,
									 <argument><expr><name>work_mem</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * (Re)set transValue to the initial value.
	 *
	 * Note that when the initial value is pass-by-ref, we must copy it (into
	 * the aggcontext) since we will pfree the transValue later.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>initValueIsNull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name> <operator>=</operator> <name><name>pertrans</name><operator>-&gt;</operator><name>initValue</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(
										   <argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curaggcontext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>initValue</name></name></expr></argument>,
											  <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeByVal</name></name></expr></argument>,
											  <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name> <operator>=</operator> <name><name>pertrans</name><operator>-&gt;</operator><name>initValueIsNull</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the initial value for the transition state doesn't exist in the
	 * pg_aggregate table then we will let the first non-NULL value returned
	 * from the outer procNode become the initial value. (This is useful for
	 * aggregates like max() and min().) The noTransValue flag signals that we
	 * still need to do this.
	 */</comment>
	<expr_stmt><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>noTransValue</name></name> <operator>=</operator> <name><name>pertrans</name><operator>-&gt;</operator><name>initValueIsNull</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize all aggregate transition states for a new group of input values.
 *
 * If there are multiple grouping sets, we initialize only the first numReset
 * of them (the grouping sets are ordered so that the most specific one, which
 * is reset most often, is first). As a convenience, if numReset is 0, we
 * reinitialize all sets.
 *
 * NB: This cannot be used for hash aggregates, as for those the grouping set
 * number has to be specified from further up.
 *
 * When called, GetCurrentMemoryContext() should be the per-query context.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initialize_aggregates</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
					  <parameter><decl><type><name>AggStatePerGroup</name> <modifier>*</modifier></type><name>pergroups</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>numReset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>transno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numGroupingSets</name> <init>= <expr><call><name>Max</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>phase</name><operator>-&gt;</operator><name>numsets</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>setno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numTrans</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>numtrans</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>transstates</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>pertrans</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>numReset</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>numReset</name> <operator>=</operator> <name>numGroupingSets</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>setno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>setno</name> <operator>&lt;</operator> <name>numReset</name></expr>;</condition> <incr><expr><name>setno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AggStatePerGroup</name></type> <name>pergroup</name> <init>= <expr><name><name>pergroups</name><index>[<expr><name>setno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>select_current_set</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>setno</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>transno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>transno</name> <operator>&lt;</operator> <name>numTrans</name></expr>;</condition> <incr><expr><name>transno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name> <init>= <expr><operator>&amp;</operator><name><name>transstates</name><index>[<expr><name>transno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name> <init>= <expr><operator>&amp;</operator><name><name>pergroup</name><index>[<expr><name>transno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>initialize_aggregate</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>pertrans</name></expr></argument>, <argument><expr><name>pergroupstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Given new input value(s), advance the transition function of one aggregate
 * state within one grouping set only (already set in aggstate-&gt;current_set)
 *
 * The new values (and null flags) have been preloaded into argument positions
 * 1 and up in pertrans-&gt;transfn_fcinfo, so that we needn't copy them again to
 * pass to the transition function.  We also expect that the static fields of
 * the fcinfo are already initialized; that was done by ExecInitAgg().
 *
 * It doesn't matter which memory context this is called in.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>advance_transition_function</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
							<parameter><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name></decl></parameter>,
							<parameter><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name> <init>= <expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transfn_fcinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>newVal</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>transfn</name><operator>.</operator><name>fn_strict</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For a strict transfn, nothing happens when there's a NULL input; we
		 * just keep the prior transValue.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>numTransInputs</name> <init>= <expr><name><name>pertrans</name><operator>-&gt;</operator><name>numTransInputs</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>numTransInputs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>noTransValue</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * transValue has not been initialized. This is the first non-NULL
			 * input value. We use it as the initial value for transValue. (We
			 * already checked that the agg's input type is binary-compatible
			 * with its transtype, so straight copy here is OK.)
			 *
			 * We must copy the datum into aggcontext if it is pass-by-ref. We
			 * do not need to pfree the old transValue, since it's NULL.
			 */</comment>
			<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(
											   <argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curaggcontext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
												  <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeByVal</name></name></expr></argument>,
												  <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>noTransValue</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Don't call a strict function with NULL inputs.  Note it is
			 * possible to get here despite the above tests, if the transfn is
			 * strict *and* returned a NULL on a prior cycle. If that happens
			 * we will propagate the NULL all the way to the end.
			 */</comment>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We run the transition functions in per-input-tuple memory context */</comment>
	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>tmpcontext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set up aggstate-&gt;curpertrans for AggGetAggref() */</comment>
	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curpertrans</name></name> <operator>=</operator> <name>pertrans</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * OK to call the transition function
	 */</comment>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>		<comment type="block">/* just in case transfn doesn't set it */</comment>

	<expr_stmt><expr><name>newVal</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curpertrans</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If pass-by-ref datatype, must copy the new value into aggcontext and
	 * free the prior transValue.  But if transfn returned a pointer to its
	 * first input, we don't need to do anything.  Also, if transfn returned a
	 * pointer to a R/W expanded object that is already a child of the
	 * aggcontext, assume we can adopt that value without copying it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeByVal</name></name> <operator>&amp;&amp;</operator>
		<call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>newVal</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curaggcontext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>DatumIsReadWriteExpandedObject</name><argument_list>(<argument><expr><name>newVal</name></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>,
											   <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>MemoryContextGetParent</name><argument_list>(<argument><expr><call><name>DatumGetEOHP</name><argument_list>(<argument><expr><name>newVal</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>eoh_context</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				 <comment type="block">/* do nothing */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>newVal</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name>newVal</name></expr></argument>,
								   <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeByVal</name></name></expr></argument>,
								   <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>DatumIsReadWriteExpandedObject</name><argument_list>(<argument><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>,
											   <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>DeleteExpandedObject</name><argument_list>(<argument><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name> <operator>=</operator> <name>newVal</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Advance each aggregate transition state for one input tuple.  The input
 * tuple has been stored in tmpcontext-&gt;ecxt_outertuple, so that it is
 * accessible to ExecEvalExpr.
 *
 * We have two sets of transition states to handle: one for sorted aggregation
 * and one for hashed; we do them both here, to avoid multiple evaluation of
 * the inputs.
 *
 * When called, GetCurrentMemoryContext() should be the per-query context.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>advance_aggregates</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>dummynull</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExecEvalExprSwitchContext</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>phase</name><operator>-&gt;</operator><name>evaltrans</name></name></expr></argument>,
							  <argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>tmpcontext</name></name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>dummynull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Run the transition function for a DISTINCT or ORDER BY aggregate
 * with only one input.  This is called after we have completed
 * entering all the input values into the sort object.  We complete the
 * sort, read out the values in sorted order, and run the transition
 * function on each value (applying DISTINCT if appropriate).
 *
 * Note that the strictness of the transition function was checked when
 * entering the values into the sort, so we don't check it again here;
 * we just apply standard SQL DISTINCT logic.
 *
 * The one-input case is handled separately from the multi-input case
 * for performance reasons: for single by-value inputs, such as the
 * common case of count(distinct id), the tuplesort_getdatum code path
 * is around 300% faster.  (The speedup for by-reference types is less
 * but still noticeable.)
 *
 * This function handles only one grouping set (already set in
 * aggstate-&gt;current_set).
 *
 * When called, GetCurrentMemoryContext() should be the per-query context.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_ordered_aggregate_single</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
								 <parameter><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name></decl></parameter>,
								 <parameter><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>oldVal</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>oldIsNull</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>haveOldVal</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>workcontext</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>tmpcontext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isDistinct</name> <init>= <expr><operator>(</operator><name><name>pertrans</name><operator>-&gt;</operator><name>numDistinctCols</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>newAbbrevVal</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>oldAbbrevVal</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name> <init>= <expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transfn_fcinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>newVal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>isNull</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>numDistinctCols</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>tuplesort_performsort</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Load the column into argument 1 (arg 0 will be transition value) */</comment>
	<expr_stmt><expr><name>newVal</name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>arg</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>isNull</name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note: if input type is pass-by-ref, the datums returned by the sort are
	 * freshly palloc'd in the per-query context, so we must be careful to
	 * pfree them when they are no longer needed.
	 */</comment>

	<while>while <condition>(<expr><call><name>tuplesort_getdatum</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name></expr>]</index></name></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>newVal</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newAbbrevVal</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Clear and select the working context for evaluation of the equality
		 * function and transition function.
		 */</comment>
		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>workcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>workcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If DISTINCT mode, and not distinct from prior, skip it.
		 *
		 * Note: we assume equality functions don't care about collation.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>isDistinct</name> <operator>&amp;&amp;</operator>
			<name>haveOldVal</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>(</operator><name>oldIsNull</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>isNull</name><operator>)</operator> <operator>||</operator>
			 <operator>(</operator><operator>!</operator><name>oldIsNull</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>*</operator><name>isNull</name> <operator>&amp;&amp;</operator>
			  <name>oldAbbrevVal</name> <operator>==</operator> <name>newAbbrevVal</name> <operator>&amp;&amp;</operator>
			  <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>equalfnOne</name></name></expr></argument>,
										 <argument><expr><name>oldVal</name></expr></argument>, <argument><expr><operator>*</operator><name>newVal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* equal to prior, so forget this one */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pertrans</name><operator>-&gt;</operator><name>inputtypeByVal</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>*</operator><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><operator>*</operator><name>newVal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>advance_transition_function</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>pertrans</name></expr></argument>, <argument><expr><name>pergroupstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* forget the old value, if any */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>oldIsNull</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pertrans</name><operator>-&gt;</operator><name>inputtypeByVal</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>oldVal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* and remember the new one for subsequent equality checks */</comment>
			<expr_stmt><expr><name>oldVal</name> <operator>=</operator> <operator>*</operator><name>newVal</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>oldAbbrevVal</name> <operator>=</operator> <name>newAbbrevVal</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>oldIsNull</name> <operator>=</operator> <operator>*</operator><name>isNull</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>haveOldVal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>oldIsNull</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pertrans</name><operator>-&gt;</operator><name>inputtypeByVal</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>oldVal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>tuplesort_end</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Run the transition function for a DISTINCT or ORDER BY aggregate
 * with more than one input.  This is called after we have completed
 * entering all the input values into the sort object.  We complete the
 * sort, read out the values in sorted order, and run the transition
 * function on each value (applying DISTINCT if appropriate).
 *
 * This function handles only one grouping set (already set in
 * aggstate-&gt;current_set).
 *
 * When called, GetCurrentMemoryContext() should be the per-query context.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_ordered_aggregate_multi</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
								<parameter><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name></decl></parameter>,
								<parameter><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>tmpcontext</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>tmpcontext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name> <init>= <expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transfn_fcinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot1</name> <init>= <expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortslot</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot2</name> <init>= <expr><name><name>pertrans</name><operator>-&gt;</operator><name>uniqslot</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numTransInputs</name> <init>= <expr><name><name>pertrans</name><operator>-&gt;</operator><name>numTransInputs</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numDistinctCols</name> <init>= <expr><name><name>pertrans</name><operator>-&gt;</operator><name>numDistinctCols</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>newAbbrevVal</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>oldAbbrevVal</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>haveOldValue</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>save</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>tmpcontext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>tuplesort_performsort</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>slot2</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><call><name>tuplesort_gettupleslot</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name></expr>]</index></name></expr></argument>,
								  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>slot1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newAbbrevVal</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>tmpcontext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>slot1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmpcontext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name> <operator>=</operator> <name>slot2</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>numDistinctCols</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<operator>!</operator><name>haveOldValue</name> <operator>||</operator>
			<name>newAbbrevVal</name> <operator>!=</operator> <name>oldAbbrevVal</name> <operator>||</operator>
			<operator>!</operator><call><name>ExecQual</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>equalfnMulti</name></name></expr></argument>, <argument><expr><name>tmpcontext</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Extract the first numTransInputs columns as datums to pass to
			 * the transfn.
			 */</comment>
			<expr_stmt><expr><call><name>slot_getsomeattrs</name><argument_list>(<argument><expr><name>slot1</name></expr></argument>, <argument><expr><name>numTransInputs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Load values into fcinfo */</comment>
			<comment type="block">/* Start from 1, since the 0th arg will be the transition value */</comment>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numTransInputs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>slot1</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>slot1</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></for>

			<expr_stmt><expr><call><name>advance_transition_function</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>pertrans</name></expr></argument>, <argument><expr><name>pergroupstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>numDistinctCols</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* swap the slot pointers to retain the current tuple */</comment>
				<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>tmpslot</name> <init>= <expr><name>slot2</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>slot2</name> <operator>=</operator> <name>slot1</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>slot1</name> <operator>=</operator> <name>tmpslot</name></expr>;</expr_stmt>
				<comment type="block">/* avoid ExecQual() calls by reusing abbreviated keys */</comment>
				<expr_stmt><expr><name>oldAbbrevVal</name> <operator>=</operator> <name>newAbbrevVal</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>haveOldValue</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Reset context each time */</comment>
		<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>tmpcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>slot2</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>tuplesort_end</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* restore previous slot, potentially in use for grouping sets */</comment>
	<expr_stmt><expr><name><name>tmpcontext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>save</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Compute the final value of one aggregate.
 *
 * This function handles only one grouping set (already set in
 * aggstate-&gt;current_set).
 *
 * The finalfunction will be run, and the result delivered, in the
 * output-tuple context; caller's GetCurrentMemoryContext() does not matter.
 *
 * The finalfn uses the state as set in the transno. This also might be
 * being used by another aggregate function, so it's important that we do
 * nothing destructive here.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>finalize_aggregate</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
				   <parameter><decl><type><name>AggStatePerAgg</name></type> <name>peragg</name></decl></parameter>,
				   <parameter><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name></decl></parameter>,
				   <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>resultVal</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>resultIsNull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FunctionCallInfoData</name></type> <name>fcinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>anynull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name> <init>= <expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>pertrans</name><index>[<expr><name><name>peragg</name><operator>-&gt;</operator><name>transno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Evaluate any direct arguments.  We do this even if there's no finalfn
	 * (which is unlikely anyway), so that side-effects happen as expected.
	 * The direct arguments go into arg positions 1 and up, leaving position 0
	 * for the transition state value.
	 */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>peragg-&gt;aggdirectargs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>ExprState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>fcinfo</name><operator>.</operator><name>arg</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>,
									 <argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name><name>fcinfo</name><operator>.</operator><name>argnull</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>anynull</name> <operator>|=</operator> <name><name>fcinfo</name><operator>.</operator><name>argnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Apply the agg's finalfn if one is provided, else return transValue.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>peragg</name><operator>-&gt;</operator><name>finalfn_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>numFinalArgs</name> <init>= <expr><name><name>peragg</name><operator>-&gt;</operator><name>numFinalArgs</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* set up aggstate-&gt;curperagg for AggGetAggref() */</comment>
		<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curperagg</name></name> <operator>=</operator> <name>peragg</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>peragg</name><operator>-&gt;</operator><name>finalfn</name></name></expr></argument>,
								 <argument><expr><name>numFinalArgs</name></expr></argument>,
								 <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>aggCollation</name></name></expr></argument>,
								 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>aggstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Fill in the transition state value */</comment>
		<expr_stmt><expr><name><name>fcinfo</name><operator>.</operator><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>MakeExpandedObjectReadOnly</name><argument_list>(<argument><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name></expr></argument>,
												   <argument><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr></argument>,
												   <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fcinfo</name><operator>.</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>anynull</name> <operator>|=</operator> <name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>;</expr_stmt>

		<comment type="block">/* Fill any remaining argument positions with nulls */</comment>
		<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numFinalArgs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>fcinfo</name><operator>.</operator><name>arg</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fcinfo</name><operator>.</operator><name>argnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>anynull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>.</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_strict</name></name> <operator>&amp;&amp;</operator> <name>anynull</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* don't call a strict function with NULL inputs */</comment>
			<expr_stmt><expr><operator>*</operator><name>resultVal</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>resultIsNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>resultVal</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>resultIsNull</name> <operator>=</operator> <name><name>fcinfo</name><operator>.</operator><name>isnull</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curperagg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Don't need MakeExpandedObjectReadOnly; datumCopy will copy it */</comment>
		<expr_stmt><expr><operator>*</operator><name>resultVal</name> <operator>=</operator> <name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>resultIsNull</name> <operator>=</operator> <name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If result is pass-by-ref, make sure it is in the right context.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>peragg</name><operator>-&gt;</operator><name>resulttypeByVal</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>*</operator><name>resultIsNull</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>MemoryContextContains</name><argument_list>(<argument><expr><call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr></argument>,
							   <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><operator>*</operator><name>resultVal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>resultVal</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><operator>*</operator><name>resultVal</name></expr></argument>,
							   <argument><expr><name><name>peragg</name><operator>-&gt;</operator><name>resulttypeByVal</name></name></expr></argument>,
							   <argument><expr><name><name>peragg</name><operator>-&gt;</operator><name>resulttypeLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Compute the output value of one partial aggregate.
 *
 * The serialization function will be run, and the result delivered, in the
 * output-tuple context; caller's GetCurrentMemoryContext() does not matter.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>finalize_partialaggregate</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
						  <parameter><decl><type><name>AggStatePerAgg</name></type> <name>peragg</name></decl></parameter>,
						  <parameter><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name></decl></parameter>,
						  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>resultVal</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>resultIsNull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name> <init>= <expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>pertrans</name><index>[<expr><name><name>peragg</name><operator>-&gt;</operator><name>transno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * serialfn_oid will be set if we must serialize the transvalue before
	 * returning it
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>serialfn_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Don't call a strict serialization function with NULL input. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>serialfn</name><operator>.</operator><name>fn_strict</name></name> <operator>&amp;&amp;</operator> <name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>resultVal</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>resultIsNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name> <init>= <expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>serialfn_fcinfo</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>MakeExpandedObjectReadOnly</name><argument_list>(<argument><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name></expr></argument>,
														<argument><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr></argument>,
														<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><operator>*</operator><name>resultVal</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>resultIsNull</name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Don't need MakeExpandedObjectReadOnly; datumCopy will copy it */</comment>
		<expr_stmt><expr><operator>*</operator><name>resultVal</name> <operator>=</operator> <name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>resultIsNull</name> <operator>=</operator> <name><name>pergroupstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* If result is pass-by-ref, make sure it is in the right context. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>peragg</name><operator>-&gt;</operator><name>resulttypeByVal</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>*</operator><name>resultIsNull</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>MemoryContextContains</name><argument_list>(<argument><expr><call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr></argument>,
							   <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><operator>*</operator><name>resultVal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>resultVal</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><operator>*</operator><name>resultVal</name></expr></argument>,
							   <argument><expr><name><name>peragg</name><operator>-&gt;</operator><name>resulttypeByVal</name></name></expr></argument>,
							   <argument><expr><name><name>peragg</name><operator>-&gt;</operator><name>resulttypeLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Prepare to finalize and project based on the specified representative tuple
 * slot and grouping set.
 *
 * In the specified tuple slot, force to null all attributes that should be
 * read as null in the context of the current grouping set.  Also stash the
 * current group bitmap where GroupingExpr can get at it.
 *
 * This relies on three conditions:
 *
 * 1) Nothing is ever going to try and extract the whole tuple from this slot,
 * only reference it in evaluations, which will only access individual
 * attributes.
 *
 * 2) No system columns are going to need to be nulled. (If a system column is
 * referenced in a group clause, it is actually projected in the outer plan
 * tlist.)
 *
 * 3) Within a given phase, we never need to recover the value of an attribute
 * once it has been set to null.
 *
 * Poking into the slot this way is a bit ugly, but the consensus is that the
 * alternative was worse.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>prepare_projection_slot</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>currentSet</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>phase</name><operator>-&gt;</operator><name>grouped_cols</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>grouped_cols</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>phase</name><operator>-&gt;</operator><name>grouped_cols</name><index>[<expr><name>currentSet</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>grouped_cols</name></name> <operator>=</operator> <name>grouped_cols</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isempty</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Force all values to be NULL if working on an empty input tuple
			 * (i.e. an empty grouping set for which no input rows were
			 * supplied).
			 */</comment>
			<expr_stmt><expr><call><name>ExecStoreAllNullTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>all_grouped_cols</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

			<comment type="block">/* all_grouped_cols is arranged in desc order */</comment>
			<expr_stmt><expr><call><name>slot_getsomeattrs</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><call><name>linitial_int</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>all_grouped_cols</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>aggstate-&gt;all_grouped_cols</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>grouped_cols</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Compute the final value of all aggregates for one group.
 *
 * This function handles only one grouping set at a time, which the caller must
 * have selected.  It's also the caller's responsibility to adjust the supplied
 * pergroup parameter to point to the current set's transvalues.
 *
 * Results are stored in the output econtext aggvalues/aggnulls.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>finalize_aggregates</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
					<parameter><decl><type><name>AggStatePerAgg</name></type> <name>peraggs</name></decl></parameter>,
					<parameter><decl><type><name>AggStatePerGroup</name></type> <name>pergroup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>aggvalues</name> <init>= <expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_aggvalues</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>aggnulls</name> <init>= <expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_aggnulls</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>aggno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>transno</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If there were any DISTINCT and/or ORDER BY aggregates, sort their
	 * inputs and run the transition functions.
	 */</comment>
	<for>for <control>(<init><expr><name>transno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>transno</name> <operator>&lt;</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>numtrans</name></name></expr>;</condition> <incr><expr><name>transno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name> <init>= <expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>pertrans</name><index>[<expr><name>transno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>pergroupstate</name> <operator>=</operator> <operator>&amp;</operator><name><name>pergroup</name><index>[<expr><name>transno</name></expr>]</index></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>numSortCols</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>!=</operator> <name>AGG_HASHED</name> <operator>&amp;&amp;</operator>
				   <name><name>aggstate</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>!=</operator> <name>AGG_MIXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>numInputs</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>process_ordered_aggregate_single</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>,
												 <argument><expr><name>pertrans</name></expr></argument>,
												 <argument><expr><name>pergroupstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>process_ordered_aggregate_multi</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>,
												<argument><expr><name>pertrans</name></expr></argument>,
												<argument><expr><name>pergroupstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Run the final functions.
	 */</comment>
	<for>for <control>(<init><expr><name>aggno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>aggno</name> <operator>&lt;</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>numaggs</name></name></expr>;</condition> <incr><expr><name>aggno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AggStatePerAgg</name></type> <name>peragg</name> <init>= <expr><operator>&amp;</operator><name><name>peraggs</name><index>[<expr><name>aggno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>transno</name> <init>= <expr><name><name>peragg</name><operator>-&gt;</operator><name>transno</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>pergroupstate</name> <operator>=</operator> <operator>&amp;</operator><name><name>pergroup</name><index>[<expr><name>transno</name></expr>]</index></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>DO_AGGSPLIT_SKIPFINAL</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>finalize_partialaggregate</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>peragg</name></expr></argument>, <argument><expr><name>pergroupstate</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name><name>aggvalues</name><index>[<expr><name>aggno</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aggnulls</name><index>[<expr><name>aggno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>finalize_aggregate</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>peragg</name></expr></argument>, <argument><expr><name>pergroupstate</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name><name>aggvalues</name><index>[<expr><name>aggno</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aggnulls</name><index>[<expr><name>aggno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Project the result of a group (whose aggs have already been calculated by
 * finalize_aggregates). Returns the result slot, or NULL if no row is
 * projected (suppressed by qual).
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>project_aggregates</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check the qual (HAVING clause); if the group does not match, ignore it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ExecQual</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>qual</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Form and return projection tuple using the aggregate results and
		 * the representative input tuple.
		 */</comment>
		<return>return <expr><call><name>ExecProject</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InstrCountFiltered1</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * find_unaggregated_cols
 *	  Construct a bitmapset of the column numbers of un-aggregated Vars
 *	  appearing in our targetlist and qual (HAVING clause)
 */</comment>
<function><type><specifier>static</specifier> <name>Bitmapset</name> <modifier>*</modifier></type>
<name>find_unaggregated_cols</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Agg</name>		   <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>Agg</name> <operator>*</operator><operator>)</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>colnos</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>colnos</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>find_unaggregated_cols_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>colnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>find_unaggregated_cols_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>colnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>colnos</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>find_unaggregated_cols_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier><modifier>*</modifier></type><name>colnos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* setrefs.c should have set the varno to OUTER_VAR */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>OUTER_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>colnos</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><operator>*</operator><name>colnos</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call> <operator>||</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>GroupingFunc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* do not descend into aggregate exprs */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>find_unaggregated_cols_walker</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>colnos</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * (Re-)initialize the hash table(s) to empty.
 *
 * To implement hashed aggregation, we need a hashtable that stores a
 * representative tuple and an array of AggStatePerGroup structs for each
 * distinct set of GROUP BY column values.  We compute the hash key from the
 * GROUP BY columns.  The per-group data is allocated in lookup_hash_entry(),
 * for each entry.
 *
 * We have a separate hashtable and associated perhash data structure for each
 * grouping set for which we're doing hashing.
 *
 * The contents of the hash tables always live in the hashcontext's per-tuple
 * memory context (there is only one of these for all tables together, since
 * they are all reset at the same time).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>build_hash_table</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>tmpmem</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>tmpcontext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>additionalsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_HASHED</name> <operator>||</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_MIXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>additionalsize</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>numtrans</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AggStatePerGroupData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>num_hashes</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AggStatePerHash</name></type> <name>perhash</name> <init>= <expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>perhash</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>aggnode</name><operator>-&gt;</operator><name>numGroups</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>perhash</name><operator>-&gt;</operator><name>hashtable</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ResetTupleHashTable</name><argument_list>(<argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashtable</name></name> <operator>=</operator> <call><name>BuildTupleHashTableExt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>,
														<argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashslot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>,
														<argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>,
														<argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashGrpColIdxHash</name></name></expr></argument>,
														<argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>eqfuncoids</name></name></expr></argument>,
														<argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashfunctions</name></name></expr></argument>,
														<argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>aggnode</name><operator>-&gt;</operator><name>numGroups</name></name></expr></argument>,
														<argument><expr><name>additionalsize</name></expr></argument>,
														<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>,
														<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>hashcontext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>,
														<argument><expr><name>tmpmem</name></expr></argument>,
														<argument><expr><call><name>DO_AGGSPLIT_SKIPFINAL</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Compute columns that actually need to be stored in hashtable entries.  The
 * incoming tuples from the child plan node will contain grouping columns,
 * other columns referenced in our targetlist and qual, columns used to
 * compute the aggregate functions, and perhaps just junk columns we don't use
 * at all.  Only columns of the first two types need to be stored in the
 * hashtable, and getting rid of the others can make the table entries
 * significantly smaller.  The hashtable only contains the relevant columns,
 * and is packed/unpacked in lookup_hash_entry() / agg_retrieve_hash_table()
 * into the format of the normal input descriptor.
 *
 * Additional columns, in addition to the columns grouped by, come from two
 * sources: Firstly functionally dependent columns that we don't need to group
 * by themselves, and secondly ctids for row-marks.
 *
 * To eliminate duplicates, we build a bitmapset of the needed columns, and
 * then build an array of the columns included in the hashtable.  Note that
 * the array is preserved over ExecReScanAgg, so we allocate it in the
 * per-query context (unlike the hash table itself).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>find_hash_columns</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>base_colnos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>outerTlist</name> <init>= <expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numHashes</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>num_hashes</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

	<comment type="block">/* Find Vars that will be needed in tlist and qual */</comment>
	<expr_stmt><expr><name>base_colnos</name> <operator>=</operator> <call><name>find_unaggregated_cols</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>numHashes</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AggStatePerHash</name></type> <name>perhash</name> <init>= <expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>perhash</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>colnos</name> <init>= <expr><call><name>bms_copy</name><argument_list>(<argument><expr><name>base_colnos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>grpColIdx</name> <init>= <expr><name><name>perhash</name><operator>-&gt;</operator><name>aggnode</name><operator>-&gt;</operator><name>grpColIdx</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>hashTlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>hashDesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>perhash</name><operator>-&gt;</operator><name>largestGrpColIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we're doing grouping sets, then some Vars might be referenced in
		 * tlist/qual for the benefit of other grouping sets, but not needed
		 * when hashing; i.e. prepare_projection_slot will null them out, so
		 * there'd be no point storing them.  Use prepare_projection_slot's
		 * logic to determine which.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>phases</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>grouped_cols</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>grouped_cols</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>phases</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>grouped_cols</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>aggstate-&gt;all_grouped_cols</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>grouped_cols</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>colnos</name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name>colnos</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Add in all the grouping columns */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>perhash</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name>colnos</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>colnos</name></expr></argument>, <argument><expr><name><name>grpColIdx</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

		<expr_stmt><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashGrpColIdxInput</name></name> <operator>=</operator>
			<call><name>palloc</name><argument_list>(<argument><expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name>colnos</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashGrpColIdxHash</name></name> <operator>=</operator>
			<call><name>palloc</name><argument_list>(<argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>numCols</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * First build mapping for columns directly hashed. These are the
		 * first, because they'll be accessed when computing hash values and
		 * comparing tuples for exact matches. We also build simple mapping
		 * for execGrouping, so it knows where to find the to-be-hashed /
		 * compared columns in the input.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>perhash</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashGrpColIdxInput</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>grpColIdx</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashGrpColIdxHash</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>perhash</name><operator>-&gt;</operator><name>numhashGrpCols</name></name><operator>++</operator></expr>;</expr_stmt>
			<comment type="block">/* delete already mapped columns */</comment>
			<expr_stmt><expr><call><name>bms_del_member</name><argument_list>(<argument><expr><name>colnos</name></expr></argument>, <argument><expr><name><name>grpColIdx</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* and add the remaining columns */</comment>
		<while>while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>bms_first_member</name><argument_list>(<argument><expr><name>colnos</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashGrpColIdxInput</name><index>[<expr><name><name>perhash</name><operator>-&gt;</operator><name>numhashGrpCols</name></name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>perhash</name><operator>-&gt;</operator><name>numhashGrpCols</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>

		<comment type="block">/* and build a tuple descriptor for the hashtable */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>perhash</name><operator>-&gt;</operator><name>numhashGrpCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>varNumber</name> <init>= <expr><name><name>perhash</name><operator>-&gt;</operator><name>hashGrpColIdxInput</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>hashTlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>hashTlist</name></expr></argument>, <argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name>outerTlist</name></expr></argument>, <argument><expr><name>varNumber</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>perhash</name><operator>-&gt;</operator><name>largestGrpColIdx</name></name> <operator>=</operator>
				<call><name>Max</name><argument_list>(<argument><expr><name>varNumber</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>largestGrpColIdx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name>hashDesc</name> <operator>=</operator> <call><name>ExecTypeFromTL</name><argument_list>(<argument><expr><name>hashTlist</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>execTuplesHashPrepare</name><argument_list>(<argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>,
							  <argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>aggnode</name><operator>-&gt;</operator><name>grpOperators</name></name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name><name>perhash</name><operator>-&gt;</operator><name>eqfuncoids</name></name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name><name>perhash</name><operator>-&gt;</operator><name>hashfunctions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashslot</name></name> <operator>=</operator>
			<call><name>ExecAllocTableSlot</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>estate</name><operator>-&gt;</operator><name>es_tupleTable</name></name></expr></argument>, <argument><expr><name>hashDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>hashTlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>colnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>base_colnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Estimate per-hash-table-entry overhead for the planner.
 *
 * Note that the estimate does not include space for pass-by-reference
 * transition data values, nor for the representative tuple of each group.
 * Nor does this account of the target fill-factor and growth policy of the
 * hash table.
 */</comment>
<function><type><name>Size</name></type>
<name>hash_agg_entry_size</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numAggs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>entrysize</name></decl>;</decl_stmt>

	<comment type="block">/* This must match build_hash_table */</comment>
	<expr_stmt><expr><name>entrysize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TupleHashEntryData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
		<name>numAggs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AggStatePerGroupData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>entrysize</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>entrysize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>entrysize</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find or create a hashtable entry for the tuple group containing the current
 * tuple (already set in tmpcontext's outertuple slot), in the current grouping
 * set (which the caller must have selected - note that initialize_aggregate
 * depends on this).
 *
 * When called, GetCurrentMemoryContext() should be the per-query context.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleHashEntryData</name> <modifier>*</modifier></type>
<name>lookup_hash_entry</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>inputslot</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>tmpcontext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AggStatePerHash</name></type> <name>perhash</name> <init>= <expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>perhash</name><index>[<expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>hashslot</name> <init>= <expr><name><name>perhash</name><operator>-&gt;</operator><name>hashslot</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleHashEntryData</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnew</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* transfer just the needed columns into hashslot */</comment>
	<expr_stmt><expr><call><name>slot_getsomeattrs</name><argument_list>(<argument><expr><name>inputslot</name></expr></argument>, <argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>largestGrpColIdx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>hashslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>perhash</name><operator>-&gt;</operator><name>numhashGrpCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>varNumber</name> <init>= <expr><name><name>perhash</name><operator>-&gt;</operator><name>hashGrpColIdxInput</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>hashslot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>inputslot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>varNumber</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashslot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>inputslot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>varNumber</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>hashslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* find or create the hashtable entry using the filtered tuple */</comment>
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>LookupTupleHashEntry</name><argument_list>(<argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashtable</name></name></expr></argument>, <argument><expr><name>hashslot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>isnew</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AggStatePerGroup</name></type> <name>pergroup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>transno</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>pergroup</name> <operator>=</operator> <operator>(</operator><name>AggStatePerGroup</name><operator>)</operator>
			<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>tablecxt</name></name></expr></argument>,
							   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AggStatePerGroupData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>numtrans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>additional</name></name> <operator>=</operator> <name>pergroup</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Initialize aggregates for new tuple group, lookup_hash_entries()
		 * already has selected the relevant grouping set.
		 */</comment>
		<for>for <control>(<init><expr><name>transno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>transno</name> <operator>&lt;</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>numtrans</name></name></expr>;</condition> <incr><expr><name>transno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name> <init>= <expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>pertrans</name><index>[<expr><name>transno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name> <init>= <expr><operator>&amp;</operator><name><name>pergroup</name><index>[<expr><name>transno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>initialize_aggregate</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>pertrans</name></expr></argument>, <argument><expr><name>pergroupstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>entry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Look up hash entries for the current tuple in all hashed grouping sets,
 * returning an array of pergroup pointers suitable for advance_aggregates.
 *
 * Be aware that lookup_hash_entry can reset the tmpcontext.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>lookup_hash_entries</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>numHashes</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>num_hashes</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AggStatePerGroup</name> <modifier>*</modifier></type><name>pergroup</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>hash_pergroup</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>setno</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>setno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>setno</name> <operator>&lt;</operator> <name>numHashes</name></expr>;</condition> <incr><expr><name>setno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>select_current_set</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>setno</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pergroup</name><index>[<expr><name>setno</name></expr>]</index></name> <operator>=</operator> <call><name>lookup_hash_entry</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>additional</name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Evaluates whether plan supports pushdowns of aggregates to DocDB, and sets
 * yb_pushdown_supported accordingly in AggState.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>yb_agg_pushdown_supported</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>scan_state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc_agg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc_arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>check_outer_plan</name></decl>;</decl_stmt>

	<comment type="block">/* Initially set pushdown supported to false. */</comment>
	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>yb_pushdown_supported</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Phase 0 is a dummy phase, so there should be two phases. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>numphases</name></name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Plain agg strategy. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>phase</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>!=</operator> <name>AGG_PLAIN</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* No GROUP BY. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>phase</name><operator>-&gt;</operator><name>numsets</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Foreign scan outer plan. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ForeignScanState</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>scan_state</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>ForeignScanState</name></expr></argument>, <argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Foreign relation we are scanning is a YB table. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsYBRelation</name><argument_list>(<argument><expr><name><name>scan_state</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* No WHERE quals. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>scan_state</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>qual</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>check_outer_plan</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc_agg</argument>, <argument>aggstate-&gt;aggs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AggrefExprState</name> <modifier>*</modifier></type><name>aggrefstate</name> <init>= <expr><operator>(</operator><name>AggrefExprState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc_agg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggref</name> <init>= <expr><name><name>aggrefstate</name><operator>-&gt;</operator><name>aggref</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>func_name</name> <init>= <expr><call><name>get_func_name</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Only support COUNT/MIN/MAX/SUM. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>func_name</name></expr></argument>, <argument><expr><literal type="string">"count"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>func_name</name></expr></argument>, <argument><expr><literal type="string">"min"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>func_name</name></expr></argument>, <argument><expr><literal type="string">"max"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>func_name</name></expr></argument>, <argument><expr><literal type="string">"sum"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/* No ORDER BY. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggorder</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/* No DISTINCT. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggdistinct</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/* No FILTER. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfilter</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/* No array arguments. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>aggref</name><operator>-&gt;</operator><name>aggvariadic</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Normal aggregate kind. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>aggref</name><operator>-&gt;</operator><name>aggkind</name></name> <operator>!=</operator> <name>AGGKIND_NORMAL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Does not belong to outer plan. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>aggref</name><operator>-&gt;</operator><name>agglevelsup</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Simple split. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>aggref</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>!=</operator> <name>AGGSPLIT_SIMPLE</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Aggtranstype is a supported YB key type and is not INTERNAL or NUMERIC. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>YbDataTypeIsValidForKey</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggtranstype</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			<name><name>aggref</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>==</operator> <name>INTERNALOID</name> <operator>||</operator>
			<name><name>aggref</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>==</operator> <name>NUMERICOID</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * The builtin functions max and min imply comparison. Character type
		 * comparison requires postgres collation info which is not accessible
		 * by DocDB. Because DocDB only does byte-wise comparison, it will not
		 * be correct for any non-C collations. In order to allow min/max
		 * pushdown for a non-C collation, we need to ensure that the argument
		 * is a key-column with a deterministic non-C collation. In such a
		 * case we store a collation-encoded string by concatenating the
		 * collation sort key with the original text value so that the byte-wise
		 * comparison result is correct.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>func_name</name></expr></argument>, <argument><expr><literal type="string">"min"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>func_name</name></expr></argument>, <argument><expr><literal type="string">"max"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>(</operator><call><name>YBIsCollationValidNonC</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggcollid</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			 <call><name>YBIsCollationValidNonC</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc_arg</argument>, <argument>aggref-&gt;args</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name>lc_arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Only support simple column expressions until DocDB can eval PG exprs. */</comment>
			<decl_stmt><decl><type><name>Oid</name></type> <name>type</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>check_outer_plan</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>vartype</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Const</name><modifier>*</modifier></type> <name>const_node</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>const_node</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
					<comment type="block">/* NULL has a type UNKNOWNOID which isn't very helpful. */</comment>
					<expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>aggref</name><operator>-&gt;</operator><name>aggtranstype</name></name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>const_node</name><operator>-&gt;</operator><name>constbyval</name></name></expr>)</condition><block type="pseudo"><block_content>
					<comment type="block">/* Do not support pointer-based constants yet. */</comment>
					<return>return;</return></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>const_node</name><operator>-&gt;</operator><name>consttype</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<return>return;</return></block_content></block></else></if_stmt>

			<comment type="block">/*
			 * Only support types that are allowed to be YB keys as we cannot guarantee
			 * we can safely perform postgres semantic compatible DocDB aggregate evaluation
			 * otherwise.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>YbDataTypeIsValidForKey</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>check_outer_plan</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Check outer plan to reject case such as:
		 *   create table foo(c0 decimal);
		 *   select sum(r) from (select random() as r from foo) as res;
		 *   select sum(r) from (select (null=random())::int as r from foo) as res;
		 * However check_outer_plan will be false for case such as:
		 *   select sum(1) from (select random() as r from foo) as res;
		 *   select sum(1) from (select (null=random())::int as r from foo) as res;
		 * and pushdown will still be supported.
		 * For simplicity, we do not try to match Var between aggref-&gt;args and outplan
		 * targetlist and simply reject once we see any item that is not a simple column
		 * reference.
		 */</comment>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
		<macro><name>foreach</name><argument_list>(<argument>t</argument>, <argument>outerPlanState(aggstate)-&gt;plan-&gt;targetlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_SPECIAL_VARNO</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>varno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If this is reached, YB pushdown is supported. */</comment>
	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>yb_pushdown_supported</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Populates aggregate pushdown information in the YB foreign scan state.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>yb_agg_pushdown</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>scan_state</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ForeignScanState</name></expr></argument>, <argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>pushdown_aggs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>aggno</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>aggno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>aggno</name> <operator>&lt;</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>numaggs</name></name></expr>;</condition> <incr><expr><name>aggno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggref</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>peragg</name><index>[<expr><name>aggno</name></expr>]</index></name><operator>.</operator><name>aggref</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>pushdown_aggs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>pushdown_aggs</name></expr></argument>, <argument><expr><name>aggref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>scan_state</name><operator>-&gt;</operator><name>yb_fdw_aggs</name></name> <operator>=</operator> <name>pushdown_aggs</name></expr>;</expr_stmt>
	<comment type="block">/* Disable projection for tuples produced by pushed down aggregate operators. */</comment>
	<expr_stmt><expr><name><name>scan_state</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecAgg -
 *
 *	  ExecAgg receives tuples from its outer subplan and aggregates over
 *	  the appropriate attribute for each aggregate function use (Aggref
 *	  node) appearing in the targetlist or qual of the node.  The number
 *	  of tuples to aggregate over depends on whether grouped or plain
 *	  aggregation is selected.  In grouped aggregation, we produce a result
 *	  row for each group; in plain aggregation there's a single result row
 *	  for the whole query.  In either case, the value of each aggregate is
 *	  stored in the expression context to be used when ExecProject evaluates
 *	  the result tuple.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecAgg</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AggState</name>   <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AggState</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>agg_done</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Use default prefetch limit when AGGREGATE is present.
		 * Aggregate functions combine multiple rows into one. The final LIMIT can be different from
		 * the number of rows to be read. As a result, we have to use default prefetch limit.
		 *
		 * Pushdown aggregates to DocDB if the plan state meets proper conditions.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>yb_exec_params</name><operator>.</operator><name>limit_use_default</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Dispatch based on strategy */</comment>
		<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>phase</name><operator>-&gt;</operator><name>aggstrategy</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>AGG_HASHED</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>table_filled</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>agg_fill_hash_table</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<case>case <expr><name>AGG_MIXED</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>agg_retrieve_hash_table</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>AGG_PLAIN</name></expr>:</case>
			<case>case <expr><name>AGG_SORTED</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>agg_retrieve_direct</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecAgg for non-hashed case
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>agg_retrieve_direct</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Agg</name>		   <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>phase</name><operator>-&gt;</operator><name>aggnode</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>tmpcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AggStatePerAgg</name></type> <name>peragg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AggStatePerGroup</name> <modifier>*</modifier></type><name>pergroups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>outerslot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>firstSlot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasGroupingSets</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>phase</name><operator>-&gt;</operator><name>numsets</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numGroupingSets</name> <init>= <expr><call><name>Max</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>phase</name><operator>-&gt;</operator><name>numsets</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>currentSet</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nextSetSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numReset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>aggno</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * get state info from node
	 *
	 * econtext is the per-output-tuple expression context
	 *
	 * tmpcontext is the per-input-tuple expression context
	 */</comment>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmpcontext</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>tmpcontext</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>peragg</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>peragg</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pergroups</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>pergroups</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>firstSlot</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We loop retrieving groups until we find one matching
	 * aggstate-&gt;ss.ps.qual
	 *
	 * For grouping sets, we have the invariant that aggstate-&gt;projected_set
	 * is either -1 (initial call) or the index (starting from 0) in
	 * gset_lengths for the group we just completed (either by projecting a
	 * row or by discarding it in the qual).
	 */</comment>
	<while>while <condition>(<expr><operator>!</operator><name><name>aggstate</name><operator>-&gt;</operator><name>agg_done</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Clear the per-output-tuple context for each group, as well as
		 * aggcontext (which contains any pass-by-ref transvalues of the old
		 * group).  Some aggregate functions store working state in child
		 * contexts; those now get reset automatically without us needing to
		 * do anything special.
		 *
		 * We use ReScanExprContext not just ResetExprContext because we want
		 * any registered shutdown callbacks to be called.  That allows
		 * aggregate functions to ensure they've cleaned up any non-memory
		 * resources.
		 */</comment>
		<expr_stmt><expr><call><name>ReScanExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Determine how many grouping sets need to be reset at this boundary.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>&lt;</operator> <name>numGroupingSets</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>numReset</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>numReset</name> <operator>=</operator> <name>numGroupingSets</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * numReset can change on a phase boundary, but that's OK; we want to
		 * reset the contexts used in _this_ phase, and later, after possibly
		 * changing phase, initialize the right number of aggregates for the
		 * _new_ phase.
		 */</comment>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numReset</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReScanExprContext</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggcontexts</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Check if input is complete and there are no more groups to project
		 * in this phase; move to next phase or mark as done.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>input_done</name></name> <operator>==</operator> <name>true</name> <operator>&amp;&amp;</operator>
			<name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>&gt;=</operator> <operator>(</operator><name>numGroupingSets</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_phase</name></name> <operator>&lt;</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>numphases</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>initialize_phase</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_phase</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>input_done</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>numGroupingSets</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>phase</name><operator>-&gt;</operator><name>numsets</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>phase</name><operator>-&gt;</operator><name>aggnode</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>numReset</name> <operator>=</operator> <name>numGroupingSets</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_MIXED</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Mixed mode; we've output all the grouped stuff and have
				 * full hashtables, so switch to outputting those.
				 */</comment>
				<expr_stmt><expr><call><name>initialize_phase</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>table_filled</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ResetTupleHashIterator</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>perhash</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>hashtable</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>perhash</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>hashiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>select_current_set</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><call><name>agg_retrieve_hash_table</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>agg_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Get the number of columns in the next grouping set after the last
		 * projected one (if any). This is the number of columns to compare to
		 * see if we reached the boundary of that set too.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>&lt;</operator> <operator>(</operator><name>numGroupingSets</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nextSetSize</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>phase</name><operator>-&gt;</operator><name>gset_lengths</name><index>[<expr><name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>nextSetSize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*----------
		 * If a subgroup for the current grouping set is present, project it.
		 *
		 * We have a new group if:
		 *	- we're out of input but haven't projected all grouping sets
		 *	  (checked above)
		 * OR
		 *	  - we already projected a row that wasn't from the last grouping
		 *		set
		 *	  AND
		 *	  - the next grouping set has at least one grouping column (since
		 *		empty grouping sets project only once input is exhausted)
		 *	  AND
		 *	  - the previous and pending rows differ on the grouping columns
		 *		of the next grouping set
		 *----------
		 */</comment>
		<expr_stmt><expr><name><name>tmpcontext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name> <operator>=</operator> <name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>input_done</name></name> <operator>||</operator>
			<operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>!=</operator> <name>AGG_PLAIN</name> <operator>&amp;&amp;</operator>
			 <name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
			 <name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>&lt;</operator> <operator>(</operator><name>numGroupingSets</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator>
			 <name>nextSetSize</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			 <operator>!</operator><call><name>ExecQualAndReset</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>phase</name><operator>-&gt;</operator><name>eqfunctions</name><index>[<expr><name>nextSetSize</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
							   <argument><expr><name>tmpcontext</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>&lt;</operator> <name>numGroupingSets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nextSetSize</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>input_done</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>yb_pushdown_supported</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>currentSet</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>select_current_set</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>currentSet</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Initialize aggregates. */</comment>
			<expr_stmt><expr><call><name>initialize_aggregates</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>pergroups</name></expr></argument>, <argument><expr><name>numReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Aggs were pushed down to YB, so handle returned aggregate results. The slot
			 * contains one value for each aggno, and there is one result per RPC response.
			 * We need to aggregate the results from all responses.
			 *
			 * We special case for COUNT and sum values so it returns the proper count
			 * aggregated across all responses.
			 */</comment>
			<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>outerslot</name> <operator>=</operator> <call><name>fetch_input_tuple</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>outerslot</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>agg_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>numaggs</name></name> <operator>==</operator> <name><name>outerslot</name><operator>-&gt;</operator><name>tts_nvalid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<for>for <control>(<init><expr><name>aggno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>aggno</name> <operator>&lt;</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>numaggs</name></name></expr>;</condition> <incr><expr><name>aggno</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type> <name>transno</name> <init>= <expr><name><name>peragg</name><index>[<expr><name>aggno</name></expr>]</index></name><operator>.</operator><name>transno</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggref</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>peragg</name><index>[<expr><name>aggno</name></expr>]</index></name><operator>.</operator><name>aggref</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>func_name</name> <init>= <expr><call><name>get_func_name</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>AggStatePerGroup</name></type> <name>pergroup</name> <init>= <expr><name><name>pergroups</name><index>[<expr><name>currentSet</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>AggStatePerGroup</name></type> <name>pergroupstate</name> <init>= <expr><operator>&amp;</operator><name><name>pergroup</name><index>[<expr><name>transno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name> <init>= <expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>pertrans</name><index>[<expr><name>transno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name> <init>= <expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transfn_fcinfo</name></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Datum</name></type> <name>value</name> <init>= <expr><name><name>outerslot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>aggno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name> <init>= <expr><name><name>outerslot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>aggno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>func_name</name></expr></argument>, <argument><expr><literal type="string">"count"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * Sum results from each response for COUNT. It is safe to do this
						 * directly on the datum as it is guaranteed to be an int64.
						 */</comment>
						<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(
							<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curaggcontext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>pergroupstate</name><operator>-&gt;</operator><name>transValue</name></name> <operator>+=</operator> <name>value</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* Set slot result as argument, then advance the transition function. */</comment>
						<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>isnull</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>advance_transition_function</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>pertrans</name></expr></argument>, <argument><expr><name>pergroupstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></for>

				<comment type="block">/* Reset per-input-tuple context after each tuple */</comment>
				<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>tmpcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * We no longer care what group we just projected, the next
			 * projection will always be the first (or only) grouping set
			 * (unless the input proves to be empty).
			 */</comment>
			<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<comment type="block">/*
			 * If we don't already have the first tuple of the new group,
			 * fetch it from the outer plan.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>grp_firstTuple</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>outerslot</name> <operator>=</operator> <call><name>fetch_input_tuple</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>outerslot</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Make a copy of the first input tuple; we will use this
					 * for comparisons (in group mode) and for projection.
					 */</comment>
					<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>grp_firstTuple</name></name> <operator>=</operator> <call><name>ExecCopySlotTuple</name><argument_list>(<argument><expr><name>outerslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* outer plan produced no tuples at all */</comment>
					<if_stmt><if>if <condition>(<expr><name>hasGroupingSets</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * If there was no input at all, we need to project
						 * rows only if there are grouping sets of size 0.
						 * Note that this implies that there can't be any
						 * references to ungrouped Vars, which would otherwise
						 * cause issues with the empty output slot.
						 *
						 * XXX: This is no longer true, we currently deal with
						 * this in finalize_aggregates().
						 */</comment>
						<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>input_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

						<while>while <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>phase</name><operator>-&gt;</operator><name>gset_lengths</name><index>[<expr><name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>&gt;=</operator> <name>numGroupingSets</name></expr>)</condition>
							<block>{<block_content>
								<comment type="block">/*
								 * We can't set agg_done here because we might
								 * have more phases to do, even though the
								 * input is empty. So we need to restart the
								 * whole outer loop.
								 */</comment>
								<break>break;</break>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block></while>

						<if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>&gt;=</operator> <name>numGroupingSets</name></expr>)</condition><block type="pseudo"><block_content>
							<continue>continue;</continue></block_content></block></if></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>agg_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<comment type="block">/* If we are grouping, we should produce no tuples too */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>!=</operator> <name>AGG_PLAIN</name></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Initialize working state for a new input tuple group.
			 */</comment>
			<expr_stmt><expr><call><name>initialize_aggregates</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>pergroups</name></expr></argument>, <argument><expr><name>numReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>grp_firstTuple</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Store the copied first input tuple in the tuple table slot
				 * reserved for it.  The tuple will be deleted when it is
				 * cleared from the slot.
				 */</comment>
				<expr_stmt><expr><call><name>ExecStoreHeapTuple</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>grp_firstTuple</name></name></expr></argument>,
								   <argument><expr><name>firstSlot</name></expr></argument>,
								   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>grp_firstTuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* don't keep two pointers */</comment>

				<comment type="block">/* set up for first advance_aggregates call */</comment>
				<expr_stmt><expr><name><name>tmpcontext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>firstSlot</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Process each outer-plan tuple, and then fetch the next one,
				 * until we exhaust the outer plan or cross a group boundary.
				 */</comment>
				<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
				<block>{<block_content>
					<comment type="block">/*
					 * During phase 1 only of a mixed agg, we need to update
					 * hashtables as well in advance_aggregates.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_MIXED</name> <operator>&amp;&amp;</operator>
						<name><name>aggstate</name><operator>-&gt;</operator><name>current_phase</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>lookup_hash_entries</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/* Advance the aggregates (or combine functions) */</comment>
					<expr_stmt><expr><call><name>advance_aggregates</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Reset per-input-tuple context after each tuple */</comment>
					<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>tmpcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>outerslot</name> <operator>=</operator> <call><name>fetch_input_tuple</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>outerslot</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* no more outer-plan tuples available */</comment>
						<if_stmt><if>if <condition>(<expr><name>hasGroupingSets</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>input_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if>
						<else>else
						<block>{<block_content>
							<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>agg_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></else></if_stmt>
					</block_content>}</block></if></if_stmt>
					<comment type="block">/* set up for next advance_aggregates call */</comment>
					<expr_stmt><expr><name><name>tmpcontext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>outerslot</name></expr>;</expr_stmt>

					<comment type="block">/*
					 * If we are grouping, check whether we've crossed a group
					 * boundary.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>!=</operator> <name>AGG_PLAIN</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>tmpcontext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name> <operator>=</operator> <name>firstSlot</name></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecQual</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>phase</name><operator>-&gt;</operator><name>eqfunctions</name><index>[<expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
									  <argument><expr><name>tmpcontext</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>grp_firstTuple</name></name> <operator>=</operator> <call><name>ExecCopySlotTuple</name><argument_list>(<argument><expr><name>outerslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Use the representative input tuple for any references to
			 * non-aggregated input columns in aggregate direct args, the node
			 * qual, and the tlist.  (If we are not grouping, and there are no
			 * input rows at all, we will come here with an empty firstSlot
			 * ... but if not grouping, there can't be any references to
			 * non-aggregated input columns, so no problem.)
			 */</comment>
			<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>firstSlot</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>currentSet</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>prepare_projection_slot</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name></expr></argument>, <argument><expr><name>currentSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>select_current_set</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>currentSet</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>finalize_aggregates</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>,
							<argument><expr><name>peragg</name></expr></argument>,
							<argument><expr><name><name>pergroups</name><index>[<expr><name>currentSet</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If there's no row to project right now, we must continue rather
		 * than returning a null since there might be more groups.
		 */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>project_aggregates</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* No more groups */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecAgg for hashed case: read input and build hash table
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>agg_fill_hash_table</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>outerslot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>tmpcontext</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>tmpcontext</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Process each outer-plan tuple, and then fetch the next one, until we
	 * exhaust the outer plan.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>outerslot</name> <operator>=</operator> <call><name>fetch_input_tuple</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>outerslot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* set up for lookup_hash_entries and advance_aggregates */</comment>
		<expr_stmt><expr><name><name>tmpcontext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>outerslot</name></expr>;</expr_stmt>

		<comment type="block">/* Find or build hashtable entries */</comment>
		<expr_stmt><expr><call><name>lookup_hash_entries</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Advance the aggregates (or combine functions) */</comment>
		<expr_stmt><expr><call><name>advance_aggregates</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Reset per-input-tuple context after each tuple, but note that the
		 * hash lookups do this too
		 */</comment>
		<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>tmpcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>table_filled</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<comment type="block">/* Initialize to walk the first hash table */</comment>
	<expr_stmt><expr><call><name>select_current_set</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ResetTupleHashIterator</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>perhash</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>hashtable</name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>perhash</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>hashiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecAgg for hashed case: retrieving groups from hash table
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>agg_retrieve_hash_table</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AggStatePerAgg</name></type> <name>peragg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AggStatePerGroup</name></type> <name>pergroup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleHashEntryData</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>firstSlot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AggStatePerHash</name></type> <name>perhash</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * get state info from node.
	 *
	 * econtext is the per-output-tuple expression context.
	 */</comment>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>peragg</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>peragg</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>firstSlot</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note that perhash (and therefore anything accessed through it) can
	 * change inside the loop, as we change between grouping sets.
	 */</comment>
	<expr_stmt><expr><name>perhash</name> <operator>=</operator> <operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>perhash</name><index>[<expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We loop retrieving groups until we find one satisfying
	 * aggstate-&gt;ss.ps.qual
	 */</comment>
	<while>while <condition>(<expr><operator>!</operator><name><name>aggstate</name><operator>-&gt;</operator><name>agg_done</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>hashslot</name> <init>= <expr><name><name>perhash</name><operator>-&gt;</operator><name>hashslot</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Find the next entry in the hash table
		 */</comment>
		<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>ScanTupleHashTable</name><argument_list>(<argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashtable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>perhash</name><operator>-&gt;</operator><name>hashiter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>nextset</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>nextset</name> <operator>&lt;</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>num_hashes</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Switch to next grouping set, reinitialize, and restart the
				 * loop.
				 */</comment>
				<expr_stmt><expr><call><name>select_current_set</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>nextset</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>perhash</name> <operator>=</operator> <operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>perhash</name><index>[<expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name></expr>]</index></name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ResetTupleHashIterator</name><argument_list>(<argument><expr><name><name>perhash</name><operator>-&gt;</operator><name>hashtable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>perhash</name><operator>-&gt;</operator><name>hashiter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<continue>continue;</continue>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* No more hashtables, so done */</comment>
				<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>agg_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Clear the per-output-tuple context for each group
		 *
		 * We intentionally don't use ReScanExprContext here; if any aggs have
		 * registered shutdown callbacks, they mustn't be called yet, since we
		 * might not be done with that agg.
		 */</comment>
		<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Transform representative tuple back into one with the right
		 * columns.
		 */</comment>
		<expr_stmt><expr><call><name>ExecStoreMinimalTuple</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>firstTuple</name></name></expr></argument>, <argument><expr><name>hashslot</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>hashslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>firstSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>firstSlot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
			   <argument><expr><name><name>firstSlot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>perhash</name><operator>-&gt;</operator><name>numhashGrpCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>varNumber</name> <init>= <expr><name><name>perhash</name><operator>-&gt;</operator><name>hashGrpColIdxInput</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>firstSlot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>varNumber</name></expr>]</index></name> <operator>=</operator> <name><name>hashslot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>firstSlot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>varNumber</name></expr>]</index></name> <operator>=</operator> <name><name>hashslot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>firstSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>pergroup</name> <operator>=</operator> <operator>(</operator><name>AggStatePerGroup</name><operator>)</operator> <name><name>entry</name><operator>-&gt;</operator><name>additional</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Use the representative input tuple for any references to
		 * non-aggregated input columns in the qual and tlist.
		 */</comment>
		<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>firstSlot</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>prepare_projection_slot</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>,
								<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name></expr></argument>,
								<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>finalize_aggregates</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>peragg</name></expr></argument>, <argument><expr><name>pergroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>project_aggregates</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* No more groups */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -----------------
 * ExecInitAgg
 *
 *	Creates the run-time information for the agg node produced by the
 *	planner and initializes its outer subtree.
 *
 * -----------------
 */</comment>
<function><type><name>AggState</name> <modifier>*</modifier></type>
<name>ExecInitAgg</name><parameter_list>(<parameter><decl><type><name>Agg</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AggState</name>   <modifier>*</modifier></type><name>aggstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AggStatePerAgg</name></type> <name>peraggs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>pertransstates</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AggStatePerGroup</name> <modifier>*</modifier></type><name>pergroups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>outerPlan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>scanDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numaggs</name></decl>,
				<decl><type ref="prev"/><name>transno</name></decl>,
				<decl><type ref="prev"/><name>aggno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>phase</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>phaseidx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>all_grouped_cols</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numGroupingSets</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numPhases</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numHashes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>use_hashing</name> <init>= <expr><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_HASHED</name> <operator>||</operator>
							   <name><name>node</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_MIXED</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<comment type="block">/* check for unsupported flags */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <operator>(</operator><name>EXEC_FLAG_BACKWARD</name> <operator>|</operator> <name>EXEC_FLAG_MARK</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * create state structure
	 */</comment>
	<expr_stmt><expr><name>aggstate</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AggState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ExecProcNode</name></name> <operator>=</operator> <name>ExecAgg</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>numaggs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>numtrans</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>aggstrategy</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>aggsplit</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>maxsets</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>peragg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>pertrans</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curperagg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curpertrans</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>input_done</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>agg_done</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>pergroups</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>grp_firstTuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>sort_in</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>sort_out</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * phases[0] always exists, but is dummy in sorted/plain mode
	 */</comment>
	<expr_stmt><expr><name>numPhases</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>use_hashing</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>numHashes</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>use_hashing</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Calculate the maximum number of grouping sets in any phase; this
	 * determines the size of some allocations.  Also calculate the number of
	 * phases, since all hashed/mixed nodes contribute to only a single phase.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>numGroupingSets</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>groupingSets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>node-&gt;chain</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Agg</name>		   <modifier>*</modifier></type><name>agg</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>numGroupingSets</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>numGroupingSets</name></expr></argument>,
								  <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>groupingSets</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * additional AGG_HASHED aggs become part of phase 0, but all
			 * others add an extra phase.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>!=</operator> <name>AGG_HASHED</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>++</operator><name>numPhases</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><operator>++</operator><name>numHashes</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>maxsets</name></name> <operator>=</operator> <name>numGroupingSets</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>numphases</name></name> <operator>=</operator> <name>numPhases</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggcontexts</name></name> <operator>=</operator> <operator>(</operator><name>ExprContext</name> <operator>*</operator><operator>*</operator><operator>)</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExprContext</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numGroupingSets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create expression contexts.  We need three or more, one for
	 * per-input-tuple processing, one for per-output-tuple processing, one
	 * for all the hashtables, and one for each grouping set.  The per-tuple
	 * memory context of the per-grouping-set ExprContexts (aggcontexts)
	 * replaces the standalone memory context formerly used to hold transition
	 * values.  We cheat a little by using ExecAssignExprContext() to build
	 * all of them.
	 *
	 * NOTE: the details of what is stored in aggcontexts and what is stored
	 * in the regular per-query memory context are driven by a simple
	 * decision: we want to reset the aggcontext at group boundaries (if not
	 * hashing) and in ExecReScanAgg to recover no-longer-wanted space.
	 */</comment>
	<expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>tmpcontext</name></name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numGroupingSets</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggcontexts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>use_hashing</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>hashcontext</name></name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize child nodes.
	 *
	 * If we are doing a hashed aggregation then the child plan does not need
	 * to handle REWIND efficiently; see ExecReScanAgg.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_HASHED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>eflags</name> <operator>&amp;=</operator> <operator>~</operator><name>EXEC_FLAG_REWIND</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>outerPlan</name> <operator>=</operator> <call><name>outerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><name>outerPlan</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * initialize source tuple type.
	 */</comment>
	<expr_stmt><expr><call><name>ExecCreateScanSlotFromOuterPlan</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scanDesc</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>chain</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>sort_slot</name></name> <operator>=</operator> <call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>scanDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Initialize result type, slot and projection.
	 */</comment>
	<expr_stmt><expr><call><name>ExecInitResultTupleSlotTL</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecAssignProjectionInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * initialize child expressions
	 *
	 * We expect the parser to have checked that no aggs contain other agg
	 * calls in their arguments (and just to be sure, we verify it again while
	 * initializing the plan node).  This would make no sense under SQL
	 * semantics, and it's forbidden by the spec.  Because it is true, we
	 * don't need to worry about evaluating the aggs in any particular order.
	 *
	 * Note: execExpr.c finds Aggrefs for us, and adds their AggrefExprState
	 * nodes to aggstate-&gt;aggs.  Aggrefs in the qual are found here; Aggrefs
	 * in the targetlist are found during ExecAssignProjectionInfo, below.
	 */</comment>
	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>qual</name></name> <operator>=</operator>
		<call><name>ExecInitQual</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>aggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We should now have found all Aggrefs in the targetlist and quals.
	 */</comment>
	<expr_stmt><expr><name>numaggs</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>numaggs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numaggs</name> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggs</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For each phase, prepare grouping set data and fmgr lookup data for
	 * compare functions.  Accumulate all_grouped_cols in passing.
	 */</comment>
	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>phases</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>numPhases</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AggStatePerPhaseData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>num_hashes</name></name> <operator>=</operator> <name>numHashes</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>numHashes</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>perhash</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AggStatePerHashData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numHashes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>phases</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>numsets</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>phases</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>gset_lengths</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numHashes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>phases</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>grouped_cols</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numHashes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Bitmapset</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>phase</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>phaseidx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>phaseidx</name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>phaseidx</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Agg</name>		   <modifier>*</modifier></type><name>aggnode</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Sort</name>	   <modifier>*</modifier></type><name>sortnode</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>phaseidx</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>aggnode</name> <operator>=</operator> <call><name>list_nth_node</name><argument_list>(<argument><expr><name>Agg</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>, <argument><expr><name>phaseidx</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sortnode</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Sort</name></expr></argument>, <argument><expr><name><name>aggnode</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>lefttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>aggnode</name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>sortnode</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>phase</name> <operator>&lt;=</operator> <literal type="number">1</literal> <operator>||</operator> <name>sortnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>aggnode</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_HASHED</name>
			<operator>||</operator> <name><name>aggnode</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_MIXED</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AggStatePerPhase</name></type> <name>phasedata</name> <init>= <expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>phases</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AggStatePerHash</name></type> <name>perhash</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>cols</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>phase</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>phasedata</name><operator>-&gt;</operator><name>numsets</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>perhash</name> <operator>=</operator> <operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>perhash</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

			<comment type="block">/* phase 0 always points to the "real" Agg in the hash case */</comment>
			<expr_stmt><expr><name><name>phasedata</name><operator>-&gt;</operator><name>aggnode</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>phasedata</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>aggstrategy</name></name></expr>;</expr_stmt>

			<comment type="block">/* but the actual Agg node representing this hash is saved here */</comment>
			<expr_stmt><expr><name><name>perhash</name><operator>-&gt;</operator><name>aggnode</name></name> <operator>=</operator> <name>aggnode</name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>phasedata</name><operator>-&gt;</operator><name>gset_lengths</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>perhash</name><operator>-&gt;</operator><name>numCols</name></name> <operator>=</operator> <name><name>aggnode</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>aggnode</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name>cols</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>cols</name></expr></argument>, <argument><expr><name><name>aggnode</name><operator>-&gt;</operator><name>grpColIdx</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

			<expr_stmt><expr><name><name>phasedata</name><operator>-&gt;</operator><name>grouped_cols</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>cols</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>all_grouped_cols</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>all_grouped_cols</name></expr></argument>, <argument><expr><name>cols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>AggStatePerPhase</name></type> <name>phasedata</name> <init>= <expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>phases</name><index>[<expr><operator>++</operator><name>phase</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>num_sets</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>phasedata</name><operator>-&gt;</operator><name>numsets</name></name> <operator>=</operator> <name>num_sets</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>aggnode</name><operator>-&gt;</operator><name>groupingSets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>num_sets</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>phasedata</name><operator>-&gt;</operator><name>gset_lengths</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_sets</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>phasedata</name><operator>-&gt;</operator><name>grouped_cols</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_sets</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Bitmapset</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>aggnode-&gt;groupingSets</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>current_length</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>cols</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

					<comment type="block">/* planner forces this to be correct */</comment>
					<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>current_length</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>
						<expr_stmt><expr><name>cols</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>cols</name></expr></argument>, <argument><expr><name><name>aggnode</name><operator>-&gt;</operator><name>grpColIdx</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

					<expr_stmt><expr><name><name>phasedata</name><operator>-&gt;</operator><name>grouped_cols</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>cols</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>phasedata</name><operator>-&gt;</operator><name>gset_lengths</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>current_length</name></expr>;</expr_stmt>

					<expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt>
				</block_content>}</block>

				<expr_stmt><expr><name>all_grouped_cols</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>all_grouped_cols</name></expr></argument>,
												   <argument><expr><name><name>phasedata</name><operator>-&gt;</operator><name>grouped_cols</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>phaseidx</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>phasedata</name><operator>-&gt;</operator><name>gset_lengths</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>phasedata</name><operator>-&gt;</operator><name>grouped_cols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * If we are grouping, precompute fmgr lookup data for inner loop.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>aggnode</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_SORTED</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aggnode</name><operator>-&gt;</operator><name>numCols</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Build a separate function for each subset of columns that
				 * need to be compared.
				 */</comment>
				<expr_stmt><expr><name><name>phasedata</name><operator>-&gt;</operator><name>eqfunctions</name></name> <operator>=</operator>
					<operator>(</operator><name>ExprState</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>aggnode</name><operator>-&gt;</operator><name>numCols</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ExprState</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* for each grouping set */</comment>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>phasedata</name><operator>-&gt;</operator><name>numsets</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>length</name> <init>= <expr><name><name>phasedata</name><operator>-&gt;</operator><name>gset_lengths</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>phasedata</name><operator>-&gt;</operator><name>eqfunctions</name><index>[<expr><name>length</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<expr_stmt><expr><name><name>phasedata</name><operator>-&gt;</operator><name>eqfunctions</name><index>[<expr><name>length</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
						<call><name>execTuplesMatchPrepare</name><argument_list>(<argument><expr><name>scanDesc</name></expr></argument>,
											   <argument><expr><name>length</name></expr></argument>,
											   <argument><expr><name><name>aggnode</name><operator>-&gt;</operator><name>grpColIdx</name></name></expr></argument>,
											   <argument><expr><name><name>aggnode</name><operator>-&gt;</operator><name>grpOperators</name></name></expr></argument>,
											   <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>aggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></for>

				<comment type="block">/* and for all grouped columns, unless already computed */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>phasedata</name><operator>-&gt;</operator><name>eqfunctions</name><index>[<expr><name><name>aggnode</name><operator>-&gt;</operator><name>numCols</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>phasedata</name><operator>-&gt;</operator><name>eqfunctions</name><index>[<expr><name><name>aggnode</name><operator>-&gt;</operator><name>numCols</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
						<call><name>execTuplesMatchPrepare</name><argument_list>(<argument><expr><name>scanDesc</name></expr></argument>,
											   <argument><expr><name><name>aggnode</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>,
											   <argument><expr><name><name>aggnode</name><operator>-&gt;</operator><name>grpColIdx</name></name></expr></argument>,
											   <argument><expr><name><name>aggnode</name><operator>-&gt;</operator><name>grpOperators</name></name></expr></argument>,
											   <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>aggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>phasedata</name><operator>-&gt;</operator><name>aggnode</name></name> <operator>=</operator> <name>aggnode</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>phasedata</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>=</operator> <name><name>aggnode</name><operator>-&gt;</operator><name>aggstrategy</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>phasedata</name><operator>-&gt;</operator><name>sortnode</name></name> <operator>=</operator> <name>sortnode</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Convert all_grouped_cols to a descending-order list.
	 */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>all_grouped_cols</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>all_grouped_cols</name></name> <operator>=</operator> <call><name>lcons_int</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>all_grouped_cols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/*
	 * Set up aggregate-result storage in the output expr context, and also
	 * allocate my private per-agg working storage
	 */</comment>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_aggvalues</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numaggs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_aggnulls</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numaggs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>peraggs</name> <operator>=</operator> <operator>(</operator><name>AggStatePerAgg</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AggStatePerAggData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numaggs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pertransstates</name> <operator>=</operator> <operator>(</operator><name>AggStatePerTrans</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AggStatePerTransData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numaggs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>peragg</name></name> <operator>=</operator> <name>peraggs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>pertrans</name></name> <operator>=</operator> <name>pertransstates</name></expr>;</expr_stmt>


	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>all_pergroups</name></name> <operator>=</operator>
		<operator>(</operator><name>AggStatePerGroup</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AggStatePerGroup</name></expr></argument>)</argument_list></sizeof>
									 <operator>*</operator> <operator>(</operator><name>numGroupingSets</name> <operator>+</operator> <name>numHashes</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pergroups</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>all_pergroups</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>!=</operator> <name>AGG_HASHED</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numGroupingSets</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>pergroups</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>AggStatePerGroup</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AggStatePerGroupData</name></expr></argument>)</argument_list></sizeof>
													  <operator>*</operator> <name>numaggs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>pergroups</name></name> <operator>=</operator> <name>pergroups</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pergroups</name> <operator>+=</operator> <name>numGroupingSets</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Hashing can only appear in the initial phase.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>use_hashing</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* this is an array of pointers, not structures */</comment>
		<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>hash_pergroup</name></name> <operator>=</operator> <name>pergroups</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>find_hash_columns</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Skip massive memory allocation if we are just doing EXPLAIN */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>build_hash_table</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>table_filled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Initialize current phase-dependent values to initial phase. The initial
	 * phase is 1 (first sort pass) for all strategies that use sorting (if
	 * hashing is being done too, then phase 0 is processed last); but if only
	 * hashing is being done, then phase 0 is all there is.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_HASHED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_phase</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>initialize_phase</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>select_current_set</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_phase</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>initialize_phase</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>select_current_set</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Internally set whether plan supports YB agg pushdown. */</comment>
	<expr_stmt><expr><call><name>yb_agg_pushdown_supported</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* -----------------
	 * Perform lookups of aggregate function info, and initialize the
	 * unchanging fields of the per-agg and per-trans data.
	 *
	 * We try to optimize by detecting duplicate aggregate functions so that
	 * their state and final values are re-used, rather than needlessly being
	 * re-calculated independently. We also detect aggregates that are not
	 * the same, but which can share the same transition state.
	 *
	 * Scenarios:
	 *
	 * 1. Identical aggregate function calls appear in the query:
	 *
	 *	  SELECT SUM(x) FROM ... HAVING SUM(x) &gt; 0
	 *
	 *	  Since these aggregates are identical, we only need to calculate
	 *	  the value once. Both aggregates will share the same 'aggno' value.
	 *
	 * 2. Two different aggregate functions appear in the query, but the
	 *	  aggregates have the same arguments, transition functions and
	 *	  initial values (and, presumably, different final functions):
	 *
	 *	  SELECT AVG(x), STDDEV(x) FROM ...
	 *
	 *	  In this case we must create a new peragg for the varying aggregate,
	 *	  and we need to call the final functions separately, but we need
	 *	  only run the transition function once.  (This requires that the
	 *	  final functions be nondestructive of the transition state, but
	 *	  that's required anyway for other reasons.)
	 *
	 * For either of these optimizations to be valid, all aggregate properties
	 * used in the transition phase must be the same, including any modifiers
	 * such as ORDER BY, DISTINCT and FILTER, and the arguments mustn't
	 * contain any volatile functions.
	 * -----------------
	 */</comment>
	<expr_stmt><expr><name>aggno</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>transno</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>aggstate-&gt;aggs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AggrefExprState</name> <modifier>*</modifier></type><name>aggrefstate</name> <init>= <expr><operator>(</operator><name>AggrefExprState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>aggref</name> <init>= <expr><name><name>aggrefstate</name><operator>-&gt;</operator><name>aggref</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AggStatePerAgg</name></type> <name>peragg</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>existing_aggno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>existing_transno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>same_input_transnos</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name><name>inputTypes</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>numArguments</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>numDirectArgs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>aggTuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_aggregate</name></type> <name>aggform</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>transfn_oid</name></decl>,
					<decl><type ref="prev"/><name>finalfn_oid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>shareable</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>serialfn_oid</name></decl>,
					<decl><type ref="prev"/><name>deserialfn_oid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>finalfnexpr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>aggtranstype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>textInitVal</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>initValue</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>initValueIsNull</name></decl>;</decl_stmt>

		<comment type="block">/* Planner should have assigned aggregate to correct level */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>agglevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* ... and the split mode should match */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>==</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* 1. Check for already processed aggs which can be re-used */</comment>
		<expr_stmt><expr><name>existing_aggno</name> <operator>=</operator> <call><name>find_compatible_peragg</name><argument_list>(<argument><expr><name>aggref</name></expr></argument>, <argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>aggno</name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>same_input_transnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>existing_aggno</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Existing compatible agg found. so just point the Aggref to the
			 * same per-agg struct.
			 */</comment>
			<expr_stmt><expr><name><name>aggrefstate</name><operator>-&gt;</operator><name>aggno</name></name> <operator>=</operator> <name>existing_aggno</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Mark Aggref state node with assigned index in the result array */</comment>
		<expr_stmt><expr><name>peragg</name> <operator>=</operator> <operator>&amp;</operator><name><name>peraggs</name><index>[<expr><operator>++</operator><name>aggno</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>peragg</name><operator>-&gt;</operator><name>aggref</name></name> <operator>=</operator> <name>aggref</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aggrefstate</name><operator>-&gt;</operator><name>aggno</name></name> <operator>=</operator> <name>aggno</name></expr>;</expr_stmt>

		<comment type="block">/* Fetch the pg_aggregate row */</comment>
		<expr_stmt><expr><name>aggTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AGGFNOID</name></expr></argument>,
								   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>aggTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for aggregate %u"</literal></expr></argument>,
				 <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>aggform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_aggregate</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>aggTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Check permission to call aggregate function */</comment>
		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_proc_aclcheck</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
									 <argument><expr><name>ACL_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_AGGREGATE</name></expr></argument>,
						   <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>InvokeFunctionExecuteHook</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* planner recorded transition state type in the Aggref itself */</comment>
		<expr_stmt><expr><name>aggtranstype</name> <operator>=</operator> <name><name>aggref</name><operator>-&gt;</operator><name>aggtranstype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>aggtranstype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If this aggregation is performing state combines, then instead of
		 * using the transition function, we'll use the combine function
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>DO_AGGSPLIT_COMBINE</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>transfn_oid</name> <operator>=</operator> <name><name>aggform</name><operator>-&gt;</operator><name>aggcombinefn</name></name></expr>;</expr_stmt>

			<comment type="block">/* If not set then the planner messed up */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>transfn_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"combinefn not set for aggregate function"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>transfn_oid</name> <operator>=</operator> <name><name>aggform</name><operator>-&gt;</operator><name>aggtransfn</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Final function only required if we're finalizing the aggregates */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>DO_AGGSPLIT_SKIPFINAL</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>peragg</name><operator>-&gt;</operator><name>finalfn_oid</name></name> <operator>=</operator> <name>finalfn_oid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>peragg</name><operator>-&gt;</operator><name>finalfn_oid</name></name> <operator>=</operator> <name>finalfn_oid</name> <operator>=</operator> <name><name>aggform</name><operator>-&gt;</operator><name>aggfinalfn</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * If finalfn is marked read-write, we can't share transition states;
		 * but it is okay to share states for AGGMODIFY_SHAREABLE aggs.  Also,
		 * if we're not executing the finalfn here, we can share regardless.
		 */</comment>
		<expr_stmt><expr><name>shareable</name> <operator>=</operator> <operator>(</operator><name><name>aggform</name><operator>-&gt;</operator><name>aggfinalmodify</name></name> <operator>!=</operator> <name>AGGMODIFY_READ_WRITE</name><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name>finalfn_oid</name> <operator>==</operator> <name>InvalidOid</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>peragg</name><operator>-&gt;</operator><name>shareable</name></name> <operator>=</operator> <name>shareable</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>serialfn_oid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>deserialfn_oid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check if serialization/deserialization is required.  We only do it
		 * for aggregates that have transtype INTERNAL.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>aggtranstype</name> <operator>==</operator> <name>INTERNALOID</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The planner should only have generated a serialize agg node if
			 * every aggregate with an INTERNAL state has a serialization
			 * function.  Verify that.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>DO_AGGSPLIT_SERIALIZE</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* serialization only valid when not running finalfn */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>DO_AGGSPLIT_SKIPFINAL</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>aggform</name><operator>-&gt;</operator><name>aggserialfn</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"serialfunc not provided for serialization aggregation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>serialfn_oid</name> <operator>=</operator> <name><name>aggform</name><operator>-&gt;</operator><name>aggserialfn</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Likewise for deserialization functions */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>DO_AGGSPLIT_DESERIALIZE</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* deserialization only valid when combining states */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>DO_AGGSPLIT_COMBINE</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>aggform</name><operator>-&gt;</operator><name>aggdeserialfn</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"deserialfunc not provided for deserialization aggregation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>deserialfn_oid</name> <operator>=</operator> <name><name>aggform</name><operator>-&gt;</operator><name>aggdeserialfn</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Check that aggregate owner has permission to call component fns */</comment>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>procTuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>aggOwner</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>procTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>,
										<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>procTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>,
					 <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>aggOwner</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>procTuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>proowner</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>procTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_proc_aclcheck</name><argument_list>(<argument><expr><name>transfn_oid</name></expr></argument>, <argument><expr><name>aggOwner</name></expr></argument>,
										 <argument><expr><name>ACL_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_FUNCTION</name></expr></argument>,
							   <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>transfn_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>InvokeFunctionExecuteHook</name><argument_list>(<argument><expr><name>transfn_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>finalfn_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_proc_aclcheck</name><argument_list>(<argument><expr><name>finalfn_oid</name></expr></argument>, <argument><expr><name>aggOwner</name></expr></argument>,
											 <argument><expr><name>ACL_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_FUNCTION</name></expr></argument>,
								   <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>finalfn_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>InvokeFunctionExecuteHook</name><argument_list>(<argument><expr><name>finalfn_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>serialfn_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_proc_aclcheck</name><argument_list>(<argument><expr><name>serialfn_oid</name></expr></argument>, <argument><expr><name>aggOwner</name></expr></argument>,
											 <argument><expr><name>ACL_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_FUNCTION</name></expr></argument>,
								   <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>serialfn_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>InvokeFunctionExecuteHook</name><argument_list>(<argument><expr><name>serialfn_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>deserialfn_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_proc_aclcheck</name><argument_list>(<argument><expr><name>deserialfn_oid</name></expr></argument>, <argument><expr><name>aggOwner</name></expr></argument>,
											 <argument><expr><name>ACL_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_FUNCTION</name></expr></argument>,
								   <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>deserialfn_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>InvokeFunctionExecuteHook</name><argument_list>(<argument><expr><name>deserialfn_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Get actual datatypes of the (nominal) aggregate inputs.  These
		 * could be different from the agg's declared input types, when the
		 * agg accepts ANY or a polymorphic type.
		 */</comment>
		<expr_stmt><expr><name>numArguments</name> <operator>=</operator> <call><name>get_aggregate_argtypes</name><argument_list>(<argument><expr><name>aggref</name></expr></argument>, <argument><expr><name>inputTypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we support YB agg pushdown we set transition function input types
		 * to be the same as the transition value that will be the type returned by
		 * the DocDB aggregate result which we combine using the appropriate transition
		 * function. Aggstar (e.g. COUNT(*)) do not have arguments so we skip them.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>yb_pushdown_supported</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>aggref</name><operator>-&gt;</operator><name>aggstar</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* We currently only support single argument aggregates for YB pushdown. */</comment>
			<expr_stmt><expr><name>numArguments</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggargtypes</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>numArguments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>inputTypes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>aggref</name><operator>-&gt;</operator><name>aggtranstype</name></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Convert SUM function to 8-byte SUM for appropriate types to match values
			 * returned from DocDB aggregates.
			 *
			 * Note that we don't need to perform this for floats as they use accumulators
			 * of the same precision as the input. Also, we don't support pushdown of 8-byte
			 * integer SUM as PG uses a numeric type to avoid overflow which we don't yet fully
			 * support in DocDB, so we don't need to handle that here either.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"sum"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<switch>switch <condition>(<expr><call><name>linitial_oid</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggargtypes</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>INT2OID</name></expr>:</case>
					<case>case <expr><name>INT4OID</name></expr>:</case>
						<expr_stmt><expr><name>transfn_oid</name> <operator>=</operator> <name>F_INT8PL</name></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Count the "direct" arguments, if any */</comment>
		<expr_stmt><expr><name>numDirectArgs</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggdirectargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Detect how many arguments to pass to the finalfn */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>aggform</name><operator>-&gt;</operator><name>aggfinalextra</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>peragg</name><operator>-&gt;</operator><name>numFinalArgs</name></name> <operator>=</operator> <name>numArguments</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>peragg</name><operator>-&gt;</operator><name>numFinalArgs</name></name> <operator>=</operator> <name>numDirectArgs</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Initialize any direct-argument expressions */</comment>
		<expr_stmt><expr><name><name>peragg</name><operator>-&gt;</operator><name>aggdirectargs</name></name> <operator>=</operator> <call><name>ExecInitExprList</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggdirectargs</name></name></expr></argument>,
												 <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>aggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * build expression trees using actual argument &amp; result types for the
		 * finalfn, if it exists and is required.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>finalfn_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>build_aggregate_finalfn_expr</name><argument_list>(<argument><expr><name>inputTypes</name></expr></argument>,
										 <argument><expr><name><name>peragg</name><operator>-&gt;</operator><name>numFinalArgs</name></name></expr></argument>,
										 <argument><expr><name>aggtranstype</name></expr></argument>,
										 <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggtype</name></name></expr></argument>,
										 <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>,
										 <argument><expr><name>finalfn_oid</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>finalfnexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>finalfn_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>peragg</name><operator>-&gt;</operator><name>finalfn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fmgr_info_set_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>finalfnexpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>peragg</name><operator>-&gt;</operator><name>finalfn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* get info about the output value's datatype */</comment>
		<expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggtype</name></name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name><name>peragg</name><operator>-&gt;</operator><name>resulttypeLen</name></name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name><name>peragg</name><operator>-&gt;</operator><name>resulttypeByVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * initval is potentially null, so don't try to access it as a struct
		 * field. Must do it the hard way with SysCacheGetAttr.
		 */</comment>
		<expr_stmt><expr><name>textInitVal</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>AGGFNOID</name></expr></argument>, <argument><expr><name>aggTuple</name></expr></argument>,
									  <argument><expr><name>Anum_pg_aggregate_agginitval</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>initValueIsNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>initValueIsNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>initValue</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>initValue</name> <operator>=</operator> <call><name>GetAggInitVal</name><argument_list>(<argument><expr><name>textInitVal</name></expr></argument>, <argument><expr><name>aggtranstype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * 2. Build working state for invoking the transition function, or
		 * look up previously initialized working state, if we can share it.
		 *
		 * find_compatible_peragg() already collected a list of shareable
		 * per-Trans's with the same inputs. Check if any of them have the
		 * same transition function and initial value.
		 */</comment>
		<expr_stmt><expr><name>existing_transno</name> <operator>=</operator> <call><name>find_compatible_pertrans</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>aggref</name></expr></argument>,
													<argument><expr><name>shareable</name></expr></argument>,
													<argument><expr><name>transfn_oid</name></expr></argument>, <argument><expr><name>aggtranstype</name></expr></argument>,
													<argument><expr><name>serialfn_oid</name></expr></argument>, <argument><expr><name>deserialfn_oid</name></expr></argument>,
													<argument><expr><name>initValue</name></expr></argument>, <argument><expr><name>initValueIsNull</name></expr></argument>,
													<argument><expr><name>same_input_transnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>existing_transno</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Existing compatible trans found, so just point the 'peragg' to
			 * the same per-trans struct, and mark the trans state as shared.
			 */</comment>
			<expr_stmt><expr><name>pertrans</name> <operator>=</operator> <operator>&amp;</operator><name><name>pertransstates</name><index>[<expr><name>existing_transno</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>aggshared</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>peragg</name><operator>-&gt;</operator><name>transno</name></name> <operator>=</operator> <name>existing_transno</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>pertrans</name> <operator>=</operator> <operator>&amp;</operator><name><name>pertransstates</name><index>[<expr><operator>++</operator><name>transno</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>build_pertrans_for_aggref</name><argument_list>(<argument><expr><name>pertrans</name></expr></argument>, <argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>,
									  <argument><expr><name>aggref</name></expr></argument>, <argument><expr><name>transfn_oid</name></expr></argument>, <argument><expr><name>aggtranstype</name></expr></argument>,
									  <argument><expr><name>serialfn_oid</name></expr></argument>, <argument><expr><name>deserialfn_oid</name></expr></argument>,
									  <argument><expr><name>initValue</name></expr></argument>, <argument><expr><name>initValueIsNull</name></expr></argument>,
									  <argument><expr><name>inputTypes</name></expr></argument>, <argument><expr><name>numArguments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>peragg</name><operator>-&gt;</operator><name>transno</name></name> <operator>=</operator> <name>transno</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>aggTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Update aggstate-&gt;numaggs to be the number of unique aggregates found.
	 * Also set numstates to the number of unique transition states found.
	 */</comment>
	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>numaggs</name></name> <operator>=</operator> <name>aggno</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>numtrans</name></name> <operator>=</operator> <name>transno</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Last, check whether any more aggregates got added onto the node while
	 * we processed the expressions for the aggregate arguments (including not
	 * only the regular arguments and FILTER expressions handled immediately
	 * above, but any direct arguments we might've handled earlier).  If so,
	 * we have nested aggregate functions, which is semantically nonsensical,
	 * so complain.  (This should have been caught by the parser, so we don't
	 * need to work hard on a helpful error message; but we defend against it
	 * here anyway, just to be sure.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numaggs</name> <operator>!=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggs</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GROUPING_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggregate function calls cannot be nested"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Build expressions doing all the transition work at once. We build a
	 * different one for each phase, as the number of transition function
	 * invocation can differ between phases. Note this'll work both for
	 * transition and combination functions (although there'll only be one
	 * phase in the latter case).
	 */</comment>
	<for>for <control>(<init><expr><name>phaseidx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>phaseidx</name> <operator>&lt;</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>numphases</name></name></expr>;</condition> <incr><expr><name>phaseidx</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AggStatePerPhase</name></type> <name>phase</name> <init>= <expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>phases</name><index>[<expr><name>phaseidx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>dohash</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>dosort</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* phase 0 doesn't necessarily exist */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>phase</name><operator>-&gt;</operator><name>aggnode</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_MIXED</name> <operator>&amp;&amp;</operator> <name>phaseidx</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Phase one, and only phase one, in a mixed agg performs both
			 * sorting and aggregation.
			 */</comment>
			<expr_stmt><expr><name>dohash</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>dosort</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_MIXED</name> <operator>&amp;&amp;</operator> <name>phaseidx</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * No need to compute a transition function for an AGG_MIXED phase
			 * 0 - the contents of the hashtables will have been computed
			 * during phase 1.
			 */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>phase</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_PLAIN</name> <operator>||</operator>
				 <name><name>phase</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_SORTED</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>dohash</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>dosort</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>phase</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_HASHED</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>dohash</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>dosort</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>phase</name><operator>-&gt;</operator><name>evaltrans</name></name> <operator>=</operator> <call><name>ExecBuildAggTrans</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>phase</name></expr></argument>, <argument><expr><name>dosort</name></expr></argument>, <argument><expr><name>dohash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>yb_pushdown_supported</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>yb_agg_pushdown</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>aggstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Build the state needed to calculate a state value for an aggregate.
 *
 * This initializes all the fields in 'pertrans'. 'aggref' is the aggregate
 * to initialize the state for. 'aggtransfn', 'aggtranstype', and the rest
 * of the arguments could be calculated from 'aggref', but the caller has
 * calculated them already, so might as well pass them.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>build_pertrans_for_aggref</name><parameter_list>(<parameter><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name></decl></parameter>,
						  <parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
						  <parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggref</name></decl></parameter>,
						  <parameter><decl><type><name>Oid</name></type> <name>aggtransfn</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>aggtranstype</name></decl></parameter>,
						  <parameter><decl><type><name>Oid</name></type> <name>aggserialfn</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>aggdeserialfn</name></decl></parameter>,
						  <parameter><decl><type><name>Datum</name></type> <name>initValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>initValueIsNull</name></decl></parameter>,
						  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>inputTypes</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numArguments</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>numGroupingSets</name> <init>= <expr><call><name>Max</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>maxsets</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>serialfnexpr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>deserialfnexpr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numInputs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numDirectArgs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sortlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numSortCols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numDistinctCols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Begin filling in the pertrans data */</comment>
	<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>aggref</name></name> <operator>=</operator> <name>aggref</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>aggshared</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>aggCollation</name></name> <operator>=</operator> <name><name>aggref</name><operator>-&gt;</operator><name>inputcollid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transfn_oid</name></name> <operator>=</operator> <name>aggtransfn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>serialfn_oid</name></name> <operator>=</operator> <name>aggserialfn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>deserialfn_oid</name></name> <operator>=</operator> <name>aggdeserialfn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>initValue</name></name> <operator>=</operator> <name>initValue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>initValueIsNull</name></name> <operator>=</operator> <name>initValueIsNull</name></expr>;</expr_stmt>

	<comment type="block">/* Count the "direct" arguments, if any */</comment>
	<expr_stmt><expr><name>numDirectArgs</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggdirectargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Count the number of aggregated input columns */</comment>
	<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>numInputs</name></name> <operator>=</operator> <name>numInputs</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>=</operator> <name>aggtranstype</name></expr>;</expr_stmt>

	<comment type="block">/* Detect how many arguments to pass to the transfn */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>AGGKIND_IS_ORDERED_SET</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggkind</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>numTransInputs</name></name> <operator>=</operator> <name>numInputs</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>numTransInputs</name></name> <operator>=</operator> <name>numArguments</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * When combining states, we have no use at all for the aggregate
	 * function's transfn. Instead we use the combinefn.  In this case, the
	 * transfn and transfn_oid fields of pertrans refer to the combine
	 * function rather than the transition function.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>DO_AGGSPLIT_COMBINE</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>combinefnexpr</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>build_aggregate_combinefn_expr</name><argument_list>(<argument><expr><name>aggtranstype</name></expr></argument>,
									   <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>,
									   <argument><expr><name>aggtransfn</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>combinefnexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>aggtransfn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transfn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fmgr_info_set_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>combinefnexpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transfn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transfn_fcinfo</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transfn</name></name></expr></argument>,
								 <argument><expr><literal type="number">2</literal></expr></argument>,
								 <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>aggCollation</name></name></expr></argument>,
								 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>aggstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Ensure that a combine function to combine INTERNAL states is not
		 * strict. This should have been checked during CREATE AGGREGATE, but
		 * the strict property could have been changed since then.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>transfn</name><operator>.</operator><name>fn_strict</name></name> <operator>&amp;&amp;</operator> <name>aggtranstype</name> <operator>==</operator> <name>INTERNALOID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"combine function with transition type %s must not be declared STRICT"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>aggtranstype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>transfnexpr</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Set up infrastructure for calling the transfn.  Note that
		 * invtransfn is not needed here.
		 */</comment>
		<expr_stmt><expr><call><name>build_aggregate_transfn_expr</name><argument_list>(<argument><expr><name>inputTypes</name></expr></argument>,
									 <argument><expr><name>numArguments</name></expr></argument>,
									 <argument><expr><name>numDirectArgs</name></expr></argument>,
									 <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggvariadic</name></name></expr></argument>,
									 <argument><expr><name>aggtranstype</name></expr></argument>,
									 <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>,
									 <argument><expr><name>aggtransfn</name></expr></argument>,
									 <argument><expr><name>InvalidOid</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>transfnexpr</name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>aggtransfn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transfn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fmgr_info_set_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>transfnexpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transfn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transfn_fcinfo</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transfn</name></name></expr></argument>,
								 <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>numTransInputs</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
								 <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>aggCollation</name></name></expr></argument>,
								 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>aggstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the transfn is strict and the initval is NULL, make sure input
		 * type and transtype are the same (or at least binary-compatible), so
		 * that it's OK to use the first aggregated input value as the initial
		 * transValue.  This should have been checked at agg definition time,
		 * but we must check again in case the transfn's strictness property
		 * has been changed.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>transfn</name><operator>.</operator><name>fn_strict</name></name> <operator>&amp;&amp;</operator> <name><name>pertrans</name><operator>-&gt;</operator><name>initValueIsNull</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>numArguments</name> <operator>&lt;=</operator> <name>numDirectArgs</name> <operator>||</operator>
				<operator>!</operator><call><name>IsBinaryCoercible</name><argument_list>(<argument><expr><name><name>inputTypes</name><index>[<expr><name>numDirectArgs</name></expr>]</index></name></expr></argument>,
								   <argument><expr><name>aggtranstype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggregate %u needs to have compatible input type and transition type"</literal></expr></argument>,
								<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* get info about the state value's datatype */</comment>
	<expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name>aggtranstype</name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeByVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>aggserialfn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>build_aggregate_serialfn_expr</name><argument_list>(<argument><expr><name>aggserialfn</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>serialfnexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>aggserialfn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>serialfn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fmgr_info_set_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>serialfnexpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>serialfn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>serialfn_fcinfo</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>serialfn</name></name></expr></argument>,
								 <argument><expr><literal type="number">1</literal></expr></argument>,
								 <argument><expr><name>InvalidOid</name></expr></argument>,
								 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>aggstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>aggdeserialfn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>build_aggregate_deserialfn_expr</name><argument_list>(<argument><expr><name>aggdeserialfn</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>deserialfnexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>aggdeserialfn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>deserialfn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fmgr_info_set_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>deserialfnexpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>deserialfn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>deserialfn_fcinfo</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>deserialfn</name></name></expr></argument>,
								 <argument><expr><literal type="number">2</literal></expr></argument>,
								 <argument><expr><name>InvalidOid</name></expr></argument>,
								 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>aggstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we're doing either DISTINCT or ORDER BY for a plain agg, then we
	 * have a list of SortGroupClause nodes; fish out the data in them and
	 * stick them into arrays.  We ignore ORDER BY for an ordered-set agg,
	 * however; the agg's transfn and finalfn are responsible for that.
	 *
	 * Note that by construction, if there is a DISTINCT clause then the ORDER
	 * BY clause is a prefix of it (see transformDistinctClause).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>AGGKIND_IS_ORDERED_SET</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggkind</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>sortlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>numSortCols</name> <operator>=</operator> <name>numDistinctCols</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>aggref</name><operator>-&gt;</operator><name>aggdistinct</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>sortlist</name> <operator>=</operator> <name><name>aggref</name><operator>-&gt;</operator><name>aggdistinct</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>numSortCols</name> <operator>=</operator> <name>numDistinctCols</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>sortlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numSortCols</name> <operator>&gt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggorder</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>sortlist</name> <operator>=</operator> <name><name>aggref</name><operator>-&gt;</operator><name>aggorder</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>numSortCols</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>sortlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>numDistinctCols</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>numSortCols</name></name> <operator>=</operator> <name>numSortCols</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>numDistinctCols</name></name> <operator>=</operator> <name>numDistinctCols</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we have either sorting or filtering to do, create a tupledesc and
	 * slot corresponding to the aggregated inputs (including sort
	 * expressions) of the agg.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numSortCols</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>aggref</name><operator>-&gt;</operator><name>aggfilter</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortdesc</name></name> <operator>=</operator> <call><name>ExecTypeFromTL</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortslot</name></name> <operator>=</operator>
			<call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>numSortCols</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We don't implement DISTINCT or ORDER BY aggs in the HASHED case
		 * (yet)
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>!=</operator> <name>AGG_HASHED</name> <operator>&amp;&amp;</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>!=</operator> <name>AGG_MIXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If we have only one input, we need its len/byval info. */</comment>
		<if_stmt><if>if <condition>(<expr><name>numInputs</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name><name>inputTypes</name><index>[<expr><name>numDirectArgs</name></expr>]</index></name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>inputtypeLen</name></name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>inputtypeByVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>numDistinctCols</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* we will need an extra slot to store prior values */</comment>
			<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>uniqslot</name></name> <operator>=</operator>
				<call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Extract the sort information for use later */</comment>
		<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortColIdx</name></name> <operator>=</operator>
			<operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numSortCols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortOperators</name></name> <operator>=</operator>
			<operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numSortCols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortCollations</name></name> <operator>=</operator>
			<operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numSortCols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortNullsFirst</name></name> <operator>=</operator>
			<operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numSortCols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>sortlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sortcl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>sortcl</name></expr></argument>, <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* the parser should have made sure of this */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>sortcl</name><operator>-&gt;</operator><name>sortop</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortColIdx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortOperators</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>sortcl</name><operator>-&gt;</operator><name>sortop</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortCollations</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortNullsFirst</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>sortcl</name><operator>-&gt;</operator><name>nulls_first</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <name>numSortCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>aggref</name><operator>-&gt;</operator><name>aggdistinct</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>ops</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numArguments</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggdistinct</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>numDistinctCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ops</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numDistinctCols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>aggref-&gt;aggdistinct</argument>)</argument_list></macro>
			<expr_stmt><expr><name><name>ops</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>eqop</name></expr>;</expr_stmt>

		<comment type="block">/* lookup / build the necessary comparators */</comment>
		<if_stmt><if>if <condition>(<expr><name>numDistinctCols</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><call><name>get_opcode</name><argument_list>(<argument><expr><name><name>ops</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>equalfnOne</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>equalfnMulti</name></name> <operator>=</operator>
				<call><name>execTuplesMatchPrepare</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortdesc</name></name></expr></argument>,
									   <argument><expr><name>numDistinctCols</name></expr></argument>,
									   <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortColIdx</name></name></expr></argument>,
									   <argument><expr><name>ops</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ops</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name></name> <operator>=</operator> <operator>(</operator><name>Tuplesortstate</name> <operator>*</operator><operator>*</operator><operator>)</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Tuplesortstate</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numGroupingSets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>GetAggInitVal</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>textInitVal</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>transtype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typinput</name></decl>,
				<decl><type ref="prev"/><name>typioparam</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>strInitVal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>initVal</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>getTypeInputInfo</name><argument_list>(<argument><expr><name>transtype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typinput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typioparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>strInitVal</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>textInitVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>initVal</name> <operator>=</operator> <call><name>OidInputFunctionCall</name><argument_list>(<argument><expr><name>typinput</name></expr></argument>, <argument><expr><name>strInitVal</name></expr></argument>,
								   <argument><expr><name>typioparam</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>strInitVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>initVal</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * find_compatible_peragg - search for a previously initialized per-Agg struct
 *
 * Searches the previously looked at aggregates to find one which is compatible
 * with this one, with the same input parameters. If no compatible aggregate
 * can be found, returns -1.
 *
 * As a side-effect, this also collects a list of existing, shareable per-Trans
 * structs with matching inputs. If no identical Aggref is found, the list is
 * passed later to find_compatible_pertrans, to see if we can at least reuse
 * the state value of another aggregate.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>find_compatible_peragg</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>newagg</name></decl></parameter>, <parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>lastaggno</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>same_input_transnos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>aggno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AggStatePerAgg</name></type> <name>peraggs</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>same_input_transnos</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/* we mustn't reuse the aggref if it contains volatile function calls */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newagg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>peraggs</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>peragg</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Search through the list of already seen aggregates. If we find an
	 * existing identical aggregate call, then we can re-use that one. While
	 * searching, we'll also collect a list of Aggrefs with the same input
	 * parameters. If no matching Aggref is found, the caller can potentially
	 * still re-use the transition state of one of them.  (At this stage we
	 * just compare the parsetrees; whether different aggregates share the
	 * same transition function will be checked later.)
	 */</comment>
	<for>for <control>(<init><expr><name>aggno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>aggno</name> <operator>&lt;=</operator> <name>lastaggno</name></expr>;</condition> <incr><expr><name>aggno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AggStatePerAgg</name></type> <name>peragg</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>existingRef</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>peragg</name> <operator>=</operator> <operator>&amp;</operator><name><name>peraggs</name><index>[<expr><name>aggno</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>existingRef</name> <operator>=</operator> <name><name>peragg</name><operator>-&gt;</operator><name>aggref</name></name></expr>;</expr_stmt>

		<comment type="block">/* all of the following must be the same or it's no match */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>newagg</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>!=</operator> <name><name>existingRef</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>||</operator>
			<name><name>newagg</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>!=</operator> <name><name>existingRef</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>||</operator>
			<name><name>newagg</name><operator>-&gt;</operator><name>aggstar</name></name> <operator>!=</operator> <name><name>existingRef</name><operator>-&gt;</operator><name>aggstar</name></name> <operator>||</operator>
			<name><name>newagg</name><operator>-&gt;</operator><name>aggvariadic</name></name> <operator>!=</operator> <name><name>existingRef</name><operator>-&gt;</operator><name>aggvariadic</name></name> <operator>||</operator>
			<name><name>newagg</name><operator>-&gt;</operator><name>aggkind</name></name> <operator>!=</operator> <name><name>existingRef</name><operator>-&gt;</operator><name>aggkind</name></name> <operator>||</operator>
			<operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name><name>newagg</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>existingRef</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			<operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name><name>newagg</name><operator>-&gt;</operator><name>aggorder</name></name></expr></argument>, <argument><expr><name><name>existingRef</name><operator>-&gt;</operator><name>aggorder</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			<operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name><name>newagg</name><operator>-&gt;</operator><name>aggdistinct</name></name></expr></argument>, <argument><expr><name><name>existingRef</name><operator>-&gt;</operator><name>aggdistinct</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			<operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name><name>newagg</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>, <argument><expr><name><name>existingRef</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* if it's the same aggregate function then report exact match */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>newagg</name><operator>-&gt;</operator><name>aggfnoid</name></name> <operator>==</operator> <name><name>existingRef</name><operator>-&gt;</operator><name>aggfnoid</name></name> <operator>&amp;&amp;</operator>
			<name><name>newagg</name><operator>-&gt;</operator><name>aggtype</name></name> <operator>==</operator> <name><name>existingRef</name><operator>-&gt;</operator><name>aggtype</name></name> <operator>&amp;&amp;</operator>
			<name><name>newagg</name><operator>-&gt;</operator><name>aggcollid</name></name> <operator>==</operator> <name><name>existingRef</name><operator>-&gt;</operator><name>aggcollid</name></name> <operator>&amp;&amp;</operator>
			<call><name>equal</name><argument_list>(<argument><expr><name><name>newagg</name><operator>-&gt;</operator><name>aggdirectargs</name></name></expr></argument>, <argument><expr><name><name>existingRef</name><operator>-&gt;</operator><name>aggdirectargs</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><operator>*</operator><name>same_input_transnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>same_input_transnos</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<return>return <expr><name>aggno</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Not identical, but it had the same inputs.  If the final function
		 * permits sharing, return its transno to the caller, in case we can
		 * re-use its per-trans state.  (If there's already sharing going on,
		 * we might report a transno more than once.  find_compatible_pertrans
		 * is cheap enough that it's not worth spending cycles to avoid that.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>peragg</name><operator>-&gt;</operator><name>shareable</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>same_input_transnos</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><operator>*</operator><name>same_input_transnos</name></expr></argument>,
											   <argument><expr><name><name>peragg</name><operator>-&gt;</operator><name>transno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * find_compatible_pertrans - search for a previously initialized per-Trans
 * struct
 *
 * Searches the list of transnos for a per-Trans struct with the same
 * transition function and initial condition. (The inputs have already been
 * verified to match.)
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>find_compatible_pertrans</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>, <parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>newagg</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>shareable</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>aggtransfn</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>aggtranstype</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>aggserialfn</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>aggdeserialfn</name></decl></parameter>,
						 <parameter><decl><type><name>Datum</name></type> <name>initValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>initValueIsNull</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>transnos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* If this aggregate can't share transition states, give up */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>shareable</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>transnos</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>transno</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name> <init>= <expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>pertrans</name><index>[<expr><name>transno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * if the transfns or transition state types are not the same then the
		 * state can't be shared.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>aggtransfn</name> <operator>!=</operator> <name><name>pertrans</name><operator>-&gt;</operator><name>transfn_oid</name></name> <operator>||</operator>
			<name>aggtranstype</name> <operator>!=</operator> <name><name>pertrans</name><operator>-&gt;</operator><name>aggtranstype</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * The serialization and deserialization functions must match, if
		 * present, as we're unable to share the trans state for aggregates
		 * which will serialize or deserialize into different formats.
		 * Remember that these will be InvalidOid if they're not required for
		 * this agg node.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>aggserialfn</name> <operator>!=</operator> <name><name>pertrans</name><operator>-&gt;</operator><name>serialfn_oid</name></name> <operator>||</operator>
			<name>aggdeserialfn</name> <operator>!=</operator> <name><name>pertrans</name><operator>-&gt;</operator><name>deserialfn_oid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Check that the initial condition matches, too.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>initValueIsNull</name> <operator>&amp;&amp;</operator> <name><name>pertrans</name><operator>-&gt;</operator><name>initValueIsNull</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>transno</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>initValueIsNull</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pertrans</name><operator>-&gt;</operator><name>initValueIsNull</name></name> <operator>&amp;&amp;</operator>
			<call><name>datumIsEqual</name><argument_list>(<argument><expr><name>initValue</name></expr></argument>, <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>initValue</name></name></expr></argument>,
						 <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeByVal</name></name></expr></argument>, <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>transno</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecEndAgg</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>outerPlan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>transno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numGroupingSets</name> <init>= <expr><call><name>Max</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>maxsets</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>setno</name></decl>;</decl_stmt>

	<comment type="block">/* Make sure we have closed any open tuplesorts */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>sort_in</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tuplesort_end</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>sort_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>sort_out</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tuplesort_end</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>sort_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>transno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>transno</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numtrans</name></name></expr>;</condition> <incr><expr><name>transno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>pertrans</name><index>[<expr><name>transno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>setno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>setno</name> <operator>&lt;</operator> <name>numGroupingSets</name></expr>;</condition> <incr><expr><name>setno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name>setno</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>tuplesort_end</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name>setno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<comment type="block">/* And ensure any agg shutdown callbacks have been called */</comment>
	<for>for <control>(<init><expr><name>setno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>setno</name> <operator>&lt;</operator> <name>numGroupingSets</name></expr>;</condition> <incr><expr><name>setno</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReScanExprContext</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>aggcontexts</name><index>[<expr><name>setno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>hashcontext</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReScanExprContext</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hashcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We don't actually free any ExprContexts here (see comment in
	 * ExecFreeExprContext), just unlinking the output one from the plan node
	 * suffices.
	 */</comment>
	<expr_stmt><expr><call><name>ExecFreeExprContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* clean up tuple table */</comment>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>outerPlan</name> <operator>=</operator> <call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><name>outerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecReScanAgg</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>outerPlan</name> <init>= <expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Agg</name>		   <modifier>*</modifier></type><name>aggnode</name> <init>= <expr><operator>(</operator><name>Agg</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>transno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numGroupingSets</name> <init>= <expr><call><name>Max</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>maxsets</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>setno</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>agg_done</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_HASHED</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * In the hashed case, if we haven't yet built the hash table then we
		 * can just return; nothing done yet, so nothing to undo. If subnode's
		 * chgParam is not NULL then it will be re-scanned by ExecProcNode,
		 * else no reason to re-scan it at all.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>table_filled</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If we do have the hash table, and the subplan does not have any
		 * parameter changes, and none of our own parameter changes affect
		 * input expressions of the aggregated functions, then we can just
		 * rescan the existing hash table; no need to build it again.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>outerPlan</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>chgParam</name></name></expr></argument>, <argument><expr><name><name>aggnode</name><operator>-&gt;</operator><name>aggParams</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ResetTupleHashIterator</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>perhash</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>hashtable</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>perhash</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>hashiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>select_current_set</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Make sure we have closed any open tuplesorts */</comment>
	<for>for <control>(<init><expr><name>transno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>transno</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numtrans</name></name></expr>;</condition> <incr><expr><name>transno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>setno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>setno</name> <operator>&lt;</operator> <name>numGroupingSets</name></expr>;</condition> <incr><expr><name>setno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>pertrans</name><index>[<expr><name>transno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name>setno</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>tuplesort_end</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name>setno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name>setno</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<comment type="block">/*
	 * We don't need to ReScanExprContext the output tuple context here;
	 * ExecReScan already did it. But we do need to reset our per-grouping-set
	 * contexts, which may have transvalues stored in them. (We use rescan
	 * rather than just reset because transfns may have registered callbacks
	 * that need to be run now.) For the AGG_HASHED case, see below.
	 */</comment>

	<for>for <control>(<init><expr><name>setno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>setno</name> <operator>&lt;</operator> <name>numGroupingSets</name></expr>;</condition> <incr><expr><name>setno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReScanExprContext</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>aggcontexts</name><index>[<expr><name>setno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Release first tuple of group, if we have made a copy */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>grp_firstTuple</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>grp_firstTuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>grp_firstTuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Forget current agg values */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_aggvalues</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>node</name><operator>-&gt;</operator><name>numaggs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_aggnulls</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>node</name><operator>-&gt;</operator><name>numaggs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * With AGG_HASHED/MIXED, the hash table is allocated in a sub-context of
	 * the hashcontext. This used to be an issue, but now, resetting a context
	 * automatically deletes sub-contexts too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_HASHED</name> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_MIXED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReScanExprContext</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hashcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Rebuild an empty hash table */</comment>
		<expr_stmt><expr><call><name>build_hash_table</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>table_filled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<comment type="block">/* iterator will be reset when the table is filled */</comment>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>!=</operator> <name>AGG_HASHED</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Reset the per-group state (in particular, mark transvalues null)
		 */</comment>
		<for>for <control>(<init><expr><name>setno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>setno</name> <operator>&lt;</operator> <name>numGroupingSets</name></expr>;</condition> <incr><expr><name>setno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>pergroups</name><index>[<expr><name>setno</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
				   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AggStatePerGroupData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>node</name><operator>-&gt;</operator><name>numaggs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* reset to phase 1 */</comment>
		<expr_stmt><expr><call><name>initialize_phase</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>input_done</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>projected_set</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>outerPlan</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><name>outerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/***********************************************************************
 * API exposed to aggregate functions
 ***********************************************************************/</comment>


<comment type="block">/*
 * AggCheckCallContext - test if a SQL function is being called as an aggregate
 *
 * The transition and/or final functions of an aggregate may want to verify
 * that they are being called as aggregates, rather than as plain SQL
 * functions.  They should use this function to do so.  The return value
 * is nonzero if being called as an aggregate, or zero if not.  (Specific
 * nonzero values are AGG_CONTEXT_AGGREGATE or AGG_CONTEXT_WINDOW, but more
 * values could conceivably appear in future.)
 *
 * If aggcontext isn't NULL, the function also stores at *aggcontext the
 * identity of the memory context that aggregate transition values are being
 * stored in.  Note that the same aggregate call site (flinfo) may be called
 * interleaved on different transition values in different contexts, so it's
 * not kosher to cache aggcontext under fn_extra.  It is, however, kosher to
 * cache it in the transvalue itself (for internal-type transvalues).
 */</comment>
<function><type><name>int</name></type>
<name>AggCheckCallContext</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name> <modifier>*</modifier></type><name>aggcontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>AggState</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>aggcontext</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AggState</name>   <modifier>*</modifier></type><name>aggstate</name> <init>= <expr><operator>(</operator><operator>(</operator><name>AggState</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>cxt</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>curaggcontext</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><operator>*</operator><name>aggcontext</name> <operator>=</operator> <name><name>cxt</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>AGG_CONTEXT_AGGREGATE</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>WindowAggState</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>aggcontext</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>aggcontext</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>WindowAggState</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name><operator>)</operator><operator>-&gt;</operator><name>curaggcontext</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>AGG_CONTEXT_WINDOW</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* this is just to prevent "uninitialized variable" warnings */</comment>
	<if_stmt><if>if <condition>(<expr><name>aggcontext</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>aggcontext</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * AggGetAggref - allow an aggregate support function to get its Aggref
 *
 * If the function is being called as an aggregate support function,
 * return the Aggref node for the aggregate call.  Otherwise, return NULL.
 *
 * Aggregates sharing the same inputs and transition functions can get
 * merged into a single transition calculation.  If the transition function
 * calls AggGetAggref, it will get some one of the Aggrefs for which it is
 * executing.  It must therefore not pay attention to the Aggref fields that
 * relate to the final function, as those are indeterminate.  But if a final
 * function calls AggGetAggref, it will get a precise result.
 *
 * Note that if an aggregate is being used as a window function, this will
 * return NULL.  We could provide a similar function to return the relevant
 * WindowFunc node in such cases, but it's not needed yet.
 */</comment>
<function><type><name>Aggref</name> <modifier>*</modifier></type>
<name>AggGetAggref</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>AggState</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AggState</name>   <modifier>*</modifier></type><name>aggstate</name> <init>= <expr><operator>(</operator><name>AggState</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AggStatePerAgg</name></type> <name>curperagg</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>curpertrans</name></decl>;</decl_stmt>

		<comment type="block">/* check curperagg (valid when in a final function) */</comment>
		<expr_stmt><expr><name>curperagg</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>curperagg</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>curperagg</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>curperagg</name><operator>-&gt;</operator><name>aggref</name></name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* check curpertrans (valid when in a transition function) */</comment>
		<expr_stmt><expr><name>curpertrans</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>curpertrans</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>curpertrans</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>curpertrans</name><operator>-&gt;</operator><name>aggref</name></name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * AggGetTempMemoryContext - fetch short-term memory context for aggregates
 *
 * This is useful in agg final functions; the context returned is one that
 * the final function can safely reset as desired.  This isn't useful for
 * transition functions, since the context returned MAY (we don't promise)
 * be the same as the context those are called in.
 *
 * As above, this is currently not useful for aggs called as window functions.
 */</comment>
<function><type><name>MemoryContext</name></type>
<name>AggGetTempMemoryContext</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>AggState</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AggState</name>   <modifier>*</modifier></type><name>aggstate</name> <init>= <expr><operator>(</operator><name>AggState</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></init></decl>;</decl_stmt>

		<return>return <expr><name><name>aggstate</name><operator>-&gt;</operator><name>tmpcontext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * AggStateIsShared - find out whether transition state is shared
 *
 * If the function is being called as an aggregate support function,
 * return true if the aggregate's transition state is shared across
 * multiple aggregates, false if it is not.
 *
 * Returns true if not called as an aggregate support function.
 * This is intended as a conservative answer, ie "no you'd better not
 * scribble on your input".  In particular, will return true if the
 * aggregate is being used as a window function, which is a scenario
 * in which changing the transition state is a bad idea.  We might
 * want to refine the behavior for the window case in future.
 */</comment>
<function><type><name>bool</name></type>
<name>AggStateIsShared</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>AggState</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AggState</name>   <modifier>*</modifier></type><name>aggstate</name> <init>= <expr><operator>(</operator><name>AggState</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AggStatePerAgg</name></type> <name>curperagg</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>curpertrans</name></decl>;</decl_stmt>

		<comment type="block">/* check curperagg (valid when in a final function) */</comment>
		<expr_stmt><expr><name>curperagg</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>curperagg</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>curperagg</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>aggstate</name><operator>-&gt;</operator><name>pertrans</name><index>[<expr><name><name>curperagg</name><operator>-&gt;</operator><name>transno</name></name></expr>]</index></name><operator>.</operator><name>aggshared</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* check curpertrans (valid when in a transition function) */</comment>
		<expr_stmt><expr><name>curpertrans</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>curpertrans</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>curpertrans</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>curpertrans</name><operator>-&gt;</operator><name>aggshared</name></name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * AggRegisterCallback - register a cleanup callback for an aggregate
 *
 * This is useful for aggs to register shutdown callbacks, which will ensure
 * that non-memory resources are freed.  The callback will occur just before
 * the associated aggcontext (as returned by AggCheckCallContext) is reset,
 * either between groups or as a result of rescanning the query.  The callback
 * will NOT be called on error paths.  The typical use-case is for freeing of
 * tuplestores or tuplesorts maintained in aggcontext, or pins held by slots
 * created by the agg functions.  (The callback will not be called until after
 * the result of the finalfn is no longer needed, so it's safe for the finalfn
 * to return data that will be freed by the callback.)
 *
 * As above, this is currently not useful for aggs called as window functions.
 */</comment>
<function><type><name>void</name></type>
<name>AggRegisterCallback</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>,
					<parameter><decl><type><name>ExprContextCallbackFunction</name></type> <name>func</name></decl></parameter>,
					<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>AggState</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AggState</name>   <modifier>*</modifier></type><name>aggstate</name> <init>= <expr><operator>(</operator><name>AggState</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>cxt</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>curaggcontext</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>RegisterExprContextCallback</name><argument_list>(<argument><expr><name>cxt</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"aggregate function cannot register a callback in this context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * aggregate_dummy - dummy execution routine for aggregate functions
 *
 * This function is listed as the implementation (prosrc field) of pg_proc
 * entries for aggregate functions.  Its only purpose is to throw an error
 * if someone mistakenly executes such a function in the normal way.
 *
 * Perhaps someday we could assign real meaning to the prosrc field of
 * an aggregate?
 */</comment>
<function><type><name>Datum</name></type>
<name>aggregate_dummy</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"aggregate function %u called as normal function"</literal></expr></argument>,
		 <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>			<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>
</unit>
