<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/executor/execExprInterp.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * execExprInterp.c
 *	  Interpreted evaluation of an expression step list.
 *
 * This file provides either a "direct threaded" (for gcc, clang and
 * compatible) or a "switch threaded" (for all compilers) implementation of
 * expression evaluation.  The former is amongst the fastest known methods
 * of interpreting programs without resorting to assembly level work, or
 * just-in-time compilation, but it requires support for computed gotos.
 * The latter is amongst the fastest approaches doable in standard C.
 *
 * In either case we use ExprEvalStep-&gt;opcode to dispatch to the code block
 * within ExecInterpExpr() that implements the specific opcode type.
 *
 * Switch-threading uses a plain switch() statement to perform the
 * dispatch.  This has the advantages of being plain C and allowing the
 * compiler to warn if implementation of a specific opcode has been forgotten.
 * The disadvantage is that dispatches will, as commonly implemented by
 * compilers, happen from a single location, requiring more jumps and causing
 * bad branch prediction.
 *
 * In direct threading, we use gcc's label-as-values extension - also adopted
 * by some other compilers - to replace ExprEvalStep-&gt;opcode with the address
 * of the block implementing the instruction. Dispatch to the next instruction
 * is done by a "computed goto".  This allows for better branch prediction
 * (as the jumps are happening from different locations) and fewer jumps
 * (as no preparatory jump to a common dispatch location is needed).
 *
 * When using direct threading, ExecReadyInterpretedExpr will replace
 * each step's opcode field with the address of the relevant code block and
 * ExprState-&gt;flags will contain EEO_FLAG_DIRECT_THREADED to remember that
 * that's been done.
 *
 * For very simple instructions the overhead of the full interpreter
 * "startup", as minimal as it is, is noticeable.  Therefore
 * ExecReadyInterpretedExpr will choose to implement certain simple
 * opcode patterns using special fast-path routines (ExecJust*).
 *
 * Complex or uncommon instructions are not implemented in-line in
 * ExecInterpExpr(), rather we call out to a helper function appearing later
 * in this file.  For one reason, there'd not be a noticeable performance
 * benefit, but more importantly those complex routines are intended to be
 * shared between different expression evaluation approaches.  For instance
 * a JIT compiler would generate calls to them.  (This is why they are
 * exported rather than being "static" in this file.)
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/executor/execExprInterp.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tuptoaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/sequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execExpr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSubplan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/date.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/expandedrecord.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/xml.h"</cpp:file></cpp:include>

<comment type="block">/* YB includes. */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>


<comment type="block">/*
 * Use computed-goto-based opcode dispatch when computed gotos are available.
 * But use a separate symbol so that it's easy to adjust locally in this file
 * for development and testing.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_COMPUTED_GOTO</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EEO_USE_COMPUTED_GOTO</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* HAVE_COMPUTED_GOTO */</comment>

<comment type="block">/*
 * Macros for opcode dispatch.
 *
 * EEO_SWITCH - just hides the switch if not in use.
 * EEO_CASE - labels the implementation of named expression step type.
 * EEO_DISPATCH - jump to the implementation of the step type for 'op'.
 * EEO_OPCODE - compute opcode required by used expression evaluation method.
 * EEO_NEXT - increment 'op' and jump to correct next step type.
 * EEO_JUMP - jump to the specified step number within the current expression.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EEO_USE_COMPUTED_GOTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<comment type="block">/* struct for jump target -&gt; opcode lookup table */</comment>
<typedef>typedef <type><struct>struct <name>ExprEvalOpLookup</name>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>opcode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprEvalOp</name></type>	<name>op</name></decl>;</decl_stmt>
}</block></struct></type> <name>ExprEvalOpLookup</name>;</typedef>

<comment type="block">/* to make dispatch_table accessible outside ExecInterpExpr() */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>dispatch_table</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* jump target -&gt; opcode lookup table */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>ExprEvalOpLookup</name></type> <name><name>reverse_dispatch_table</name><index>[<expr><name>EEOP_LAST</name></expr>]</index></name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EEO_SWITCH</name><parameter_list>()</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EEO_CASE</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>CASE_##name:</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EEO_DISPATCH</name><parameter_list>()</parameter_list></cpp:macro>		<cpp:value>goto *((void *) op-&gt;opcode)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EEO_OPCODE</name><parameter_list>(<parameter><type><name>opcode</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((intptr_t) dispatch_table[opcode])</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* !EEO_USE_COMPUTED_GOTO */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EEO_SWITCH</name><parameter_list>()</parameter_list></cpp:macro>		<cpp:value>starteval: switch ((ExprEvalOp) op-&gt;opcode)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EEO_CASE</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>case name:</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EEO_DISPATCH</name><parameter_list>()</parameter_list></cpp:macro>		<cpp:value>goto starteval</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EEO_OPCODE</name><parameter_list>(<parameter><type><name>opcode</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(opcode)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* EEO_USE_COMPUTED_GOTO */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EEO_NEXT</name><parameter_list>()</parameter_list></cpp:macro> \
	<cpp:value>do { \
		op++; \
		EEO_DISPATCH(); \
	} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EEO_JUMP</name><parameter_list>(<parameter><type><name>stepno</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		op = &amp;state-&gt;steps[stepno]; \
		EEO_DISPATCH(); \
	} while (0)</cpp:value></cpp:define>


<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>ExecInterpExpr</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecInitInterpreter</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* support functions */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CheckVarSlotCompatibility</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>vartype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleDesc</name></type> <name>get_cached_rowtype</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type_id</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>,
									<parameter><decl><type><name>ExprEvalRowtypeCache</name> <modifier>*</modifier></type><name>rowcache</name></decl></parameter>,
									<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>changed</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecEvalRowNullInt</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>,
				   <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>checkisnull</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* fast-path evaluation functions */</comment>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>ExecJustInnerVar</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>ExecJustOuterVar</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>ExecJustScanVar</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>ExecJustConst</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>ExecJustAssignInnerVar</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>ExecJustAssignOuterVar</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>ExecJustAssignScanVar</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>ExecJustApplyFuncToCase</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Prepare ExprState for interpreted execution.
 */</comment>
<function><type><name>void</name></type>
<name>ExecReadyInterpretedExpr</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Ensure one-time interpreter setup has been done */</comment>
	<expr_stmt><expr><call><name>ExecInitInterpreter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Simple validity checks on expression */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>steps</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>opcode</name> <operator>==</operator> <name>EEOP_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Don't perform redundant initialization. This is unreachable in current
	 * cases, but might be hit if there's additional expression evaluation
	 * methods that rely on interpreted execution to work.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EEO_FLAG_INTERPRETER_INITIALIZED</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * First time through, check whether attribute matches Var.  Might not be
	 * ok anymore, due to schema changes. We do that by setting up a callback
	 * that does checking on the first call, which then sets the evalfunc
	 * callback to the actual method of execution.
	 */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>evalfunc</name></name> <operator>=</operator> <name>ExecInterpExprStillValid</name></expr>;</expr_stmt>

	<comment type="block">/* DIRECT_THREADED should not already be set */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EEO_FLAG_DIRECT_THREADED</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * There shouldn't be any errors before the expression is fully
	 * initialized, and even if so, it'd lead to the expression being
	 * abandoned.  So we can set the flag now and save some code.
	 */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>EEO_FLAG_INTERPRETER_INITIALIZED</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Select fast-path evalfuncs for very simple expressions.  "Starting up"
	 * the full interpreter is a measurable overhead for these, and these
	 * patterns occur often enough to be worth optimizing.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExprEvalOp</name></type>	<name>step0</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>steps</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>opcode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExprEvalOp</name></type>	<name>step1</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>steps</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>opcode</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>step0</name> <operator>==</operator> <name>EEOP_INNER_FETCHSOME</name> <operator>&amp;&amp;</operator>
			<name>step1</name> <operator>==</operator> <name>EEOP_INNER_VAR</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>evalfunc_private</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>ExecJustInnerVar</name></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>step0</name> <operator>==</operator> <name>EEOP_OUTER_FETCHSOME</name> <operator>&amp;&amp;</operator>
				 <name>step1</name> <operator>==</operator> <name>EEOP_OUTER_VAR</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>evalfunc_private</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>ExecJustOuterVar</name></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>step0</name> <operator>==</operator> <name>EEOP_SCAN_FETCHSOME</name> <operator>&amp;&amp;</operator>
				 <name>step1</name> <operator>==</operator> <name>EEOP_SCAN_VAR</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>evalfunc_private</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>ExecJustScanVar</name></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>step0</name> <operator>==</operator> <name>EEOP_INNER_FETCHSOME</name> <operator>&amp;&amp;</operator>
				 <name>step1</name> <operator>==</operator> <name>EEOP_ASSIGN_INNER_VAR</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>evalfunc_private</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>ExecJustAssignInnerVar</name></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>step0</name> <operator>==</operator> <name>EEOP_OUTER_FETCHSOME</name> <operator>&amp;&amp;</operator>
				 <name>step1</name> <operator>==</operator> <name>EEOP_ASSIGN_OUTER_VAR</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>evalfunc_private</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>ExecJustAssignOuterVar</name></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>step0</name> <operator>==</operator> <name>EEOP_SCAN_FETCHSOME</name> <operator>&amp;&amp;</operator>
				 <name>step1</name> <operator>==</operator> <name>EEOP_ASSIGN_SCAN_VAR</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>evalfunc_private</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>ExecJustAssignScanVar</name></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>step0</name> <operator>==</operator> <name>EEOP_CASE_TESTVAL</name> <operator>&amp;&amp;</operator>
				 <name>step1</name> <operator>==</operator> <name>EEOP_FUNCEXPR_STRICT</name> <operator>&amp;&amp;</operator>
				 <name><name>state</name><operator>-&gt;</operator><name>steps</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>d</name><operator>.</operator><name>casetest</name><operator>.</operator><name>value</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>evalfunc_private</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>ExecJustApplyFuncToCase</name></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
			 <name><name>state</name><operator>-&gt;</operator><name>steps</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>opcode</name> <operator>==</operator> <name>EEOP_CONST</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>evalfunc_private</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>ExecJustConst</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EEO_USE_COMPUTED_GOTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

	<comment type="block">/*
	 * In the direct-threaded implementation, replace each opcode with the
	 * address to jump to.  (Use ExecEvalStepOp() to get back the opcode.)
	 */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>off</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>off</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name></expr>;</condition> <incr><expr><name>off</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>steps</name><index>[<expr><name>off</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <call><name>EEO_OPCODE</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>opcode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>EEO_FLAG_DIRECT_THREADED</name></expr>;</expr_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* EEO_USE_COMPUTED_GOTO */</comment>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>evalfunc_private</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>ExecInterpExpr</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Evaluate expression identified by "state" in the execution context
 * given by "econtext".  *isnull is set to the is-null flag for the result,
 * and the Datum value is the function result.
 *
 * As a special case, return the dispatch table's address if state is NULL.
 * This is used by ExecInitInterpreter to set up the dispatch_table global.
 * (Only applies when EEO_USE_COMPUTED_GOTO is defined.)
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>ExecInterpExpr</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>resultslot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>innerslot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>outerslot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>scanslot</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * This array has to be in the same order as enum ExprEvalOp.
	 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EEO_USE_COMPUTED_GOTO</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>void</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>dispatch_table</name><index>[]</index></name> <init>= <expr><block>{
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_DONE</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_INNER_FETCHSOME</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_OUTER_FETCHSOME</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_SCAN_FETCHSOME</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_INNER_VAR</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_OUTER_VAR</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_SCAN_VAR</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_INNER_SYSVAR</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_OUTER_SYSVAR</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_SCAN_SYSVAR</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_WHOLEROW</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_ASSIGN_INNER_VAR</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_ASSIGN_OUTER_VAR</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_ASSIGN_SCAN_VAR</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_ASSIGN_TMP</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_ASSIGN_TMP_MAKE_RO</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_CONST</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_FUNCEXPR</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_FUNCEXPR_STRICT</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_FUNCEXPR_FUSAGE</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_FUNCEXPR_STRICT_FUSAGE</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_BOOL_AND_STEP_FIRST</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_BOOL_AND_STEP</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_BOOL_AND_STEP_LAST</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_BOOL_OR_STEP_FIRST</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_BOOL_OR_STEP</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_BOOL_OR_STEP_LAST</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_BOOL_NOT_STEP</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_QUAL</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_JUMP</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_JUMP_IF_NULL</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_JUMP_IF_NOT_NULL</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_JUMP_IF_NOT_TRUE</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_NULLTEST_ISNULL</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_NULLTEST_ISNOTNULL</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_NULLTEST_ROWISNULL</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_NULLTEST_ROWISNOTNULL</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_BOOLTEST_IS_TRUE</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_BOOLTEST_IS_NOT_TRUE</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_BOOLTEST_IS_FALSE</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_BOOLTEST_IS_NOT_FALSE</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_PARAM_EXEC</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_PARAM_EXTERN</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_PARAM_CALLBACK</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_CASE_TESTVAL</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_MAKE_READONLY</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_IOCOERCE</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_DISTINCT</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_NOT_DISTINCT</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_NULLIF</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_SQLVALUEFUNCTION</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_CURRENTOFEXPR</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_NEXTVALUEEXPR</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_ARRAYEXPR</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_ARRAYCOERCE</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_ROW</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_ROWCOMPARE_STEP</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_ROWCOMPARE_FINAL</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_MINMAX</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_FIELDSELECT</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_FIELDSTORE_DEFORM</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_FIELDSTORE_FORM</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_ARRAYREF_SUBSCRIPT</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_ARRAYREF_OLD</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_ARRAYREF_ASSIGN</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_ARRAYREF_FETCH</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_DOMAIN_TESTVAL</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_DOMAIN_NOTNULL</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_DOMAIN_CHECK</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_CONVERT_ROWTYPE</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_SCALARARRAYOP</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_XMLEXPR</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_AGGREF</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_GROUPING_FUNC</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_WINDOW_FUNC</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_SUBPLAN</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_ALTERNATIVE_SUBPLAN</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_AGG_STRICT_DESERIALIZE</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_AGG_DESERIALIZE</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_AGG_STRICT_INPUT_CHECK</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_AGG_INIT_TRANS</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_AGG_STRICT_TRANS_CHECK</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_AGG_PLAIN_TRANS_BYVAL</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_AGG_PLAIN_TRANS</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_AGG_ORDERED_TRANS_DATUM</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_AGG_ORDERED_TRANS_TUPLE</name></expr>,
		<expr><operator>&amp;&amp;</operator><name>CASE_EEOP_LAST</name></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>StaticAssertStmt</name><argument_list>(<argument><expr><name>EEOP_LAST</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>dispatch_table</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><literal type="string">"dispatch_table out of whack with ExprEvalOp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>state</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>dispatch_table</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>state</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* EEO_USE_COMPUTED_GOTO */</comment>

	<comment type="block">/* setup state */</comment>
	<expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>steps</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>resultslot</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>resultslot</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>innerslot</name> <operator>=</operator> <name><name>econtext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>outerslot</name> <operator>=</operator> <name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>scanslot</name> <operator>=</operator> <name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EEO_USE_COMPUTED_GOTO</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><call><name>EEO_DISPATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<macro><name>EEO_SWITCH</name><argument_list>()</argument_list></macro>
	<block>{<block_content>
		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_DONE</argument>)</argument_list></macro>
		<block>{<block_content>
			<goto>goto <name>out</name>;</goto>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_INNER_FETCHSOME</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* XXX: worthwhile to check tts_nvalid inline first? */</comment>
			<expr_stmt><expr><call><name>slot_getsomeattrs</name><argument_list>(<argument><expr><name>innerslot</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>last_var</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_OUTER_FETCHSOME</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><call><name>slot_getsomeattrs</name><argument_list>(<argument><expr><name>outerslot</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>last_var</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_SCAN_FETCHSOME</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><call><name>slot_getsomeattrs</name><argument_list>(<argument><expr><name>scanslot</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>last_var</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_INNER_VAR</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>var</name><operator>.</operator><name>attnum</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Since we already extracted all referenced columns from the
			 * tuple with a FETCHSOME step, we can just grab the value
			 * directly out of the slot's decomposed-data arrays.  But let's
			 * have an Assert to check that that did happen.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attnum</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>attnum</name> <operator>&lt;</operator> <name><name>innerslot</name><operator>-&gt;</operator><name>tts_nvalid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <name><name>innerslot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>attnum</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name><name>innerslot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>attnum</name></expr>]</index></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_OUTER_VAR</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>var</name><operator>.</operator><name>attnum</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* See EEOP_INNER_VAR comments */</comment>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attnum</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>attnum</name> <operator>&lt;</operator> <name><name>outerslot</name><operator>-&gt;</operator><name>tts_nvalid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <name><name>outerslot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>attnum</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name><name>outerslot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>attnum</name></expr>]</index></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_SCAN_VAR</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>var</name><operator>.</operator><name>attnum</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* See EEOP_INNER_VAR comments */</comment>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attnum</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>attnum</name> <operator>&lt;</operator> <name><name>scanslot</name><operator>-&gt;</operator><name>tts_nvalid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <name><name>scanslot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>attnum</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name><name>scanslot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>attnum</name></expr>]</index></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_INNER_SYSVAR</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>var</name><operator>.</operator><name>attnum</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>d</name></decl>;</decl_stmt>

			<comment type="block">/* these asserts must match defenses in slot_getattr */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>innerslot</name><operator>-&gt;</operator><name>tts_tuple</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>innerslot</name><operator>-&gt;</operator><name>tts_tuple</name></name> <operator>!=</operator> <operator>&amp;</operator><operator>(</operator><name><name>innerslot</name><operator>-&gt;</operator><name>tts_minhdr</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* heap_getsysattr has sufficient defenses against bad attnums */</comment>
			<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>heap_getsysattr</name><argument_list>(<argument><expr><name><name>innerslot</name><operator>-&gt;</operator><name>tts_tuple</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>,
								<argument><expr><name><name>innerslot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>,
								<argument><expr><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_OUTER_SYSVAR</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>var</name><operator>.</operator><name>attnum</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>d</name></decl>;</decl_stmt>

			<comment type="block">/* these asserts must match defenses in slot_getattr */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>outerslot</name><operator>-&gt;</operator><name>tts_tuple</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>outerslot</name><operator>-&gt;</operator><name>tts_tuple</name></name> <operator>!=</operator> <operator>&amp;</operator><operator>(</operator><name><name>outerslot</name><operator>-&gt;</operator><name>tts_minhdr</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* heap_getsysattr has sufficient defenses against bad attnums */</comment>
			<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>heap_getsysattr</name><argument_list>(<argument><expr><name><name>outerslot</name><operator>-&gt;</operator><name>tts_tuple</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>,
								<argument><expr><name><name>outerslot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>,
								<argument><expr><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_SCAN_SYSVAR</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>var</name><operator>.</operator><name>attnum</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>d</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * The ybctid may be copied to the slot.
			 * The heap tuple does not need to be formed in this case.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <name>YBTupleIdAttributeNumber</name> <operator>&amp;&amp;</operator> <name><name>scanslot</name><operator>-&gt;</operator><name>tts_ybctid</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>d</name> <operator>=</operator> <name><name>scanslot</name><operator>-&gt;</operator><name>tts_ybctid</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* these asserts must match defenses in slot_getattr */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>scanslot</name><operator>-&gt;</operator><name>tts_tuple</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>scanslot</name><operator>-&gt;</operator><name>tts_tuple</name></name> <operator>!=</operator> <operator>&amp;</operator><operator>(</operator><name><name>scanslot</name><operator>-&gt;</operator><name>tts_minhdr</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * heap_getsysattr has sufficient defenses against bad attnums
				 */</comment>
				<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>heap_getsysattr</name><argument_list>(<argument><expr><name><name>scanslot</name><operator>-&gt;</operator><name>tts_tuple</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>,
									<argument><expr><name><name>scanslot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>,
									<argument><expr><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_WHOLEROW</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* too complex for an inline implementation */</comment>
			<expr_stmt><expr><call><name>ExecEvalWholeRowVar</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_ASSIGN_INNER_VAR</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>resultnum</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>assign_var</name><operator>.</operator><name>resultnum</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>assign_var</name><operator>.</operator><name>attnum</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * We do not need CheckVarSlotCompatibility here; that was taken
			 * care of at compilation time.  But see EEOP_INNER_VAR comments.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attnum</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>attnum</name> <operator>&lt;</operator> <name><name>innerslot</name><operator>-&gt;</operator><name>tts_nvalid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>resultnum</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>resultnum</name> <operator>&lt;</operator> <name><name>resultslot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>resultslot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>resultnum</name></expr>]</index></name> <operator>=</operator> <name><name>innerslot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>attnum</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>resultslot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>resultnum</name></expr>]</index></name> <operator>=</operator> <name><name>innerslot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>attnum</name></expr>]</index></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_ASSIGN_OUTER_VAR</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>resultnum</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>assign_var</name><operator>.</operator><name>resultnum</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>assign_var</name><operator>.</operator><name>attnum</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * We do not need CheckVarSlotCompatibility here; that was taken
			 * care of at compilation time.  But see EEOP_INNER_VAR comments.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attnum</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>attnum</name> <operator>&lt;</operator> <name><name>outerslot</name><operator>-&gt;</operator><name>tts_nvalid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>resultnum</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>resultnum</name> <operator>&lt;</operator> <name><name>resultslot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>resultslot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>resultnum</name></expr>]</index></name> <operator>=</operator> <name><name>outerslot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>attnum</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>resultslot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>resultnum</name></expr>]</index></name> <operator>=</operator> <name><name>outerslot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>attnum</name></expr>]</index></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_ASSIGN_SCAN_VAR</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>resultnum</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>assign_var</name><operator>.</operator><name>resultnum</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>assign_var</name><operator>.</operator><name>attnum</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * We do not need CheckVarSlotCompatibility here; that was taken
			 * care of at compilation time.  But see EEOP_INNER_VAR comments.
			 */</comment>

			<comment type="block">/* Hacky way to allow YSQL upgrade INSERTs to set oid column. */</comment>
			<if_stmt><if>if <condition>(<expr><name>IsYsqlUpgrade</name> <operator>&amp;&amp;</operator> <name>resultnum</name> <operator>==</operator> <name>ObjectIdAttributeNumber</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>resultslot</name><operator>-&gt;</operator><name>tts_yb_insert_oid</name></name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name><name>scanslot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attnum</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>attnum</name> <operator>&lt;</operator> <name><name>scanslot</name><operator>-&gt;</operator><name>tts_nvalid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>resultnum</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>resultnum</name> <operator>&lt;</operator> <name><name>resultslot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>resultslot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>resultnum</name></expr>]</index></name> <operator>=</operator> <name><name>scanslot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>attnum</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>resultslot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>resultnum</name></expr>]</index></name> <operator>=</operator> <name><name>scanslot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>attnum</name></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_ASSIGN_TMP</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>resultnum</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>assign_tmp</name><operator>.</operator><name>resultnum</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Hacky way to allow YSQL upgrade INSERTs to set oid column. */</comment>
			<if_stmt><if>if <condition>(<expr><name>IsYsqlUpgrade</name> <operator>&amp;&amp;</operator> <name>resultnum</name> <operator>==</operator> <name>ObjectIdAttributeNumber</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>resultslot</name><operator>-&gt;</operator><name>tts_yb_insert_oid</name></name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>resvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>resultnum</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>resultnum</name> <operator>&lt;</operator> <name><name>resultslot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>resultslot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>resultnum</name></expr>]</index></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>resvalue</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>resultslot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>resultnum</name></expr>]</index></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>resnull</name></name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_ASSIGN_TMP_MAKE_RO</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>resultnum</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>assign_tmp</name><operator>.</operator><name>resultnum</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>resultnum</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>resultnum</name> <operator>&lt;</operator> <name><name>resultslot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>resultslot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>resultnum</name></expr>]</index></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>resnull</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>resultslot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>resultnum</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>resultslot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>resultnum</name></expr>]</index></name> <operator>=</operator>
					<call><name>MakeExpandedObjectReadOnlyInternal</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>resvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>resultslot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>resultnum</name></expr>]</index></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>resvalue</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_CONST</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>constval</name><operator>.</operator><name>isnull</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>constval</name><operator>.</operator><name>value</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Function-call implementations. Arguments have previously been
		 * evaluated directly into fcinfo-&gt;args.
		 *
		 * As both STRICT checks and function-usage are noticeable performance
		 * wise, and function calls are a very hot-path (they also back
		 * operators!), it's worth having so many separate opcodes.
		 *
		 * Note: the reason for using a temporary variable "d", here and in
		 * other places, is that some compilers think "*op-&gt;resvalue = f();"
		 * requires them to evaluate op-&gt;resvalue into a register before
		 * calling f(), just in case f() is able to modify op-&gt;resvalue
		 * somehow.  The extra line of code can save a useless register spill
		 * and reload across the function call.
		 */</comment>
		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_FUNCEXPR</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>func</name><operator>.</operator><name>fcinfo_data</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>d</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>func</name><operator>.</operator><name>fn_addr</name></name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_FUNCEXPR_STRICT</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>func</name><operator>.</operator><name>fcinfo_data</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>argnull</name> <init>= <expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>argno</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>d</name></decl>;</decl_stmt>

			<comment type="block">/* strict function, so check for NULL args */</comment>
			<for>for <control>(<init><expr><name>argno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>argno</name> <operator>&lt;</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>func</name><operator>.</operator><name>nargs</name></name></expr>;</condition> <incr><expr><name>argno</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>argnull</name><index>[<expr><name>argno</name></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<goto>goto <name>strictfail</name>;</goto>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>func</name><operator>.</operator><name>fn_addr</name></name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>

	<label><name>strictfail</name>:</label>
			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_FUNCEXPR_FUSAGE</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* not common enough to inline */</comment>
			<expr_stmt><expr><call><name>ExecEvalFuncExprFusage</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_FUNCEXPR_STRICT_FUSAGE</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* not common enough to inline */</comment>
			<expr_stmt><expr><call><name>ExecEvalFuncExprStrictFusage</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * If any of its clauses is FALSE, an AND's result is FALSE regardless
		 * of the states of the rest of the clauses, so we can stop evaluating
		 * and return FALSE immediately.  If none are FALSE and one or more is
		 * NULL, we return NULL; otherwise we return TRUE.  This makes sense
		 * when you interpret NULL as "don't know": perhaps one of the "don't
		 * knows" would have been FALSE if we'd known its value.  Only when
		 * all the inputs are known to be TRUE can we state confidently that
		 * the AND's result is TRUE.
		 */</comment>
		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_BOOL_AND_STEP_FIRST</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>boolexpr</name><operator>.</operator><name>anynull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * EEOP_BOOL_AND_STEP_FIRST resets anynull, otherwise it's the
			 * same as EEOP_BOOL_AND_STEP - so fall through to that.
			 */</comment>

			<comment type="block">/* FALL THROUGH */</comment>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_BOOL_AND_STEP</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>boolexpr</name><operator>.</operator><name>anynull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* result is already set to FALSE, need not change it */</comment>
				<comment type="block">/* bail out early */</comment>
				<expr_stmt><expr><call><name>EEO_JUMP</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>boolexpr</name><operator>.</operator><name>jumpdone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_BOOL_AND_STEP_LAST</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* result is already set to NULL, need not change it */</comment>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* result is already set to FALSE, need not change it */</comment>

				<comment type="block">/*
				 * No point jumping early to jumpdone - would be same target
				 * (as this is the last argument to the AND expression),
				 * except more expensive.
				 */</comment>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>boolexpr</name><operator>.</operator><name>anynull</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* result is already set to TRUE, need not change it */</comment>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * If any of its clauses is TRUE, an OR's result is TRUE regardless of
		 * the states of the rest of the clauses, so we can stop evaluating
		 * and return TRUE immediately.  If none are TRUE and one or more is
		 * NULL, we return NULL; otherwise we return FALSE.  This makes sense
		 * when you interpret NULL as "don't know": perhaps one of the "don't
		 * knows" would have been TRUE if we'd known its value.  Only when all
		 * the inputs are known to be FALSE can we state confidently that the
		 * OR's result is FALSE.
		 */</comment>
		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_BOOL_OR_STEP_FIRST</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>boolexpr</name><operator>.</operator><name>anynull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * EEOP_BOOL_OR_STEP_FIRST resets anynull, otherwise it's the same
			 * as EEOP_BOOL_OR_STEP - so fall through to that.
			 */</comment>

			<comment type="block">/* FALL THROUGH */</comment>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_BOOL_OR_STEP</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>boolexpr</name><operator>.</operator><name>anynull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* result is already set to TRUE, need not change it */</comment>
				<comment type="block">/* bail out early */</comment>
				<expr_stmt><expr><call><name>EEO_JUMP</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>boolexpr</name><operator>.</operator><name>jumpdone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_BOOL_OR_STEP_LAST</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* result is already set to NULL, need not change it */</comment>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* result is already set to TRUE, need not change it */</comment>

				<comment type="block">/*
				 * No point jumping to jumpdone - would be same target (as
				 * this is the last argument to the AND expression), except
				 * more expensive.
				 */</comment>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>boolexpr</name><operator>.</operator><name>anynull</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* result is already set to FALSE, need not change it */</comment>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_BOOL_NOT_STEP</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/*
			 * Evaluation of 'not' is simple... if expr is false, then return
			 * 'true' and vice versa.  It's safe to do this even on a
			 * nominally null value, so we ignore resnull; that means that
			 * NULL in produces NULL out, which is what we want.
			 */</comment>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_QUAL</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* simplified version of BOOL_AND_STEP for use by ExecQual() */</comment>

			<comment type="block">/* If argument (also result) is false or null ... */</comment>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>||</operator>
				<operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* ... bail out early, returning FALSE */</comment>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>EEO_JUMP</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>qualexpr</name><operator>.</operator><name>jumpdone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Otherwise, leave the TRUE value in place, in case this is the
			 * last qual.  Then, TRUE is the correct answer.
			 */</comment>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_JUMP</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* Unconditionally jump to target step */</comment>
			<expr_stmt><expr><call><name>EEO_JUMP</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>jump</name><operator>.</operator><name>jumpdone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_JUMP_IF_NULL</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* Transfer control if current result is null */</comment>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>EEO_JUMP</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>jump</name><operator>.</operator><name>jumpdone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_JUMP_IF_NOT_NULL</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* Transfer control if current result is non-null */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>EEO_JUMP</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>jump</name><operator>.</operator><name>jumpdone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_JUMP_IF_NOT_TRUE</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* Transfer control if current result is null or false */</comment>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>||</operator> <operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>EEO_JUMP</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>jump</name><operator>.</operator><name>jumpdone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_NULLTEST_ISNULL</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_NULLTEST_ISNOTNULL</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><operator>!</operator><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_NULLTEST_ROWISNULL</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* out of line implementation: too large */</comment>
			<expr_stmt><expr><call><name>ExecEvalRowNull</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_NULLTEST_ROWISNOTNULL</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* out of line implementation: too large */</comment>
			<expr_stmt><expr><call><name>ExecEvalRowNotNull</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* BooleanTest implementations for all booltesttypes */</comment>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_BOOLTEST_IS_TRUE</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* else, input value is the correct output as well */</comment>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_BOOLTEST_IS_NOT_TRUE</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_BOOLTEST_IS_FALSE</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_BOOLTEST_IS_NOT_FALSE</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* else, input value is the correct output as well */</comment>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_PARAM_EXEC</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* out of line implementation: too large */</comment>
			<expr_stmt><expr><call><name>ExecEvalParamExec</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_PARAM_EXTERN</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* out of line implementation: too large */</comment>
			<expr_stmt><expr><call><name>ExecEvalParamExtern</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_PARAM_CALLBACK</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* allow an extension module to supply a PARAM_EXTERN value */</comment>
			<expr_stmt><expr><call><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>cparam</name><operator>.</operator><name>paramfunc</name></name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_CASE_TESTVAL</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/*
			 * Normally upper parts of the expression tree have setup the
			 * values to be returned here, but some parts of the system
			 * currently misuse {caseValue,domainValue}_{datum,isNull} to set
			 * run-time data.  So if no values have been set-up, use
			 * ExprContext's.  This isn't pretty, but also not *that* ugly,
			 * and this is unlikely to be performance sensitive enough to
			 * worry about an extra branch.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>casetest</name><operator>.</operator><name>value</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>casetest</name><operator>.</operator><name>value</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>casetest</name><operator>.</operator><name>isnull</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <name><name>econtext</name><operator>-&gt;</operator><name>caseValue_datum</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name><name>econtext</name><operator>-&gt;</operator><name>caseValue_isNull</name></name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_DOMAIN_TESTVAL</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/*
			 * See EEOP_CASE_TESTVAL comment.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>casetest</name><operator>.</operator><name>value</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>casetest</name><operator>.</operator><name>value</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>casetest</name><operator>.</operator><name>isnull</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <name><name>econtext</name><operator>-&gt;</operator><name>domainValue_datum</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name><name>econtext</name><operator>-&gt;</operator><name>domainValue_isNull</name></name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_MAKE_READONLY</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/*
			 * Force a varlena value that might be read multiple times to R/O
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>make_readonly</name><operator>.</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator>
					<call><name>MakeExpandedObjectReadOnlyInternal</name><argument_list>(<argument><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>make_readonly</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>make_readonly</name><operator>.</operator><name>isnull</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_IOCOERCE</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/*
			 * Evaluate a CoerceViaIO node.  This can be quite a hot path, so
			 * inline as much work as possible.  The source value is in our
			 * result variable.
			 */</comment>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

			<comment type="block">/* call output function (similar to OutputFunctionCall) */</comment>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* output functions are not called on nulls */</comment>
				<expr_stmt><expr><name>str</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo_out</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>fcinfo_out</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>iocoerce</name><operator>.</operator><name>fcinfo_data_out</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>fcinfo_out</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>fcinfo_out</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>fcinfo_out</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo_out</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* OutputFunctionCall assumes result isn't null */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>fcinfo_out</name><operator>-&gt;</operator><name>isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* call input function (similar to InputFunctionCall) */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>iocoerce</name><operator>.</operator><name>finfo_in</name><operator>-&gt;</operator><name>fn_strict</name></name> <operator>||</operator> <name>str</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo_in</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Datum</name></type>		<name>d</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>fcinfo_in</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>iocoerce</name><operator>.</operator><name>fcinfo_data_in</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>fcinfo_in</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>fcinfo_in</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr>;</expr_stmt>
				<comment type="block">/* second and third arguments are already set up */</comment>

				<expr_stmt><expr><name><name>fcinfo_in</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>

				<comment type="block">/* Should get null result if and only if str is NULL */</comment>
				<if_stmt><if>if <condition>(<expr><name>str</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fcinfo_in</name><operator>-&gt;</operator><name>isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>fcinfo_in</name><operator>-&gt;</operator><name>isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_DISTINCT</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/*
			 * IS DISTINCT FROM must evaluate arguments (already done into
			 * fcinfo-&gt;arg/argnull) to determine whether they are NULL; if
			 * either is NULL then the result is determined.  If neither is
			 * NULL, then proceed to evaluate the comparison function, which
			 * is just the type's standard equality operator.  We need not
			 * care whether that function is strict.  Because the handling of
			 * nulls is different, we can't just reuse EEOP_FUNCEXPR.
			 */</comment>
			<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>func</name><operator>.</operator><name>fcinfo_data</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* check function arguments for NULLness */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Both NULL? Then is not distinct... */</comment>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Only one is NULL? Then is distinct... */</comment>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Neither null, so apply the equality function */</comment>
				<decl_stmt><decl><type><name>Datum</name></type>		<name>eqresult</name></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>eqresult</name> <operator>=</operator> <call><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>func</name><operator>.</operator><name>fn_addr</name></name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Must invert result of "="; safe to do even if null */</comment>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>eqresult</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* see EEOP_DISTINCT for comments, this is just inverted */</comment>
		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_NOT_DISTINCT</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>func</name><operator>.</operator><name>fcinfo_data</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>Datum</name></type>		<name>eqresult</name></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>eqresult</name> <operator>=</operator> <call><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>func</name><operator>.</operator><name>fn_addr</name></name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <name>eqresult</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_NULLIF</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/*
			 * The arguments are already evaluated into fcinfo-&gt;arg/argnull.
			 */</comment>
			<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>func</name><operator>.</operator><name>fcinfo_data</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* if either argument is NULL they can't be equal */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>func</name><operator>.</operator><name>fn_addr</name></name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* if the arguments are equal return null */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>&amp;&amp;</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Arguments aren't equal, so return the first one */</comment>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_SQLVALUEFUNCTION</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/*
			 * Doesn't seem worthwhile to have an inline implementation
			 * efficiency-wise.
			 */</comment>
			<expr_stmt><expr><call><name>ExecEvalSQLValueFunction</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_CURRENTOFEXPR</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* error invocation uses space, and shouldn't ever occur */</comment>
			<expr_stmt><expr><call><name>ExecEvalCurrentOfExpr</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_NEXTVALUEEXPR</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/*
			 * Doesn't seem worthwhile to have an inline implementation
			 * efficiency-wise.
			 */</comment>
			<expr_stmt><expr><call><name>ExecEvalNextValueExpr</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_ARRAYEXPR</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* too complex for an inline implementation */</comment>
			<expr_stmt><expr><call><name>ExecEvalArrayExpr</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_ARRAYCOERCE</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* too complex for an inline implementation */</comment>
			<expr_stmt><expr><call><name>ExecEvalArrayCoerce</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_ROW</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* too complex for an inline implementation */</comment>
			<expr_stmt><expr><call><name>ExecEvalRow</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_ROWCOMPARE_STEP</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>rowcompare_step</name><operator>.</operator><name>fcinfo_data</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>d</name></decl>;</decl_stmt>

			<comment type="block">/* force NULL result if strict fn and NULL input */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>rowcompare_step</name><operator>.</operator><name>finfo</name><operator>-&gt;</operator><name>fn_strict</name></name> <operator>&amp;&amp;</operator>
				<operator>(</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>EEO_JUMP</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>rowcompare_step</name><operator>.</operator><name>jumpnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Apply comparison function */</comment>
			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>rowcompare_step</name><operator>.</operator><name>fn_addr</name></name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>

			<comment type="block">/* force NULL result if NULL function result */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>EEO_JUMP</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>rowcompare_step</name><operator>.</operator><name>jumpnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<comment type="block">/* If unequal, no need to compare remaining columns */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>EEO_JUMP</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>rowcompare_step</name><operator>.</operator><name>jumpdone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_ROWCOMPARE_FINAL</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int32</name></type>		<name>cmpresult</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RowCompareType</name></type> <name>rctype</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>rowcompare_final</name><operator>.</operator><name>rctype</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<switch>switch <condition>(<expr><name>rctype</name></expr>)</condition>
			<block>{<block_content>
					<comment type="block">/* EQ and NE cases aren't allowed here */</comment>
				<case>case <expr><name>ROWCOMPARE_LT</name></expr>:</case>
					<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>cmpresult</name> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>ROWCOMPARE_LE</name></expr>:</case>
					<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>cmpresult</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>ROWCOMPARE_GE</name></expr>:</case>
					<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>cmpresult</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>ROWCOMPARE_GT</name></expr>:</case>
					<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>cmpresult</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_MINMAX</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* too complex for an inline implementation */</comment>
			<expr_stmt><expr><call><name>ExecEvalMinMax</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_FIELDSELECT</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* too complex for an inline implementation */</comment>
			<expr_stmt><expr><call><name>ExecEvalFieldSelect</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_FIELDSTORE_DEFORM</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* too complex for an inline implementation */</comment>
			<expr_stmt><expr><call><name>ExecEvalFieldStoreDeForm</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_FIELDSTORE_FORM</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* too complex for an inline implementation */</comment>
			<expr_stmt><expr><call><name>ExecEvalFieldStoreForm</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_ARRAYREF_SUBSCRIPT</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* Process an array subscript */</comment>

			<comment type="block">/* too complex for an inline implementation */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>ExecEvalArrayRefSubscript</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Subscript is null, short-circuit ArrayRef to NULL */</comment>
				<expr_stmt><expr><call><name>EEO_JUMP</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>arrayref_subscript</name><operator>.</operator><name>jumpdone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_ARRAYREF_OLD</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/*
			 * Fetch the old value in an arrayref assignment, in case it's
			 * referenced (via a CaseTestExpr) inside the assignment
			 * expression.
			 */</comment>

			<comment type="block">/* too complex for an inline implementation */</comment>
			<expr_stmt><expr><call><name>ExecEvalArrayRefOld</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Perform ArrayRef assignment
		 */</comment>
		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_ARRAYREF_ASSIGN</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* too complex for an inline implementation */</comment>
			<expr_stmt><expr><call><name>ExecEvalArrayRefAssign</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Fetch subset of an array.
		 */</comment>
		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_ARRAYREF_FETCH</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* too complex for an inline implementation */</comment>
			<expr_stmt><expr><call><name>ExecEvalArrayRefFetch</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_CONVERT_ROWTYPE</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* too complex for an inline implementation */</comment>
			<expr_stmt><expr><call><name>ExecEvalConvertRowtype</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_SCALARARRAYOP</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* too complex for an inline implementation */</comment>
			<expr_stmt><expr><call><name>ExecEvalScalarArrayOp</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_DOMAIN_NOTNULL</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* too complex for an inline implementation */</comment>
			<expr_stmt><expr><call><name>ExecEvalConstraintNotNull</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_DOMAIN_CHECK</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* too complex for an inline implementation */</comment>
			<expr_stmt><expr><call><name>ExecEvalConstraintCheck</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_XMLEXPR</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* too complex for an inline implementation */</comment>
			<expr_stmt><expr><call><name>ExecEvalXmlExpr</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_AGGREF</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/*
			 * Returns a Datum whose value is the precomputed aggregate value
			 * found in the given expression context.
			 */</comment>
			<decl_stmt><decl><type><name>AggrefExprState</name> <modifier>*</modifier></type><name>aggref</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>aggref</name><operator>.</operator><name>astate</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_aggvalues</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <name><name>econtext</name><operator>-&gt;</operator><name>ecxt_aggvalues</name><index>[<expr><name><name>aggref</name><operator>-&gt;</operator><name>aggno</name></name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name><name>econtext</name><operator>-&gt;</operator><name>ecxt_aggnulls</name><index>[<expr><name><name>aggref</name><operator>-&gt;</operator><name>aggno</name></name></expr>]</index></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_GROUPING_FUNC</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* too complex/uncommon for an inline implementation */</comment>
			<expr_stmt><expr><call><name>ExecEvalGroupingFunc</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_WINDOW_FUNC</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/*
			 * Like Aggref, just return a precomputed value from the econtext.
			 */</comment>
			<decl_stmt><decl><type><name>WindowFuncExprState</name> <modifier>*</modifier></type><name>wfunc</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>window_func</name><operator>.</operator><name>wfstate</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_aggvalues</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <name><name>econtext</name><operator>-&gt;</operator><name>ecxt_aggvalues</name><index>[<expr><name><name>wfunc</name><operator>-&gt;</operator><name>wfuncno</name></name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name><name>econtext</name><operator>-&gt;</operator><name>ecxt_aggnulls</name><index>[<expr><name><name>wfunc</name><operator>-&gt;</operator><name>wfuncno</name></name></expr>]</index></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_SUBPLAN</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* too complex for an inline implementation */</comment>
			<expr_stmt><expr><call><name>ExecEvalSubPlan</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_ALTERNATIVE_SUBPLAN</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* too complex for an inline implementation */</comment>
			<expr_stmt><expr><call><name>ExecEvalAlternativeSubPlan</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* evaluate a strict aggregate deserialization function */</comment>
		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_AGG_STRICT_DESERIALIZE</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>argnull</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_deserialize</name><operator>.</operator><name>fcinfo_data</name><operator>-&gt;</operator><name>argnull</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Don't call a strict deserialization function with NULL input */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>EEO_JUMP</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_deserialize</name><operator>.</operator><name>jumpnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* fallthrough */</comment>
		</block_content>}</block>

		<comment type="block">/* evaluate aggregate deserialization function (non-strict portion) */</comment>
		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_AGG_DESERIALIZE</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_deserialize</name><operator>.</operator><name>fcinfo_data</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AggState</name>   <modifier>*</modifier></type><name>aggstate</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_deserialize</name><operator>.</operator><name>aggstate</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * We run the deserialization functions in per-input-tuple memory
			 * context.
			 */</comment>
			<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>tmpcontext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Check that a strict aggregate transition / combination function's
		 * input is not NULL.
		 */</comment>
		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_AGG_STRICT_INPUT_CHECK</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>argno</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_strict_input_check</name><operator>.</operator><name>nulls</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_strict_input_check</name><operator>.</operator><name>nargs</name></name></expr></init></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>argno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>argno</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>argno</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>nulls</name><index>[<expr><name>argno</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>EEO_JUMP</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_strict_input_check</name><operator>.</operator><name>jumpnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Initialize an aggregate's first value if necessary.
		 */</comment>
		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_AGG_INIT_TRANS</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AggState</name>   <modifier>*</modifier></type><name>aggstate</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AggStatePerGroup</name></type> <name>pergroup</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>aggstate</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_init_trans</name><operator>.</operator><name>aggstate</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>pergroup</name> <operator>=</operator> <operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>all_pergroups</name>
				<index>[<expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_init_trans</name><operator>.</operator><name>setoff</name></name></expr>]</index>
				<index>[<expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_init_trans</name><operator>.</operator><name>transno</name></name></expr>]</index></name></expr>;</expr_stmt>

			<comment type="block">/* If transValue has not yet been initialized, do so now. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>pergroup</name><operator>-&gt;</operator><name>noTransValue</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_init_trans</name><operator>.</operator><name>pertrans</name></name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curaggcontext</name></name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_init_trans</name><operator>.</operator><name>aggcontext</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_init_trans</name><operator>.</operator><name>setno</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ExecAggInitGroup</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>pertrans</name></expr></argument>, <argument><expr><name>pergroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* copied trans value from input, done this round */</comment>
				<expr_stmt><expr><call><name>EEO_JUMP</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_init_trans</name><operator>.</operator><name>jumpnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* check that a strict aggregate's input isn't NULL */</comment>
		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_AGG_STRICT_TRANS_CHECK</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AggState</name>   <modifier>*</modifier></type><name>aggstate</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AggStatePerGroup</name></type> <name>pergroup</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>aggstate</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_strict_trans_check</name><operator>.</operator><name>aggstate</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>pergroup</name> <operator>=</operator> <operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>all_pergroups</name>
				<index>[<expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_strict_trans_check</name><operator>.</operator><name>setoff</name></name></expr>]</index>
				<index>[<expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_strict_trans_check</name><operator>.</operator><name>transno</name></name></expr>]</index></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>pergroup</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>EEO_JUMP</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_strict_trans_check</name><operator>.</operator><name>jumpnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Evaluate aggregate transition / combine function that has a
		 * by-value transition type. That's a seperate case from the
		 * by-reference implementation because it's a bit simpler.
		 */</comment>
		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_AGG_PLAIN_TRANS_BYVAL</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AggState</name>   <modifier>*</modifier></type><name>aggstate</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AggStatePerGroup</name></type> <name>pergroup</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>newVal</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>aggstate</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_trans</name><operator>.</operator><name>aggstate</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>pertrans</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_trans</name><operator>.</operator><name>pertrans</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name>pergroup</name> <operator>=</operator> <operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>all_pergroups</name>
				<index>[<expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_trans</name><operator>.</operator><name>setoff</name></name></expr>]</index>
				<index>[<expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_trans</name><operator>.</operator><name>transno</name></name></expr>]</index></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeByVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>fcinfo</name> <operator>=</operator> <operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transfn_fcinfo</name></name></expr>;</expr_stmt>

			<comment type="block">/* cf. select_current_set() */</comment>
			<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curaggcontext</name></name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_trans</name><operator>.</operator><name>aggcontext</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_trans</name><operator>.</operator><name>setno</name></name></expr>;</expr_stmt>

			<comment type="block">/* set up aggstate-&gt;curpertrans for AggGetAggref() */</comment>
			<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curpertrans</name></name> <operator>=</operator> <name>pertrans</name></expr>;</expr_stmt>

			<comment type="block">/* invoke transition function in per-tuple context */</comment>
			<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>tmpcontext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pergroup</name><operator>-&gt;</operator><name>transValue</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pergroup</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* just in case transfn doesn't set it */</comment>

			<expr_stmt><expr><name>newVal</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>pergroup</name><operator>-&gt;</operator><name>transValue</name></name> <operator>=</operator> <name>newVal</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pergroup</name><operator>-&gt;</operator><name>transValueIsNull</name></name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Evaluate aggregate transition / combine function that has a
		 * by-reference transition type.
		 *
		 * Could optimize a bit further by splitting off by-reference
		 * fixed-length types, but currently that doesn't seem worth it.
		 */</comment>
		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_AGG_PLAIN_TRANS</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AggState</name>   <modifier>*</modifier></type><name>aggstate</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AggStatePerGroup</name></type> <name>pergroup</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>newVal</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>aggstate</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_trans</name><operator>.</operator><name>aggstate</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>pertrans</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_trans</name><operator>.</operator><name>pertrans</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name>pergroup</name> <operator>=</operator> <operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>all_pergroups</name>
				<index>[<expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_trans</name><operator>.</operator><name>setoff</name></name></expr>]</index>
				<index>[<expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_trans</name><operator>.</operator><name>transno</name></name></expr>]</index></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeByVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>fcinfo</name> <operator>=</operator> <operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transfn_fcinfo</name></name></expr>;</expr_stmt>

			<comment type="block">/* cf. select_current_set() */</comment>
			<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curaggcontext</name></name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_trans</name><operator>.</operator><name>aggcontext</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>current_set</name></name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_trans</name><operator>.</operator><name>setno</name></name></expr>;</expr_stmt>

			<comment type="block">/* set up aggstate-&gt;curpertrans for AggGetAggref() */</comment>
			<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curpertrans</name></name> <operator>=</operator> <name>pertrans</name></expr>;</expr_stmt>

			<comment type="block">/* invoke transition function in per-tuple context */</comment>
			<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>tmpcontext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pergroup</name><operator>-&gt;</operator><name>transValue</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pergroup</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* just in case transfn doesn't set it */</comment>

			<expr_stmt><expr><name>newVal</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * For pass-by-ref datatype, must copy the new value into
			 * aggcontext and free the prior transValue.  But if transfn
			 * returned a pointer to its first input, we don't need to do
			 * anything.  Also, if transfn returned a pointer to a R/W
			 * expanded object that is already a child of the aggcontext,
			 * assume we can adopt that value without copying it.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>newVal</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>pergroup</name><operator>-&gt;</operator><name>transValue</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>newVal</name> <operator>=</operator> <call><name>ExecAggTransReparent</name><argument_list>(<argument><expr><name>aggstate</name></expr></argument>, <argument><expr><name>pertrans</name></expr></argument>,
											  <argument><expr><name>newVal</name></expr></argument>, <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr></argument>,
											  <argument><expr><name><name>pergroup</name><operator>-&gt;</operator><name>transValue</name></name></expr></argument>,
											  <argument><expr><name><name>pergroup</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>pergroup</name><operator>-&gt;</operator><name>transValue</name></name> <operator>=</operator> <name>newVal</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pergroup</name><operator>-&gt;</operator><name>transValueIsNull</name></name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* process single-column ordered aggregate datum */</comment>
		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_AGG_ORDERED_TRANS_DATUM</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* too complex for an inline implementation */</comment>
			<expr_stmt><expr><call><name>ExecEvalAggOrderedTransDatum</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* process multi-column ordered aggregate tuple */</comment>
		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_AGG_ORDERED_TRANS_TUPLE</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* too complex for an inline implementation */</comment>
			<expr_stmt><expr><call><name>ExecEvalAggOrderedTransTuple</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EEO_NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>EEO_CASE</name><argument_list>(<argument>EEOP_LAST</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* unreachable */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>out</name>;</goto>
		</block_content>}</block>
	</block_content>}</block>

<label><name>out</name>:</label>
	<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>resnull</name></name></expr>;</expr_stmt>
	<return>return <expr><name><name>state</name><operator>-&gt;</operator><name>resvalue</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Expression evaluation callback that performs extra checks before executing
 * the expression. Declared extern so other methods of execution can use it
 * too.
 */</comment>
<function><type><name>Datum</name></type>
<name>ExecInterpExprStillValid</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * First time through, check whether attribute matches Var.  Might not be
	 * ok anymore, due to schema changes.
	 */</comment>
	<expr_stmt><expr><call><name>CheckExprStillValid</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* skip the check during further executions */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>evalfunc</name></name> <operator>=</operator> <operator>(</operator><name>ExprStateEvalFunc</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>evalfunc_private</name></name></expr>;</expr_stmt>

	<comment type="block">/* and actually execute */</comment>
	<return>return <expr><call><name><name>state</name><operator>-&gt;</operator><name>evalfunc</name></name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check that an expression is still valid in the face of potential schema
 * changes since the plan has been created.
 */</comment>
<function><type><name>void</name></type>
<name>CheckExprStillValid</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>innerslot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>outerslot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>scanslot</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>innerslot</name> <operator>=</operator> <name><name>econtext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>outerslot</name> <operator>=</operator> <name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>scanslot</name> <operator>=</operator> <name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>steps</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><call><name>ExecEvalStepOp</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>EEOP_INNER_VAR</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>var</name><operator>.</operator><name>attnum</name></name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>CheckVarSlotCompatibility</name><argument_list>(<argument><expr><name>innerslot</name></expr></argument>, <argument><expr><name>attnum</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>var</name><operator>.</operator><name>vartype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>

			<case>case <expr><name>EEOP_OUTER_VAR</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>var</name><operator>.</operator><name>attnum</name></name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>CheckVarSlotCompatibility</name><argument_list>(<argument><expr><name>outerslot</name></expr></argument>, <argument><expr><name>attnum</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>var</name><operator>.</operator><name>vartype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>

			<case>case <expr><name>EEOP_SCAN_VAR</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>var</name><operator>.</operator><name>attnum</name></name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>CheckVarSlotCompatibility</name><argument_list>(<argument><expr><name>scanslot</name></expr></argument>, <argument><expr><name>attnum</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>var</name><operator>.</operator><name>vartype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>
			<default>default:</default>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Check whether a user attribute in a slot can be referenced by a Var
 * expression.  This should succeed unless there have been schema changes
 * since the expression tree has been created.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CheckVarSlotCompatibility</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>vartype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * What we have to check for here is the possibility of an attribute
	 * having been dropped or changed in type since the plan tree was created.
	 * Ideally the plan will get invalidated and not re-used, but just in
	 * case, we keep these defenses.  Fortunately it's sufficient to check
	 * once on the first time through.
	 *
	 * Note: ideally we'd check typmod as well as typid, but that seems
	 * impractical at the moment: in many cases the tupdesc will have been
	 * generated by ExecTypeFromTL(), and that can't guarantee to generate an
	 * accurate typmod in all cases, because some expression node types don't
	 * carry typmod.  Fortunately, for precisely that reason, there should be
	 * no places with a critical dependency on the typmod of a value.
	 *
	 * System attributes don't require checking since their types never
	 * change.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>slot_tupdesc</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&gt;</operator> <name><name>slot_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* should never happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"attribute number %d exceeds number of columns %d"</literal></expr></argument>,
				 <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name><name>slot_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>slot_tupdesc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"attribute %d of type %s has been dropped"</literal></expr></argument>,
							<argument><expr><name>attnum</name></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>slot_tupdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>vartype</name> <operator>!=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"attribute %d of type %s has wrong type"</literal></expr></argument>,
							<argument><expr><name>attnum</name></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>slot_tupdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Table has type %s, but query expects %s."</literal></expr></argument>,
							   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>vartype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_cached_rowtype: utility function to lookup a rowtype tupdesc
 *
 * type_id, typmod: identity of the rowtype
 * rowcache: space for caching identity info
 *		(rowcache-&gt;cacheptr must be initialized to NULL)
 * changed: if not NULL, *changed is set to true on any update
 *
 * The returned TupleDesc is not guaranteed pinned; caller must pin it
 * to use it across any operation that might incur cache invalidation.
 * (The TupleDesc is always refcounted, so just use IncrTupleDescRefCount.)
 *
 * NOTE: because composite types can change contents, we must be prepared
 * to re-do this during any node execution; cannot call just once during
 * expression initialization.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleDesc</name></type>
<name>get_cached_rowtype</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type_id</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>,
				   <parameter><decl><type><name>ExprEvalRowtypeCache</name> <modifier>*</modifier></type><name>rowcache</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>changed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>type_id</name> <operator>!=</operator> <name>RECORDOID</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * It's a named composite type, so use the regular typcache.  Do a
		 * lookup first time through, or if the composite type changed.  Note:
		 * "tupdesc_id == 0" may look redundant, but it protects against the
		 * admittedly-theoretical possibility that type_id was RECORDOID the
		 * last time through, so that the cacheptr isn't TypeCacheEntry *.
		 */</comment>
		<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name> <init>= <expr><operator>(</operator><name>TypeCacheEntry</name> <operator>*</operator><operator>)</operator> <name><name>rowcache</name><operator>-&gt;</operator><name>cacheptr</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>typentry</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
					 <name><name>rowcache</name><operator>-&gt;</operator><name>tupdesc_id</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					 <name><name>typentry</name><operator>-&gt;</operator><name>tupDesc_identifier</name></name> <operator>!=</operator> <name><name>rowcache</name><operator>-&gt;</operator><name>tupdesc_id</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>type_id</name></expr></argument>, <argument><expr><name>TYPECACHE_TUPDESC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type %s is not composite"</literal></expr></argument>,
								<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>type_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>rowcache</name><operator>-&gt;</operator><name>cacheptr</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>typentry</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rowcache</name><operator>-&gt;</operator><name>tupdesc_id</name></name> <operator>=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>tupDesc_identifier</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>changed</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name><name>typentry</name><operator>-&gt;</operator><name>tupDesc</name></name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * A RECORD type, once registered, doesn't change for the life of the
		 * backend.  So we don't need a typcache entry as such, which is good
		 * because there isn't one.  It's possible that the caller is asking
		 * about a different type than before, though.
		 */</comment>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name> <init>= <expr><operator>(</operator><name>TupleDesc</name><operator>)</operator> <name><name>rowcache</name><operator>-&gt;</operator><name>cacheptr</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>tupDesc</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
					 <name><name>rowcache</name><operator>-&gt;</operator><name>tupdesc_id</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
					 <name>type_id</name> <operator>!=</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>tdtypeid</name></name> <operator>||</operator>
					 <name>typmod</name> <operator>!=</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><name>type_id</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Drop pin acquired by lookup_rowtype_tupdesc */</comment>
			<expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rowcache</name><operator>-&gt;</operator><name>cacheptr</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>tupDesc</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rowcache</name><operator>-&gt;</operator><name>tupdesc_id</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* not a valid value for non-RECORD */</comment>
			<if_stmt><if>if <condition>(<expr><name>changed</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>tupDesc</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Fast-path functions, for very simple expressions
 */</comment>

<comment type="block">/* Simple reference to inner Var */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>ExecJustInnerVar</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>steps</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>var</name><operator>.</operator><name>attnum</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Since we use slot_getattr(), we don't need to implement the FETCHSOME
	 * step explicitly, and we also needn't Assert that the attnum is in range
	 * --- slot_getattr() will take care of any problems.
	 */</comment>
	<return>return <expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Simple reference to outer Var */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>ExecJustOuterVar</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>steps</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>var</name><operator>.</operator><name>attnum</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* See comments in ExecJustInnerVar */</comment>
	<return>return <expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Simple reference to scan Var */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>ExecJustScanVar</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>steps</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>var</name><operator>.</operator><name>attnum</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* See comments in ExecJustInnerVar */</comment>
	<return>return <expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Simple Const expression */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>ExecJustConst</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>steps</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>constval</name><operator>.</operator><name>isnull</name></name></expr>;</expr_stmt>
	<return>return <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>constval</name><operator>.</operator><name>value</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Evaluate inner Var and assign to appropriate column of result tuple */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>ExecJustAssignInnerVar</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>steps</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>assign_var</name><operator>.</operator><name>attnum</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>resultnum</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>assign_var</name><operator>.</operator><name>resultnum</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>inslot</name> <init>= <expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>outslot</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>resultslot</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We do not need CheckVarSlotCompatibility here; that was taken care of
	 * at compilation time.
	 *
	 * Since we use slot_getattr(), we don't need to implement the FETCHSOME
	 * step explicitly, and we also needn't Assert that the attnum is in range
	 * --- slot_getattr() will take care of any problems.  Nonetheless, check
	 * that resultnum is in range.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>resultnum</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>resultnum</name> <operator>&lt;</operator> <name><name>outslot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>outslot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>resultnum</name></expr>]</index></name> <operator>=</operator>
		<call><name>slot_getattr</name><argument_list>(<argument><expr><name>inslot</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>outslot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>resultnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Evaluate outer Var and assign to appropriate column of result tuple */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>ExecJustAssignOuterVar</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>steps</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>assign_var</name><operator>.</operator><name>attnum</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>resultnum</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>assign_var</name><operator>.</operator><name>resultnum</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>inslot</name> <init>= <expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>outslot</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>resultslot</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* See comments in ExecJustAssignInnerVar */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>resultnum</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>resultnum</name> <operator>&lt;</operator> <name><name>outslot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>outslot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>resultnum</name></expr>]</index></name> <operator>=</operator>
		<call><name>slot_getattr</name><argument_list>(<argument><expr><name>inslot</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>outslot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>resultnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Evaluate scan Var and assign to appropriate column of result tuple */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>ExecJustAssignScanVar</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>steps</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>assign_var</name><operator>.</operator><name>attnum</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>resultnum</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>assign_var</name><operator>.</operator><name>resultnum</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>inslot</name> <init>= <expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>outslot</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>resultslot</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* See comments in ExecJustAssignInnerVar */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>resultnum</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>resultnum</name> <operator>&lt;</operator> <name><name>outslot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>outslot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>resultnum</name></expr>]</index></name> <operator>=</operator>
		<call><name>slot_getattr</name><argument_list>(<argument><expr><name>inslot</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>outslot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>resultnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Evaluate CASE_TESTVAL and apply a strict function to it */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>ExecJustApplyFuncToCase</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>steps</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>argnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>argno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>d</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * XXX with some redesign of the CaseTestExpr mechanism, maybe we could
	 * get rid of this data shuffling?
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>casetest</name><operator>.</operator><name>value</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>casetest</name><operator>.</operator><name>isnull</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>op</name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>fcinfo</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>func</name><operator>.</operator><name>fcinfo_data</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>argnull</name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name></name></expr>;</expr_stmt>

	<comment type="block">/* strict function, so check for NULL args */</comment>
	<for>for <control>(<init><expr><name>argno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>argno</name> <operator>&lt;</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>func</name><operator>.</operator><name>nargs</name></name></expr>;</condition> <incr><expr><name>argno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>argnull</name><index>[<expr><name>argno</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>func</name><operator>.</operator><name>fn_addr</name></name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>
	<return>return <expr><name>d</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EEO_USE_COMPUTED_GOTO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
 * Comparator used when building address-&gt;opcode lookup table for
 * ExecEvalStepOp() in the threaded dispatch case.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dispatch_compare_ptr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ExprEvalOpLookup</name> <modifier>*</modifier></type><name>la</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>ExprEvalOpLookup</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ExprEvalOpLookup</name> <modifier>*</modifier></type><name>lb</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>ExprEvalOpLookup</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>la</name><operator>-&gt;</operator><name>opcode</name></name> <operator>&lt;</operator> <name><name>lb</name><operator>-&gt;</operator><name>opcode</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>la</name><operator>-&gt;</operator><name>opcode</name></name> <operator>&gt;</operator> <name><name>lb</name><operator>-&gt;</operator><name>opcode</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Do one-time initialization of interpretation machinery.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecInitInterpreter</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EEO_USE_COMPUTED_GOTO</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<comment type="block">/* Set up externally-visible pointer to dispatch table */</comment>
	<if_stmt><if>if <condition>(<expr><name>dispatch_table</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dispatch_table</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator>
			<call><name>DatumGetPointer</name><argument_list>(<argument><expr><call><name>ExecInterpExpr</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* build reverse lookup table */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>EEOP_LAST</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>reverse_dispatch_table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>opcode</name> <operator>=</operator> <name><name>dispatch_table</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>reverse_dispatch_table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>op</name> <operator>=</operator> <operator>(</operator><name>ExprEvalOp</name><operator>)</operator> <name>i</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* make it bsearch()able */</comment>
		<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>reverse_dispatch_table</name></expr></argument>,
			  <argument><expr><name>EEOP_LAST</name></expr></argument> <comment type="block">/* nmembers */</comment> ,
			  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExprEvalOpLookup</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			  <argument><expr><name>dispatch_compare_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Function to return the opcode of an expression step.
 *
 * When direct-threading is in use, ExprState-&gt;opcode isn't easily
 * decipherable. This function returns the appropriate enum member.
 */</comment>
<function><type><name>ExprEvalOp</name></type>
<name>ExecEvalStepOp</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EEO_USE_COMPUTED_GOTO</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EEO_FLAG_DIRECT_THREADED</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExprEvalOpLookup</name></type> <name>key</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExprEvalOpLookup</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>key</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>op</name><operator>-&gt;</operator><name>opcode</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>bsearch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,
					  <argument><expr><name>reverse_dispatch_table</name></expr></argument>,
					  <argument><expr><name>EEOP_LAST</name></expr></argument> <comment type="block">/* nmembers */</comment> ,
					  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExprEvalOpLookup</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					  <argument><expr><name>dispatch_compare_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>			<comment type="block">/* unknown ops shouldn't get looked up */</comment>
		<return>return <expr><name><name>res</name><operator>-&gt;</operator><name>op</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><operator>(</operator><name>ExprEvalOp</name><operator>)</operator> <name><name>op</name><operator>-&gt;</operator><name>opcode</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Out-of-line helper functions for complex instructions.
 */</comment>

<comment type="block">/*
 * Evaluate EEOP_FUNCEXPR_FUSAGE
 */</comment>
<function><type><name>void</name></type>
<name>ExecEvalFuncExprFusage</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>,
					   <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>func</name><operator>.</operator><name>fcinfo_data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgStat_FunctionCallUsage</name></type> <name>fcusage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>d</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pgstat_init_function_usage</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fcusage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>func</name><operator>.</operator><name>fn_addr</name></name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_end_function_usage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fcusage</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Evaluate EEOP_FUNCEXPR_STRICT_FUSAGE
 */</comment>
<function><type><name>void</name></type>
<name>ExecEvalFuncExprStrictFusage</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>,
							 <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content>

	<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>func</name><operator>.</operator><name>fcinfo_data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgStat_FunctionCallUsage</name></type> <name>fcusage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>argnull</name> <init>= <expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>argno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>d</name></decl>;</decl_stmt>

	<comment type="block">/* strict function, so check for NULL args */</comment>
	<for>for <control>(<init><expr><name>argno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>argno</name> <operator>&lt;</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>func</name><operator>.</operator><name>nargs</name></name></expr>;</condition> <incr><expr><name>argno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>argnull</name><index>[<expr><name>argno</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pgstat_init_function_usage</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fcusage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>func</name><operator>.</operator><name>fn_addr</name></name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_end_function_usage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fcusage</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Evaluate a PARAM_EXEC parameter.
 *
 * PARAM_EXEC params (internal executor parameters) are stored in the
 * ecxt_param_exec_vals array, and can be accessed by array index.
 */</comment>
<function><type><name>void</name></type>
<name>ExecEvalParamExec</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParamExecData</name> <modifier>*</modifier></type><name>prm</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>prm</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_param_exec_vals</name><index>[<expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>param</name><operator>.</operator><name>paramid</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>execPlan</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Parameter not evaluated yet, so go do it */</comment>
		<expr_stmt><expr><call><name>ExecSetParamPlan</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>execPlan</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* ExecSetParamPlan should have processed this param... */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>execPlan</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <name><name>prm</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Evaluate a PARAM_EXTERN parameter.
 *
 * PARAM_EXTERN parameters must be sought in ecxt_param_list_info.
 */</comment>
<function><type><name>void</name></type>
<name>ExecEvalParamExtern</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramInfo</name> <init>= <expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_param_list_info</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>paramId</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>param</name><operator>.</operator><name>paramid</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><name>paramInfo</name> <operator>&amp;&amp;</operator>
			   <name>paramId</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>paramId</name> <operator>&lt;=</operator> <name><name>paramInfo</name><operator>-&gt;</operator><name>numParams</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ParamExternData</name> <modifier>*</modifier></type><name>prm</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ParamExternData</name></type> <name>prmdata</name></decl>;</decl_stmt>

		<comment type="block">/* give hook a chance in case parameter is dynamic */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>paramInfo</name><operator>-&gt;</operator><name>paramFetch</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>prm</name> <operator>=</operator> <call><name><name>paramInfo</name><operator>-&gt;</operator><name>paramFetch</name></name><argument_list>(<argument><expr><name>paramInfo</name></expr></argument>, <argument><expr><name>paramId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prmdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>prm</name> <operator>=</operator> <operator>&amp;</operator><name><name>paramInfo</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>paramId</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* safety check in case hook did something unexpected */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name> <operator>!=</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>param</name><operator>.</operator><name>paramtype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type of parameter %d (%s) does not match that when preparing the plan (%s)"</literal></expr></argument>,
								<argument><expr><name>paramId</name></expr></argument>,
								<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>param</name><operator>.</operator><name>paramtype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <name><name>prm</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no value found for parameter %d"</literal></expr></argument>, <argument><expr><name>paramId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Evaluate a SQLValueFunction expression.
 */</comment>
<function><type><name>void</name></type>
<name>ExecEvalSQLValueFunction</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SQLValueFunction</name> <modifier>*</modifier></type><name>svf</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>sqlvaluefunction</name><operator>.</operator><name>svf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FunctionCallInfoData</name></type> <name>fcinfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note: current_schema() can return NULL.  current_user() etc currently
	 * cannot, but might as well code those cases the same way for safety.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>svf</name><operator>-&gt;</operator><name>op</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SVFOP_CURRENT_DATE</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>DateADTGetDatum</name><argument_list>(<argument><expr><call><name>GetSQLCurrentDate</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SVFOP_CURRENT_TIME</name></expr>:</case>
		<case>case <expr><name>SVFOP_CURRENT_TIME_N</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>TimeTzADTPGetDatum</name><argument_list>(<argument><expr><call><name>GetSQLCurrentTime</name><argument_list>(<argument><expr><name><name>svf</name><operator>-&gt;</operator><name>typmod</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SVFOP_CURRENT_TIMESTAMP</name></expr>:</case>
		<case>case <expr><name>SVFOP_CURRENT_TIMESTAMP_N</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><call><name>GetSQLCurrentTimestamp</name><argument_list>(<argument><expr><name><name>svf</name><operator>-&gt;</operator><name>typmod</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SVFOP_LOCALTIME</name></expr>:</case>
		<case>case <expr><name>SVFOP_LOCALTIME_N</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>TimeADTGetDatum</name><argument_list>(<argument><expr><call><name>GetSQLLocalTime</name><argument_list>(<argument><expr><name><name>svf</name><operator>-&gt;</operator><name>typmod</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SVFOP_LOCALTIMESTAMP</name></expr>:</case>
		<case>case <expr><name>SVFOP_LOCALTIMESTAMP_N</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>TimestampGetDatum</name><argument_list>(<argument><expr><call><name>GetSQLLocalTimestamp</name><argument_list>(<argument><expr><name><name>svf</name><operator>-&gt;</operator><name>typmod</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SVFOP_CURRENT_ROLE</name></expr>:</case>
		<case>case <expr><name>SVFOP_CURRENT_USER</name></expr>:</case>
		<case>case <expr><name>SVFOP_USER</name></expr>:</case>
			<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>current_user</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name><name>fcinfo</name><operator>.</operator><name>isnull</name></name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SVFOP_SESSION_USER</name></expr>:</case>
			<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>session_user</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name><name>fcinfo</name><operator>.</operator><name>isnull</name></name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SVFOP_CURRENT_CATALOG</name></expr>:</case>
			<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>current_database</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name><name>fcinfo</name><operator>.</operator><name>isnull</name></name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SVFOP_CURRENT_SCHEMA</name></expr>:</case>
			<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>current_schema</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name><name>fcinfo</name><operator>.</operator><name>isnull</name></name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Raise error if a CURRENT OF expression is evaluated.
 *
 * The planner should convert CURRENT OF into a TidScan qualification, or some
 * other special handling in a ForeignScan node.  So we have to be able to do
 * ExecInitExpr on a CurrentOfExpr, but we shouldn't ever actually execute it.
 * If we get here, we suppose we must be dealing with CURRENT OF on a foreign
 * table whose FDW doesn't handle it, and complain accordingly.
 */</comment>
<function><type><name>void</name></type>
<name>ExecEvalCurrentOfExpr</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"WHERE CURRENT OF is not supported for this table type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Evaluate NextValueExpr.
 */</comment>
<function><type><name>void</name></type>
<name>ExecEvalNextValueExpr</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>		<name>newval</name> <init>= <expr><call><name>nextval_internal</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>nextvalueexpr</name><operator>.</operator><name>seqid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>nextvalueexpr</name><operator>.</operator><name>seqtypid</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INT2OID</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>Int16GetDatum</name><argument_list>(<argument><expr><operator>(</operator><name>int16</name><operator>)</operator> <name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>INT4OID</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>(</operator><name>int32</name><operator>)</operator> <name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>INT8OID</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported sequence type %u"</literal></expr></argument>,
				 <argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>nextvalueexpr</name><operator>.</operator><name>seqtypid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
	<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Evaluate NullTest / IS NULL for rows.
 */</comment>
<function><type><name>void</name></type>
<name>ExecEvalRowNull</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ExecEvalRowNullInt</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Evaluate NullTest / IS NOT NULL for rows.
 */</comment>
<function><type><name>void</name></type>
<name>ExecEvalRowNotNull</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ExecEvalRowNullInt</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Common code for IS [NOT] NULL on a row value */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecEvalRowNullInt</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>,
				   <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>checkisnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name> <init>= <expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name> <init>= <expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>tupType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>tupTypmod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tmptup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>att</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* NULL row variables are treated just as NULL scalar columns */</comment>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>checkisnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The SQL standard defines IS [NOT] NULL for a non-null rowtype argument
	 * as:
	 *
	 * "R IS NULL" is true if every field is the null value.
	 *
	 * "R IS NOT NULL" is true if no field is the null value.
	 *
	 * This definition is (apparently intentionally) not recursive; so our
	 * tests on the fields are primitive attisnull tests, not recursive checks
	 * to see if they are all-nulls or no-nulls rowtypes.
	 *
	 * The standard does not consider the possibility of zero-field rows, but
	 * here we consider them to vacuously satisfy both predicates.
	 */</comment>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>DatumGetHeapTupleHeader</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tupType</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypeId</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupTypmod</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypMod</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Lookup tupdesc if first time through or if type changes */</comment>
	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>get_cached_rowtype</name><argument_list>(<argument><expr><name>tupType</name></expr></argument>, <argument><expr><name>tupTypmod</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>nulltest_row</name><operator>.</operator><name>rowcache</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * heap_attisnull needs a HeapTuple not a bare HeapTupleHeader.
	 */</comment>
	<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetDatumLength</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>tuple</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>att</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>att</name> <operator>&lt;=</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>att</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* ignore dropped columns */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>att</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>heap_attisnull</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmptup</name></expr></argument>, <argument><expr><name>att</name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* null field disproves IS NOT NULL */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>checkisnull</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* non-null field disproves IS NULL */</comment>
			<if_stmt><if>if <condition>(<expr><name>checkisnull</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Evaluate an ARRAY[] expression.
 *
 * The individual array elements (or subarrays) have already been evaluated
 * into op-&gt;d.arrayexpr.elemvalues[]/elemnulls[].
 */</comment>
<function><type><name>void</name></type>
<name>ExecEvalArrayExpr</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>element_type</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>arrayexpr</name><operator>.</operator><name>elemtype</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nelems</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>arrayexpr</name><operator>.</operator><name>nelems</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndims</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>dims</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>lbs</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* Set non-null as default */</comment>
	<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>arrayexpr</name><operator>.</operator><name>multidims</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Elements are presumably of scalar type */</comment>
		<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>dvalues</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>arrayexpr</name><operator>.</operator><name>elemvalues</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>dnulls</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>arrayexpr</name><operator>.</operator><name>elemnulls</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* setup for 1-D array of the given length */</comment>
		<expr_stmt><expr><name>ndims</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dims</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>nelems</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lbs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>construct_md_array</name><argument_list>(<argument><expr><name>dvalues</name></expr></argument>, <argument><expr><name>dnulls</name></expr></argument>, <argument><expr><name>ndims</name></expr></argument>, <argument><expr><name>dims</name></expr></argument>, <argument><expr><name>lbs</name></expr></argument>,
									<argument><expr><name>element_type</name></expr></argument>,
									<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>arrayexpr</name><operator>.</operator><name>elemlength</name></name></expr></argument>,
									<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>arrayexpr</name><operator>.</operator><name>elembyval</name></name></expr></argument>,
									<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>arrayexpr</name><operator>.</operator><name>elemalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Must be nested array expressions */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>nbytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nitems</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>outer_nelems</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>elem_ndims</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>elem_dims</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>elem_lbs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>firstone</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>havenulls</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>haveempty</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>subdata</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bits8</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>subbitmaps</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>subbytes</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>subnitems</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>dataoffset</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dat</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>iitem</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>elemoff</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>subdata</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nelems</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>subbitmaps</name> <operator>=</operator> <operator>(</operator><name>bits8</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nelems</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bits8</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>subbytes</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nelems</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>subnitems</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nelems</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* loop through and get data area from each element */</comment>
		<for>for <control>(<init><expr><name>elemoff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>elemoff</name> <operator>&lt;</operator> <name>nelems</name></expr>;</condition> <incr><expr><name>elemoff</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>arraydatum</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>eisnull</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>array</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>this_ndims</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>arraydatum</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>arrayexpr</name><operator>.</operator><name>elemvalues</name><index>[<expr><name>elemoff</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>eisnull</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>arrayexpr</name><operator>.</operator><name>elemnulls</name><index>[<expr><name>elemoff</name></expr>]</index></name></expr>;</expr_stmt>

			<comment type="block">/* temporarily ignore null subarrays */</comment>
			<if_stmt><if>if <condition>(<expr><name>eisnull</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>haveempty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>array</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>arraydatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* run-time double-check on element type */</comment>
			<if_stmt><if>if <condition>(<expr><name>element_type</name> <operator>!=</operator> <call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot merge incompatible arrays"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Array with element type %s cannot be "</literal>
								   <literal type="string">"included in ARRAY construct with element type %s."</literal></expr></argument>,
								   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>this_ndims</name> <operator>=</operator> <call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* temporarily ignore zero-dimensional subarrays */</comment>
			<if_stmt><if>if <condition>(<expr><name>this_ndims</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>haveempty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>firstone</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Get sub-array details from first member */</comment>
				<expr_stmt><expr><name>elem_ndims</name> <operator>=</operator> <name>this_ndims</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>ndims</name> <operator>=</operator> <name>elem_ndims</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>ndims</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>ndims</name> <operator>&gt;</operator> <name>MAXDIM</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of array dimensions (%d) exceeds "</literal> \
									<literal type="string">"the maximum allowed (%d)"</literal></expr></argument>, <argument><expr><name>ndims</name></expr></argument>, <argument><expr><name>MAXDIM</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>elem_dims</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>elem_ndims</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>elem_dims</name></expr></argument>, <argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>elem_ndims</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>elem_lbs</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>elem_ndims</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>elem_lbs</name></expr></argument>, <argument><expr><call><name>ARR_LBOUND</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>elem_ndims</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>firstone</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Check other sub-arrays are compatible */</comment>
				<if_stmt><if>if <condition>(<expr><name>elem_ndims</name> <operator>!=</operator> <name>this_ndims</name> <operator>||</operator>
					<call><name>memcmp</name><argument_list>(<argument><expr><name>elem_dims</name></expr></argument>, <argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name>elem_ndims</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
					<call><name>memcmp</name><argument_list>(<argument><expr><name>elem_lbs</name></expr></argument>, <argument><expr><call><name>ARR_LBOUND</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name>elem_ndims</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multidimensional arrays must have array "</literal>
									<literal type="string">"expressions with matching dimensions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name><name>subdata</name><index>[<expr><name>outer_nelems</name></expr>]</index></name> <operator>=</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>subbitmaps</name><index>[<expr><name>outer_nelems</name></expr>]</index></name> <operator>=</operator> <call><name>ARR_NULLBITMAP</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>subbytes</name><index>[<expr><name>outer_nelems</name></expr>]</index></name> <operator>=</operator> <call><name>ARR_SIZE</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>ARR_DATA_OFFSET</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>nbytes</name> <operator>+=</operator> <name><name>subbytes</name><index>[<expr><name>outer_nelems</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>subnitems</name><index>[<expr><name>outer_nelems</name></expr>]</index></name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><name>this_ndims</name></expr></argument>,
													 <argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>nitems</name> <operator>+=</operator> <name><name>subnitems</name><index>[<expr><name>outer_nelems</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>havenulls</name> <operator>|=</operator> <call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>outer_nelems</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * If all items were null or empty arrays, return an empty array;
		 * otherwise, if some were and some weren't, raise error.  (Note: we
		 * must special-case this somehow to avoid trying to generate a 1-D
		 * array formed from empty arrays.  It's not ideal...)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>haveempty</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>ndims</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>		<comment type="block">/* didn't find any nonempty array */</comment>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>construct_empty_array</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multidimensional arrays must have array "</literal>
							<literal type="string">"expressions with matching dimensions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* setup for multi-D array */</comment>
		<expr_stmt><expr><name><name>dims</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>outer_nelems</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lbs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndims</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>dims</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>elem_dims</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>lbs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>elem_lbs</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* check for subscript overflow */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><name>ndims</name></expr></argument>, <argument><expr><name>dims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ArrayCheckBounds</name><argument_list>(<argument><expr><name>ndims</name></expr></argument>, <argument><expr><name>dims</name></expr></argument>, <argument><expr><name>lbs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>havenulls</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>dataoffset</name> <operator>=</operator> <call><name>ARR_OVERHEAD_WITHNULLS</name><argument_list>(<argument><expr><name>ndims</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>nbytes</name> <operator>+=</operator> <name>dataoffset</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>dataoffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>		<comment type="block">/* marker for no null bitmap */</comment>
			<expr_stmt><expr><name>nbytes</name> <operator>+=</operator> <call><name>ARR_OVERHEAD_NONULLS</name><argument_list>(<argument><expr><name>ndims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>ArrayType</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>ndim</name></name> <operator>=</operator> <name>ndims</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dataoffset</name></name> <operator>=</operator> <name>dataoffset</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>elemtype</name></name> <operator>=</operator> <name>element_type</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dims</name></expr></argument>, <argument><expr><name>ndims</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>ARR_LBOUND</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lbs</name></expr></argument>, <argument><expr><name>ndims</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>dat</name> <operator>=</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>iitem</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>outer_nelems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dat</name></expr></argument>, <argument><expr><name><name>subdata</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>subbytes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>dat</name> <operator>+=</operator> <name><name>subbytes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>havenulls</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>array_bitmap_copy</name><argument_list>(<argument><expr><call><name>ARR_NULLBITMAP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>iitem</name></expr></argument>,
								  <argument><expr><name><name>subbitmaps</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								  <argument><expr><name><name>subnitems</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>iitem</name> <operator>+=</operator> <name><name>subnitems</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Evaluate an ArrayCoerceExpr expression.
 *
 * Source array is in step's result variable.
 */</comment>
<function><type><name>void</name></type>
<name>ExecEvalArrayCoerce</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>arraydatum</name></decl>;</decl_stmt>

	<comment type="block">/* NULL array -&gt; NULL result */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>arraydatum</name> <operator>=</operator> <operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it's binary-compatible, modify the element type in the array header,
	 * but otherwise leave the array as we received it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>arraycoerce</name><operator>.</operator><name>elemexprstate</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Detoast input array if necessary, and copy in any case */</comment>
		<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>array</name> <init>= <expr><call><name>DatumGetArrayTypePCopy</name><argument_list>(<argument><expr><name>arraydatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>arraycoerce</name><operator>.</operator><name>resultelemtype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Use array_map to apply the sub-expression to each array element.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>array_map</name><argument_list>(<argument><expr><name>arraydatum</name></expr></argument>,
							  <argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>arraycoerce</name><operator>.</operator><name>elemexprstate</name></name></expr></argument>,
							  <argument><expr><name>econtext</name></expr></argument>,
							  <argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>arraycoerce</name><operator>.</operator><name>resultelemtype</name></name></expr></argument>,
							  <argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>arraycoerce</name><operator>.</operator><name>amstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Evaluate a ROW() expression.
 *
 * The individual columns have already been evaluated into
 * op-&gt;d.row.elemvalues[]/elemnulls[].
 */</comment>
<function><type><name>void</name></type>
<name>ExecEvalRow</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<comment type="block">/* build tuple from evaluated field values */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>row</name><operator>.</operator><name>tupdesc</name></name></expr></argument>,
							<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>row</name><operator>.</operator><name>elemvalues</name></name></expr></argument>,
							<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>row</name><operator>.</operator><name>elemnulls</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Evaluate GREATEST() or LEAST() expression (note this is *not* MIN()/MAX()).
 *
 * All of the to-be-compared expressions have already been evaluated into
 * op-&gt;d.minmax.values[]/nulls[].
 */</comment>
<function><type><name>void</name></type>
<name>ExecEvalMinMax</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>minmax</name><operator>.</operator><name>values</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>minmax</name><operator>.</operator><name>nulls</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>minmax</name><operator>.</operator><name>fcinfo_data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MinMaxOp</name></type>	<name>operator</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>minmax</name><operator>.</operator><name>op</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>off</name></decl>;</decl_stmt>

	<comment type="block">/* set at initialization */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* default to null result */</comment>
	<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>off</name> <operator>&lt;</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>minmax</name><operator>.</operator><name>nelems</name></name></expr>;</condition> <incr><expr><name>off</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* ignore NULL inputs */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>nulls</name><index>[<expr><name>off</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* first nonnull input, adopt value */</comment>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <name><name>values</name><index>[<expr><name>off</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>cmpresult</name></decl>;</decl_stmt>

			<comment type="block">/* apply comparison function */</comment>
			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>values</name><index>[<expr><name>off</name></expr>]</index></name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>cmpresult</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* probably should not happen */</comment>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>cmpresult</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>operator</name> <operator>==</operator> <name>IS_LEAST</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <name><name>values</name><index>[<expr><name>off</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>cmpresult</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>operator</name> <operator>==</operator> <name>IS_GREATEST</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <name><name>values</name><index>[<expr><name>off</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Evaluate a FieldSelect node.
 *
 * Source record is in step's result variable.
 */</comment>
<function><type><name>void</name></type>
<name>ExecEvalFieldSelect</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>fieldnum</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>fieldselect</name><operator>.</operator><name>fieldnum</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>tupDatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>tupType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>tupTypmod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tmptup</name></decl>;</decl_stmt>

	<comment type="block">/* NULL record -&gt; NULL result */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tupDatum</name> <operator>=</operator> <operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name></expr>;</expr_stmt>

	<comment type="block">/* We can special-case expanded records for speed */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_EXPANDED</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>tupDatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>erh</name> <init>= <expr><operator>(</operator><name>ExpandedRecordHeader</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetEOHP</name><argument_list>(<argument><expr><name>tupDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>erh</name><operator>-&gt;</operator><name>er_magic</name></name> <operator>==</operator> <name>ER_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Extract record's TupleDesc */</comment>
		<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>expanded_record_get_tupdesc</name><argument_list>(<argument><expr><name>erh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Find field's attr record.  Note we don't support system columns
		 * here: a datum tuple doesn't have valid values for most of the
		 * interesting system columns anyway.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>fieldnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* should never happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported reference to system column %d in FieldSelect"</literal></expr></argument>,
				 <argument><expr><name>fieldnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>fieldnum</name> <operator>&gt;</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* should never happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"attribute number %d exceeds number of columns %d"</literal></expr></argument>,
				 <argument><expr><name>fieldnum</name></expr></argument>, <argument><expr><name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>fieldnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Check for dropped column, and force a NULL result if so */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Check for type mismatch --- possible after ALTER COLUMN TYPE? */</comment>
		<comment type="block">/* As in CheckVarSlotCompatibility, we should but can't check typmod */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>fieldselect</name><operator>.</operator><name>resulttype</name></name> <operator>!=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"attribute %d has wrong type"</literal></expr></argument>, <argument><expr><name>fieldnum</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Table has type %s, but query expects %s."</literal></expr></argument>,
							   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>fieldselect</name><operator>.</operator><name>resulttype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* extract the field */</comment>
		<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>expanded_record_get_field</name><argument_list>(<argument><expr><name>erh</name></expr></argument>, <argument><expr><name>fieldnum</name></expr></argument>,
												  <argument><expr><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Get the composite datum and extract its type fields */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>DatumGetHeapTupleHeader</name><argument_list>(<argument><expr><name>tupDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tupType</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypeId</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tupTypmod</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypMod</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Lookup tupdesc if first time through or if type changes */</comment>
		<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>get_cached_rowtype</name><argument_list>(<argument><expr><name>tupType</name></expr></argument>, <argument><expr><name>tupTypmod</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>fieldselect</name><operator>.</operator><name>rowcache</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Find field's attr record.  Note we don't support system columns
		 * here: a datum tuple doesn't have valid values for most of the
		 * interesting system columns anyway.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>fieldnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* should never happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported reference to system column %d in FieldSelect"</literal></expr></argument>,
				 <argument><expr><name>fieldnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>fieldnum</name> <operator>&gt;</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* should never happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"attribute number %d exceeds number of columns %d"</literal></expr></argument>,
				 <argument><expr><name>fieldnum</name></expr></argument>, <argument><expr><name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>fieldnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Check for dropped column, and force a NULL result if so */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Check for type mismatch --- possible after ALTER COLUMN TYPE? */</comment>
		<comment type="block">/* As in CheckVarSlotCompatibility, we should but can't check typmod */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>fieldselect</name><operator>.</operator><name>resulttype</name></name> <operator>!=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"attribute %d has wrong type"</literal></expr></argument>, <argument><expr><name>fieldnum</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Table has type %s, but query expects %s."</literal></expr></argument>,
							   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>fieldselect</name><operator>.</operator><name>resulttype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* heap_getattr needs a HeapTuple not a bare HeapTupleHeader */</comment>
		<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetDatumLength</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>tuple</name></expr>;</expr_stmt>

		<comment type="block">/* extract the field */</comment>
		<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmptup</name></expr></argument>,
									 <argument><expr><name>fieldnum</name></expr></argument>,
									 <argument><expr><name>tupDesc</name></expr></argument>,
									 <argument><expr><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deform source tuple, filling in the step's values/nulls arrays, before
 * evaluating individual new values as part of a FieldStore expression.
 * Subsequent steps will overwrite individual elements of the values/nulls
 * arrays with the new field values, and then FIELDSTORE_FORM will build the
 * new tuple value.
 *
 * Source record is in step's result variable.
 */</comment>
<function><type><name>void</name></type>
<name>ExecEvalFieldStoreDeForm</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>

	<comment type="block">/* Lookup tupdesc if first time through or if type changes */</comment>
	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>get_cached_rowtype</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>fieldstore</name><operator>.</operator><name>fstore</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
								 <argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>fieldstore</name><operator>.</operator><name>rowcache</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check that current tupdesc doesn't have more fields than we allocated */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>&gt;</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>fieldstore</name><operator>.</operator><name>ncolumns</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too many columns in composite type %u"</literal></expr></argument>,
			 <argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>fieldstore</name><operator>.</operator><name>fstore</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Convert null input tuple into an all-nulls row */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>fieldstore</name><operator>.</operator><name>nulls</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
			   <argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>fieldstore</name><operator>.</operator><name>ncolumns</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * heap_deform_tuple needs a HeapTuple not a bare HeapTupleHeader. We
		 * set all the fields in the struct just in case.
		 */</comment>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>tupDatum</name> <init>= <expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>tuphdr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tmptup</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tuphdr</name> <operator>=</operator> <call><name>DatumGetHeapTupleHeader</name><argument_list>(<argument><expr><name>tupDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetDatumLength</name><argument_list>(<argument><expr><name>tuphdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tmptup</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>tuphdr</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmptup</name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>,
						  <argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>fieldstore</name><operator>.</operator><name>values</name></name></expr></argument>,
						  <argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>fieldstore</name><operator>.</operator><name>nulls</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Compute the new composite datum after each individual field value of a
 * FieldStore expression has been evaluated.
 */</comment>
<function><type><name>void</name></type>
<name>ExecEvalFieldStoreForm</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<comment type="block">/* Lookup tupdesc (should be valid already) */</comment>
	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>get_cached_rowtype</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>fieldstore</name><operator>.</operator><name>fstore</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
								 <argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>fieldstore</name><operator>.</operator><name>rowcache</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>,
							<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>fieldstore</name><operator>.</operator><name>values</name></name></expr></argument>,
							<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>fieldstore</name><operator>.</operator><name>nulls</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Process a subscript in an ArrayRef expression.
 *
 * If subscript is NULL, throw error in assignment case, or in fetch case
 * set result to NULL and return false (instructing caller to skip the rest
 * of the ArrayRef sequence).
 *
 * Subscript expression result is in subscriptvalue/subscriptnull.
 * On success, integer subscript value has been saved in upperindex[] or
 * lowerindex[] for use later.
 */</comment>
<function><type><name>bool</name></type>
<name>ExecEvalArrayRefSubscript</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayRefState</name> <modifier>*</modifier></type><name>arefstate</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>arrayref_subscript</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>indexes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>off</name></decl>;</decl_stmt>

	<comment type="block">/* If any index expr yields NULL, result is NULL or error */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>arefstate</name><operator>-&gt;</operator><name>subscriptnull</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>arefstate</name><operator>-&gt;</operator><name>isassignment</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"array subscript in assignment must not be null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Convert datum to int, save in appropriate place */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>arrayref_subscript</name><operator>.</operator><name>isupper</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>indexes</name> <operator>=</operator> <name><name>arefstate</name><operator>-&gt;</operator><name>upperindex</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>indexes</name> <operator>=</operator> <name><name>arefstate</name><operator>-&gt;</operator><name>lowerindex</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>off</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>arrayref_subscript</name><operator>.</operator><name>off</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>indexes</name><index>[<expr><name>off</name></expr>]</index></name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>subscriptvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Evaluate ArrayRef fetch.
 *
 * Source array is in step's result variable.
 */</comment>
<function><type><name>void</name></type>
<name>ExecEvalArrayRefFetch</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayRefState</name> <modifier>*</modifier></type><name>arefstate</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>arrayref</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Should not get here if source array (or any subscript) is null */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>arefstate</name><operator>-&gt;</operator><name>numlower</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Scalar case */</comment>
		<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>array_get_element</name><argument_list>(<argument><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name></expr></argument>,
										  <argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>numupper</name></name></expr></argument>,
										  <argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>upperindex</name></name></expr></argument>,
										  <argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>refattrlength</name></name></expr></argument>,
										  <argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>refelemlength</name></name></expr></argument>,
										  <argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>refelembyval</name></name></expr></argument>,
										  <argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>refelemalign</name></name></expr></argument>,
										  <argument><expr><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Slice case */</comment>
		<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>array_get_slice</name><argument_list>(<argument><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name></expr></argument>,
										<argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>numupper</name></name></expr></argument>,
										<argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>upperindex</name></name></expr></argument>,
										<argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>lowerindex</name></name></expr></argument>,
										<argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>upperprovided</name></name></expr></argument>,
										<argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>lowerprovided</name></name></expr></argument>,
										<argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>refattrlength</name></name></expr></argument>,
										<argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>refelemlength</name></name></expr></argument>,
										<argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>refelembyval</name></name></expr></argument>,
										<argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>refelemalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Compute old array element/slice value for an ArrayRef assignment
 * expression.  Will only be generated if the new-value subexpression
 * contains ArrayRef or FieldStore.  The value is stored into the
 * ArrayRefState's prevvalue/prevnull fields.
 */</comment>
<function><type><name>void</name></type>
<name>ExecEvalArrayRefOld</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayRefState</name> <modifier>*</modifier></type><name>arefstate</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>arrayref</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* whole array is null, so any element or slice is too */</comment>
		<expr_stmt><expr><name><name>arefstate</name><operator>-&gt;</operator><name>prevvalue</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>arefstate</name><operator>-&gt;</operator><name>prevnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>arefstate</name><operator>-&gt;</operator><name>numlower</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Scalar case */</comment>
		<expr_stmt><expr><name><name>arefstate</name><operator>-&gt;</operator><name>prevvalue</name></name> <operator>=</operator> <call><name>array_get_element</name><argument_list>(<argument><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name></expr></argument>,
												 <argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>numupper</name></name></expr></argument>,
												 <argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>upperindex</name></name></expr></argument>,
												 <argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>refattrlength</name></name></expr></argument>,
												 <argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>refelemlength</name></name></expr></argument>,
												 <argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>refelembyval</name></name></expr></argument>,
												 <argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>refelemalign</name></name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name><name>arefstate</name><operator>-&gt;</operator><name>prevnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Slice case */</comment>
		<comment type="block">/* this is currently unreachable */</comment>
		<expr_stmt><expr><name><name>arefstate</name><operator>-&gt;</operator><name>prevvalue</name></name> <operator>=</operator> <call><name>array_get_slice</name><argument_list>(<argument><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name></expr></argument>,
											   <argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>numupper</name></name></expr></argument>,
											   <argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>upperindex</name></name></expr></argument>,
											   <argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>lowerindex</name></name></expr></argument>,
											   <argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>upperprovided</name></name></expr></argument>,
											   <argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>lowerprovided</name></name></expr></argument>,
											   <argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>refattrlength</name></name></expr></argument>,
											   <argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>refelemlength</name></name></expr></argument>,
											   <argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>refelembyval</name></name></expr></argument>,
											   <argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>refelemalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>arefstate</name><operator>-&gt;</operator><name>prevnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Evaluate ArrayRef assignment.
 *
 * Input array (possibly null) is in result area, replacement value is in
 * ArrayRefState's replacevalue/replacenull.
 */</comment>
<function><type><name>void</name></type>
<name>ExecEvalArrayRefAssign</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayRefState</name> <modifier>*</modifier></type><name>arefstate</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>arrayref</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * For an assignment to a fixed-length array type, both the original array
	 * and the value to be assigned into it must be non-NULL, else we punt and
	 * return the original array.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>arefstate</name><operator>-&gt;</operator><name>refattrlength</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>	<comment type="block">/* fixed-length array? */</comment>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>||</operator> <name><name>arefstate</name><operator>-&gt;</operator><name>replacenull</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * For assignment to varlena arrays, we handle a NULL original array by
	 * substituting an empty (zero-dimensional) array; insertion of the new
	 * element will result in a singleton array value.  It does not matter
	 * whether the new element is NULL.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>construct_empty_array</name><argument_list>(<argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>refelemtype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>arefstate</name><operator>-&gt;</operator><name>numlower</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Scalar case */</comment>
		<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>array_set_element</name><argument_list>(<argument><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name></expr></argument>,
										  <argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>numupper</name></name></expr></argument>,
										  <argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>upperindex</name></name></expr></argument>,
										  <argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>replacevalue</name></name></expr></argument>,
										  <argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>replacenull</name></name></expr></argument>,
										  <argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>refattrlength</name></name></expr></argument>,
										  <argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>refelemlength</name></name></expr></argument>,
										  <argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>refelembyval</name></name></expr></argument>,
										  <argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>refelemalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Slice case */</comment>
		<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>array_set_slice</name><argument_list>(<argument><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name></expr></argument>,
										<argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>numupper</name></name></expr></argument>,
										<argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>upperindex</name></name></expr></argument>,
										<argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>lowerindex</name></name></expr></argument>,
										<argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>upperprovided</name></name></expr></argument>,
										<argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>lowerprovided</name></name></expr></argument>,
										<argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>replacevalue</name></name></expr></argument>,
										<argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>replacenull</name></name></expr></argument>,
										<argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>refattrlength</name></name></expr></argument>,
										<argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>refelemlength</name></name></expr></argument>,
										<argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>refelembyval</name></name></expr></argument>,
										<argument><expr><name><name>arefstate</name><operator>-&gt;</operator><name>refelemalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Evaluate a rowtype coercion operation.
 * This may require rearranging field positions.
 *
 * Source record is in step's result variable.
 */</comment>
<function><type><name>void</name></type>
<name>ExecEvalConvertRowtype</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>tupDatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tmptup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>indesc</name></decl>,
				<decl><type ref="prev"/><name>outdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>changed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* NULL in -&gt; NULL out */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tupDatum</name> <operator>=</operator> <operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>DatumGetHeapTupleHeader</name><argument_list>(<argument><expr><name>tupDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Lookup tupdescs if first time through or if type changes.  We'd better
	 * pin them since type conversion functions could do catalog lookups and
	 * hence cause cache invalidation.
	 */</comment>
	<expr_stmt><expr><name>indesc</name> <operator>=</operator> <call><name>get_cached_rowtype</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>convert_rowtype</name><operator>.</operator><name>inputtype</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
								<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>convert_rowtype</name><operator>.</operator><name>incache</name></name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>changed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>IncrTupleDescRefCount</name><argument_list>(<argument><expr><name>indesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>outdesc</name> <operator>=</operator> <call><name>get_cached_rowtype</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>convert_rowtype</name><operator>.</operator><name>outputtype</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
								 <argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>convert_rowtype</name><operator>.</operator><name>outcache</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>changed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>IncrTupleDescRefCount</name><argument_list>(<argument><expr><name>outdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We used to be able to assert that incoming tuples are marked with
	 * exactly the rowtype of indesc.  However, now that ExecEvalWholeRowVar
	 * might change the tuples' marking to plain RECORD due to inserting
	 * aliases, we can only make this weak test:
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetTypeId</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>indesc</name><operator>-&gt;</operator><name>tdtypeid</name></name> <operator>||</operator>
		   <call><name>HeapTupleHeaderGetTypeId</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RECORDOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if first time through, or after change, initialize conversion map */</comment>
	<if_stmt><if>if <condition>(<expr><name>changed</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_cxt</name></decl>;</decl_stmt>

		<comment type="block">/* allocate map in long-lived memory context */</comment>
		<expr_stmt><expr><name>old_cxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* prepare map from old to new attribute numbers */</comment>
		<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>convert_rowtype</name><operator>.</operator><name>map</name></name> <operator>=</operator>
			<call><name>convert_tuples_by_name</name><argument_list>(<argument><expr><name>indesc</name></expr></argument>, <argument><expr><name>outdesc</name></expr></argument>,
								   <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Following steps need a HeapTuple not a bare HeapTupleHeader */</comment>
	<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetDatumLength</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>tuple</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>convert_rowtype</name><operator>.</operator><name>map</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Full conversion with attribute rearrangement needed */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>execute_attr_map_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmptup</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>convert_rowtype</name><operator>.</operator><name>map</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Result already has appropriate composite-datum header fields */</comment>
		<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * The tuple is physically compatible as-is, but we need to insert the
		 * destination rowtype OID in its composite-datum header field, so we
		 * have to copy it anyway.  heap_copy_tuple_as_datum() is convenient
		 * for this since it will both make the physical copy and insert the
		 * correct composite header fields.  Note that we aren't expecting to
		 * have to flatten any toasted fields: the input was a composite
		 * datum, so it shouldn't contain any.  So heap_copy_tuple_as_datum()
		 * is overkill here, but its check for external fields is cheap.
		 */</comment>
		<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>heap_copy_tuple_as_datum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmptup</name></expr></argument>, <argument><expr><name>outdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>DecrTupleDescRefCount</name><argument_list>(<argument><expr><name>indesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DecrTupleDescRefCount</name><argument_list>(<argument><expr><name>outdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Evaluate "scalar op ANY/ALL (array)".
 *
 * Source array is in our result area, scalar arg is already evaluated into
 * fcinfo-&gt;arg[0]/argnull[0].
 *
 * The operator always yields boolean, and we combine the results across all
 * array elements using OR and AND (for ANY and ALL respectively).  Of course
 * we short-circuit as soon as the result is known.
 */</comment>
<function><type><name>void</name></type>
<name>ExecEvalScalarArrayOp</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>scalararrayop</name><operator>.</operator><name>fcinfo_data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>useOr</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>scalararrayop</name><operator>.</operator><name>useOr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>strictfunc</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>scalararrayop</name><operator>.</operator><name>finfo</name><operator>-&gt;</operator><name>fn_strict</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nitems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>resultnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>typlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typbyval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>typalign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bits8</name>	   <modifier>*</modifier></type><name>bitmap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bitmask</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the array is NULL then we return NULL --- it's not very meaningful
	 * to do anything else, even if the operator isn't strict.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Else okay to fetch and detoast the array */</comment>
	<expr_stmt><expr><name>arr</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the array is empty, we return either FALSE or TRUE per the useOr
	 * flag.  This is correct even if the scalar is NULL; since we would
	 * evaluate the operator zero times, it matters not whether it would want
	 * to return NULL.
	 */</comment>
	<expr_stmt><expr><name>nitems</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nitems</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><operator>!</operator><name>useOr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the scalar is NULL, and the function is strict, return NULL; no
	 * point in iterating the loop.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name>strictfunc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We arrange to look up info about the element type only once per series
	 * of calls, assuming the element type doesn't change underneath us.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>scalararrayop</name><operator>.</operator><name>element_type</name></name> <operator>!=</operator> <call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>scalararrayop</name><operator>.</operator><name>typlen</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>scalararrayop</name><operator>.</operator><name>typbyval</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>scalararrayop</name><operator>.</operator><name>typalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>scalararrayop</name><operator>.</operator><name>element_type</name></name> <operator>=</operator> <call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>typlen</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>scalararrayop</name><operator>.</operator><name>typlen</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>typbyval</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>scalararrayop</name><operator>.</operator><name>typbyval</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>typalign</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>scalararrayop</name><operator>.</operator><name>typalign</name></name></expr>;</expr_stmt>

	<comment type="block">/* Initialize result appropriately depending on useOr */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><operator>!</operator><name>useOr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>resultnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Loop over the array elements */</comment>
	<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bitmap</name> <operator>=</operator> <call><name>ARR_NULLBITMAP</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bitmask</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>elt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>thisresult</name></decl>;</decl_stmt>

		<comment type="block">/* Get array element, checking for NULL */</comment>
		<if_stmt><if>if <condition>(<expr><name>bitmap</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>bitmap</name> <operator>&amp;</operator> <name>bitmask</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>elt</name> <operator>=</operator> <call><name>fetch_att</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>att_addlength_pointer</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>elt</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Call comparison function */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name>strictfunc</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>thisresult</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>thisresult</name> <operator>=</operator> <call><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>scalararrayop</name><operator>.</operator><name>fn_addr</name></name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Combine results per OR or AND semantics */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>resultnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>useOr</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>thisresult</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>resultnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>			<comment type="block">/* needn't look at any more elements */</comment>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>thisresult</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>resultnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>			<comment type="block">/* needn't look at any more elements */</comment>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* advance bitmap pointer if any */</comment>
		<if_stmt><if>if <condition>(<expr><name>bitmap</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>bitmask</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>bitmask</name> <operator>==</operator> <literal type="number">0x100</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>bitmap</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>bitmask</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>resultnull</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Evaluate a NOT NULL domain constraint.
 */</comment>
<function><type><name>void</name></type>
<name>ExecEvalConstraintNotNull</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NOT_NULL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"domain %s does not allow null values"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>domaincheck</name><operator>.</operator><name>resulttype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdatatype</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>domaincheck</name><operator>.</operator><name>resulttype</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Evaluate a CHECK domain constraint.
 */</comment>
<function><type><name>void</name></type>
<name>ExecEvalConstraintCheck</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>domaincheck</name><operator>.</operator><name>checknull</name></name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>domaincheck</name><operator>.</operator><name>checkvalue</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CHECK_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"value for domain %s violates check constraint \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>domaincheck</name><operator>.</operator><name>resulttype</name></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>domaincheck</name><operator>.</operator><name>constraintname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdomainconstraint</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>domaincheck</name><operator>.</operator><name>resulttype</name></name></expr></argument>,
									 <argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>domaincheck</name><operator>.</operator><name>constraintname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Evaluate the various forms of XmlExpr.
 *
 * Arguments have been evaluated into named_argvalue/named_argnull
 * and/or argvalue/argnull arrays.
 */</comment>
<function><type><name>void</name></type>
<name>ExecEvalXmlExpr</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XmlExpr</name>    <modifier>*</modifier></type><name>xexpr</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>xexpr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>		<comment type="block">/* until we get a result */</comment>
	<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>xexpr</name><operator>-&gt;</operator><name>op</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>IS_XMLCONCAT</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>argvalue</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>argvalue</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>argnull</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>argnull</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>values</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>argnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>values</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>argvalue</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></for>

				<if_stmt><if>if <condition>(<expr><name>values</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>xmlconcat</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>IS_XMLFOREST</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>argvalue</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>named_argvalue</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>argnull</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>named_argnull</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<macro><name>forboth</name><argument_list>(<argument>lc</argument>, <argument>xexpr-&gt;named_args</argument>, <argument>lc2</argument>, <argument>xexpr-&gt;arg_names</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>argname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>argnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>value</name> <operator>=</operator> <name><name>argvalue</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"&lt;%s&gt;%s&lt;/%s&gt;"</literal></expr></argument>,
										 <argument><expr><name>argname</name></expr></argument>,
										 <argument><expr><call><name>map_sql_value_to_xml_value</name><argument_list>(<argument><expr><name>value</name></expr></argument>,
																	<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>e</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>argname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>IS_XMLELEMENT</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>xmlelement</name><argument_list>(<argument><expr><name>xexpr</name></expr></argument>,
													   <argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>named_argvalue</name></name></expr></argument>,
													   <argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>named_argnull</name></name></expr></argument>,
													   <argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>argvalue</name></name></expr></argument>,
													   <argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>argnull</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>IS_XMLPARSE</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>argvalue</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>argvalue</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>argnull</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>argnull</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>preserve_whitespace</name></decl>;</decl_stmt>

				<comment type="block">/* arguments are known to be text, bool */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>value</name> <operator>=</operator> <name><name>argvalue</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>argnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* probably can't happen */</comment>
					<return>return;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>value</name> <operator>=</operator> <name><name>argvalue</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>preserve_whitespace</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>xmlparse</name><argument_list>(<argument><expr><name>data</name></expr></argument>,
														 <argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>xmloption</name></name></expr></argument>,
														 <argument><expr><name>preserve_whitespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>IS_XMLPI</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

				<comment type="block">/* optional argument is known to be text */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>xexpr</name><operator>-&gt;</operator><name>args</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>isnull</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>arg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>argvalue</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>arg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>xmlpi</name><argument_list>(<argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
													  <argument><expr><name>arg</name></expr></argument>,
													  <argument><expr><name>isnull</name></expr></argument>,
													  <argument><expr><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>IS_XMLROOT</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>argvalue</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>argvalue</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>argnull</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>argnull</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>xmltype</name>    <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>version</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>standalone</name></decl>;</decl_stmt>

				<comment type="block">/* arguments are known to be xml, text, int */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>DatumGetXmlP</name><argument_list>(<argument><expr><name><name>argvalue</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>argnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>version</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>version</name> <operator>=</operator> <call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name><name>argvalue</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>argnull</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* always present */</comment>
				<expr_stmt><expr><name>standalone</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>argvalue</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>xmlroot</name><argument_list>(<argument><expr><name>data</name></expr></argument>,
														<argument><expr><name>version</name></expr></argument>,
														<argument><expr><name>standalone</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>IS_XMLSERIALIZE</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>argvalue</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>argvalue</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>argnull</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>argnull</name></name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* argument type is known to be xml */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>value</name> <operator>=</operator> <name><name>argvalue</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(
												<argument><expr><call><name>xmltotext_with_xmloption</name><argument_list>(<argument><expr><call><name>DatumGetXmlP</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>,
																		 <argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>xmloption</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>IS_DOCUMENT</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>argvalue</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>argvalue</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>argnull</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>argnull</name></name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* optional argument is known to be xml */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>value</name> <operator>=</operator> <name><name>argvalue</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator>
					<call><name>BoolGetDatum</name><argument_list>(<argument><expr><call><name>xml_is_document</name><argument_list>(<argument><expr><call><name>DatumGetXmlP</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized XML operation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * ExecEvalGroupingFunc
 *
 * Computes a bitmask with a bit for each (unevaluated) argument expression
 * (rightmost arg is least significant bit).
 *
 * A bit is set if the corresponding expression is NOT part of the set of
 * grouping expressions in the current grouping set.
 */</comment>
<function><type><name>void</name></type>
<name>ExecEvalGroupingFunc</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>grouped_cols</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>grouping_func</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>grouped_cols</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>op-&gt;d.grouping_func.clauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>grouped_cols</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>|=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Hand off evaluation of a subplan to nodeSubplan.c
 */</comment>
<function><type><name>void</name></type>
<name>ExecEvalSubPlan</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SubPlanState</name> <modifier>*</modifier></type><name>sstate</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>subplan</name><operator>.</operator><name>sstate</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* could potentially be nested, so make sure there's enough stack */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>ExecSubPlan</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Hand off evaluation of an alternative subplan to nodeSubplan.c
 */</comment>
<function><type><name>void</name></type>
<name>ExecEvalAlternativeSubPlan</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlternativeSubPlanState</name> <modifier>*</modifier></type><name>asstate</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>alternative_subplan</name><operator>.</operator><name>asstate</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* could potentially be nested, so make sure there's enough stack */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>ExecAlternativeSubPlan</name><argument_list>(<argument><expr><name>asstate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Evaluate a wholerow Var expression.
 *
 * Returns a Datum whose value is the value of a whole-row range variable
 * with respect to given expression context.
 */</comment>
<function><type><name>void</name></type>
<name>ExecEvalWholeRowVar</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>variable</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>wholerow</name><operator>.</operator><name>var</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>output_tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>dtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<comment type="block">/* This was checked by ExecInitExpr */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>variable</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name>InvalidAttrNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get the input slot we want */</comment>
	<switch>switch <condition>(<expr><name><name>variable</name><operator>-&gt;</operator><name>varno</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INNER_VAR</name></expr>:</case>
			<comment type="block">/* get the tuple from the inner node */</comment>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>econtext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OUTER_VAR</name></expr>:</case>
			<comment type="block">/* get the tuple from the outer node */</comment>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/* INDEX_VAR is handled by default case */</comment>

		<default>default:</default>
			<comment type="block">/* get the tuple from the relation being scanned */</comment>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Apply the junkfilter if any */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>wholerow</name><operator>.</operator><name>junkFilter</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecFilterJunk</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>wholerow</name><operator>.</operator><name>junkFilter</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If first time through, obtain tuple descriptor and check compatibility.
	 *
	 * XXX: It'd be great if this could be moved to the expression
	 * initialization phase, but due to using slots that's currently not
	 * feasible.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>wholerow</name><operator>.</operator><name>first</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* optimistically assume we don't need slow path */</comment>
		<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>wholerow</name><operator>.</operator><name>slow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the Var identifies a named composite type, we must check that
		 * the actual tuple type is compatible with it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>variable</name><operator>-&gt;</operator><name>vartype</name></name> <operator>!=</operator> <name>RECORDOID</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>var_tupdesc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>slot_tupdesc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * We really only care about numbers of attributes and data types.
			 * Also, we can ignore type mismatch on columns that are dropped
			 * in the destination type, so long as (1) the physical storage
			 * matches or (2) the actual column value is NULL.  Case (1) is
			 * helpful in some cases involving out-of-date cached plans, while
			 * case (2) is expected behavior in situations such as an INSERT
			 * into a table with dropped columns (the planner typically
			 * generates an INT4 NULL regardless of the dropped column type).
			 * If we find a dropped column and cannot verify that case (1)
			 * holds, we have to use the slow path to check (2) for each row.
			 *
			 * If vartype is a domain over composite, just look through that
			 * to the base composite type.
			 */</comment>
			<expr_stmt><expr><name>var_tupdesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc_domain</name><argument_list>(<argument><expr><name><name>variable</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>,
														<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>slot_tupdesc</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>var_tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>!=</operator> <name><name>slot_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table row type and query-specified row type do not match"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail_plural</name><argument_list>(<argument><expr><literal type="string">"Table row contains %d attribute, but query expects %d."</literal></expr></argument>,
										  <argument><expr><literal type="string">"Table row contains %d attributes, but query expects %d."</literal></expr></argument>,
										  <argument><expr><name><name>slot_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>,
										  <argument><expr><name><name>slot_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>,
										  <argument><expr><name><name>var_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>var_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>vattr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>var_tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>sattr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>slot_tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>vattr</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>==</operator> <name><name>sattr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>	<comment type="block">/* no worries */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>vattr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table row type and query-specified row type do not match"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Table has type %s at ordinal position %d, but query expects %s."</literal></expr></argument>,
									   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>sattr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
									   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>vattr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>vattr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>!=</operator> <name><name>sattr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>||</operator>
					<name><name>vattr</name><operator>-&gt;</operator><name>attalign</name></name> <operator>!=</operator> <name><name>sattr</name><operator>-&gt;</operator><name>attalign</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>wholerow</name><operator>.</operator><name>slow</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* need to check for nulls */</comment>
			</block_content>}</block></for>

			<comment type="block">/*
			 * Use the variable's declared rowtype as the descriptor for the
			 * output values, modulo possibly assigning new column names
			 * below. In particular, we *must* absorb any attisdropped
			 * markings.
			 */</comment>
			<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>output_tupdesc</name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name>var_tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name>var_tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * In the RECORD case, we use the input slot's rowtype as the
			 * descriptor for the output values, modulo possibly assigning new
			 * column names below.
			 */</comment>
			<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>output_tupdesc</name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Construct a tuple descriptor for the composite values we'll
		 * produce, and make sure its record type is "blessed".  The main
		 * reason to do this is to be sure that operations such as
		 * row_to_json() will see the desired column names when they look up
		 * the descriptor from the type information embedded in the composite
		 * values.
		 *
		 * We already got the correct physical datatype info above, but now we
		 * should try to find the source RTE and adopt its column aliases, in
		 * case they are different from the original rowtype's names.  For
		 * example, in "SELECT foo(t) FROM tab t(x,y)", the first two columns
		 * in the composite output should be named "x" and "y" regardless of
		 * tab's column names.
		 *
		 * If we can't locate the RTE, assume the column names we've got are
		 * OK.  (As of this writing, the only cases where we can't locate the
		 * RTE are in execution of trigger WHEN clauses, and then the Var will
		 * have the trigger's relation's rowtype, so its names are fine.)
		 * Also, if the creator of the RTE didn't bother to fill in an eref
		 * field, assume our column names are OK.  (This happens in COPY, and
		 * perhaps other places.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_estate</name></name> <operator>&amp;&amp;</operator>
			<name><name>variable</name><operator>-&gt;</operator><name>varno</name></name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_estate</name><operator>-&gt;</operator><name>es_range_table</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>variable</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>,
										  <argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_estate</name><operator>-&gt;</operator><name>es_range_table</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecTypeSetColNames</name><argument_list>(<argument><expr><name>output_tupdesc</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Bless the tupdesc if needed, and save it in the execution state */</comment>
		<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>wholerow</name><operator>.</operator><name>tupdesc</name></name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>output_tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>wholerow</name><operator>.</operator><name>first</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Make sure all columns of the slot are accessible in the slot's
	 * Datum/isnull arrays.
	 */</comment>
	<expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>wholerow</name><operator>.</operator><name>slow</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Check to see if any dropped attributes are non-null */</comment>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupleDesc</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>var_tupdesc</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>wholerow</name><operator>.</operator><name>tupdesc</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var_tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>==</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>var_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>vattr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>var_tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>sattr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>vattr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* already checked non-dropped cols */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* null is always okay */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>vattr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>!=</operator> <name><name>sattr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>||</operator>
				<name><name>vattr</name><operator>-&gt;</operator><name>attalign</name></name> <operator>!=</operator> <name><name>sattr</name><operator>-&gt;</operator><name>attalign</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table row type and query-specified row type do not match"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Physical storage mismatch on dropped attribute at ordinal position %d."</literal></expr></argument>,
								   <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Build a composite datum, making sure any toasted fields get detoasted.
	 *
	 * (Note: it is critical that we not change the slot's state here.)
	 */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>toast_build_flattened_tuple</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>,
										<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>,
										<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dtuple</name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Label the datum with the composite type info we identified before.
	 *
	 * (Note: we could skip doing this by passing op-&gt;d.wholerow.tupdesc to
	 * the tuple build step; but that seems a tad risky so let's not.)
	 */</comment>
	<expr_stmt><expr><call><name>HeapTupleHeaderSetTypeId</name><argument_list>(<argument><expr><name>dtuple</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>wholerow</name><operator>.</operator><name>tupdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HeapTupleHeaderSetTypMod</name><argument_list>(<argument><expr><name>dtuple</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>wholerow</name><operator>.</operator><name>tupdesc</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>dtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Transition value has not been initialized. This is the first non-NULL input
 * value for a group. We use it as the initial value for transValue.
 */</comment>
<function><type><name>void</name></type>
<name>ExecAggInitGroup</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>, <parameter><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name></decl></parameter>, <parameter><decl><type><name>AggStatePerGroup</name></type> <name>pergroup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name> <init>= <expr><operator>&amp;</operator><name><name>pertrans</name><operator>-&gt;</operator><name>transfn_fcinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We must copy the datum into aggcontext if it is pass-by-ref. We do not
	 * need to pfree the old transValue, since it's NULL.  (We already checked
	 * that the agg's input type is binary-compatible with its transtype, so
	 * straight copy here is OK.)
	 */</comment>
	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(
									   <argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curaggcontext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pergroup</name><operator>-&gt;</operator><name>transValue</name></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
									 <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeByVal</name></name></expr></argument>,
									 <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pergroup</name><operator>-&gt;</operator><name>transValueIsNull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pergroup</name><operator>-&gt;</operator><name>noTransValue</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Ensure that the current transition value is a child of the aggcontext,
 * rather than the per-tuple context.
 *
 * NB: This can change the current memory context.
 */</comment>
<function><type><name>Datum</name></type>
<name>ExecAggTransReparent</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>, <parameter><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name></decl></parameter>,
					 <parameter><decl><type><name>Datum</name></type> <name>newValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>newValueIsNull</name></decl></parameter>,
					 <parameter><decl><type><name>Datum</name></type> <name>oldValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>oldValueIsNull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>newValueIsNull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>curaggcontext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>DatumIsReadWriteExpandedObject</name><argument_list>(<argument><expr><name>newValue</name></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>MemoryContextGetParent</name><argument_list>(<argument><expr><call><name>DatumGetEOHP</name><argument_list>(<argument><expr><name>newValue</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>eoh_context</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			 <comment type="block">/* do nothing */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>newValue</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name>newValue</name></expr></argument>,
								 <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeByVal</name></name></expr></argument>,
								 <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>oldValueIsNull</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>DatumIsReadWriteExpandedObject</name><argument_list>(<argument><expr><name>oldValue</name></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>DeleteExpandedObject</name><argument_list>(<argument><expr><name>oldValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>oldValue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>newValue</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Invoke ordered transition function, with a datum argument.
 */</comment>
<function><type><name>void</name></type>
<name>ExecEvalAggOrderedTransDatum</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>,
							 <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_trans</name><operator>.</operator><name>pertrans</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>setno</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_trans</name><operator>.</operator><name>setno</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>tuplesort_putdatum</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name>setno</name></expr>]</index></name></expr></argument>,
					   <argument><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name></expr></argument>, <argument><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Invoke ordered transition function, with a tuple argument.
 */</comment>
<function><type><name>void</name></type>
<name>ExecEvalAggOrderedTransTuple</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>,
							 <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_trans</name><operator>.</operator><name>pertrans</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>setno</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_trans</name><operator>.</operator><name>setno</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortslot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortslot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>=</operator> <name><name>pertrans</name><operator>-&gt;</operator><name>numInputs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortslot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tuplesort_puttupleslot</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortstates</name><index>[<expr><name>setno</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortslot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
