<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/executor/execPartition.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * execPartition.c
 *	  Support routines for partitioning.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/executor/execPartition.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/partition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execPartition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/fdwapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning/partbounds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning/partprune.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/partcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rls.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>


<comment type="block">/*-----------------------
 * PartitionDispatch - information about one partitioned table in a partition
 * hierarchy required to route a tuple to one of its partitions
 *
 *	reldesc		Relation descriptor of the table
 *	key			Partition key information of the table
 *	keystate	Execution state required for expressions in the partition key
 *	partdesc	Partition descriptor of the table
 *	tupslot		A standalone TupleTableSlot initialized with this table's tuple
 *				descriptor
 *	tupmap		TupleConversionMap to convert from the parent's rowtype to
 *				this table's rowtype (when extracting the partition key of a
 *				tuple just before routing it through this table)
 *	indexes		Array with partdesc-&gt;nparts members (for details on what
 *				individual members represent, see how they are set in
 *				get_partition_dispatch_recurse())
 *-----------------------
 */</comment>
<typedef>typedef <type><struct>struct <name>PartitionDispatchData</name>
<block>{
	<decl_stmt><decl><type><name>Relation</name></type>	<name>reldesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>keystate</name></decl>;</decl_stmt>		<comment type="block">/* list of ExprState */</comment>
	<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>tupslot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>tupmap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>indexes</name></decl>;</decl_stmt>
}</block></struct></type> <name>PartitionDispatchData</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>PartitionDispatch</name> <modifier>*</modifier></type><name>RelationGetPartitionDispatchInfo</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
								 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_parted</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>leaf_part_oids</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_partition_dispatch_recurse</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>pds</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>leaf_part_oids</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FormPartitionKeyDatum</name><parameter_list>(<parameter><decl><type><name>PartitionDispatch</name></type> <name>pd</name></decl></parameter>,
					  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
					  <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
					  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>get_partition_for_tuple</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
						<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>ExecBuildSlotPartitionKeyDescription</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
									 <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
									 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>,
									 <parameter><decl><type><name>int</name></type> <name>maxfieldlen</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>adjust_partition_tlist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>map</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>find_matching_subplans_recurse</name><parameter_list>(<parameter><decl><type><name>PartitionPruningData</name> <modifier>*</modifier></type><name>prunedata</name></decl></parameter>,
							   <parameter><decl><type><name>PartitionedRelPruningData</name> <modifier>*</modifier></type><name>pprune</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>initial_prune</name></decl></parameter>,
							   <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier><modifier>*</modifier></type><name>validsubplans</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * ExecSetupPartitionTupleRouting - sets up information needed during
 * tuple routing for partitioned tables, encapsulates it in
 * PartitionTupleRouting, and returns it.
 *
 * Note that all the relations in the partition tree are locked using the
 * RowExclusiveLock mode upon return from this function.
 *
 * While we allocate the arrays of pointers of ResultRelInfo and
 * TupleConversionMap for all partitions here, actual objects themselves are
 * lazily allocated for a given partition if a tuple is actually routed to it;
 * see ExecInitPartitionInfo.  However, if the function is invoked for update
 * tuple routing, caller would already have initialized ResultRelInfo's for
 * some of the partitions, which are reused and assigned to their respective
 * slot in the aforementioned array.  For such partitions, we delay setting
 * up objects such as TupleConversionMap until those are actually chosen as
 * the partitions to route tuples to.  See ExecPrepareTupleRouting.
 */</comment>
<function><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type>
<name>ExecSetupPartitionTupleRouting</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rootResultRelInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>leaf_parts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>update_rri</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_update_rri</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>update_rri_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type><name>proute</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nparts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><ternary><condition><expr><name>mtstate</name></expr> ?</condition><then> <expr><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get the information about the partition tree after locking all the
	 * partitions.
	 */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>rootResultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>RowExclusiveLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>proute</name> <operator>=</operator> <operator>(</operator><name>PartitionTupleRouting</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionTupleRouting</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>partition_dispatch_info</name></name> <operator>=</operator>
		<call><name>RelationGetPartitionDispatchInfo</name><argument_list>(<argument><expr><name><name>rootResultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name><name>proute</name><operator>-&gt;</operator><name>num_dispatch</name></name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>leaf_parts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>num_partitions</name></name> <operator>=</operator> <name>nparts</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>leaf_parts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>partitions</name></name> <operator>=</operator>
		<operator>(</operator><name>ResultRelInfo</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nparts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ResultRelInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>parent_child_tupconv_maps</name></name> <operator>=</operator>
		<operator>(</operator><name>TupleConversionMap</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nparts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TupleConversionMap</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>partition_oids</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nparts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up details specific to the type of tuple routing we are doing. */</comment>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_UPDATE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>update_rri</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>num_update_rri</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>plans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>subplan_partition_offsets</name></name> <operator>=</operator>
			<call><name>palloc</name><argument_list>(<argument><expr><name>num_update_rri</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>num_subplan_partition_offsets</name></name> <operator>=</operator> <name>num_update_rri</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * We need an additional tuple slot for storing transient tuples that
		 * are converted to the root table descriptor.
		 */</comment>
		<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>root_tuple_slot</name></name> <operator>=</operator> <call><name>MakeTupleTableSlot</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>rootResultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>leaf_parts</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>leaf_part_rri</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>leaf_oid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>partition_oids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>leaf_oid</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the leaf partition is already present in the per-subplan result
		 * rels, we re-use that rather than initialize a new result rel. The
		 * per-subplan resultrels and the resultrels of the leaf partitions
		 * are both in the same canonical order. So while going through the
		 * leaf partition oids, we need to keep track of the next per-subplan
		 * result rel to be looked for in the leaf partition resultrels.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>update_rri_index</name> <operator>&lt;</operator> <name>num_update_rri</name> <operator>&amp;&amp;</operator>
			<call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>update_rri</name><index>[<expr><name>update_rri_index</name></expr>]</index></name><operator>.</operator><name>ri_RelationDesc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>leaf_oid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>leaf_part_rri</name> <operator>=</operator> <operator>&amp;</operator><name><name>update_rri</name><index>[<expr><name>update_rri_index</name></expr>]</index></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * This is required in order to convert the partition's tuple to
			 * be compatible with the root partitioned table's tuple
			 * descriptor.  When generating the per-subplan result rels, this
			 * was not set.
			 */</comment>
			<expr_stmt><expr><name><name>leaf_part_rri</name><operator>-&gt;</operator><name>ri_RootResultRelInfo</name></name> <operator>=</operator> <name>rootResultRelInfo</name></expr>;</expr_stmt>

			<comment type="block">/* Remember the subplan offset for this ResultRelInfo */</comment>
			<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>subplan_partition_offsets</name><index>[<expr><name>update_rri_index</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>update_rri_index</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>partitions</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>leaf_part_rri</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * For UPDATE, we should have found all the per-subplan resultrels in the
	 * leaf partitions.  (If this is an INSERT, both values will be zero.)
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>update_rri_index</name> <operator>==</operator> <name>num_update_rri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>proute</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecFindPartition -- Find a leaf partition in the partition tree rooted
 * at parent, for the heap tuple contained in *slot
 *
 * estate must be non-NULL; we'll need it to compute any expressions in the
 * partition key(s)
 *
 * If no leaf partition is found, this routine errors out with the appropriate
 * error message, else it returns the leaf partition sequence number
 * as an index into the array of (ResultRelInfos of) all leaf partitions in
 * the partition tree.
 */</comment>
<function><type><name>int</name></type>
<name>ExecFindPartition</name><parameter_list>(<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>, <parameter><decl><type><name>PartitionDispatch</name> <modifier>*</modifier></type><name>pd</name></decl></parameter>,
				  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>PARTITION_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>isnull</name><index>[<expr><name>PARTITION_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionDispatch</name></type> <name>dispatch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>ecxt</name> <init>= <expr><call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>ecxt_scantuple_old</name> <init>= <expr><name><name>ecxt</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>myslot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type>	<name>oldcxt</name></decl>;</decl_stmt>

	<comment type="block">/* use per-tuple context here to avoid leaking memory */</comment>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * First check the root table's partition constraint, if any.  No point in
	 * routing the tuple if it doesn't belong in the root table itself.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionCheck</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecPartitionCheck</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* start with the root partitioned table */</comment>
	<expr_stmt><expr><name>dispatch</name> <operator>=</operator> <name><name>pd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partdesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>map</name> <init>= <expr><name><name>dispatch</name><operator>-&gt;</operator><name>tupmap</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>cur_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>rel</name> <operator>=</operator> <name><name>dispatch</name><operator>-&gt;</operator><name>reldesc</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>partdesc</name> <operator>=</operator> <call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Convert the tuple to this parent's layout, if different from the
		 * current relation.
		 */</comment>
		<expr_stmt><expr><name>myslot</name> <operator>=</operator> <name><name>dispatch</name><operator>-&gt;</operator><name>tupslot</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>myslot</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>map</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>execute_attr_map_slot</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>myslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Extract partition key from tuple. Expression evaluation machinery
		 * that FormPartitionKeyDatum() invokes expects ecxt_scantuple to
		 * point to the correct tuple slot.  The slot might have changed from
		 * what was used for the parent table if the table of the current
		 * partitioning level has different tuple descriptor from the parent.
		 * So update ecxt_scantuple accordingly.
		 */</comment>
		<expr_stmt><expr><name><name>ecxt</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FormPartitionKeyDatum</name><argument_list>(<argument><expr><name>dispatch</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Nothing for get_partition_for_tuple() to do if there are no
		 * partitions to begin with.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>cur_index</name> <operator>=</operator> <call><name>get_partition_for_tuple</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * cur_index &lt; 0 means we failed to find a partition of this parent.
		 * cur_index &gt;= 0 means we either found the leaf partition, or the
		 * next parent to find a partition of.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>cur_index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>dispatch</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>cur_index</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>dispatch</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>cur_index</name></expr>]</index></name></expr>;</expr_stmt>
			<comment type="block">/* success! */</comment>
			<break>break;</break>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* move down one level */</comment>
			<expr_stmt><expr><name>dispatch</name> <operator>=</operator> <name><name>pd</name><index>[<expr><operator>-</operator><name><name>dispatch</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>cur_index</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Release the tuple in the lowest parent's dedicated slot. */</comment>
	<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>==</operator> <name>myslot</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>myslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* A partition was not found. */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val_desc</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>val_desc</name> <operator>=</operator> <call><name>ExecBuildSlotPartitionKeyDescription</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
														<argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CHECK_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no partition of relation \"%s\" found for row"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><name>val_desc</name></expr> ?</condition><then> <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Partition key of the failing row contains %s."</literal></expr></argument>, <argument><expr><name>val_desc</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ecxt</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>ecxt_scantuple_old</name></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecInitPartitionInfo
 *		Initialize ResultRelInfo and other information for a partition
 *
 * Returns the ResultRelInfo
 */</comment>
<function><type><name>ResultRelInfo</name> <modifier>*</modifier></type>
<name>ExecInitPartitionInfo</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>,
					  <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rootResultRelInfo</name></decl></parameter>,
					  <parameter><decl><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type><name>proute</name></decl></parameter>,
					  <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>partidx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>partrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>firstVarno</name> <init>= <expr><name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>ri_RangeTableIndex</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>firstResultRel</name> <init>= <expr><name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>ri_RelationDesc</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>leaf_part_rri</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>part_attnos</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found_whole_row</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We locked all the partitions in ExecSetupPartitionTupleRouting
	 * including the leaf partitions.
	 */</comment>
	<expr_stmt><expr><name>partrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>proute</name><operator>-&gt;</operator><name>partition_oids</name><index>[<expr><name>partidx</name></expr>]</index></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Keep ResultRelInfo and other information for this partition in the
	 * per-query memory context so they'll survive throughout the query.
	 */</comment>
	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The result relation's range table index passed into InitResultRelInfo
	 * later gets used in the YB code-path to fetch range table entry
	 * during ExecUpdate(). The actual nominalRelation value needs to be
	 * passed on in order to correctly fetch the entry.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>resultRelationIndex</name> <init>=
			<expr><ternary><condition><expr><operator>(</operator><operator>!</operator><call><name>IsYBRelation</name><argument_list>(<argument><expr><name>firstResultRel</name></expr></argument>)</argument_list></call> <operator>||</operator>
			 <name><name>partrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>:
			<expr><operator>(</operator><ternary><condition><expr><name>node</name></expr> ?</condition><then> <expr><name><name>node</name><operator>-&gt;</operator><name>nominalRelation</name></name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>leaf_part_rri</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ResultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitResultRelInfo</name><argument_list>(<argument><expr><name>leaf_part_rri</name></expr></argument>,
					  <argument><expr><name>partrel</name></expr></argument>,
					  <argument><expr><name>resultRelationIndex</name></expr></argument>,
					  <argument><expr><name>rootResultRelInfo</name></expr></argument>,
					  <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Verify result relation is a valid target for an INSERT.  An UPDATE of a
	 * partition-key becomes a DELETE+INSERT operation, so this check is still
	 * required when the operation is CMD_UPDATE.
	 */</comment>
	<expr_stmt><expr><call><name>CheckValidResultRel</name><argument_list>(<argument><expr><name>leaf_part_rri</name></expr></argument>, <argument><expr><name>CMD_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since we've just initialized this ResultRelInfo, it's not in any list
	 * attached to the estate as yet.  Add it, so that it can be found later.
	 *
	 * Note that the entries in this list appear in no predetermined order,
	 * because partition result rels are initialized as and when they're
	 * needed.
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_tuple_routing_result_relations</name></name> <operator>=</operator>
		<call><name>lappend</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_tuple_routing_result_relations</name></name></expr></argument>,
				<argument><expr><name>leaf_part_rri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Open partition indices.  The user may have asked to check for conflicts
	 * within this leaf partition and do "nothing" instead of throwing an
	 * error.  Be prepared in that case by initializing the index information
	 * needed by ExecInsert() to perform speculative insertions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>partrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasindex</name></name> <operator>&amp;&amp;</operator>
		<name><name>leaf_part_rri</name><operator>-&gt;</operator><name>ri_IndexRelationDescs</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecOpenIndices</name><argument_list>(<argument><expr><name>leaf_part_rri</name></expr></argument>,
						<argument><expr><operator>(</operator><name>node</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
						 <name><name>node</name><operator>-&gt;</operator><name>onConflictAction</name></name> <operator>!=</operator> <name>ONCONFLICT_NONE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Build WITH CHECK OPTION constraints for the partition.  Note that we
	 * didn't build the withCheckOptionList for partitions within the planner,
	 * but simple translation of varattnos will suffice.  This only occurs for
	 * the INSERT case or in the case of UPDATE tuple routing where we didn't
	 * find a result rel to reuse in ExecSetupPartitionTupleRouting().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>withCheckOptionLists</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>wcoList</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>wcoExprs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ll</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * In the case of INSERT on a partitioned table, there is only one
		 * plan.  Likewise, there is only one WCO list, not one per partition.
		 * For UPDATE, there are as many WCO lists as there are plans.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_INSERT</name> <operator>&amp;&amp;</operator>
				<call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>withCheckOptionLists</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
				<call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>plans</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator>
			   <operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>&amp;&amp;</operator>
				<call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>withCheckOptionLists</name></name></expr></argument>)</argument_list></call> <operator>==</operator>
				<call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>plans</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Use the WCO list of the first plan as a reference to calculate
		 * attno's for the WCO list of this partition.  In the INSERT case,
		 * that refers to the root partitioned table, whereas in the UPDATE
		 * tuple routing case, that refers to the first partition in the
		 * mtstate-&gt;resultRelInfo array.  In any case, both that relation and
		 * this partition should have the same columns, so we should be able
		 * to map attributes successfully.
		 */</comment>
		<expr_stmt><expr><name>wcoList</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>withCheckOptionLists</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Convert Vars in it to contain this partition's attribute numbers.
		 */</comment>
		<expr_stmt><expr><name>part_attnos</name> <operator>=</operator>
			<call><name>convert_tuples_by_name_map</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>firstResultRel</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>wcoList</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>map_variable_attnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>wcoList</name></expr></argument>,
								<argument><expr><name>firstVarno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								<argument><expr><name>part_attnos</name></expr></argument>,
								<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>firstResultRel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>natts</name></expr></argument>,
								<argument><expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>reltype</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* We ignore the value of found_whole_row. */</comment>

		<macro><name>foreach</name><argument_list>(<argument>ll</argument>, <argument>wcoList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>WithCheckOption</name> <modifier>*</modifier></type><name>wco</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>WithCheckOption</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>ll</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>wcoExpr</name> <init>= <expr><call><name>ExecInitQual</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name><name>wco</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>wcoExprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>wcoExprs</name></expr></argument>, <argument><expr><name>wcoExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><name><name>leaf_part_rri</name><operator>-&gt;</operator><name>ri_WithCheckOptions</name></name> <operator>=</operator> <name>wcoList</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>leaf_part_rri</name><operator>-&gt;</operator><name>ri_WithCheckOptionExprs</name></name> <operator>=</operator> <name>wcoExprs</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Build the RETURNING projection for the partition.  Note that we didn't
	 * build the returningList for partitions within the planner, but simple
	 * translation of varattnos will suffice.  This only occurs for the INSERT
	 * case or in the case of UPDATE tuple routing where we didn't find a
	 * result rel to reuse in ExecSetupPartitionTupleRouting().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>returningLists</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>returningList</name></decl>;</decl_stmt>

		<comment type="block">/* See the comment above for WCO lists. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_INSERT</name> <operator>&amp;&amp;</operator>
				<call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>returningLists</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
				<call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>plans</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator>
			   <operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>&amp;&amp;</operator>
				<call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>returningLists</name></name></expr></argument>)</argument_list></call> <operator>==</operator>
				<call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>plans</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Use the RETURNING list of the first plan as a reference to
		 * calculate attno's for the RETURNING list of this partition.  See
		 * the comment above for WCO lists for more details on why this is
		 * okay.
		 */</comment>
		<expr_stmt><expr><name>returningList</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>returningLists</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Convert Vars in it to contain this partition's attribute numbers.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>part_attnos</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>part_attnos</name> <operator>=</operator>
				<call><name>convert_tuples_by_name_map</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>firstResultRel</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>returningList</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>map_variable_attnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>returningList</name></expr></argument>,
								<argument><expr><name>firstVarno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								<argument><expr><name>part_attnos</name></expr></argument>,
								<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>firstResultRel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>natts</name></expr></argument>,
								<argument><expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>reltype</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* We ignore the value of found_whole_row. */</comment>

		<expr_stmt><expr><name><name>leaf_part_rri</name><operator>-&gt;</operator><name>ri_returningList</name></name> <operator>=</operator> <name>returningList</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Initialize the projection itself.
		 *
		 * Use the slot and the expression context that would have been set up
		 * in ExecInitModifyTable() for projection's output.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>leaf_part_rri</name><operator>-&gt;</operator><name>ri_projectReturning</name></name> <operator>=</operator>
			<call><name>ExecBuildProjectionInfo</name><argument_list>(<argument><expr><name>returningList</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Set up information needed for routing tuples to the partition. */</comment>
	<expr_stmt><expr><call><name>ExecInitRoutingInfo</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>proute</name></expr></argument>, <argument><expr><name>leaf_part_rri</name></expr></argument>, <argument><expr><name>partidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there is an ON CONFLICT clause, initialize state for it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>onConflictAction</name></name> <operator>!=</operator> <name>ONCONFLICT_NONE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>map</name> <init>= <expr><name><name>proute</name><operator>-&gt;</operator><name>parent_child_tupconv_maps</name><index>[<expr><name>partidx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>partrelDesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>arbiterIndexes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If there is a list of arbiter indexes, map it to a list of indexes
		 * in the partition.  We do that by scanning the partition's index
		 * list and searching for ancestry relationships to each index in the
		 * ancestor table.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rootResultRelInfo</name><operator>-&gt;</operator><name>ri_onConflictArbiterIndexes</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>childIdxs</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>childIdxs</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name><name>leaf_part_rri</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>childIdxs</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>childIdx</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>ancestors</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>ancestors</name> <operator>=</operator> <call><name>get_partition_ancestors</name><argument_list>(<argument><expr><name>childIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>rootResultRelInfo-&gt;ri_onConflictArbiterIndexes</argument>)</argument_list></macro>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>list_member_oid</name><argument_list>(<argument><expr><name>ancestors</name></expr></argument>, <argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>arbiterIndexes</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>arbiterIndexes</name></expr></argument>, <argument><expr><name>childIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block>
				<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>ancestors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If the resulting lists are of inequal length, something is wrong.
		 * (This shouldn't happen, since arbiter index selection should not
		 * pick up an invalid index.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rootResultRelInfo</name><operator>-&gt;</operator><name>ri_onConflictArbiterIndexes</name></name></expr></argument>)</argument_list></call> <operator>!=</operator>
			<call><name>list_length</name><argument_list>(<argument><expr><name>arbiterIndexes</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid arbiter index list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>leaf_part_rri</name><operator>-&gt;</operator><name>ri_onConflictArbiterIndexes</name></name> <operator>=</operator> <name>arbiterIndexes</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * In the DO UPDATE case, we have some more state to initialize.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>onConflictAction</name></name> <operator>==</operator> <name>ONCONFLICT_UPDATE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>onConflictSet</name></name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rootResultRelInfo</name><operator>-&gt;</operator><name>ri_onConflict</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If the partition's tuple descriptor matches exactly the root
			 * parent (the common case), we can simply re-use the parent's ON
			 * CONFLICT SET state, skipping a bunch of work.  Otherwise, we
			 * need to create state specific to this partition.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>map</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>leaf_part_rri</name><operator>-&gt;</operator><name>ri_onConflict</name></name> <operator>=</operator> <name><name>rootResultRelInfo</name><operator>-&gt;</operator><name>ri_onConflict</name></name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>OnConflictSetState</name> <modifier>*</modifier></type><name>onconfl</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>OnConflictSetState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>onconflset</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>found_whole_row</name></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>leaf_part_rri</name><operator>-&gt;</operator><name>ri_onConflict</name></name> <operator>=</operator> <name>onconfl</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Translate expressions in onConflictSet to account for
				 * different attribute numbers.  For that, map partition
				 * varattnos twice: first to catch the EXCLUDED
				 * pseudo-relation (INNER_VAR), and second to handle the main
				 * target relation (firstVarno).
				 */</comment>
				<expr_stmt><expr><name>onconflset</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>onConflictSet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>part_attnos</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>part_attnos</name> <operator>=</operator>
						<call><name>convert_tuples_by_name_map</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call></expr></argument>,
												   <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>firstResultRel</name></expr></argument>)</argument_list></call></expr></argument>,
												   <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>onconflset</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
					<call><name>map_variable_attnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>onconflset</name></expr></argument>,
										<argument><expr><name>INNER_VAR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										<argument><expr><name>part_attnos</name></expr></argument>,
										<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>firstResultRel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>natts</name></expr></argument>,
										<argument><expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>reltype</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* We ignore the value of found_whole_row. */</comment>
				<expr_stmt><expr><name>onconflset</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
					<call><name>map_variable_attnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>onconflset</name></expr></argument>,
										<argument><expr><name>firstVarno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										<argument><expr><name>part_attnos</name></expr></argument>,
										<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>firstResultRel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>natts</name></expr></argument>,
										<argument><expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>reltype</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* We ignore the value of found_whole_row. */</comment>

				<comment type="block">/* Finally, reorder the tlist to match the partition. */</comment>
				<expr_stmt><expr><name>onconflset</name> <operator>=</operator> <call><name>adjust_partition_tlist</name><argument_list>(<argument><expr><name>onconflset</name></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Build UPDATE SET's projection info.  The user of this
				 * projection is responsible for setting the slot's tupdesc!
				 * We set aside a tupdesc that's good for the common case of a
				 * partition that's tupdesc-equal to the partitioned table;
				 * partitions of different tupdescs must generate their own.
				 */</comment>
				<expr_stmt><expr><call><name>ExecSetSlotDescriptor</name><argument_list>(<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_conflproj</name></name></expr></argument>, <argument><expr><name>partrelDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>onconfl</name><operator>-&gt;</operator><name>oc_ProjInfo</name></name> <operator>=</operator>
					<call><name>ExecBuildProjectionInfoExt</name><argument_list>(<argument><expr><name>onconflset</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>,
											   <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_conflproj</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>, <argument><expr><name>partrelDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>onconfl</name><operator>-&gt;</operator><name>oc_ProjTupdesc</name></name> <operator>=</operator> <name>partrelDesc</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * If there is a WHERE clause, initialize state where it will
				 * be evaluated, mapping the attribute numbers appropriately.
				 * As with onConflictSet, we need to map partition varattnos
				 * to the partition's tupdesc.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>onConflictWhere</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>clause</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>clause</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>onConflictWhere</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>clause</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
						<call><name>map_variable_attnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>,
											<argument><expr><name>INNER_VAR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
											<argument><expr><name>part_attnos</name></expr></argument>,
											<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>firstResultRel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>natts</name></expr></argument>,
											<argument><expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>reltype</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* We ignore the value of found_whole_row. */</comment>
					<expr_stmt><expr><name>clause</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
						<call><name>map_variable_attnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>,
											<argument><expr><name>firstVarno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
											<argument><expr><name>part_attnos</name></expr></argument>,
											<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>firstResultRel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>natts</name></expr></argument>,
											<argument><expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>reltype</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* We ignore the value of found_whole_row. */</comment>
					<expr_stmt><expr><name><name>onconfl</name><operator>-&gt;</operator><name>oc_WhereClause</name></name> <operator>=</operator>
						<call><name>ExecInitQual</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>proute</name><operator>-&gt;</operator><name>partitions</name><index>[<expr><name>partidx</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>partitions</name><index>[<expr><name>partidx</name></expr>]</index></name> <operator>=</operator> <name>leaf_part_rri</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>leaf_part_rri</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecInitRoutingInfo
 *		Set up information needed for routing tuples to a leaf partition
 */</comment>
<function><type><name>void</name></type>
<name>ExecInitRoutingInfo</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>,
					<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
					<parameter><decl><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type><name>proute</name></decl></parameter>,
					<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>partRelInfo</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>partidx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rootRelInfo</name> <init>= <expr><name><name>partRelInfo</name><operator>-&gt;</operator><name>ri_RootResultRelInfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Switch into per-query memory context.
	 */</comment>
	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up a tuple conversion map to convert a tuple routed to the
	 * partition from the parent's type to the partition's.
	 */</comment>
	<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>parent_child_tupconv_maps</name><index>[<expr><name>partidx</name></expr>]</index></name> <operator>=</operator>
		<call><name>convert_tuples_by_name</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>rootRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>partRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If a partition has a different rowtype than the root parent, initialize
	 * a slot dedicated to storing this partition's tuples.  The slot is used
	 * for various operations that are applied to tuples after routing, such
	 * as checking constraints.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>proute</name><operator>-&gt;</operator><name>parent_child_tupconv_maps</name><index>[<expr><name>partidx</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>partrel</name> <init>= <expr><name><name>partRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Initialize the array in proute where these slots are stored, if not
		 * already done.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>proute</name><operator>-&gt;</operator><name>partition_tuple_slots</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>partition_tuple_slots</name></name> <operator>=</operator> <operator>(</operator><name>TupleTableSlot</name> <operator>*</operator><operator>*</operator><operator>)</operator>
				<call><name>palloc0</name><argument_list>(<argument><expr><name><name>proute</name><operator>-&gt;</operator><name>num_partitions</name></name> <operator>*</operator>
						<sizeof>sizeof<argument_list>(<argument><expr><name>TupleTableSlot</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Initialize the slot itself setting its descriptor to this
		 * partition's TupleDesc; TupleDesc reference will be released at the
		 * end of the command.
		 */</comment>
		<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>partition_tuple_slots</name><index>[<expr><name>partidx</name></expr>]</index></name> <operator>=</operator>
			<call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
								   <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the partition is a foreign table, let the FDW init itself for
	 * routing tuples to the partition.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>partRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<name><name>partRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name><operator>-&gt;</operator><name>BeginForeignInsert</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>partRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name><operator>-&gt;</operator><name>BeginForeignInsert</name></name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>, <argument><expr><name>partRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>partRelInfo</name><operator>-&gt;</operator><name>ri_PartitionReadyForRouting</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecSetupChildParentMapForLeaf -- Initialize the per-leaf-partition
 * child-to-root tuple conversion map array.
 *
 * This map is required for capturing transition tuples when the target table
 * is a partitioned table. For a tuple that is routed by an INSERT or UPDATE,
 * we need to convert it from the leaf partition to the target table
 * descriptor.
 */</comment>
<function><type><name>void</name></type>
<name>ExecSetupChildParentMapForLeaf</name><parameter_list>(<parameter><decl><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type><name>proute</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>proute</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * These array elements get filled up with maps on an on-demand basis.
	 * Initially just set all of them to NULL.
	 */</comment>
	<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>child_parent_tupconv_maps</name></name> <operator>=</operator>
		<operator>(</operator><name>TupleConversionMap</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TupleConversionMap</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator>
										<name><name>proute</name><operator>-&gt;</operator><name>num_partitions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Same is the case for this array. All the values are set to false */</comment>
	<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>child_parent_map_not_required</name></name> <operator>=</operator>
		<operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>proute</name><operator>-&gt;</operator><name>num_partitions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * TupConvMapForLeaf -- Get the tuple conversion map for a given leaf partition
 * index.
 */</comment>
<function><type><name>TupleConversionMap</name> <modifier>*</modifier></type>
<name>TupConvMapForLeaf</name><parameter_list>(<parameter><decl><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type><name>proute</name></decl></parameter>,
				  <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rootRelInfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>leaf_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>resultRelInfos</name> <init>= <expr><name><name>proute</name><operator>-&gt;</operator><name>partitions</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier><modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>

	<comment type="block">/* Don't call this if we're not supposed to be using this type of map. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>proute</name><operator>-&gt;</operator><name>child_parent_tupconv_maps</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If it's already known that we don't need a map, return NULL. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>proute</name><operator>-&gt;</operator><name>child_parent_map_not_required</name><index>[<expr><name>leaf_index</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If we've already got a map, return it. */</comment>
	<expr_stmt><expr><name>map</name> <operator>=</operator> <operator>&amp;</operator><name><name>proute</name><operator>-&gt;</operator><name>child_parent_tupconv_maps</name><index>[<expr><name>leaf_index</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>map</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>*</operator><name>map</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* No map yet; try to create one. */</comment>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>resultRelInfos</name><index>[<expr><name>leaf_index</name></expr>]</index></name><operator>-&gt;</operator><name>ri_RelationDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>map</name> <operator>=</operator>
		<call><name>convert_tuples_by_name</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>,
							   <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>rootRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If it turns out no map is needed, remember for next time. */</comment>
	<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>child_parent_map_not_required</name><index>[<expr><name>leaf_index</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>map</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>

	<return>return <expr><operator>*</operator><name>map</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecCleanupTupleRouting -- Clean up objects allocated for partition tuple
 * routing.
 *
 * Close all the partitioned tables, leaf partitions, and their indices.
 */</comment>
<function><type><name>void</name></type>
<name>ExecCleanupTupleRouting</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>,
						<parameter><decl><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type><name>proute</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>subplan_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Remember, proute-&gt;partition_dispatch_info[0] corresponds to the root
	 * partitioned table, which we must not try to close, because it is the
	 * main target table of the query that will be closed by callers such as
	 * ExecEndPlan() or DoCopy(). Also, tupslot is NULL for the root
	 * partitioned table.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>proute</name><operator>-&gt;</operator><name>num_dispatch</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionDispatch</name></type> <name>pd</name> <init>= <expr><name><name>proute</name><operator>-&gt;</operator><name>partition_dispatch_info</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name><name>pd</name><operator>-&gt;</operator><name>reldesc</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>pd</name><operator>-&gt;</operator><name>tupslot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>proute</name><operator>-&gt;</operator><name>num_partitions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name> <init>= <expr><name><name>proute</name><operator>-&gt;</operator><name>partitions</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* skip further processsing for uninitialized partitions */</comment>
		<if_stmt><if>if <condition>(<expr><name>resultRelInfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Allow any FDWs to shut down if they've been exercised */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionReadyForRouting</name></name> <operator>&amp;&amp;</operator>
			<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name><operator>-&gt;</operator><name>EndForeignInsert</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name><operator>-&gt;</operator><name>EndForeignInsert</name></name><argument_list>(<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>,
														   <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If this result rel is one of the UPDATE subplan result rels, let
		 * ExecEndPlan() close it. For INSERT or COPY,
		 * proute-&gt;subplan_partition_offsets will always be NULL. Note that
		 * the subplan_partition_offsets array and the partitions array have
		 * the partitions in the same order. So, while we iterate over
		 * partitions array, we also iterate over the
		 * subplan_partition_offsets array in order to figure out which of the
		 * result rels are present in the UPDATE subplans.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>proute</name><operator>-&gt;</operator><name>subplan_partition_offsets</name></name> <operator>&amp;&amp;</operator>
			<name>subplan_index</name> <operator>&lt;</operator> <name><name>proute</name><operator>-&gt;</operator><name>num_subplan_partition_offsets</name></name> <operator>&amp;&amp;</operator>
			<name><name>proute</name><operator>-&gt;</operator><name>subplan_partition_offsets</name><index>[<expr><name>subplan_index</name></expr>]</index></name> <operator>==</operator> <name>i</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>subplan_index</name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ExecCloseIndices</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Release the standalone partition tuple descriptors, if any */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>proute</name><operator>-&gt;</operator><name>root_tuple_slot</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>proute</name><operator>-&gt;</operator><name>root_tuple_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RelationGetPartitionDispatchInfo
 *		Returns information necessary to route tuples down a partition tree
 *
 * The number of elements in the returned array (that is, the number of
 * PartitionDispatch objects for the partitioned tables in the partition tree)
 * is returned in *num_parted and a list of the OIDs of all the leaf
 * partitions of rel is returned in *leaf_part_oids.
 *
 * All the relations in the partition tree (including 'rel') must have been
 * locked (using at least the AccessShareLock) by the caller.
 */</comment>
<function><type><specifier>static</specifier> <name>PartitionDispatch</name> <modifier>*</modifier></type>
<name>RelationGetPartitionDispatchInfo</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
								 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_parted</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>leaf_part_oids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pdlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionDispatchData</name> <modifier>*</modifier><modifier>*</modifier></type><name>pd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>num_parted</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>leaf_part_oids</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>get_partition_dispatch_recurse</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pdlist</name></expr></argument>, <argument><expr><name>leaf_part_oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>num_parted</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>pdlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pd</name> <operator>=</operator> <operator>(</operator><name>PartitionDispatchData</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>*</operator><name>num_parted</name> <operator>*</operator>
										   <sizeof>sizeof<argument_list>(<argument><expr><name>PartitionDispatchData</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>pdlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name><name>pd</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>pd</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_partition_dispatch_recurse
 *		Recursively expand partition tree rooted at rel
 *
 * As the partition tree is expanded in a depth-first manner, we maintain two
 * global lists: of PartitionDispatch objects corresponding to partitioned
 * tables in *pds and of the leaf partition OIDs in *leaf_part_oids.
 *
 * Note that the order of OIDs of leaf partitions in leaf_part_oids matches
 * the order in which the planner's expand_partitioned_rtentry() processes
 * them.  It's not necessarily the case that the offsets match up exactly,
 * because constraint exclusion might prune away some partitions on the
 * planner side, whereas we'll always have the complete list; but unpruned
 * partitions will appear in the same order in the plan as they are returned
 * here.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_partition_dispatch_recurse</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>pds</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>leaf_part_oids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partdesc</name> <init>= <expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>partkey</name> <init>= <expr><call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionDispatch</name></type> <name>pd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build a PartitionDispatch for this table and add it to *pds. */</comment>
	<expr_stmt><expr><name>pd</name> <operator>=</operator> <operator>(</operator><name>PartitionDispatch</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionDispatchData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>pds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>pds</name></expr></argument>, <argument><expr><name>pd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pd</name><operator>-&gt;</operator><name>reldesc</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pd</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name>partkey</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pd</name><operator>-&gt;</operator><name>keystate</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pd</name><operator>-&gt;</operator><name>partdesc</name></name> <operator>=</operator> <name>partdesc</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>parent</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For every partitioned table other than the root, we must store a
		 * tuple table slot initialized with its tuple descriptor and a tuple
		 * conversion map to convert a tuple from its parent's rowtype to its
		 * own. That is to make sure that we are looking at the correct row
		 * using the correct tuple descriptor when computing its partition key
		 * for tuple routing.
		 */</comment>
		<expr_stmt><expr><name><name>pd</name><operator>-&gt;</operator><name>tupslot</name></name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pd</name><operator>-&gt;</operator><name>tupmap</name></name> <operator>=</operator> <call><name>convert_tuples_by_name_map_if_req</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>,
													   <argument><expr><name>tupdesc</name></expr></argument>,
													   <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Not required for the root partitioned table */</comment>
		<expr_stmt><expr><name><name>pd</name><operator>-&gt;</operator><name>tupslot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pd</name><operator>-&gt;</operator><name>tupmap</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Go look at each partition of this table.  If it's a leaf partition,
	 * simply add its OID to *leaf_part_oids.  If it's a partitioned table,
	 * recursively call get_partition_dispatch_recurse(), so that its
	 * partitions are processed as well and a corresponding PartitionDispatch
	 * object gets added to *pds.
	 *
	 * The 'indexes' array is used when searching for a partition matching a
	 * given tuple.  The actual value we store here depends on whether the
	 * array element belongs to a leaf partition or a subpartitioned table.
	 * For leaf partitions we store the index into *leaf_part_oids, and for
	 * sub-partitioned tables we store a negative version of the index into
	 * the *pds list.  Both indexes are 0-based, but the first element of the
	 * *pds list is the root partition, so 0 always means the first leaf. When
	 * searching, if we see a negative value, the search must continue in the
	 * corresponding sub-partition; otherwise, we've identified the correct
	 * partition.
	 */</comment>
	<expr_stmt><expr><name><name>pd</name><operator>-&gt;</operator><name>indexes</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>partrelid</name> <init>= <expr><name><name>partdesc</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>partrelid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>leaf_part_oids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><operator>*</operator><name>leaf_part_oids</name></expr></argument>, <argument><expr><name>partrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pd</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><operator>*</operator><name>leaf_part_oids</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * We assume all tables in the partition tree were already locked
			 * by the caller.
			 */</comment>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>partrel</name> <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name>partrelid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>pd</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><call><name>list_length</name><argument_list>(<argument><expr><operator>*</operator><name>pds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>get_partition_dispatch_recurse</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>pds</name></expr></argument>, <argument><expr><name>leaf_part_oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		FormPartitionKeyDatum
 *			Construct values[] and isnull[] arrays for the partition key
 *			of a tuple.
 *
 *	pd				Partition dispatch object of the partitioned table
 *	slot			Heap tuple from which to extract partition key
 *	estate			executor state for evaluating any partition key
 *					expressions (must be non-NULL)
 *	values			Array of partition key Datums (output area)
 *	isnull			Array of is-null indicators (output area)
 *
 * the ecxt_scantuple slot of estate's per-tuple expr context must point to
 * the heap tuple passed in.
 * ----------------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FormPartitionKeyDatum</name><parameter_list>(<parameter><decl><type><name>PartitionDispatch</name></type> <name>pd</name></decl></parameter>,
					  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
					  <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
					  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>partexpr_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pd</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>partexprs</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name><name>pd</name><operator>-&gt;</operator><name>keystate</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Check caller has set up context correctly */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>estate</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			   <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ecxt_scantuple</name> <operator>==</operator> <name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* First time through, set up expression evaluation state */</comment>
		<expr_stmt><expr><name><name>pd</name><operator>-&gt;</operator><name>keystate</name></name> <operator>=</operator> <call><name>ExecPrepareExprList</name><argument_list>(<argument><expr><name><name>pd</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>partexprs</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>partexpr_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>pd</name><operator>-&gt;</operator><name>keystate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pd</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>keycol</name> <init>= <expr><name><name>pd</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>keycol</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Plain column; get the value directly from the heap tuple */</comment>
			<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>keycol</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Expression; need to evaluate it */</comment>
			<if_stmt><if>if <condition>(<expr><name>partexpr_item</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"wrong number of partition key expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>ExecEvalExprSwitchContext</name><argument_list>(<argument><expr><operator>(</operator><name>ExprState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>partexpr_item</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>partexpr_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>partexpr_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>datum</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>isNull</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>partexpr_item</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"wrong number of partition key expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_partition_for_tuple
 *		Finds partition of relation which accepts the partition key specified
 *		in values and isnull
 *
 * Return value is index of the partition (&gt;= 0 and &lt; partdesc-&gt;nparts) if one
 * found or -1 if none found.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_partition_for_tuple</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>bound_offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>part_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name> <init>= <expr><call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partdesc</name> <init>= <expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name> <init>= <expr><name><name>partdesc</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Route as appropriate based on partitioning strategy. */</comment>
	<switch>switch <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PARTITION_STRATEGY_HASH</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>greatest_modulus</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>uint64</name></type>		<name>rowHash</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>greatest_modulus</name> <operator>=</operator> <call><name>get_hash_partition_greatest_modulus</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rowHash</name> <operator>=</operator> <call><name>compute_partition_hash_value</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr></argument>,
													   <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name></name></expr></argument>,
													   <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>part_index</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>rowHash</name> <operator>%</operator> <name>greatest_modulus</name></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PARTITION_STRATEGY_LIST</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>isnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>partition_bound_accepts_nulls</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>part_index</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>null_index</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type>		<name>equal</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>bound_offset</name> <operator>=</operator> <call><name>partition_list_bsearch</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name></name></expr></argument>,
													  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name></name></expr></argument>,
													  <argument><expr><name>boundinfo</name></expr></argument>,
													  <argument><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>equal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>bound_offset</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>equal</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>part_index</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>bound_offset</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><name>PARTITION_STRATEGY_RANGE</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type>		<name>equal</name> <init>= <expr><name>false</name></expr></init></decl>,
							<decl><type ref="prev"/><name>range_partkey_has_null</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * No range includes NULL, so this will be accepted by the
				 * default partition if there is one, and otherwise rejected.
				 */</comment>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>range_partkey_has_null</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>range_partkey_has_null</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>bound_offset</name> <operator>=</operator> <call><name>partition_range_datum_bsearch</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name></name></expr></argument>,
																 <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name></name></expr></argument>,
																 <argument><expr><name>boundinfo</name></expr></argument>,
																 <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr></argument>,
																 <argument><expr><name>values</name></expr></argument>,
																 <argument><expr><operator>&amp;</operator><name>equal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * The bound at bound_offset is less than or equal to the
					 * tuple value, so the bound at offset+1 is the upper
					 * bound of the partition we're looking for, if there
					 * actually exists one.
					 */</comment>
					<expr_stmt><expr><name>part_index</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>bound_offset</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected partition strategy: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>key</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * part_index &lt; 0 means we failed to find a partition of this parent. Use
	 * the default partition, if there is one.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>part_index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>part_index</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>default_index</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>part_index</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecBuildSlotPartitionKeyDescription
 *
 * This works very much like BuildIndexValueDescription() and is currently
 * used for building error messages when ExecFindPartition() fails to find
 * partition for a row.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ExecBuildSlotPartitionKeyDescription</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
									 <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
									 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>,
									 <parameter><decl><type><name>int</name></type> <name>maxfieldlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name> <init>= <expr><call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>partnatts</name> <init>= <expr><call><name>get_partition_natts</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>check_enable_rls</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RLS_ENABLED</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If the user has table-level access, just go build the description. */</comment>
	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_class_aclcheck</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Step through the columns of the partition key and make sure the
		 * user has SELECT rights on all of them.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>partnatts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name> <init>= <expr><call><name>get_partition_col_attnum</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * If this partition key column is an expression, we return no
			 * detail rather than try to figure out what column(s) the
			 * expression includes and if the user has SELECT rights on them.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <name>InvalidAttrNumber</name> <operator>||</operator>
				<call><name>pg_attribute_aclcheck</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
									  <argument><expr><name>ACL_SELECT</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"(%s) = ("</literal></expr></argument>,
					 <argument><expr><call><name>pg_get_partkeydef_columns</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>partnatts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>vallen</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="string">"null"</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>foutoid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>typisvarlena</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><call><name>get_partition_col_typid</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>foutoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typisvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>foutoid</name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* truncate if needed */</comment>
		<expr_stmt><expr><name>vallen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>vallen</name> <operator>&lt;=</operator> <name>maxfieldlen</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>vallen</name> <operator>=</operator> <call><name>pg_mbcliplen</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>vallen</name></expr></argument>, <argument><expr><name>maxfieldlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>vallen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * adjust_partition_tlist
 *		Re-order the targetlist entries for a given partition to account for
 *		column position differences between the parent and the partition.
 *
 * The expressions have already been fixed, but we must now re-order the
 * entries in case the partition has different column order, and possibly
 * add or remove dummy entries for dropped columns.
 *
 * Although a new List is returned, this feels free to scribble on resno
 * fields of the given tlist, so that should be a working copy.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>adjust_partition_tlist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>map</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_tlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><name><name>map</name><operator>-&gt;</operator><name>outdesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attrMap</name> <init>= <expr><name><name>map</name><operator>-&gt;</operator><name>attrMap</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attrno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>attrno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>attrno</name> <operator>&lt;=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>attrno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att_tup</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attrno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>parentattrno</name> <init>= <expr><name><name>attrMap</name><index>[<expr><name>attrno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>parentattrno</name> <operator>!=</operator> <name>InvalidAttrNumber</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Use the corresponding entry from the parent's tlist, adjusting
			 * the resno to match the partition's attno.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>att_tup</name><operator>-&gt;</operator><name>attisdropped</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tle</name> <operator>=</operator> <operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>parentattrno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>==</operator> <name>parentattrno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name>attrno</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * For a dropped attribute in the partition, generate a dummy
			 * entry with resno matching the partition's attno.  This should
			 * match what expand_targetlist() does.
			 */</comment>
			<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>attisdropped</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>,
							 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
							 <argument><expr><name>InvalidOid</name></expr></argument>,
							 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>,
							 <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
							 <argument><expr><name>true</name></expr></argument>,	<comment type="block">/* isnull */</comment>
							 <argument><expr><name>true</name></expr></argument> <comment type="block">/* byval */</comment> )</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>,
								  <argument><expr><name>attrno</name></expr></argument>,
								  <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>new_tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_tlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Finally, attach any resjunk entries to the end of the new tlist */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>new_tlist</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>new_tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_tlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>new_tlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*-------------------------------------------------------------------------
 * Run-Time Partition Pruning Support.
 *
 * The following series of functions exist to support the removal of unneeded
 * subplans for queries against partitioned tables.  The supporting functions
 * here are designed to work with any plan type which supports an arbitrary
 * number of subplans, e.g. Append, MergeAppend.
 *
 * When pruning involves comparison of a partition key to a constant, it's
 * done by the planner.  However, if we have a comparison to a non-constant
 * but not volatile expression, that presents an opportunity for run-time
 * pruning by the executor, allowing irrelevant partitions to be skipped
 * dynamically.
 *
 * We must distinguish expressions containing PARAM_EXEC Params from
 * expressions that don't contain those.  Even though a PARAM_EXEC Param is
 * considered to be a stable expression, it can change value from one plan
 * node scan to the next during query execution.  Stable comparison
 * expressions that don't involve such Params allow partition pruning to be
 * done once during executor startup.  Expressions that do involve such Params
 * require us to prune separately for each scan of the parent plan node.
 *
 * Note that pruning away unneeded subplans during executor startup has the
 * added benefit of not having to initialize the unneeded subplans at all.
 *
 *
 * Functions:
 *
 * ExecCreatePartitionPruneState:
 *		Creates the PartitionPruneState required by each of the two pruning
 *		functions.  Details stored include how to map the partition index
 *		returned by the partition pruning code into subplan indexes.
 *
 * ExecDestroyPartitionPruneState:
 *		Deletes a PartitionPruneState. Must be called during executor shutdown.
 *
 * ExecFindInitialMatchingSubPlans:
 *		Returns indexes of matching subplans.  Partition pruning is attempted
 *		without any evaluation of expressions containing PARAM_EXEC Params.
 *		This function must be called during executor startup for the parent
 *		plan before the subplans themselves are initialized.  Subplans which
 *		are found not to match by this function must be removed from the
 *		plan's list of subplans during execution, as this function performs a
 *		remap of the partition index to subplan index map and the newly
 *		created map provides indexes only for subplans which remain after
 *		calling this function.
 *
 * ExecFindMatchingSubPlans:
 *		Returns indexes of matching subplans after evaluating all available
 *		expressions.  This function can only be called during execution and
 *		must be called again each time the value of a Param listed in
 *		PartitionPruneState's 'execparamids' changes.
 *-------------------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * ExecCreatePartitionPruneState
 *		Build the data structure required for calling
 *		ExecFindInitialMatchingSubPlans and ExecFindMatchingSubPlans.
 *
 * 'planstate' is the parent plan node's execution state.
 *
 * 'partitionpruneinfo' is a PartitionPruneInfo as generated by
 * make_partition_pruneinfo.  Here we build a PartitionPruneState containing a
 * PartitionPruningData for each partitioning hierarchy (i.e., each sublist of
 * partitionpruneinfo-&gt;prune_infos), each of which contains a
 * PartitionedRelPruningData for each PartitionedRelPruneInfo appearing in
 * that sublist.  This two-level system is needed to keep from confusing the
 * different hierarchies when a UNION ALL contains multiple partitioned tables
 * as children.  The data stored in each PartitionedRelPruningData can be
 * re-used each time we re-evaluate which partitions match the pruning steps
 * provided in each PartitionedRelPruneInfo.
 */</comment>
<function><type><name>PartitionPruneState</name> <modifier>*</modifier></type>
<name>ExecCreatePartitionPruneState</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
							  <parameter><decl><type><name>PartitionPruneInfo</name> <modifier>*</modifier></type><name>partitionpruneinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionPruneState</name> <modifier>*</modifier></type><name>prunestate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>n_part_hierarchies</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>n_part_hierarchies</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>partitionpruneinfo</name><operator>-&gt;</operator><name>prune_infos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>n_part_hierarchies</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate the data structure
	 */</comment>
	<expr_stmt><expr><name>prunestate</name> <operator>=</operator> <operator>(</operator><name>PartitionPruneState</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PartitionPruneState</name></expr></argument>, <argument><expr><name>partprunedata</name></expr></argument>)</argument_list></call> <operator>+</operator>
			   <sizeof>sizeof<argument_list>(<argument><expr><name>PartitionPruningData</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>n_part_hierarchies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>prunestate</name><operator>-&gt;</operator><name>execparamids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<comment type="block">/* other_subplans can change at runtime, so we need our own copy */</comment>
	<expr_stmt><expr><name><name>prunestate</name><operator>-&gt;</operator><name>other_subplans</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>partitionpruneinfo</name><operator>-&gt;</operator><name>other_subplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prunestate</name><operator>-&gt;</operator><name>do_initial_prune</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* may be set below */</comment>
	<expr_stmt><expr><name><name>prunestate</name><operator>-&gt;</operator><name>do_exec_prune</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* may be set below */</comment>
	<expr_stmt><expr><name><name>prunestate</name><operator>-&gt;</operator><name>num_partprunedata</name></name> <operator>=</operator> <name>n_part_hierarchies</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create a short-term memory context which we'll use when making calls to
	 * the partition pruning functions.  This avoids possible memory leaks,
	 * since the pruning functions call comparison functions that aren't under
	 * our control.
	 */</comment>
	<expr_stmt><expr><name><name>prunestate</name><operator>-&gt;</operator><name>prune_context</name></name> <operator>=</operator>
		<call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr></argument>,
							  <argument><expr><literal type="string">"Partition Prune"</literal></expr></argument>,
							  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>partitionpruneinfo-&gt;prune_infos</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partrelpruneinfos</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>npartrelpruneinfos</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>partrelpruneinfos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PartitionPruningData</name> <modifier>*</modifier></type><name>prunedata</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>prunedata</name> <operator>=</operator> <operator>(</operator><name>PartitionPruningData</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PartitionPruningData</name></expr></argument>, <argument><expr><name>partrelprunedata</name></expr></argument>)</argument_list></call> <operator>+</operator>
				   <name>npartrelpruneinfos</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PartitionedRelPruningData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prunestate</name><operator>-&gt;</operator><name>partprunedata</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>prunedata</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prunedata</name><operator>-&gt;</operator><name>num_partrelprunedata</name></name> <operator>=</operator> <name>npartrelpruneinfos</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>partrelpruneinfos</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PartitionedRelPruneInfo</name> <modifier>*</modifier></type><name>pinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>PartitionedRelPruneInfo</name></expr></argument>, <argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PartitionedRelPruningData</name> <modifier>*</modifier></type><name>pprune</name> <init>= <expr><operator>&amp;</operator><name><name>prunedata</name><operator>-&gt;</operator><name>partrelprunedata</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PartitionPruneContext</name> <modifier>*</modifier></type><name>context</name> <init>= <expr><operator>&amp;</operator><name><name>pprune</name><operator>-&gt;</operator><name>context</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partdesc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PartitionKey</name></type> <name>partkey</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>partnatts</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>n_steps</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc3</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * We must copy the subplan_map rather than pointing directly to
			 * the plan's version, as we may end up making modifications to it
			 * later.
			 */</comment>
			<expr_stmt><expr><name><name>pprune</name><operator>-&gt;</operator><name>subplan_map</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>pinfo</name><operator>-&gt;</operator><name>nparts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pprune</name><operator>-&gt;</operator><name>subplan_map</name></name></expr></argument>, <argument><expr><name><name>pinfo</name><operator>-&gt;</operator><name>subplan_map</name></name></expr></argument>,
				   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>pinfo</name><operator>-&gt;</operator><name>nparts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* We can use the subpart_map verbatim, since we never modify it */</comment>
			<expr_stmt><expr><name><name>pprune</name><operator>-&gt;</operator><name>subpart_map</name></name> <operator>=</operator> <name><name>pinfo</name><operator>-&gt;</operator><name>subpart_map</name></name></expr>;</expr_stmt>

			<comment type="block">/* present_parts is also subject to later modification */</comment>
			<expr_stmt><expr><name><name>pprune</name><operator>-&gt;</operator><name>present_parts</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>pinfo</name><operator>-&gt;</operator><name>present_parts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We need to hold a pin on the partitioned table's relcache entry
			 * so that we can rely on its copies of the table's partition key
			 * and partition descriptor.  We need not get a lock though; one
			 * should have been acquired already by InitPlan or
			 * ExecLockNonLeafAppendTables.
			 */</comment>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>partrel</name></name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name><name>pinfo</name><operator>-&gt;</operator><name>reloid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>partkey</name> <operator>=</operator> <call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>partrel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>partdesc</name> <operator>=</operator> <call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>partrel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>n_steps</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pinfo</name><operator>-&gt;</operator><name>pruning_steps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name><name>partkey</name><operator>-&gt;</operator><name>strategy</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>=</operator> <name>partnatts</name> <operator>=</operator> <name><name>partkey</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>nparts</name></name> <operator>=</operator> <name><name>pinfo</name><operator>-&gt;</operator><name>nparts</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>boundinfo</name></name> <operator>=</operator> <name><name>partdesc</name><operator>-&gt;</operator><name>boundinfo</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>partcollation</name></name> <operator>=</operator> <name><name>partkey</name><operator>-&gt;</operator><name>partcollation</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>partsupfunc</name></name> <operator>=</operator> <name><name>partkey</name><operator>-&gt;</operator><name>partsupfunc</name></name></expr>;</expr_stmt>

			<comment type="block">/* We'll look up type-specific support functions as needed */</comment>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>stepcmpfuncs</name></name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator>
				<call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>n_steps</name> <operator>*</operator> <name>partnatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>ppccontext</name></name> <operator>=</operator> <call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>planstate</name></name> <operator>=</operator> <name>planstate</name></expr>;</expr_stmt>

			<comment type="block">/* Initialize expression state for each expression we need */</comment>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>exprstates</name></name> <operator>=</operator> <operator>(</operator><name>ExprState</name> <operator>*</operator><operator>*</operator><operator>)</operator>
				<call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExprState</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>n_steps</name> <operator>*</operator> <name>partnatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>lc3</argument>, <argument>pinfo-&gt;pruning_steps</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PartitionPruneStepOp</name> <modifier>*</modifier></type><name>step</name> <init>= <expr><operator>(</operator><name>PartitionPruneStepOp</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc3</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc4</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>keyno</name></decl>;</decl_stmt>

				<comment type="block">/* not needed for other step kinds */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>step</name></expr></argument>, <argument><expr><name>PartitionPruneStepOp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>partnatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>keyno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>lc4</argument>, <argument>step-&gt;exprs</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc4</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<comment type="block">/* not needed for Consts */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>int</name></type>			<name>stateidx</name> <init>= <expr><call><name>PruneCxtStateIdx</name><argument_list>(<argument><expr><name>partnatts</name></expr></argument>,
																<argument><expr><name><name>step</name><operator>-&gt;</operator><name>step</name><operator>.</operator><name>step_id</name></name></expr></argument>,
																<argument><expr><name>keyno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>exprstates</name><index>[<expr><name>stateidx</name></expr>]</index></name> <operator>=</operator>
							<call><name>ExecInitExpr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name>keyno</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block>
			</block_content>}</block>

			<comment type="block">/* Array is not modified at runtime, so just point to plan's copy */</comment>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>exprhasexecparam</name></name> <operator>=</operator> <name><name>pinfo</name><operator>-&gt;</operator><name>hasexecparam</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>pprune</name><operator>-&gt;</operator><name>pruning_steps</name></name> <operator>=</operator> <name><name>pinfo</name><operator>-&gt;</operator><name>pruning_steps</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pprune</name><operator>-&gt;</operator><name>do_initial_prune</name></name> <operator>=</operator> <name><name>pinfo</name><operator>-&gt;</operator><name>do_initial_prune</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pprune</name><operator>-&gt;</operator><name>do_exec_prune</name></name> <operator>=</operator> <name><name>pinfo</name><operator>-&gt;</operator><name>do_exec_prune</name></name></expr>;</expr_stmt>

			<comment type="block">/* Record if pruning would be useful at any level */</comment>
			<expr_stmt><expr><name><name>prunestate</name><operator>-&gt;</operator><name>do_initial_prune</name></name> <operator>|=</operator> <name><name>pinfo</name><operator>-&gt;</operator><name>do_initial_prune</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>prunestate</name><operator>-&gt;</operator><name>do_exec_prune</name></name> <operator>|=</operator> <name><name>pinfo</name><operator>-&gt;</operator><name>do_exec_prune</name></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Accumulate the IDs of all PARAM_EXEC Params affecting the
			 * partitioning decisions at this plan node.
			 */</comment>
			<expr_stmt><expr><name><name>prunestate</name><operator>-&gt;</operator><name>execparamids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>prunestate</name><operator>-&gt;</operator><name>execparamids</name></name></expr></argument>,
													   <argument><expr><name><name>pinfo</name><operator>-&gt;</operator><name>execparamids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>prunestate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecDestroyPartitionPruneState
 *		Release resources at plan shutdown.
 *
 * We don't bother to free any memory here, since the whole executor context
 * will be going away shortly.  We do need to release our relcache pins.
 */</comment>
<function><type><name>void</name></type>
<name>ExecDestroyPartitionPruneState</name><parameter_list>(<parameter><decl><type><name>PartitionPruneState</name> <modifier>*</modifier></type><name>prunestate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionPruningData</name> <modifier>*</modifier><modifier>*</modifier></type><name>partprunedata</name> <init>= <expr><name><name>prunestate</name><operator>-&gt;</operator><name>partprunedata</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>prunestate</name><operator>-&gt;</operator><name>num_partprunedata</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionPruningData</name> <modifier>*</modifier></type><name>prunedata</name> <init>= <expr><name><name>partprunedata</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PartitionedRelPruningData</name> <modifier>*</modifier></type><name>pprune</name> <init>= <expr><name><name>prunedata</name><operator>-&gt;</operator><name>partrelprunedata</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>prunedata</name><operator>-&gt;</operator><name>num_partrelprunedata</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name><name>pprune</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>context</name><operator>.</operator><name>partrel</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * ExecFindInitialMatchingSubPlans
 *		Identify the set of subplans that cannot be eliminated by initial
 *		pruning (disregarding any pruning constraints involving PARAM_EXEC
 *		Params).  Also re-map the translation matrix which allows conversion
 *		of partition indexes into subplan indexes to account for the unneeded
 *		subplans having been removed.
 *
 * Must only be called once per 'prunestate', and only if initial pruning
 * is required.
 *
 * 'nsubplans' must be passed as the total number of unpruned subplans.
 */</comment>
<function><type><name>Bitmapset</name> <modifier>*</modifier></type>
<name>ExecFindInitialMatchingSubPlans</name><parameter_list>(<parameter><decl><type><name>PartitionPruneState</name> <modifier>*</modifier></type><name>prunestate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nsubplans</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>prunestate</name><operator>-&gt;</operator><name>do_initial_prune</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Switch to a temp context to avoid leaking memory in the executor's
	 * memory context.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>prunestate</name><operator>-&gt;</operator><name>prune_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For each hierarchy, do the pruning tests, and add deletable subplans'
	 * indexes to "result".
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>prunestate</name><operator>-&gt;</operator><name>num_partprunedata</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionPruningData</name> <modifier>*</modifier></type><name>prunedata</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PartitionedRelPruningData</name> <modifier>*</modifier></type><name>pprune</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>prunedata</name> <operator>=</operator> <name><name>prunestate</name><operator>-&gt;</operator><name>partprunedata</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pprune</name> <operator>=</operator> <operator>&amp;</operator><name><name>prunedata</name><operator>-&gt;</operator><name>partrelprunedata</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/* Perform pruning without using PARAM_EXEC Params */</comment>
		<expr_stmt><expr><call><name>find_matching_subplans_recurse</name><argument_list>(<argument><expr><name>prunedata</name></expr></argument>, <argument><expr><name>pprune</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Expression eval may have used space in node's ps_ExprContext too */</comment>
		<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name><name>pprune</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>planstate</name><operator>-&gt;</operator><name>ps_ExprContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy result out of the temp context before we reset it */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add in any subplans that partition pruning didn't account for */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>prunestate</name><operator>-&gt;</operator><name>other_subplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>prunestate</name><operator>-&gt;</operator><name>prune_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If any subplans were pruned, we must re-sequence the subplan indexes so
	 * that ExecFindMatchingSubPlans properly returns the indexes from the
	 * subplans which will remain after execution of this function.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>nsubplans</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>new_subplan_indexes</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>new_other_subplans</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>newidx</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * First we must build a temporary array which maps old subplan
		 * indexes to new ones.  While we're at it, also recompute the
		 * other_subplans set, since indexes in it may change.
		 */</comment>
		<expr_stmt><expr><name>new_subplan_indexes</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nsubplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_other_subplans</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>newidx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nsubplans</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>new_subplan_indexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>newidx</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>new_subplan_indexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* Newly pruned */</comment>

			<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>prunestate</name><operator>-&gt;</operator><name>other_subplans</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>new_other_subplans</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>new_other_subplans</name></expr></argument>,
													<argument><expr><name><name>new_subplan_indexes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>prunestate</name><operator>-&gt;</operator><name>other_subplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prunestate</name><operator>-&gt;</operator><name>other_subplans</name></name> <operator>=</operator> <name>new_other_subplans</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now we can update each PartitionedRelPruneInfo's subplan_map with
		 * new subplan indexes.  We must also recompute its present_parts
		 * bitmap.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>prunestate</name><operator>-&gt;</operator><name>num_partprunedata</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PartitionPruningData</name> <modifier>*</modifier></type><name>prunedata</name> <init>= <expr><name><name>prunestate</name><operator>-&gt;</operator><name>partprunedata</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Within each hierarchy, we perform this loop in back-to-front
			 * order so that we determine present_parts for the lowest-level
			 * partitioned tables first.  This way we can tell whether a
			 * sub-partitioned table's partitions were entirely pruned so we
			 * can exclude that from 'present_parts'.
			 */</comment>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name><name>prunedata</name><operator>-&gt;</operator><name>num_partrelprunedata</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PartitionedRelPruningData</name> <modifier>*</modifier></type><name>pprune</name> <init>= <expr><operator>&amp;</operator><name><name>prunedata</name><operator>-&gt;</operator><name>partrelprunedata</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>nparts</name> <init>= <expr><name><name>pprune</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>nparts</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>k</name></decl>;</decl_stmt>

				<comment type="block">/* We just rebuild present_parts from scratch */</comment>
				<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>pprune</name><operator>-&gt;</operator><name>present_parts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pprune</name><operator>-&gt;</operator><name>present_parts</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>nparts</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>oldidx</name> <init>= <expr><name><name>pprune</name><operator>-&gt;</operator><name>subplan_map</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>subidx</name></decl>;</decl_stmt>

					<comment type="block">/*
					 * If this partition existed as a subplan then change the
					 * old subplan index to the new subplan index.  The new
					 * index may become -1 if the partition was pruned above,
					 * or it may just come earlier in the subplan list due to
					 * some subplans being removed earlier in the list.  If
					 * it's a subpartition, add it to present_parts unless
					 * it's entirely pruned.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>oldidx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>oldidx</name> <operator>&lt;</operator> <name>nsubplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>pprune</name><operator>-&gt;</operator><name>subplan_map</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name><name>new_subplan_indexes</name><index>[<expr><name>oldidx</name></expr>]</index></name></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><name><name>new_subplan_indexes</name><index>[<expr><name>oldidx</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>pprune</name><operator>-&gt;</operator><name>present_parts</name></name> <operator>=</operator>
								<call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>pprune</name><operator>-&gt;</operator><name>present_parts</name></name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><operator>(</operator><name>subidx</name> <operator>=</operator> <name><name>pprune</name><operator>-&gt;</operator><name>subpart_map</name><index>[<expr><name>k</name></expr>]</index></name><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>PartitionedRelPruningData</name> <modifier>*</modifier></type><name>subprune</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>subprune</name> <operator>=</operator> <operator>&amp;</operator><name><name>prunedata</name><operator>-&gt;</operator><name>partrelprunedata</name><index>[<expr><name>subidx</name></expr>]</index></name></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>subprune</name><operator>-&gt;</operator><name>present_parts</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>pprune</name><operator>-&gt;</operator><name>present_parts</name></name> <operator>=</operator>
								<call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>pprune</name><operator>-&gt;</operator><name>present_parts</name></name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
			</block_content>}</block></for>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_subplan_indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecFindMatchingSubPlans
 *		Determine which subplans match the pruning steps detailed in
 *		'prunestate' for the current comparison expression values.
 *
 * Here we assume we may evaluate PARAM_EXEC Params.
 */</comment>
<function><type><name>Bitmapset</name> <modifier>*</modifier></type>
<name>ExecFindMatchingSubPlans</name><parameter_list>(<parameter><decl><type><name>PartitionPruneState</name> <modifier>*</modifier></type><name>prunestate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Switch to a temp context to avoid leaking memory in the executor's
	 * memory context.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>prunestate</name><operator>-&gt;</operator><name>prune_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For each hierarchy, do the pruning tests, and add deletable subplans'
	 * indexes to "result".
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>prunestate</name><operator>-&gt;</operator><name>num_partprunedata</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionPruningData</name> <modifier>*</modifier></type><name>prunedata</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PartitionedRelPruningData</name> <modifier>*</modifier></type><name>pprune</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>prunedata</name> <operator>=</operator> <name><name>prunestate</name><operator>-&gt;</operator><name>partprunedata</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pprune</name> <operator>=</operator> <operator>&amp;</operator><name><name>prunedata</name><operator>-&gt;</operator><name>partrelprunedata</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>find_matching_subplans_recurse</name><argument_list>(<argument><expr><name>prunedata</name></expr></argument>, <argument><expr><name>pprune</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Expression eval may have used space in node's ps_ExprContext too */</comment>
		<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name><name>pprune</name><operator>-&gt;</operator><name>context</name><operator>.</operator><name>planstate</name><operator>-&gt;</operator><name>ps_ExprContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy result out of the temp context before we reset it */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add in any subplans that partition pruning didn't account for */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>prunestate</name><operator>-&gt;</operator><name>other_subplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>prunestate</name><operator>-&gt;</operator><name>prune_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * find_matching_subplans_recurse
 *		Recursive worker function for ExecFindMatchingSubPlans and
 *		ExecFindInitialMatchingSubPlans
 *
 * Adds valid (non-prunable) subplan IDs to *validsubplans
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>find_matching_subplans_recurse</name><parameter_list>(<parameter><decl><type><name>PartitionPruningData</name> <modifier>*</modifier></type><name>prunedata</name></decl></parameter>,
							   <parameter><decl><type><name>PartitionedRelPruningData</name> <modifier>*</modifier></type><name>pprune</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>initial_prune</name></decl></parameter>,
							   <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier><modifier>*</modifier></type><name>validsubplans</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>partset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Guard against stack overflow due to overly deep partition hierarchy. */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Only prune if pruning would be useful at this level. */</comment>
	<if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>initial_prune</name></expr> ?</condition><then> <expr><name><name>pprune</name><operator>-&gt;</operator><name>do_initial_prune</name></name></expr> </then><else>: <expr><name><name>pprune</name><operator>-&gt;</operator><name>do_exec_prune</name></name></expr></else></ternary></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionPruneContext</name> <modifier>*</modifier></type><name>context</name> <init>= <expr><operator>&amp;</operator><name><name>pprune</name><operator>-&gt;</operator><name>context</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Set whether we can evaluate PARAM_EXEC Params or not */</comment>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>evalexecparams</name></name> <operator>=</operator> <operator>!</operator><name>initial_prune</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>partset</name> <operator>=</operator> <call><name>get_matching_partitions</name><argument_list>(<argument><expr><name>context</name></expr></argument>,
										  <argument><expr><name><name>pprune</name><operator>-&gt;</operator><name>pruning_steps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If no pruning is to be done, just include all partitions at this
		 * level.
		 */</comment>
		<expr_stmt><expr><name>partset</name> <operator>=</operator> <name><name>pprune</name><operator>-&gt;</operator><name>present_parts</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Translate partset into subplan indexes */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>partset</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>pprune</name><operator>-&gt;</operator><name>subplan_map</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>validsubplans</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><operator>*</operator><name>validsubplans</name></expr></argument>,
											<argument><expr><name><name>pprune</name><operator>-&gt;</operator><name>subplan_map</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>partidx</name> <init>= <expr><name><name>pprune</name><operator>-&gt;</operator><name>subpart_map</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>partidx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>find_matching_subplans_recurse</name><argument_list>(<argument><expr><name>prunedata</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name><name>prunedata</name><operator>-&gt;</operator><name>partrelprunedata</name><index>[<expr><name>partidx</name></expr>]</index></name></expr></argument>,
											   <argument><expr><name>initial_prune</name></expr></argument>, <argument><expr><name>validsubplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * We get here if the planner already pruned all the sub-
				 * partitions for this partition.  Silently ignore this
				 * partition in this case.  The end result is the same: we
				 * would have pruned all partitions just the same, but we
				 * don't have any pruning steps to execute to verify this.
				 */</comment>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>
</unit>
