<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/tsearch/ts_typanalyze.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * ts_typanalyze.c
 *	  functions for gathering statistics from tsvector columns
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 *
 *
 * IDENTIFICATION
 *	  src/backend/tsearch/ts_typanalyze.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/vacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tsearch/ts_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>


<comment type="block">/* A hash key for lexemes */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>lexeme</name></decl>;</decl_stmt>			<comment type="block">/* lexeme (not NULL terminated!) */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>length</name></decl>;</decl_stmt>			<comment type="block">/* its length in bytes */</comment>
}</block></struct></type> <name>LexemeHashKey</name>;</typedef>

<comment type="block">/* A hash table entry for the Lossy Counting algorithm */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>LexemeHashKey</name></type> <name>key</name></decl>;</decl_stmt>			<comment type="block">/* This is 'e' from the LC algorithm. */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>frequency</name></decl>;</decl_stmt>		<comment type="block">/* This is 'f'. */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>delta</name></decl>;</decl_stmt>			<comment type="block">/* And this is 'delta'. */</comment>
}</block></struct></type> <name>TrackItem</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>compute_tsvector_stats</name><parameter_list>(<parameter><decl><type><name>VacAttrStats</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>,
					   <parameter><decl><type><name>AnalyzeAttrFetchFunc</name></type> <name>fetchfunc</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>samplerows</name></decl></parameter>,
					   <parameter><decl><type><name>double</name></type> <name>totalrows</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>prune_lexemes_hashtable</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>lexemes_tab</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b_current</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>lexeme_hash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>lexeme_match</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key2</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>lexeme_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>trackitem_compare_frequencies_desc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>e1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>e2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>trackitem_compare_lexemes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>e1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>e2</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 *	ts_typanalyze -- a custom typanalyze function for tsvector columns
 */</comment>
<function><type><name>Datum</name></type>
<name>ts_typanalyze</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>VacAttrStats</name> <modifier>*</modifier></type><name>stats</name> <init>= <expr><operator>(</operator><name>VacAttrStats</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* If the attstattarget column is negative, use the default value */</comment>
	<comment type="block">/* NB: it is okay to scribble on stats-&gt;attr since it's a copy */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name> <operator>=</operator> <name>default_statistics_target</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>compute_stats</name></name> <operator>=</operator> <name>compute_tsvector_stats</name></expr>;</expr_stmt>
	<comment type="block">/* see comment about the choice of minrows in commands/analyze.c */</comment>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>minrows</name></name> <operator>=</operator> <literal type="number">300</literal> <operator>*</operator> <name><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	compute_tsvector_stats() -- compute statistics for a tsvector column
 *
 *	This functions computes statistics that are useful for determining @@
 *	operations' selectivity, along with the fraction of non-null rows and
 *	average width.
 *
 *	Instead of finding the most common values, as we do for most datatypes,
 *	we're looking for the most common lexemes. This is more useful, because
 *	there most probably won't be any two rows with the same tsvector and thus
 *	the notion of a MCV is a bit bogus with this datatype. With a list of the
 *	most common lexemes we can do a better job at figuring out @@ selectivity.
 *
 *	For the same reasons we assume that tsvector columns are unique when
 *	determining the number of distinct values.
 *
 *	The algorithm used is Lossy Counting, as proposed in the paper "Approximate
 *	frequency counts over data streams" by G. S. Manku and R. Motwani, in
 *	Proceedings of the 28th International Conference on Very Large Data Bases,
 *	Hong Kong, China, August 2002, section 4.2. The paper is available at
 *	http://www.vldb.org/conf/2002/S10P03.pdf
 *
 *	The Lossy Counting (aka LC) algorithm goes like this:
 *	Let s be the threshold frequency for an item (the minimum frequency we
 *	are interested in) and epsilon the error margin for the frequency. Let D
 *	be a set of triples (e, f, delta), where e is an element value, f is that
 *	element's frequency (actually, its current occurrence count) and delta is
 *	the maximum error in f. We start with D empty and process the elements in
 *	batches of size w. (The batch size is also known as "bucket size" and is
 *	equal to 1/epsilon.) Let the current batch number be b_current, starting
 *	with 1. For each element e we either increment its f count, if it's
 *	already in D, or insert a new triple into D with values (e, 1, b_current
 *	- 1). After processing each batch we prune D, by removing from it all
 *	elements with f + delta &lt;= b_current.  After the algorithm finishes we
 *	suppress all elements from D that do not satisfy f &gt;= (s - epsilon) * N,
 *	where N is the total number of elements in the input.  We emit the
 *	remaining elements with estimated frequency f/N.  The LC paper proves
 *	that this algorithm finds all elements with true frequency at least s,
 *	and that no frequency is overestimated or is underestimated by more than
 *	epsilon.  Furthermore, given reasonable assumptions about the input
 *	distribution, the required table size is no more than about 7 times w.
 *
 *	We set s to be the estimated frequency of the K'th word in a natural
 *	language's frequency table, where K is the target number of entries in
 *	the MCELEM array plus an arbitrary constant, meant to reflect the fact
 *	that the most common words in any language would usually be stopwords
 *	so we will not actually see them in the input.  We assume that the
 *	distribution of word frequencies (including the stopwords) follows Zipf's
 *	law with an exponent of 1.
 *
 *	Assuming Zipfian distribution, the frequency of the K'th word is equal
 *	to 1/(K * H(W)) where H(n) is 1/2 + 1/3 + ... + 1/n and W is the number of
 *	words in the language.  Putting W as one million, we get roughly 0.07/K.
 *	Assuming top 10 words are stopwords gives s = 0.07/(K + 10).  We set
 *	epsilon = s/10, which gives bucket width w = (K + 10)/0.007 and
 *	maximum expected hashtable size of about 1000 * (K + 10).
 *
 *	Note: in the above discussion, s, epsilon, and f/N are in terms of a
 *	lexeme's frequency as a fraction of all lexemes seen in the input.
 *	However, what we actually want to store in the finished pg_statistic
 *	entry is each lexeme's frequency as a fraction of all rows that it occurs
 *	in.  Assuming that the input tsvectors are correctly constructed, no
 *	lexeme occurs more than once per tsvector, so the final count f is a
 *	correct estimate of the number of input tsvectors it occurs in, and we
 *	need only change the divisor from N to nonnull_cnt to get the number we
 *	want.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compute_tsvector_stats</name><parameter_list>(<parameter><decl><type><name>VacAttrStats</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>,
					   <parameter><decl><type><name>AnalyzeAttrFetchFunc</name></type> <name>fetchfunc</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>samplerows</name></decl></parameter>,
					   <parameter><decl><type><name>double</name></type> <name>totalrows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_mcelem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>null_cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>total_width</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* This is D from the LC algorithm. */</comment>
	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>lexemes_tab</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>hash_ctl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>scan_status</name></decl>;</decl_stmt>

	<comment type="block">/* This is the current bucket number from the LC algorithm */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>b_current</name></decl>;</decl_stmt>

	<comment type="block">/* This is 'w' from the LC algorithm */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>bucket_width</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>vector_no</name></decl>,
				<decl><type ref="prev"/><name>lexeme_no</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LexemeHashKey</name></type> <name>hash_key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TrackItem</name>  <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We want statistics_target * 10 lexemes in the MCELEM array.  This
	 * multiplier is pretty arbitrary, but is meant to reflect the fact that
	 * the number of individual lexeme values tracked in pg_statistic ought to
	 * be more than the number of values for a simple scalar column.
	 */</comment>
	<expr_stmt><expr><name>num_mcelem</name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name> <operator>*</operator> <literal type="number">10</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * We set bucket width equal to (num_mcelem + 10) / 0.007 as per the
	 * comment above.
	 */</comment>
	<expr_stmt><expr><name>bucket_width</name> <operator>=</operator> <operator>(</operator><name>num_mcelem</name> <operator>+</operator> <literal type="number">10</literal><operator>)</operator> <operator>*</operator> <literal type="number">1000</literal> <operator>/</operator> <literal type="number">7</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create the hashtable. It will be in local memory, so we don't need to
	 * worry about overflowing the initial size. Also we don't need to pay any
	 * attention to locking and memory management.
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LexemeHashKey</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TrackItem</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>lexeme_hash</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>match</name></name> <operator>=</operator> <name>lexeme_match</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lexemes_tab</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Analyzed lexemes table"</literal></expr></argument>,
							  <argument><expr><name>num_mcelem</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
							  <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name> <operator>|</operator> <name>HASH_COMPARE</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize counters. */</comment>
	<expr_stmt><expr><name>b_current</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>lexeme_no</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Loop over the tsvectors. */</comment>
	<for>for <control>(<init><expr><name>vector_no</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>vector_no</name> <operator>&lt;</operator> <name>samplerows</name></expr>;</condition> <incr><expr><name>vector_no</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TSVector</name></type>	<name>vector</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>WordEntry</name>  <modifier>*</modifier></type><name>curentryptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>lexemesptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>vacuum_delay_point</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>fetchfunc</name><argument_list>(<argument><expr><name>stats</name></expr></argument>, <argument><expr><name>vector_no</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check for null/nonnull.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>null_cnt</name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Add up widths for average-width calculation.  Since it's a
		 * tsvector, we know it's varlena.  As in the regular
		 * compute_minimal_stats function, we use the toasted width for this
		 * calculation.
		 */</comment>
		<expr_stmt><expr><name>total_width</name> <operator>+=</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now detoast the tsvector if needed.
		 */</comment>
		<expr_stmt><expr><name>vector</name> <operator>=</operator> <call><name>DatumGetTSVector</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We loop through the lexemes in the tsvector and add them to our
		 * tracking hashtable.
		 */</comment>
		<expr_stmt><expr><name>lexemesptr</name> <operator>=</operator> <call><name>STRPTR</name><argument_list>(<argument><expr><name>vector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>curentryptr</name> <operator>=</operator> <call><name>ARRPTR</name><argument_list>(<argument><expr><name>vector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>vector</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Construct a hash key.  The key points into the (detoasted)
			 * tsvector value at this point, but if a new entry is created, we
			 * make a copy of it.  This way we can free the tsvector value
			 * once we've processed all its lexemes.
			 */</comment>
			<expr_stmt><expr><name><name>hash_key</name><operator>.</operator><name>lexeme</name></name> <operator>=</operator> <name>lexemesptr</name> <operator>+</operator> <name><name>curentryptr</name><operator>-&gt;</operator><name>pos</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hash_key</name><operator>.</operator><name>length</name></name> <operator>=</operator> <name><name>curentryptr</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

			<comment type="block">/* Lookup current lexeme in hashtable, adding it if new */</comment>
			<expr_stmt><expr><name>item</name> <operator>=</operator> <operator>(</operator><name>TrackItem</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>lexemes_tab</name></expr></argument>,
											 <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>hash_key</name></expr></argument>,
											 <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* The lexeme is already on the tracking list */</comment>
				<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>frequency</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Initialize new tracking list element */</comment>
				<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>frequency</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>delta</name></name> <operator>=</operator> <name>b_current</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>lexeme</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>hash_key</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>lexeme</name></name></expr></argument>, <argument><expr><name><name>hash_key</name><operator>.</operator><name>lexeme</name></name></expr></argument>, <argument><expr><name><name>hash_key</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* lexeme_no is the number of elements processed (ie N) */</comment>
			<expr_stmt><expr><name>lexeme_no</name><operator>++</operator></expr>;</expr_stmt>

			<comment type="block">/* We prune the D structure after processing each bucket */</comment>
			<if_stmt><if>if <condition>(<expr><name>lexeme_no</name> <operator>%</operator> <name>bucket_width</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>prune_lexemes_hashtable</name><argument_list>(<argument><expr><name>lexemes_tab</name></expr></argument>, <argument><expr><name>b_current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>b_current</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Advance to the next WordEntry in the tsvector */</comment>
			<expr_stmt><expr><name>curentryptr</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* If the vector was toasted, free the detoasted copy. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TSVectorGetDatum</name><argument_list>(<argument><expr><name>vector</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>value</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>vector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* We can only compute real stats if we found some non-null values. */</comment>
	<if_stmt><if>if <condition>(<expr><name>null_cnt</name> <operator>&lt;</operator> <name>samplerows</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>nonnull_cnt</name> <init>= <expr><name>samplerows</name> <operator>-</operator> <name>null_cnt</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TrackItem</name> <modifier>*</modifier><modifier>*</modifier></type><name>sort_table</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>track_len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>cutoff_freq</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>minfreq</name></decl>,
					<decl><type ref="prev"/><name>maxfreq</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stats_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<comment type="block">/* Do the simple null-frac and average width stats */</comment>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>null_cnt</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>samplerows</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <name>total_width</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>nonnull_cnt</name></expr>;</expr_stmt>

		<comment type="block">/* Assume it's a unique column (see notes above) */</comment>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1.0</literal> <operator>*</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Construct an array of the interesting hashtable items, that is,
		 * those meeting the cutoff frequency (s - epsilon)*N.  Also identify
		 * the minimum and maximum frequencies among these items.
		 *
		 * Since epsilon = s/10 and bucket_width = 1/epsilon, the cutoff
		 * frequency is 9*N / bucket_width.
		 */</comment>
		<expr_stmt><expr><name>cutoff_freq</name> <operator>=</operator> <literal type="number">9</literal> <operator>*</operator> <name>lexeme_no</name> <operator>/</operator> <name>bucket_width</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>hash_get_num_entries</name><argument_list>(<argument><expr><name>lexemes_tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* surely enough space */</comment>
		<expr_stmt><expr><name>sort_table</name> <operator>=</operator> <operator>(</operator><name>TrackItem</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TrackItem</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan_status</name></expr></argument>, <argument><expr><name>lexemes_tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>track_len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>minfreq</name> <operator>=</operator> <name>lexeme_no</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>maxfreq</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>item</name> <operator>=</operator> <operator>(</operator><name>TrackItem</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan_status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>frequency</name></name> <operator>&gt;</operator> <name>cutoff_freq</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>sort_table</name><index>[<expr><name>track_len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>item</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>minfreq</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>minfreq</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>frequency</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>maxfreq</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>maxfreq</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>frequency</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>track_len</name> <operator>&lt;=</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* emit some statistics for debug purposes */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"tsvector_stats: target # mces = %d, bucket width = %d, "</literal>
			 <literal type="string">"# lexemes = %d, hashtable size = %d, usable entries = %d"</literal></expr></argument>,
			 <argument><expr><name>num_mcelem</name></expr></argument>, <argument><expr><name>bucket_width</name></expr></argument>, <argument><expr><name>lexeme_no</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>track_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we obtained more lexemes than we really want, get rid of those
		 * with least frequencies.  The easiest way is to qsort the array into
		 * descending frequency order and truncate the array.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>num_mcelem</name> <operator>&lt;</operator> <name>track_len</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>sort_table</name></expr></argument>, <argument><expr><name>track_len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TrackItem</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
				  <argument><expr><name>trackitem_compare_frequencies_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* reset minfreq to the smallest frequency we're keeping */</comment>
			<expr_stmt><expr><name>minfreq</name> <operator>=</operator> <name><name>sort_table</name><index>[<expr><name>num_mcelem</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>frequency</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>num_mcelem</name> <operator>=</operator> <name>track_len</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Generate MCELEM slot entry */</comment>
		<if_stmt><if>if <condition>(<expr><name>num_mcelem</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_context</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>mcelem_values</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>float4</name>	   <modifier>*</modifier></type><name>mcelem_freqs</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * We want to store statistics sorted on the lexeme value using
			 * first length, then byte-for-byte comparison. The reason for
			 * doing length comparison first is that we don't care about the
			 * ordering so long as it's consistent, and comparing lengths
			 * first gives us a chance to avoid a strncmp() call.
			 *
			 * This is different from what we do with scalar statistics --
			 * they get sorted on frequencies. The rationale is that we
			 * usually search through most common elements looking for a
			 * specific value, so we can grab its frequency.  When values are
			 * presorted we can employ binary search for that.  See
			 * ts_selfuncs.c for a real usage scenario.
			 */</comment>
			<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>sort_table</name></expr></argument>, <argument><expr><name>num_mcelem</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TrackItem</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
				  <argument><expr><name>trackitem_compare_lexemes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Must copy the target values into anl_context */</comment>
			<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>anl_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We sorted statistics on the lexeme value, but we want to be
			 * able to find out the minimal and maximal frequency without
			 * going through all the values.  We keep those two extra
			 * frequencies in two extra cells in mcelem_freqs.
			 *
			 * (Note: the MCELEM statistics slot definition allows for a third
			 * extra number containing the frequency of nulls, but we don't
			 * create that for a tsvector column, since null elements aren't
			 * possible.)
			 */</comment>
			<expr_stmt><expr><name>mcelem_values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_mcelem</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>mcelem_freqs</name> <operator>=</operator> <operator>(</operator><name>float4</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>num_mcelem</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>float4</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * See comments above about use of nonnull_cnt as the divisor for
			 * the final frequency estimates.
			 */</comment>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_mcelem</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TrackItem</name>  <modifier>*</modifier></type><name>item</name> <init>= <expr><name><name>sort_table</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>mcelem_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
					<call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>lexeme</name></name></expr></argument>,
															 <argument><expr><name><name>item</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>mcelem_freqs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>item</name><operator>-&gt;</operator><name>frequency</name></name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>nonnull_cnt</name></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><name><name>mcelem_freqs</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>minfreq</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>nonnull_cnt</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mcelem_freqs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>maxfreq</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>nonnull_cnt</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stakind</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>STATISTIC_KIND_MCELEM</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>staop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>TextEqualOperator</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanumbers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>mcelem_freqs</name></expr>;</expr_stmt>
			<comment type="block">/* See above comment about two extra frequency fields */</comment>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>numnumbers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>num_mcelem</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stavalues</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>mcelem_values</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>numvalues</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>num_mcelem</name></expr>;</expr_stmt>
			<comment type="block">/* We are storing text values */</comment>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statypid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>TEXTOID</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statyplen</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* typlen, -1 for varlena */</comment>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statypbyval</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statypalign</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'i'</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* We found only nulls; assume the column is entirely null */</comment>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stats_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* "unknown" */</comment>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>	<comment type="block">/* "unknown" */</comment>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * We don't need to bother cleaning up any of our temporary palloc's. The
	 * hashtable should also go away, as it used a child memory context.
	 */</comment>
</block_content>}</block></function>

<comment type="block">/*
 *	A function to prune the D structure from the Lossy Counting algorithm.
 *	Consult compute_tsvector_stats() for wider explanation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>prune_lexemes_hashtable</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>lexemes_tab</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b_current</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>scan_status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TrackItem</name>  <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan_status</name></expr></argument>, <argument><expr><name>lexemes_tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>item</name> <operator>=</operator> <operator>(</operator><name>TrackItem</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan_status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>frequency</name></name> <operator>+</operator> <name><name>item</name><operator>-&gt;</operator><name>delta</name></name> <operator>&lt;=</operator> <name>b_current</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>lexeme</name> <init>= <expr><name><name>item</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>lexeme</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>hash_search</name><argument_list>(<argument><expr><name>lexemes_tab</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>key</name></name></expr></argument>,
							<argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"hash table corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>lexeme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Hash functions for lexemes. They are strings, but not NULL terminated,
 * so we need a special hash function.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>lexeme_hash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>LexemeHashKey</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>LexemeHashKey</name> <operator>*</operator><operator>)</operator> <name>key</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>DatumGetUInt32</name><argument_list>(<argument><expr><call><name>hash_any</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name><name>l</name><operator>-&gt;</operator><name>lexeme</name></name></expr></argument>,
								   <argument><expr><name><name>l</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	Matching function for lexemes, to be used in hashtable lookups.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>lexeme_match</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key2</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* The keysize parameter is superfluous, the keys store their lengths */</comment>
	<return>return <expr><call><name>lexeme_compare</name><argument_list>(<argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	Comparison function for lexemes.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>lexeme_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>LexemeHashKey</name> <modifier>*</modifier></type><name>d1</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>LexemeHashKey</name> <operator>*</operator><operator>)</operator> <name>key1</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>LexemeHashKey</name> <modifier>*</modifier></type><name>d2</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>LexemeHashKey</name> <operator>*</operator><operator>)</operator> <name>key2</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* First, compare by length */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>d1</name><operator>-&gt;</operator><name>length</name></name> <operator>&gt;</operator> <name><name>d2</name><operator>-&gt;</operator><name>length</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>d1</name><operator>-&gt;</operator><name>length</name></name> <operator>&lt;</operator> <name><name>d2</name><operator>-&gt;</operator><name>length</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Lengths are equal, do a byte-by-byte comparison */</comment>
	<return>return <expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>d1</name><operator>-&gt;</operator><name>lexeme</name></name></expr></argument>, <argument><expr><name><name>d2</name><operator>-&gt;</operator><name>lexeme</name></name></expr></argument>, <argument><expr><name><name>d1</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	qsort() comparator for sorting TrackItems on frequencies (descending sort)
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>trackitem_compare_frequencies_desc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>e1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>e2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>TrackItem</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>t1</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>TrackItem</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>e1</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>TrackItem</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>t2</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>TrackItem</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>e2</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><name><operator>(</operator><operator>*</operator><name>t2</name><operator>)</operator><operator>-&gt;</operator><name>frequency</name></name> <operator>-</operator> <name><operator>(</operator><operator>*</operator><name>t1</name><operator>)</operator><operator>-&gt;</operator><name>frequency</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	qsort() comparator for sorting TrackItems on lexemes
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>trackitem_compare_lexemes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>e1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>e2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>TrackItem</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>t1</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>TrackItem</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>e1</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>TrackItem</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>t2</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>TrackItem</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>e2</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>lexeme_compare</name><argument_list>(<argument><expr><operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>t1</name><operator>)</operator><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>t2</name><operator>)</operator><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
