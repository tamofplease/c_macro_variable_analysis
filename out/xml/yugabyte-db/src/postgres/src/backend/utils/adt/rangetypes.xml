<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/utils/adt/rangetypes.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * rangetypes.c
 *	  I/O functions, operators, and support functions for range types.
 *
 * The stored (serialized) format of a range value is:
 *
 *	4 bytes: varlena header
 *	4 bytes: range type's OID
 *	Lower boundary value, if any, aligned according to subtype's typalign
 *	Upper boundary value, if any, aligned according to subtype's typalign
 *	1 byte for flags
 *
 * This representation is chosen to avoid needing any padding before the
 * lower boundary value, even when it requires double alignment.  We can
 * expect that the varlena header is presented to us on a suitably aligned
 * boundary (possibly after detoasting), and then the lower boundary is too.
 * Note that this means we can't work with a packed (short varlena header)
 * value; we must detoast it first.
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/utils/adt/rangetypes.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/date.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/int8.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rangetypes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RANGE_EMPTY_LITERAL</name></cpp:macro> <cpp:value>"empty"</cpp:value></cpp:define>

<comment type="block">/* fn_extra cache entry for one of the range I/O functions */</comment>
<typedef>typedef <type><struct>struct <name>RangeIOData</name>
<block>{
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>	<comment type="block">/* range type's typcache entry */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typiofunc</name></decl>;</decl_stmt>		<comment type="block">/* element type's I/O function */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typioparam</name></decl>;</decl_stmt>		<comment type="block">/* element type's I/O parameter */</comment>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>proc</name></decl>;</decl_stmt>			<comment type="block">/* lookup result for typiofunc */</comment>
}</block></struct></type> <name>RangeIOData</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>RangeIOData</name> <modifier>*</modifier></type><name>get_range_io_data</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>rngtypid</name></decl></parameter>,
				  <parameter><decl><type><name>IOFuncSelector</name></type> <name>func</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name></type> <name>range_parse_flags</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>flags_str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>range_parse</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input_str</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>lbound_str</name></decl></parameter>,
			<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ubound_str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>range_parse_bound</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>,
				  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>bound_str</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>infinite</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>range_deparse</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lbound_str</name></decl></parameter>,
			  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ubound_str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>range_bound_escape</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Size</name></type> <name>datum_compute_size</name><parameter_list>(<parameter><decl><type><name>Size</name></type> <name>sz</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>datum</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>typbyval</name></decl></parameter>,
				   <parameter><decl><type><name>char</name></type> <name>typalign</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>typlen</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>typstorage</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Pointer</name></type> <name>datum_write</name><parameter_list>(<parameter><decl><type><name>Pointer</name></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>datum</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>typbyval</name></decl></parameter>,
			<parameter><decl><type><name>char</name></type> <name>typalign</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>typlen</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>typstorage</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 *----------------------------------------------------------
 * I/O FUNCTIONS
 *----------------------------------------------------------
 */</comment>

<function><type><name>Datum</name></type>
<name>range_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>input_str</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>rngtypoid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typmod</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>range</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeIOData</name> <modifier>*</modifier></type><name>cache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>lbound_str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ubound_str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>lower</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>upper</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* recurses when subtype is a range type */</comment>

	<expr_stmt><expr><name>cache</name> <operator>=</operator> <call><name>get_range_io_data</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>rngtypoid</name></expr></argument>, <argument><expr><name>IOFunc_input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* parse */</comment>
	<expr_stmt><expr><call><name>range_parse</name><argument_list>(<argument><expr><name>input_str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lbound_str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ubound_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* call element type's input function */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RANGE_HAS_LBOUND</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>lower</name><operator>.</operator><name>val</name></name> <operator>=</operator> <call><name>InputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>, <argument><expr><name>lbound_str</name></expr></argument>,
									  <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>typioparam</name></name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>RANGE_HAS_UBOUND</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>upper</name><operator>.</operator><name>val</name></name> <operator>=</operator> <call><name>InputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>, <argument><expr><name>ubound_str</name></expr></argument>,
									  <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>typioparam</name></name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>lower</name><operator>.</operator><name>infinite</name></name> <operator>=</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>RANGE_LB_INF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lower</name><operator>.</operator><name>inclusive</name></name> <operator>=</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>RANGE_LB_INC</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lower</name><operator>.</operator><name>lower</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>upper</name><operator>.</operator><name>infinite</name></name> <operator>=</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>RANGE_UB_INF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>upper</name><operator>.</operator><name>inclusive</name></name> <operator>=</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>RANGE_UB_INC</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>upper</name><operator>.</operator><name>lower</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* serialize and canonicalize */</comment>
	<expr_stmt><expr><name>range</name> <operator>=</operator> <call><name>make_range</name><argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>typcache</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper</name></expr></argument>, <argument><expr><name>flags</name> <operator>&amp;</operator> <name>RANGE_EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_RANGE_P</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>range_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>range</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DatumDecodeOptions</name> <modifier>*</modifier></type><name>decode_options</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>output_str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeIOData</name> <modifier>*</modifier></type><name>cache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>lbound_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ubound_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>lower</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>upper</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>empty</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* recurses when subtype is a range type */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>decode_options</name> <operator>=</operator> <operator>(</operator><name>DatumDecodeOptions</name> <operator>*</operator><operator>)</operator><call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>TypeCacheEntry</name></type> <name>elemtype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TypeCacheEntry</name></type> <name>typcache</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>typcache</name><operator>.</operator><name>type_id</name></name> <operator>=</operator> <name><name>decode_options</name><operator>-&gt;</operator><name>range_type</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>elemtype</name><operator>.</operator><name>typlen</name></name> <operator>=</operator> <name><name>decode_options</name><operator>-&gt;</operator><name>elem_len</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>elemtype</name><operator>.</operator><name>typbyval</name></name> <operator>=</operator> <name><name>decode_options</name><operator>-&gt;</operator><name>elem_by_val</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>elemtype</name><operator>.</operator><name>typalign</name></name> <operator>=</operator> <name><name>decode_options</name><operator>-&gt;</operator><name>elem_align</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>typcache</name><operator>.</operator><name>rngelemtype</name></name> <operator>=</operator> <operator>&amp;</operator><name>elemtype</name></expr>;</expr_stmt>

		<comment type="block">/* deserialize */</comment>
		<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>typcache</name></expr></argument>, <argument><expr><name>range</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>cache</name> <operator>=</operator> <call><name>get_range_io_data</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>IOFunc_output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* deserialize */</comment>
		<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>typcache</name></name></expr></argument>, <argument><expr><name>range</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>range_get_flags</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>decode_options</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>decode_options</name><operator>-&gt;</operator><name>from_YB</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>RANGE_HAS_LBOUND</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>decode_options</name><operator>-&gt;</operator><name>option</name></name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>DatumDecodeOptions</name></type> <name>tz_datum_decodeOptions</name></decl>;</decl_stmt>
				<expr_stmt><expr><name><name>tz_datum_decodeOptions</name><operator>.</operator><name>timezone</name></name> <operator>=</operator> <name><name>decode_options</name><operator>-&gt;</operator><name>timezone</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tz_datum_decodeOptions</name><operator>.</operator><name>from_YB</name></name> <operator>=</operator> <name><name>decode_options</name><operator>-&gt;</operator><name>from_YB</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>lbound_str</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>FunctionCall2</name><argument_list>(<argument><expr><name><name>decode_options</name><operator>-&gt;</operator><name>elem_finfo</name></name></expr></argument>, <argument><expr><name><name>lower</name><operator>.</operator><name>val</name></name></expr></argument>,
							<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tz_datum_decodeOptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>lbound_str</name> <operator>=</operator> <call><name>OutputFunctionCall</name><argument_list>(<argument><expr><name><name>decode_options</name><operator>-&gt;</operator><name>elem_finfo</name></name></expr></argument>, <argument><expr><name><name>lower</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>RANGE_HAS_UBOUND</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>decode_options</name><operator>-&gt;</operator><name>option</name></name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>DatumDecodeOptions</name></type> <name>tz_datum_decodeOptions</name></decl>;</decl_stmt>
				<expr_stmt><expr><name><name>tz_datum_decodeOptions</name><operator>.</operator><name>timezone</name></name> <operator>=</operator> <name><name>decode_options</name><operator>-&gt;</operator><name>timezone</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tz_datum_decodeOptions</name><operator>.</operator><name>from_YB</name></name> <operator>=</operator> <name><name>decode_options</name><operator>-&gt;</operator><name>from_YB</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>ubound_str</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>FunctionCall2</name><argument_list>(<argument><expr><name><name>decode_options</name><operator>-&gt;</operator><name>elem_finfo</name></name></expr></argument>, <argument><expr><name><name>upper</name><operator>.</operator><name>val</name></name></expr></argument>,
							<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tz_datum_decodeOptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>ubound_str</name> <operator>=</operator> <call><name>OutputFunctionCall</name><argument_list>(<argument><expr><name><name>decode_options</name><operator>-&gt;</operator><name>elem_finfo</name></name></expr></argument>, <argument><expr><name><name>upper</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* call element type's output function */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RANGE_HAS_LBOUND</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lbound_str</name> <operator>=</operator> <call><name>OutputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>, <argument><expr><name><name>lower</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>RANGE_HAS_UBOUND</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ubound_str</name> <operator>=</operator> <call><name>OutputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>, <argument><expr><name><name>upper</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* construct result string */</comment>
	<expr_stmt><expr><name>output_str</name> <operator>=</operator> <call><name>range_deparse</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>lbound_str</name></expr></argument>, <argument><expr><name>ubound_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>output_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Binary representation: The first byte is the flags, then the lower bound
 * (if present), then the upper bound (if present).  Each bound is represented
 * by a 4-byte length header and the binary representation of that bound (as
 * returned by a call to the send function for the subtype).
 */</comment>

<function><type><name>Datum</name></type>
<name>range_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>rngtypoid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>range</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeIOData</name> <modifier>*</modifier></type><name>cache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>lower</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>upper</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* recurses when subtype is a range type */</comment>

	<expr_stmt><expr><name>cache</name> <operator>=</operator> <call><name>get_range_io_data</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>rngtypoid</name></expr></argument>, <argument><expr><name>IOFunc_receive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* receive the flags... */</comment>
	<expr_stmt><expr><name>flags</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <call><name>pq_getmsgbyte</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Mask out any unsupported flags, particularly RANGE_xB_NULL which would
	 * confuse following tests.  Note that range_serialize will take care of
	 * cleaning up any inconsistencies in the remaining flags.
	 */</comment>
	<expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>(</operator><name>RANGE_EMPTY</name> <operator>|</operator>
			  <name>RANGE_LB_INC</name> <operator>|</operator>
			  <name>RANGE_LB_INF</name> <operator>|</operator>
			  <name>RANGE_UB_INC</name> <operator>|</operator>
			  <name>RANGE_UB_INF</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* receive the bounds ... */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RANGE_HAS_LBOUND</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>bound_len</name> <init>= <expr><call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bound_data</name> <init>= <expr><call><name>pq_getmsgbytes</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bound_len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>bound_buf</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bound_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bound_buf</name></expr></argument>, <argument><expr><name>bound_data</name></expr></argument>, <argument><expr><name>bound_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>lower</name><operator>.</operator><name>val</name></name> <operator>=</operator> <call><name>ReceiveFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>bound_buf</name></expr></argument>,
										<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>typioparam</name></name></expr></argument>,
										<argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>bound_buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>lower</name><operator>.</operator><name>val</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RANGE_HAS_UBOUND</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>bound_len</name> <init>= <expr><call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bound_data</name> <init>= <expr><call><name>pq_getmsgbytes</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bound_len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>bound_buf</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bound_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bound_buf</name></expr></argument>, <argument><expr><name>bound_data</name></expr></argument>, <argument><expr><name>bound_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>upper</name><operator>.</operator><name>val</name></name> <operator>=</operator> <call><name>ReceiveFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>bound_buf</name></expr></argument>,
										<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>typioparam</name></name></expr></argument>,
										<argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>bound_buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>upper</name><operator>.</operator><name>val</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* finish constructing RangeBound representation */</comment>
	<expr_stmt><expr><name><name>lower</name><operator>.</operator><name>infinite</name></name> <operator>=</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>RANGE_LB_INF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lower</name><operator>.</operator><name>inclusive</name></name> <operator>=</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>RANGE_LB_INC</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lower</name><operator>.</operator><name>lower</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>upper</name><operator>.</operator><name>infinite</name></name> <operator>=</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>RANGE_UB_INF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>upper</name><operator>.</operator><name>inclusive</name></name> <operator>=</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>RANGE_UB_INC</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>upper</name><operator>.</operator><name>lower</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* serialize and canonicalize */</comment>
	<expr_stmt><expr><name>range</name> <operator>=</operator> <call><name>make_range</name><argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>typcache</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper</name></expr></argument>, <argument><expr><name>flags</name> <operator>&amp;</operator> <name>RANGE_EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_RANGE_P</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>range_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>range</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeIOData</name> <modifier>*</modifier></type><name>cache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>lower</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>upper</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>empty</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* recurses when subtype is a range type */</comment>

	<expr_stmt><expr><name>cache</name> <operator>=</operator> <call><name>get_range_io_data</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>IOFunc_send</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* deserialize */</comment>
	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>typcache</name></name></expr></argument>, <argument><expr><name>range</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>range_get_flags</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* construct output */</comment>
	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RANGE_HAS_LBOUND</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>bound</name> <init>= <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>SendFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>,
															 <argument><expr><name><name>lower</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>bound_len</name> <init>= <expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>bound</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>bound_data</name> <init>= <expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>bound</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bound_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bound_data</name></expr></argument>, <argument><expr><name>bound_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RANGE_HAS_UBOUND</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>bound</name> <init>= <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>SendFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>,
															 <argument><expr><name><name>upper</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>bound_len</name> <init>= <expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>bound</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>bound_data</name> <init>= <expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>bound</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bound_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bound_data</name></expr></argument>, <argument><expr><name>bound_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_range_io_data: get cached information needed for range type I/O
 *
 * The range I/O functions need a bit more cached info than other range
 * functions, so they store a RangeIOData struct in fn_extra, not just a
 * pointer to a type cache entry.
 */</comment>
<function><type><specifier>static</specifier> <name>RangeIOData</name> <modifier>*</modifier></type>
<name>get_range_io_data</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>rngtypid</name></decl></parameter>, <parameter><decl><type><name>IOFuncSelector</name></type> <name>func</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeIOData</name> <modifier>*</modifier></type><name>cache</name> <init>= <expr><operator>(</operator><name>RangeIOData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>cache</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>cache</name><operator>-&gt;</operator><name>typcache</name><operator>-&gt;</operator><name>type_id</name></name> <operator>!=</operator> <name>rngtypid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int16</name></type>		<name>typlen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>typbyval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>typalign</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>typdelim</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>cache</name> <operator>=</operator> <operator>(</operator><name>RangeIOData</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>,
												   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RangeIOData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>typcache</name></name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>rngtypid</name></expr></argument>, <argument><expr><name>TYPECACHE_RANGE_INFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>cache</name><operator>-&gt;</operator><name>typcache</name><operator>-&gt;</operator><name>rngelemtype</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"type %u is not a range type"</literal></expr></argument>, <argument><expr><name>rngtypid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* get_type_io_data does more than we need, but is convenient */</comment>
		<expr_stmt><expr><call><name>get_type_io_data</name><argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>typcache</name><operator>-&gt;</operator><name>rngelemtype</name><operator>-&gt;</operator><name>type_id</name></name></expr></argument>,
						 <argument><expr><name>func</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>typlen</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>typbyval</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>typalign</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>typdelim</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>typioparam</name></name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>typiofunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>typiofunc</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* this could only happen for receive or send */</comment>
			<if_stmt><if>if <condition>(<expr><name>func</name> <operator>==</operator> <name>IOFunc_receive</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no binary input function available for type %s"</literal></expr></argument>,
								<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>typcache</name><operator>-&gt;</operator><name>rngelemtype</name><operator>-&gt;</operator><name>type_id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no binary output function available for type %s"</literal></expr></argument>,
								<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>typcache</name><operator>-&gt;</operator><name>rngelemtype</name><operator>-&gt;</operator><name>type_id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>typiofunc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>,
					  <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>cache</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>cache</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *----------------------------------------------------------
 * GENERIC FUNCTIONS
 *----------------------------------------------------------
 */</comment>

<comment type="block">/* Construct standard-form range value from two arguments */</comment>
<function><type><name>Datum</name></type>
<name>range_constructor2</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>rngtypid</name> <init>= <expr><call><name>get_fn_expr_rettype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>range</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>lower</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>upper</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>range_get_typcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>rngtypid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>lower</name><operator>.</operator><name>val</name></name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr> </then><else>: <expr><name>arg1</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lower</name><operator>.</operator><name>infinite</name></name> <operator>=</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lower</name><operator>.</operator><name>inclusive</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lower</name><operator>.</operator><name>lower</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>upper</name><operator>.</operator><name>val</name></name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr> </then><else>: <expr><name>arg2</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>upper</name><operator>.</operator><name>infinite</name></name> <operator>=</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>upper</name><operator>.</operator><name>inclusive</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>upper</name><operator>.</operator><name>lower</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>range</name> <operator>=</operator> <call><name>make_range</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_RANGE_P</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Construct general range value from three arguments */</comment>
<function><type><name>Datum</name></type>
<name>range_constructor3</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>rngtypid</name> <init>= <expr><call><name>get_fn_expr_rettype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>range</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>lower</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>upper</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>flags</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>range_get_typcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>rngtypid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"range constructor flags argument must not be null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>range_parse_flags</name><argument_list>(<argument><expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>lower</name><operator>.</operator><name>val</name></name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr> </then><else>: <expr><name>arg1</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lower</name><operator>.</operator><name>infinite</name></name> <operator>=</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lower</name><operator>.</operator><name>inclusive</name></name> <operator>=</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>RANGE_LB_INC</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lower</name><operator>.</operator><name>lower</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>upper</name><operator>.</operator><name>val</name></name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr> </then><else>: <expr><name>arg2</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>upper</name><operator>.</operator><name>infinite</name></name> <operator>=</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>upper</name><operator>.</operator><name>inclusive</name></name> <operator>=</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>RANGE_UB_INC</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>upper</name><operator>.</operator><name>lower</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>range</name> <operator>=</operator> <call><name>make_range</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_RANGE_P</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* range -&gt; subtype functions */</comment>

<comment type="block">/* extract lower bound value */</comment>
<function><type><name>Datum</name></type>
<name>range_lower</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r1</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>lower</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>upper</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>empty</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>range_get_typcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Return NULL if there's no finite lower bound */</comment>
	<if_stmt><if>if <condition>(<expr><name>empty</name> <operator>||</operator> <name><name>lower</name><operator>.</operator><name>infinite</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><name><name>lower</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* extract upper bound value */</comment>
<function><type><name>Datum</name></type>
<name>range_upper</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r1</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>lower</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>upper</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>empty</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>range_get_typcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Return NULL if there's no finite upper bound */</comment>
	<if_stmt><if>if <condition>(<expr><name>empty</name> <operator>||</operator> <name><name>upper</name><operator>.</operator><name>infinite</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><name><name>upper</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* range -&gt; bool functions */</comment>

<comment type="block">/* is range empty? */</comment>
<function><type><name>Datum</name></type>
<name>range_empty</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r1</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>flags</name> <init>= <expr><call><name>range_get_flags</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>flags</name> <operator>&amp;</operator> <name>RANGE_EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* is lower bound inclusive? */</comment>
<function><type><name>Datum</name></type>
<name>range_lower_inc</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r1</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>flags</name> <init>= <expr><call><name>range_get_flags</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>flags</name> <operator>&amp;</operator> <name>RANGE_LB_INC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* is upper bound inclusive? */</comment>
<function><type><name>Datum</name></type>
<name>range_upper_inc</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r1</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>flags</name> <init>= <expr><call><name>range_get_flags</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>flags</name> <operator>&amp;</operator> <name>RANGE_UB_INC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* is lower bound infinite? */</comment>
<function><type><name>Datum</name></type>
<name>range_lower_inf</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r1</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>flags</name> <init>= <expr><call><name>range_get_flags</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>flags</name> <operator>&amp;</operator> <name>RANGE_LB_INF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* is upper bound infinite? */</comment>
<function><type><name>Datum</name></type>
<name>range_upper_inf</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r1</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>flags</name> <init>= <expr><call><name>range_get_flags</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>flags</name> <operator>&amp;</operator> <name>RANGE_UB_INF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* range, element -&gt; bool functions */</comment>

<comment type="block">/* contains? */</comment>
<function><type><name>Datum</name></type>
<name>range_contains_elem</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>val</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>range_get_typcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>range_contains_elem_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* contained by? */</comment>
<function><type><name>Datum</name></type>
<name>elem_contained_by_range</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>val</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>range_get_typcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>range_contains_elem_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* range, range -&gt; bool functions */</comment>

<comment type="block">/* equality (internal version) */</comment>
<function><type><name>bool</name></type>
<name>range_eq_internal</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>r1</name></decl></parameter>, <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>r2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>lower1</name></decl>,
				<decl><type ref="prev"/><name>lower2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>upper1</name></decl>,
				<decl><type ref="prev"/><name>upper2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>empty1</name></decl>,
				<decl><type ref="prev"/><name>empty2</name></decl>;</decl_stmt>

	<comment type="block">/* Different types should be prevented by ANYRANGE matching rules */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"range types do not match"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>empty1</name> <operator>&amp;&amp;</operator> <name>empty2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>empty1</name> <operator>!=</operator> <name>empty2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* equality */</comment>
<function><type><name>Datum</name></type>
<name>range_eq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r1</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r2</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>range_get_typcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>range_eq_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* inequality (internal version) */</comment>
<function><type><name>bool</name></type>
<name>range_ne_internal</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>r1</name></decl></parameter>, <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>r2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><operator>!</operator><call><name>range_eq_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* inequality */</comment>
<function><type><name>Datum</name></type>
<name>range_ne</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r1</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r2</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>range_get_typcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>range_ne_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* contains? */</comment>
<function><type><name>Datum</name></type>
<name>range_contains</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r1</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r2</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>range_get_typcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>range_contains_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* contained by? */</comment>
<function><type><name>Datum</name></type>
<name>range_contained_by</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r1</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r2</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>range_get_typcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>range_contained_by_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* strictly left of? (internal version) */</comment>
<function><type><name>bool</name></type>
<name>range_before_internal</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>r1</name></decl></parameter>, <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>r2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>lower1</name></decl>,
				<decl><type ref="prev"/><name>lower2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>upper1</name></decl>,
				<decl><type ref="prev"/><name>upper2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>empty1</name></decl>,
				<decl><type ref="prev"/><name>empty2</name></decl>;</decl_stmt>

	<comment type="block">/* Different types should be prevented by ANYRANGE matching rules */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"range types do not match"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* An empty range is neither before nor after any other range */</comment>
	<if_stmt><if>if <condition>(<expr><name>empty1</name> <operator>||</operator> <name>empty2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><operator>(</operator><call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower2</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* strictly left of? */</comment>
<function><type><name>Datum</name></type>
<name>range_before</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r1</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r2</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>range_get_typcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>range_before_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* strictly right of? (internal version) */</comment>
<function><type><name>bool</name></type>
<name>range_after_internal</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>r1</name></decl></parameter>, <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>r2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>lower1</name></decl>,
				<decl><type ref="prev"/><name>lower2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>upper1</name></decl>,
				<decl><type ref="prev"/><name>upper2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>empty1</name></decl>,
				<decl><type ref="prev"/><name>empty2</name></decl>;</decl_stmt>

	<comment type="block">/* Different types should be prevented by ANYRANGE matching rules */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"range types do not match"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* An empty range is neither before nor after any other range */</comment>
	<if_stmt><if>if <condition>(<expr><name>empty1</name> <operator>||</operator> <name>empty2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><operator>(</operator><call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper2</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* strictly right of? */</comment>
<function><type><name>Datum</name></type>
<name>range_after</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r1</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r2</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>range_get_typcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>range_after_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check if two bounds A and B are "adjacent", where A is an upper bound and B
 * is a lower bound. For the bounds to be adjacent, each subtype value must
 * satisfy strictly one of the bounds: there are no values which satisfy both
 * bounds (i.e. less than A and greater than B); and there are no values which
 * satisfy neither bound (i.e. greater than A and less than B).
 *
 * For discrete ranges, we rely on the canonicalization function to see if A..B
 * normalizes to empty. (If there is no canonicalization function, it's
 * impossible for such a range to normalize to empty, so we needn't bother to
 * try.)
 *
 * If A == B, the ranges are adjacent only if the bounds have different
 * inclusive flags (i.e., exactly one of the ranges includes the common
 * boundary point).
 *
 * And if A &gt; B then the ranges are not adjacent in this order.
 */</comment>
<function><type><name>bool</name></type>
<name>bounds_adjacent</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>RangeBound</name></type> <name>boundA</name></decl></parameter>, <parameter><decl><type><name>RangeBound</name></type> <name>boundB</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>boundA</name><operator>.</operator><name>lower</name></name> <operator>&amp;&amp;</operator> <name><name>boundB</name><operator>.</operator><name>lower</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>range_cmp_bound_values</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>boundA</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>boundB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Bounds do not overlap; see if there are points in between.
		 */</comment>

		<comment type="block">/* in a continuous subtype, there are assumed to be points between */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typcache</name><operator>-&gt;</operator><name>rng_canonical_finfo</name><operator>.</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * The bounds are of a discrete range type; so make a range A..B and
		 * see if it's empty.
		 */</comment>

		<comment type="block">/* flip the inclusion flags */</comment>
		<expr_stmt><expr><name><name>boundA</name><operator>.</operator><name>inclusive</name></name> <operator>=</operator> <operator>!</operator><name><name>boundA</name><operator>.</operator><name>inclusive</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>boundB</name><operator>.</operator><name>inclusive</name></name> <operator>=</operator> <operator>!</operator><name><name>boundB</name><operator>.</operator><name>inclusive</name></name></expr>;</expr_stmt>
		<comment type="block">/* change upper/lower labels to avoid Assert failures */</comment>
		<expr_stmt><expr><name><name>boundA</name><operator>.</operator><name>lower</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>boundB</name><operator>.</operator><name>lower</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>make_range</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>boundA</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>boundB</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>RangeIsEmpty</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>boundA</name><operator>.</operator><name>inclusive</name></name> <operator>!=</operator> <name><name>boundB</name><operator>.</operator><name>inclusive</name></name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>			<comment type="block">/* bounds overlap */</comment>
</block_content>}</block></function>

<comment type="block">/* adjacent to (but not overlapping)? (internal version) */</comment>
<function><type><name>bool</name></type>
<name>range_adjacent_internal</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>r1</name></decl></parameter>, <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>r2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>lower1</name></decl>,
				<decl><type ref="prev"/><name>lower2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>upper1</name></decl>,
				<decl><type ref="prev"/><name>upper2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>empty1</name></decl>,
				<decl><type ref="prev"/><name>empty2</name></decl>;</decl_stmt>

	<comment type="block">/* Different types should be prevented by ANYRANGE matching rules */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"range types do not match"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* An empty range is not adjacent to any other range */</comment>
	<if_stmt><if>if <condition>(<expr><name>empty1</name> <operator>||</operator> <name>empty2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Given two ranges A..B and C..D, the ranges are adjacent if and only if
	 * B is adjacent to C, or D is adjacent to A.
	 */</comment>
	<return>return <expr><operator>(</operator><call><name>bounds_adjacent</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>upper1</name></expr></argument>, <argument><expr><name>lower2</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>bounds_adjacent</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>upper2</name></expr></argument>, <argument><expr><name>lower1</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* adjacent to (but not overlapping)? */</comment>
<function><type><name>Datum</name></type>
<name>range_adjacent</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r1</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r2</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>range_get_typcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>range_adjacent_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* overlaps? (internal version) */</comment>
<function><type><name>bool</name></type>
<name>range_overlaps_internal</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>r1</name></decl></parameter>, <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>r2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>lower1</name></decl>,
				<decl><type ref="prev"/><name>lower2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>upper1</name></decl>,
				<decl><type ref="prev"/><name>upper2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>empty1</name></decl>,
				<decl><type ref="prev"/><name>empty2</name></decl>;</decl_stmt>

	<comment type="block">/* Different types should be prevented by ANYRANGE matching rules */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"range types do not match"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* An empty range does not overlap any other range */</comment>
	<if_stmt><if>if <condition>(<expr><name>empty1</name> <operator>||</operator> <name>empty2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower2</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper2</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower1</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper1</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* overlaps? */</comment>
<function><type><name>Datum</name></type>
<name>range_overlaps</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r1</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r2</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>range_get_typcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>range_overlaps_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* does not extend to right of? (internal version) */</comment>
<function><type><name>bool</name></type>
<name>range_overleft_internal</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>r1</name></decl></parameter>, <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>r2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>lower1</name></decl>,
				<decl><type ref="prev"/><name>lower2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>upper1</name></decl>,
				<decl><type ref="prev"/><name>upper2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>empty1</name></decl>,
				<decl><type ref="prev"/><name>empty2</name></decl>;</decl_stmt>

	<comment type="block">/* Different types should be prevented by ANYRANGE matching rules */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"range types do not match"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* An empty range is neither before nor after any other range */</comment>
	<if_stmt><if>if <condition>(<expr><name>empty1</name> <operator>||</operator> <name>empty2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper2</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* does not extend to right of? */</comment>
<function><type><name>Datum</name></type>
<name>range_overleft</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r1</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r2</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>range_get_typcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>range_overleft_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* does not extend to left of? (internal version) */</comment>
<function><type><name>bool</name></type>
<name>range_overright_internal</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>r1</name></decl></parameter>, <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>r2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>lower1</name></decl>,
				<decl><type ref="prev"/><name>lower2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>upper1</name></decl>,
				<decl><type ref="prev"/><name>upper2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>empty1</name></decl>,
				<decl><type ref="prev"/><name>empty2</name></decl>;</decl_stmt>

	<comment type="block">/* Different types should be prevented by ANYRANGE matching rules */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"range types do not match"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* An empty range is neither before nor after any other range */</comment>
	<if_stmt><if>if <condition>(<expr><name>empty1</name> <operator>||</operator> <name>empty2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower2</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* does not extend to left of? */</comment>
<function><type><name>Datum</name></type>
<name>range_overright</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r1</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r2</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>range_get_typcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>range_overright_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* range, range -&gt; range functions */</comment>

<comment type="block">/* set difference */</comment>
<function><type><name>Datum</name></type>
<name>range_minus</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r1</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r2</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>lower1</name></decl>,
				<decl><type ref="prev"/><name>lower2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>upper1</name></decl>,
				<decl><type ref="prev"/><name>upper2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>empty1</name></decl>,
				<decl><type ref="prev"/><name>empty2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cmp_l1l2</name></decl>,
				<decl><type ref="prev"/><name>cmp_l1u2</name></decl>,
				<decl><type ref="prev"/><name>cmp_u1l2</name></decl>,
				<decl><type ref="prev"/><name>cmp_u1u2</name></decl>;</decl_stmt>

	<comment type="block">/* Different types should be prevented by ANYRANGE matching rules */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"range types do not match"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>range_get_typcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if either is empty, r1 is the correct answer */</comment>
	<if_stmt><if>if <condition>(<expr><name>empty1</name> <operator>||</operator> <name>empty2</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_RANGE_P</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>cmp_l1l2</name> <operator>=</operator> <call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cmp_l1u2</name> <operator>=</operator> <call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cmp_u1l2</name> <operator>=</operator> <call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cmp_u1u2</name> <operator>=</operator> <call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cmp_l1l2</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>cmp_u1u2</name></expr></argument> &gt;</argument_list></name> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"result of range difference would not be contiguous"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>cmp_l1u2</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>cmp_u1l2</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_RANGE_P</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>cmp_l1l2</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>cmp_u1u2</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_RANGE_P</name><argument_list>(<argument><expr><call><name>make_empty_range</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>cmp_l1l2</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>cmp_u1l2</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>cmp_u1u2</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>lower2</name><operator>.</operator><name>inclusive</name></name> <operator>=</operator> <operator>!</operator><name><name>lower2</name><operator>.</operator><name>inclusive</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lower2</name><operator>.</operator><name>lower</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* it will become the upper bound */</comment>
		<expr_stmt><expr><call><name>PG_RETURN_RANGE_P</name><argument_list>(<argument><expr><call><name>make_range</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower2</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>cmp_l1l2</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>cmp_u1u2</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>cmp_l1u2</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>upper2</name><operator>.</operator><name>inclusive</name></name> <operator>=</operator> <operator>!</operator><name><name>upper2</name><operator>.</operator><name>inclusive</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>upper2</name><operator>.</operator><name>lower</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* it will become the lower bound */</comment>
		<expr_stmt><expr><call><name>PG_RETURN_RANGE_P</name><argument_list>(<argument><expr><call><name>make_range</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper1</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected case in range_minus"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Set union.  If strict is true, it is an error that the two input ranges
 * are not adjacent or overlapping.
 */</comment>
<function><type><specifier>static</specifier> <name>RangeType</name> <modifier>*</modifier></type>
<name>range_union_internal</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>r1</name></decl></parameter>, <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>r2</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>strict</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>lower1</name></decl>,
				<decl><type ref="prev"/><name>lower2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>upper1</name></decl>,
				<decl><type ref="prev"/><name>upper2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>empty1</name></decl>,
				<decl><type ref="prev"/><name>empty2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>result_lower</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>result_upper</name></decl>;</decl_stmt>

	<comment type="block">/* Different types should be prevented by ANYRANGE matching rules */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"range types do not match"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if either is empty, the other is the correct answer */</comment>
	<if_stmt><if>if <condition>(<expr><name>empty1</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>r2</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>empty2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>r1</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>strict</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>range_overlaps_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>range_adjacent_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"result of range union would not be contiguous"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower2</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result_lower</name> <operator>=</operator> <operator>&amp;</operator><name>lower1</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result_lower</name> <operator>=</operator> <operator>&amp;</operator><name>lower2</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper2</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result_upper</name> <operator>=</operator> <operator>&amp;</operator><name>upper1</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result_upper</name> <operator>=</operator> <operator>&amp;</operator><name>upper2</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><call><name>make_range</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>result_lower</name></expr></argument>, <argument><expr><name>result_upper</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>range_union</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r1</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r2</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>range_get_typcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_RANGE_P</name><argument_list>(<argument><expr><call><name>range_union_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * range merge: like set union, except also allow and account for non-adjacent
 * input ranges.
 */</comment>
<function><type><name>Datum</name></type>
<name>range_merge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r1</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r2</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>range_get_typcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_RANGE_P</name><argument_list>(<argument><expr><call><name>range_union_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* set intersection */</comment>
<function><type><name>Datum</name></type>
<name>range_intersect</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r1</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r2</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>lower1</name></decl>,
				<decl><type ref="prev"/><name>lower2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>upper1</name></decl>,
				<decl><type ref="prev"/><name>upper2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>empty1</name></decl>,
				<decl><type ref="prev"/><name>empty2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>result_lower</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>result_upper</name></decl>;</decl_stmt>

	<comment type="block">/* Different types should be prevented by ANYRANGE matching rules */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"range types do not match"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>range_get_typcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>empty1</name> <operator>||</operator> <name>empty2</name> <operator>||</operator> <operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>range_overlaps</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_RANGE_P</name><argument_list>(<argument><expr><call><name>make_empty_range</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower2</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result_lower</name> <operator>=</operator> <operator>&amp;</operator><name>lower1</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result_lower</name> <operator>=</operator> <operator>&amp;</operator><name>lower2</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper2</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result_upper</name> <operator>=</operator> <operator>&amp;</operator><name>upper1</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result_upper</name> <operator>=</operator> <operator>&amp;</operator><name>upper2</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_RANGE_P</name><argument_list>(<argument><expr><call><name>make_range</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>result_lower</name></expr></argument>, <argument><expr><name>result_upper</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Btree support */</comment>

<comment type="block">/* btree comparator */</comment>
<function><type><name>Datum</name></type>
<name>range_cmp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r1</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r2</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>lower1</name></decl>,
				<decl><type ref="prev"/><name>lower2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>upper1</name></decl>,
				<decl><type ref="prev"/><name>upper2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>empty1</name></decl>,
				<decl><type ref="prev"/><name>empty2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* recurses when subtype is a range type */</comment>

	<comment type="block">/* Different types should be prevented by ANYRANGE matching rules */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"range types do not match"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>range_get_typcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* For b-tree use, empty ranges sort before all else */</comment>
	<if_stmt><if>if <condition>(<expr><name>empty1</name> <operator>&amp;&amp;</operator> <name>empty2</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cmp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>empty1</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cmp</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>empty2</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cmp</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>r1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>r2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* inequality operators using the range_cmp function */</comment>
<function><type><name>Datum</name></type>
<name>range_lt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name> <init>= <expr><call><name>range_cmp</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>range_le</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name> <init>= <expr><call><name>range_cmp</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>cmp</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>range_ge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name> <init>= <expr><call><name>range_cmp</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>cmp</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>range_gt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name> <init>= <expr><call><name>range_cmp</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Hash support */</comment>

<comment type="block">/* hash a range value */</comment>
<function><type><name>Datum</name></type>
<name>hash_range</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>scache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>lower</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>upper</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>empty</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>lower_hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>upper_hash</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* recurses when subtype is a range type */</comment>

	<expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>range_get_typcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* deserialize */</comment>
	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>range_get_flags</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Look up the element type's hash function, if not done already.
	 */</comment>
	<expr_stmt><expr><name>scache</name> <operator>=</operator> <name><name>typcache</name><operator>-&gt;</operator><name>rngelemtype</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>scache</name><operator>-&gt;</operator><name>hash_proc_finfo</name><operator>.</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>scache</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name><name>scache</name><operator>-&gt;</operator><name>type_id</name></name></expr></argument>, <argument><expr><name>TYPECACHE_HASH_PROC_FINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>scache</name><operator>-&gt;</operator><name>hash_proc_finfo</name><operator>.</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not identify a hash function for type %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>scache</name><operator>-&gt;</operator><name>type_id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Apply the hash function to each bound.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RANGE_HAS_LBOUND</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>lower_hash</name> <operator>=</operator> <call><name>DatumGetUInt32</name><argument_list>(<argument><expr><call><name>FunctionCall1Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scache</name><operator>-&gt;</operator><name>hash_proc_finfo</name></name></expr></argument>,
													  <argument><expr><name><name>typcache</name><operator>-&gt;</operator><name>rng_collation</name></name></expr></argument>,
													  <argument><expr><name><name>lower</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>lower_hash</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RANGE_HAS_UBOUND</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>upper_hash</name> <operator>=</operator> <call><name>DatumGetUInt32</name><argument_list>(<argument><expr><call><name>FunctionCall1Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scache</name><operator>-&gt;</operator><name>hash_proc_finfo</name></name></expr></argument>,
													  <argument><expr><name><name>typcache</name><operator>-&gt;</operator><name>rng_collation</name></name></expr></argument>,
													  <argument><expr><name><name>upper</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>upper_hash</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Merge hashes of flags and bounds */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>hash_uint32</name><argument_list>(<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>^=</operator> <name>lower_hash</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>result</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>result</name> <operator>&gt;&gt;</operator> <literal type="number">31</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>^=</operator> <name>upper_hash</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns 64-bit value by hashing a value to a 64-bit value, with a seed.
 * Otherwise, similar to hash_range.
 */</comment>
<function><type><name>Datum</name></type>
<name>hash_range_extended</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>seed</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>scache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>lower</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>upper</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>empty</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>lower_hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>upper_hash</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>range_get_typcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>range_get_flags</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scache</name> <operator>=</operator> <name><name>typcache</name><operator>-&gt;</operator><name>rngelemtype</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>scache</name><operator>-&gt;</operator><name>hash_extended_proc_finfo</name><operator>.</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>scache</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name><name>scache</name><operator>-&gt;</operator><name>type_id</name></name></expr></argument>,
								   <argument><expr><name>TYPECACHE_HASH_EXTENDED_PROC_FINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>scache</name><operator>-&gt;</operator><name>hash_extended_proc_finfo</name><operator>.</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not identify a hash function for type %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>scache</name><operator>-&gt;</operator><name>type_id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RANGE_HAS_LBOUND</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>lower_hash</name> <operator>=</operator> <call><name>DatumGetUInt64</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scache</name><operator>-&gt;</operator><name>hash_extended_proc_finfo</name></name></expr></argument>,
													  <argument><expr><name><name>typcache</name><operator>-&gt;</operator><name>rng_collation</name></name></expr></argument>,
													  <argument><expr><name><name>lower</name><operator>.</operator><name>val</name></name></expr></argument>,
													  <argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>lower_hash</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RANGE_HAS_UBOUND</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>upper_hash</name> <operator>=</operator> <call><name>DatumGetUInt64</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scache</name><operator>-&gt;</operator><name>hash_extended_proc_finfo</name></name></expr></argument>,
													  <argument><expr><name><name>typcache</name><operator>-&gt;</operator><name>rng_collation</name></name></expr></argument>,
													  <argument><expr><name><name>upper</name><operator>.</operator><name>val</name></name></expr></argument>,
													  <argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>upper_hash</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Merge hashes of flags and bounds */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetUInt64</name><argument_list>(<argument><expr><call><name>hash_uint32_extended</name><argument_list>(<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>flags</name></expr></argument>,
												 <argument><expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>^=</operator> <name>lower_hash</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ROTATE_HIGH_AND_LOW_32BITS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>^=</operator> <name>upper_hash</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_UINT64</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *----------------------------------------------------------
 * CANONICAL FUNCTIONS
 *
 *	 Functions for specific built-in range types.
 *----------------------------------------------------------
 */</comment>

<function><type><name>Datum</name></type>
<name>int4range_canonical</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>lower</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>upper</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>empty</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>range_get_typcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>empty</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_RANGE_P</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lower</name><operator>.</operator><name>infinite</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>lower</name><operator>.</operator><name>inclusive</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>lower</name><operator>.</operator><name>val</name></name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>int4pl</name></expr></argument>, <argument><expr><name><name>lower</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lower</name><operator>.</operator><name>inclusive</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>upper</name><operator>.</operator><name>infinite</name></name> <operator>&amp;&amp;</operator> <name><name>upper</name><operator>.</operator><name>inclusive</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>upper</name><operator>.</operator><name>val</name></name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>int4pl</name></expr></argument>, <argument><expr><name><name>upper</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>upper</name><operator>.</operator><name>inclusive</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_RANGE_P</name><argument_list>(<argument><expr><call><name>range_serialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>int8range_canonical</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>lower</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>upper</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>empty</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>range_get_typcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>empty</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_RANGE_P</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lower</name><operator>.</operator><name>infinite</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>lower</name><operator>.</operator><name>inclusive</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>lower</name><operator>.</operator><name>val</name></name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>int8pl</name></expr></argument>, <argument><expr><name><name>lower</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lower</name><operator>.</operator><name>inclusive</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>upper</name><operator>.</operator><name>infinite</name></name> <operator>&amp;&amp;</operator> <name><name>upper</name><operator>.</operator><name>inclusive</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>upper</name><operator>.</operator><name>val</name></name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>int8pl</name></expr></argument>, <argument><expr><name><name>upper</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>upper</name><operator>.</operator><name>inclusive</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_RANGE_P</name><argument_list>(<argument><expr><call><name>range_serialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>daterange_canonical</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>lower</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>upper</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>empty</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>range_get_typcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>empty</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_RANGE_P</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lower</name><operator>.</operator><name>infinite</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>lower</name><operator>.</operator><name>inclusive</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>lower</name><operator>.</operator><name>val</name></name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>date_pli</name></expr></argument>, <argument><expr><name><name>lower</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lower</name><operator>.</operator><name>inclusive</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>upper</name><operator>.</operator><name>infinite</name></name> <operator>&amp;&amp;</operator> <name><name>upper</name><operator>.</operator><name>inclusive</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>upper</name><operator>.</operator><name>val</name></name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>date_pli</name></expr></argument>, <argument><expr><name><name>upper</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>upper</name><operator>.</operator><name>inclusive</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_RANGE_P</name><argument_list>(<argument><expr><call><name>range_serialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *----------------------------------------------------------
 * SUBTYPE_DIFF FUNCTIONS
 *
 * Functions for specific built-in range types.
 *
 * Note that subtype_diff does return the difference, not the absolute value
 * of the difference, and it must take care to avoid overflow.
 * (numrange_subdiff is at some risk there ...)
 *----------------------------------------------------------
 */</comment>

<function><type><name>Datum</name></type>
<name>int4range_subdiff</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>v1</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>v2</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><operator>(</operator><name>float8</name><operator>)</operator> <name>v1</name> <operator>-</operator> <operator>(</operator><name>float8</name><operator>)</operator> <name>v2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>int8range_subdiff</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>		<name>v1</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>v2</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><operator>(</operator><name>float8</name><operator>)</operator> <name>v1</name> <operator>-</operator> <operator>(</operator><name>float8</name><operator>)</operator> <name>v2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>numrange_subdiff</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>v1</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>v2</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>numresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>floatresult</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>numresult</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>numeric_sub</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>floatresult</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_float8</name></expr></argument>,
													 <argument><expr><name>numresult</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>floatresult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>daterange_subdiff</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>v1</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>v2</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><operator>(</operator><name>float8</name><operator>)</operator> <name>v1</name> <operator>-</operator> <operator>(</operator><name>float8</name><operator>)</operator> <name>v2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>tsrange_subdiff</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>v1</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>v2</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>float8</name><operator>)</operator> <name>v1</name> <operator>-</operator> <operator>(</operator><name>float8</name><operator>)</operator> <name>v2</name><operator>)</operator> <operator>/</operator> <name>USECS_PER_SEC</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>tstzrange_subdiff</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>v1</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>v2</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>float8</name><operator>)</operator> <name>v1</name> <operator>-</operator> <operator>(</operator><name>float8</name><operator>)</operator> <name>v2</name><operator>)</operator> <operator>/</operator> <name>USECS_PER_SEC</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *----------------------------------------------------------
 * SUPPORT FUNCTIONS
 *
 *	 These functions aren't in pg_proc, but are useful for
 *	 defining new generic range functions in C.
 *----------------------------------------------------------
 */</comment>

<comment type="block">/*
 * range_get_typcache: get cached information about a range type
 *
 * This is for use by range-related functions that follow the convention
 * of using the fn_extra field as a pointer to the type cache entry for
 * the range type.  Functions that need to cache more information than
 * that must fend for themselves.
 */</comment>
<function><type><name>TypeCacheEntry</name> <modifier>*</modifier></type>
<name>range_get_typcache</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>rngtypid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name> <init>= <expr><operator>(</operator><name>TypeCacheEntry</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>typcache</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<name><name>typcache</name><operator>-&gt;</operator><name>type_id</name></name> <operator>!=</operator> <name>rngtypid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>rngtypid</name></expr></argument>, <argument><expr><name>TYPECACHE_RANGE_INFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>typcache</name><operator>-&gt;</operator><name>rngelemtype</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"type %u is not a range type"</literal></expr></argument>, <argument><expr><name>rngtypid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>typcache</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>typcache</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * range_serialize: construct a range value from bounds and empty-flag
 *
 * This does not force canonicalization of the range value.  In most cases,
 * external callers should only be canonicalization functions.  Note that
 * we perform some datatype-independent canonicalization checks anyway.
 */</comment>
<function><type><name>RangeType</name> <modifier>*</modifier></type>
<name>range_serialize</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>lower</name></decl></parameter>, <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>upper</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>empty</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>range</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>msize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>typlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typbyval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>typalign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>typstorage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Verify range is not invalid on its face, and construct flags value,
	 * preventing any non-canonical combinations such as infinite+inclusive.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lower</name><operator>-&gt;</operator><name>lower</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>upper</name><operator>-&gt;</operator><name>lower</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>empty</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>RANGE_EMPTY</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>range_cmp_bound_values</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>lower</name></expr></argument>, <argument><expr><name>upper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* error check: if lower bound value is above upper, it's wrong */</comment>
		<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"range lower bound must be less than or equal to range upper bound"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* if bounds are equal, and not both inclusive, range is empty */</comment>
		<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>lower</name><operator>-&gt;</operator><name>inclusive</name></name> <operator>&amp;&amp;</operator> <name><name>upper</name><operator>-&gt;</operator><name>inclusive</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>RANGE_EMPTY</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* infinite boundaries are never inclusive */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>lower</name><operator>-&gt;</operator><name>infinite</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>RANGE_LB_INF</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>lower</name><operator>-&gt;</operator><name>inclusive</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>RANGE_LB_INC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>upper</name><operator>-&gt;</operator><name>infinite</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>RANGE_UB_INF</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>upper</name><operator>-&gt;</operator><name>inclusive</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>RANGE_UB_INC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Fetch information about range's element type */</comment>
	<expr_stmt><expr><name>typlen</name> <operator>=</operator> <name><name>typcache</name><operator>-&gt;</operator><name>rngelemtype</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>typbyval</name> <operator>=</operator> <name><name>typcache</name><operator>-&gt;</operator><name>rngelemtype</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>typalign</name> <operator>=</operator> <name><name>typcache</name><operator>-&gt;</operator><name>rngelemtype</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>typstorage</name> <operator>=</operator> <name><name>typcache</name><operator>-&gt;</operator><name>rngelemtype</name><operator>-&gt;</operator><name>typstorage</name></name></expr>;</expr_stmt>

	<comment type="block">/* Count space for varlena header and range type's OID */</comment>
	<expr_stmt><expr><name>msize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RangeType</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>msize</name> <operator>==</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>msize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Count space for bounds */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RANGE_HAS_LBOUND</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Make sure item to be inserted is not toasted.  It is essential that
		 * we not insert an out-of-line toast value pointer into a range
		 * object, for the same reasons that arrays and records can't contain
		 * them.  It would work to store a compressed-in-line value, but we
		 * prefer to decompress and then let compression be applied to the
		 * whole range object if necessary.  But, unlike arrays, we do allow
		 * short-header varlena objects to stay as-is.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>typlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>lower</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM_PACKED</name><argument_list>(<argument><expr><name><name>lower</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>msize</name> <operator>=</operator> <call><name>datum_compute_size</name><argument_list>(<argument><expr><name>msize</name></expr></argument>, <argument><expr><name><name>lower</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>,
								   <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typstorage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RANGE_HAS_UBOUND</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Make sure item to be inserted is not toasted */</comment>
		<if_stmt><if>if <condition>(<expr><name>typlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>upper</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM_PACKED</name><argument_list>(<argument><expr><name><name>upper</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>msize</name> <operator>=</operator> <call><name>datum_compute_size</name><argument_list>(<argument><expr><name>msize</name></expr></argument>, <argument><expr><name><name>upper</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>,
								   <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typstorage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Add space for flag byte */</comment>
	<expr_stmt><expr><name>msize</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<comment type="block">/* Note: zero-fill is required here, just as in heap tuples */</comment>
	<expr_stmt><expr><name>range</name> <operator>=</operator> <operator>(</operator><name>RangeType</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>msize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><name>msize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now fill in the datum */</comment>
	<expr_stmt><expr><name><name>range</name><operator>-&gt;</operator><name>rangetypid</name></name> <operator>=</operator> <name><name>typcache</name><operator>-&gt;</operator><name>type_id</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>range</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RANGE_HAS_LBOUND</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lower</name><operator>-&gt;</operator><name>lower</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>datum_write</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>lower</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>,
						  <argument><expr><name>typstorage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RANGE_HAS_UBOUND</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>upper</name><operator>-&gt;</operator><name>lower</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>datum_write</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>upper</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>,
						  <argument><expr><name>typstorage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>ptr</name><operator>)</operator> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>

	<return>return <expr><name>range</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * range_deserialize: deconstruct a range value
 *
 * NB: the given range object must be fully detoasted; it cannot have a
 * short varlena header.
 *
 * Note that if the element type is pass-by-reference, the datums in the
 * RangeBound structs will be pointers into the given range object.
 */</comment>
<function><type><name>void</name></type>
<name>range_deserialize</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>range</name></decl></parameter>,
				  <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>lower</name></decl></parameter>, <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>upper</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>empty</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name>flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>typlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typbyval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>typalign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>lbound</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>ubound</name></decl>;</decl_stmt>

	<comment type="block">/* assert caller passed the right typcache entry */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>typcache</name><operator>-&gt;</operator><name>type_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* fetch the flag byte from datum's last byte */</comment>
	<expr_stmt><expr><name>flags</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>range</name> <operator>+</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* fetch information about range's element type */</comment>
	<expr_stmt><expr><name>typlen</name> <operator>=</operator> <name><name>typcache</name><operator>-&gt;</operator><name>rngelemtype</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>typbyval</name> <operator>=</operator> <name><name>typcache</name><operator>-&gt;</operator><name>rngelemtype</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>typalign</name> <operator>=</operator> <name><name>typcache</name><operator>-&gt;</operator><name>rngelemtype</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>

	<comment type="block">/* initialize data pointer just after the range OID */</comment>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <operator>(</operator><name>range</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* fetch lower bound, if any */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RANGE_HAS_LBOUND</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* att_align_pointer cannot be necessary here */</comment>
		<expr_stmt><expr><name>lbound</name> <operator>=</operator> <call><name>fetch_att</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <call><name>att_addlength_pointer</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>lbound</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* fetch upper bound, if any */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RANGE_HAS_UBOUND</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <call><name>att_align_pointer</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ubound</name> <operator>=</operator> <call><name>fetch_att</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* no need for att_addlength_pointer */</comment>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>ubound</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* emit results */</comment>

	<expr_stmt><expr><operator>*</operator><name>empty</name> <operator>=</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>RANGE_EMPTY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>lower</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <name>lbound</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lower</name><operator>-&gt;</operator><name>infinite</name></name> <operator>=</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>RANGE_LB_INF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lower</name><operator>-&gt;</operator><name>inclusive</name></name> <operator>=</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>RANGE_LB_INC</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lower</name><operator>-&gt;</operator><name>lower</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>upper</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <name>ubound</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>upper</name><operator>-&gt;</operator><name>infinite</name></name> <operator>=</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>RANGE_UB_INF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>upper</name><operator>-&gt;</operator><name>inclusive</name></name> <operator>=</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>RANGE_UB_INC</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>upper</name><operator>-&gt;</operator><name>lower</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * range_get_flags: just get the flags from a RangeType value.
 *
 * This is frequently useful in places that only need the flags and not
 * the full results of range_deserialize.
 */</comment>
<function><type><name>char</name></type>
<name>range_get_flags</name><parameter_list>(<parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>range</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* fetch the flag byte from datum's last byte */</comment>
	<return>return <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>range</name> <operator>+</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * range_set_contain_empty: set the RANGE_CONTAIN_EMPTY bit in the value.
 *
 * This is only needed in GiST operations, so we don't include a provision
 * for setting it in range_serialize; rather, this function must be applied
 * afterwards.
 */</comment>
<function><type><name>void</name></type>
<name>range_set_contain_empty</name><parameter_list>(<parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>range</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>flagsp</name></decl>;</decl_stmt>

	<comment type="block">/* flag byte is datum's last byte */</comment>
	<expr_stmt><expr><name>flagsp</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>range</name> <operator>+</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>flagsp</name> <operator>|=</operator> <name>RANGE_CONTAIN_EMPTY</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This both serializes and canonicalizes (if applicable) the range.
 * This should be used by most callers.
 */</comment>
<function><type><name>RangeType</name> <modifier>*</modifier></type>
<name>make_range</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>lower</name></decl></parameter>, <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>upper</name></decl></parameter>,
		   <parameter><decl><type><name>bool</name></type> <name>empty</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>range</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>range</name> <operator>=</operator> <call><name>range_serialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>lower</name></expr></argument>, <argument><expr><name>upper</name></expr></argument>, <argument><expr><name>empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* no need to call canonical on empty ranges ... */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typcache</name><operator>-&gt;</operator><name>rng_canonical_finfo</name><operator>.</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>RangeIsEmpty</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>range</name> <operator>=</operator> <call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><call><name>FunctionCall1</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>typcache</name><operator>-&gt;</operator><name>rng_canonical_finfo</name></name></expr></argument>,
												 <argument><expr><call><name>RangeTypePGetDatum</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>range</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compare two range boundary points, returning &lt;0, 0, or &gt;0 according to
 * whether b1 is less than, equal to, or greater than b2.
 *
 * The boundaries can be any combination of upper and lower; so it's useful
 * for a variety of operators.
 *
 * The simple case is when b1 and b2 are both finite and inclusive, in which
 * case the result is just a comparison of the values held in b1 and b2.
 *
 * If a bound is exclusive, then we need to know whether it's a lower bound,
 * in which case we treat the boundary point as "just greater than" the held
 * value; or an upper bound, in which case we treat the boundary point as
 * "just less than" the held value.
 *
 * If a bound is infinite, it represents minus infinity (less than every other
 * point) if it's a lower bound; or plus infinity (greater than every other
 * point) if it's an upper bound.
 *
 * There is only one case where two boundaries compare equal but are not
 * identical: when both bounds are inclusive and hold the same finite value,
 * but one is an upper bound and the other a lower bound.
 */</comment>
<function><type><name>int</name></type>
<name>range_cmp_bounds</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>b1</name></decl></parameter>, <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>b2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>result</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * First, handle cases involving infinity, which don't require invoking
	 * the comparison proc.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>infinite</name></name> <operator>&amp;&amp;</operator> <name><name>b2</name><operator>-&gt;</operator><name>infinite</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Both are infinity, so they are equal unless one is lower and the
		 * other not.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>lower</name></name> <operator>==</operator> <name><name>b2</name><operator>-&gt;</operator><name>lower</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><ternary><condition><expr><name><name>b1</name><operator>-&gt;</operator><name>lower</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>infinite</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><ternary><condition><expr><name><name>b1</name><operator>-&gt;</operator><name>lower</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>b2</name><operator>-&gt;</operator><name>infinite</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><ternary><condition><expr><name><name>b2</name><operator>-&gt;</operator><name>lower</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Both boundaries are finite, so compare the held values.
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>typcache</name><operator>-&gt;</operator><name>rng_cmp_proc_finfo</name></name></expr></argument>,
											 <argument><expr><name><name>typcache</name><operator>-&gt;</operator><name>rng_collation</name></name></expr></argument>,
											 <argument><expr><name><name>b1</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>b2</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the comparison is anything other than equal, we're done. If they
	 * compare equal though, we still have to consider whether the boundaries
	 * are inclusive or exclusive.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>b1</name><operator>-&gt;</operator><name>inclusive</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>b2</name><operator>-&gt;</operator><name>inclusive</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* both are exclusive */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>lower</name></name> <operator>==</operator> <name><name>b2</name><operator>-&gt;</operator><name>lower</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><ternary><condition><expr><name><name>b1</name><operator>-&gt;</operator><name>lower</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>b1</name><operator>-&gt;</operator><name>inclusive</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><ternary><condition><expr><name><name>b1</name><operator>-&gt;</operator><name>lower</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>b2</name><operator>-&gt;</operator><name>inclusive</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><ternary><condition><expr><name><name>b2</name><operator>-&gt;</operator><name>lower</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Both are inclusive and the values held are equal, so they are
			 * equal regardless of whether they are upper or lower boundaries,
			 * or a mix.
			 */</comment>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compare two range boundary point values, returning &lt;0, 0, or &gt;0 according
 * to whether b1 is less than, equal to, or greater than b2.
 *
 * This is similar to but simpler than range_cmp_bounds().  We just compare
 * the values held in b1 and b2, ignoring inclusive/exclusive flags.  The
 * lower/upper flags only matter for infinities, where they tell us if the
 * infinity is plus or minus.
 */</comment>
<function><type><name>int</name></type>
<name>range_cmp_bound_values</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>b1</name></decl></parameter>,
					   <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>b2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * First, handle cases involving infinity, which don't require invoking
	 * the comparison proc.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>infinite</name></name> <operator>&amp;&amp;</operator> <name><name>b2</name><operator>-&gt;</operator><name>infinite</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Both are infinity, so they are equal unless one is lower and the
		 * other not.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>lower</name></name> <operator>==</operator> <name><name>b2</name><operator>-&gt;</operator><name>lower</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><ternary><condition><expr><name><name>b1</name><operator>-&gt;</operator><name>lower</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>infinite</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><ternary><condition><expr><name><name>b1</name><operator>-&gt;</operator><name>lower</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>b2</name><operator>-&gt;</operator><name>infinite</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><ternary><condition><expr><name><name>b2</name><operator>-&gt;</operator><name>lower</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Both boundaries are finite, so compare the held values.
	 */</comment>
	<return>return <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>typcache</name><operator>-&gt;</operator><name>rng_cmp_proc_finfo</name></name></expr></argument>,
										   <argument><expr><name><name>typcache</name><operator>-&gt;</operator><name>rng_collation</name></name></expr></argument>,
										   <argument><expr><name><name>b1</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>b2</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Build an empty range value of the type indicated by the typcache entry.
 */</comment>
<function><type><name>RangeType</name> <modifier>*</modifier></type>
<name>make_empty_range</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>lower</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>upper</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>lower</name><operator>.</operator><name>val</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lower</name><operator>.</operator><name>infinite</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lower</name><operator>.</operator><name>inclusive</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lower</name><operator>.</operator><name>lower</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>upper</name><operator>.</operator><name>val</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>upper</name><operator>.</operator><name>infinite</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>upper</name><operator>.</operator><name>inclusive</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>upper</name><operator>.</operator><name>lower</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<return>return <expr><call><name>make_range</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *----------------------------------------------------------
 * STATIC FUNCTIONS
 *----------------------------------------------------------
 */</comment>

<comment type="block">/*
 * Given a string representing the flags for the range type, return the flags
 * represented as a char.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name></type>
<name>range_parse_flags</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>flags_str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>flags_str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator>
		<name><name>flags_str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator>
		<name><name>flags_str</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid range bound flags"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Valid values are \"[]\", \"[)\", \"(]\", and \"()\"."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>flags_str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="char">'['</literal></expr>:</case>
			<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>RANGE_LB_INC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'('</literal></expr>:</case>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid range bound flags"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Valid values are \"[]\", \"[)\", \"(]\", and \"()\"."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<switch>switch <condition>(<expr><name><name>flags_str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="char">']'</literal></expr>:</case>
			<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>RANGE_UB_INC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">')'</literal></expr>:</case>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid range bound flags"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Valid values are \"[]\", \"[)\", \"(]\", and \"()\"."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<return>return <expr><name>flags</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Parse range input.
 *
 * Input parameters:
 *	string: input string to be parsed
 * Output parameters:
 *	*flags: receives flags bitmask
 *	*lbound_str: receives palloc'd lower bound string, or NULL if none
 *	*ubound_str: receives palloc'd upper bound string, or NULL if none
 *
 * This is modeled somewhat after record_in in rowtypes.c.
 * The input syntax is:
 *	&lt;range&gt;   := EMPTY
 *			   | &lt;lb-inc&gt; &lt;string&gt;, &lt;string&gt; &lt;ub-inc&gt;
 *	&lt;lb-inc&gt;  := '[' | '('
 *	&lt;ub-inc&gt;  := ']' | ')'
 *
 * Whitespace before or after &lt;range&gt; is ignored.  Whitespace within a &lt;string&gt;
 * is taken literally and becomes part of the input string for that bound.
 *
 * A &lt;string&gt; of length zero is taken as "infinite" (i.e. no bound), unless it
 * is surrounded by double-quotes, in which case it is the literal empty
 * string.
 *
 * Within a &lt;string&gt;, special characters (such as comma, parenthesis, or
 * brackets) can be enclosed in double-quotes or escaped with backslash. Within
 * double-quotes, a double-quote can be escaped with double-quote or backslash.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>range_parse</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>lbound_str</name></decl></parameter>,
			<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ubound_str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>string</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>infinite</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* consume whitespace */</comment>
	<while>while <condition>(<expr><operator>*</operator><name>ptr</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/* check for empty range */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>RANGE_EMPTY_LITERAL</name></expr></argument>,
					   <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>RANGE_EMPTY_LITERAL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>=</operator> <name>RANGE_EMPTY</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>lbound_str</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>ubound_str</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>RANGE_EMPTY_LITERAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* the rest should be whitespace */</comment>
		<while>while <condition>(<expr><operator>*</operator><name>ptr</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

		<comment type="block">/* should have consumed everything */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed range literal: \"%s\""</literal></expr></argument>,
							<argument><expr><name>string</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Junk after \"empty\" key word."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'['</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>RANGE_LB_INC</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'('</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed range literal: \"%s\""</literal></expr></argument>,
						<argument><expr><name>string</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Missing left parenthesis or bracket."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>range_parse_bound</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>lbound_str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>infinite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>infinite</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>RANGE_LB_INF</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed range literal: \"%s\""</literal></expr></argument>,
						<argument><expr><name>string</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Missing comma after lower bound."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>range_parse_bound</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ubound_str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>infinite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>infinite</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>RANGE_UB_INF</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">']'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>RANGE_UB_INC</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">')'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>						<comment type="block">/* must be a comma */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed range literal: \"%s\""</literal></expr></argument>,
						<argument><expr><name>string</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Too many commas."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* consume whitespace */</comment>
	<while>while <condition>(<expr><operator>*</operator><name>ptr</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed range literal: \"%s\""</literal></expr></argument>,
						<argument><expr><name>string</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Junk after right parenthesis or bracket."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Helper for range_parse: parse and de-quote one bound string.
 *
 * We scan until finding comma, right parenthesis, or right bracket.
 *
 * Input parameters:
 *	string: entire input string (used only for error reports)
 *	ptr: where to start parsing bound
 * Output parameters:
 *	*bound_str: receives palloc'd bound string, or NULL if none
 *	*infinite: set true if no bound, else false
 *
 * The return value is the scan ptr, advanced past the bound string.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>range_parse_bound</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>,
				  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>bound_str</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>infinite</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<comment type="block">/* Check for null: completely empty input means null */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">','</literal> <operator>||</operator> <operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">')'</literal> <operator>||</operator> <operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">']'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>bound_str</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>infinite</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Extract string for this bound */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>inquote</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>inquote</name> <operator>||</operator> <operator>!</operator><operator>(</operator><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">','</literal> <operator>||</operator> <operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">')'</literal> <operator>||</operator> <operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">']'</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name>ch</name> <init>= <expr><operator>*</operator><name>ptr</name><operator>++</operator></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed range literal: \"%s\""</literal></expr></argument>,
								<argument><expr><name>string</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Unexpected end of input."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed range literal: \"%s\""</literal></expr></argument>,
									<argument><expr><name>string</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Unexpected end of input."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>*</operator><name>ptr</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>inquote</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>inquote</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* doubled quote within quote sequence */</comment>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>*</operator><name>ptr</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>inquote</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><operator>*</operator><name>bound_str</name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>infinite</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>ptr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert a deserialized range value to text form
 *
 * Inputs are the flags byte, and the two bound values already converted to
 * text (but not yet quoted).  If no bound value, pass NULL.
 *
 * Result is a palloc'd string
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>range_deparse</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lbound_str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ubound_str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>RANGE_EMPTY</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>RANGE_EMPTY_LITERAL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>RANGE_LB_INC</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'['</literal></expr> </then><else>: <expr><literal type="char">'('</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RANGE_HAS_LBOUND</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>range_bound_escape</name><argument_list>(<argument><expr><name>lbound_str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RANGE_HAS_UBOUND</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>range_bound_escape</name><argument_list>(<argument><expr><name>ubound_str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>RANGE_UB_INC</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">']'</literal></expr> </then><else>: <expr><literal type="char">')'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper for range_deparse: quote a bound value as needed
 *
 * Result is a palloc'd string
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>range_bound_escape</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>nq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Detect whether we need double quotes for this value */</comment>
	<expr_stmt><expr><name>nq</name> <operator>=</operator> <operator>(</operator><name><name>value</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal><operator>)</operator></expr>;</expr_stmt>	<comment type="block">/* force quotes for empty string */</comment>
	<for>for <control>(<init><expr><name>ptr</name> <operator>=</operator> <name>value</name></expr>;</init> <condition><expr><operator>*</operator><name>ptr</name></expr>;</condition> <incr><expr><name>ptr</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name>ch</name> <init>= <expr><operator>*</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'"'</literal> <operator>||</operator> <name>ch</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>||</operator>
			<name>ch</name> <operator>==</operator> <literal type="char">'('</literal> <operator>||</operator> <name>ch</name> <operator>==</operator> <literal type="char">')'</literal> <operator>||</operator>
			<name>ch</name> <operator>==</operator> <literal type="char">'['</literal> <operator>||</operator> <name>ch</name> <operator>==</operator> <literal type="char">']'</literal> <operator>||</operator>
			<name>ch</name> <operator>==</operator> <literal type="char">','</literal> <operator>||</operator>
			<call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>ch</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>nq</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* And emit the string */</comment>
	<if_stmt><if>if <condition>(<expr><name>nq</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<for>for <control>(<init><expr><name>ptr</name> <operator>=</operator> <name>value</name></expr>;</init> <condition><expr><operator>*</operator><name>ptr</name></expr>;</condition> <incr><expr><name>ptr</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name>ch</name> <init>= <expr><operator>*</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'"'</literal> <operator>||</operator> <name>ch</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>nq</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Test whether range r1 contains range r2.
 *
 * Caller has already checked that they are the same range type, and looked up
 * the necessary typcache entry.
 */</comment>
<function><type><name>bool</name></type>
<name>range_contains_internal</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>r1</name></decl></parameter>, <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>r2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>lower1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>upper1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>empty1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>lower2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>upper2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>empty2</name></decl>;</decl_stmt>

	<comment type="block">/* Different types should be prevented by ANYRANGE matching rules */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"range types do not match"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If either range is empty, the answer is easy */</comment>
	<if_stmt><if>if <condition>(<expr><name>empty2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>empty1</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Else we must have lower1 &lt;= lower2 and upper1 &gt;= upper2 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower2</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper2</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>range_contained_by_internal</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>r1</name></decl></parameter>, <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>r2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>range_contains_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Test whether range r contains a specific element value.
 */</comment>
<function><type><name>bool</name></type>
<name>range_contains_elem_internal</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>lower</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>upper</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>empty</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>cmp</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>empty</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lower</name><operator>.</operator><name>infinite</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>typcache</name><operator>-&gt;</operator><name>rng_cmp_proc_finfo</name></name></expr></argument>,
											  <argument><expr><name><name>typcache</name><operator>-&gt;</operator><name>rng_collation</name></name></expr></argument>,
											  <argument><expr><name><name>lower</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>lower</name><operator>.</operator><name>inclusive</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>upper</name><operator>.</operator><name>infinite</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>typcache</name><operator>-&gt;</operator><name>rng_cmp_proc_finfo</name></name></expr></argument>,
											  <argument><expr><name><name>typcache</name><operator>-&gt;</operator><name>rng_collation</name></name></expr></argument>,
											  <argument><expr><name><name>upper</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>upper</name><operator>.</operator><name>inclusive</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * datum_compute_size() and datum_write() are used to insert the bound
 * values into a range object.  They are modeled after heaptuple.c's
 * heap_compute_data_size() and heap_fill_tuple(), but we need not handle
 * null values here.  TYPE_IS_PACKABLE must test the same conditions as
 * heaptuple.c's ATT_IS_PACKABLE macro.
 */</comment>

<comment type="block">/* Does datatype allow packing into the 1-byte-header varlena format? */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPE_IS_PACKABLE</name><parameter_list>(<parameter><type><name>typlen</name></type></parameter>, <parameter><type><name>typstorage</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((typlen) == -1 &amp;&amp; (typstorage) != 'p')</cpp:value></cpp:define>

<comment type="block">/*
 * Increment data_length by the space needed by the datum, including any
 * preceding alignment padding.
 */</comment>
<function><type><specifier>static</specifier> <name>Size</name></type>
<name>datum_compute_size</name><parameter_list>(<parameter><decl><type><name>Size</name></type> <name>data_length</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>typbyval</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>typalign</name></decl></parameter>,
				   <parameter><decl><type><name>int16</name></type> <name>typlen</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>typstorage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>TYPE_IS_PACKABLE</name><argument_list>(<argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typstorage</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>VARATT_CAN_MAKE_SHORT</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * we're anticipating converting to a short varlena header, so adjust
		 * length and don't count any alignment
		 */</comment>
		<expr_stmt><expr><name>data_length</name> <operator>+=</operator> <call><name>VARATT_CONVERTED_SHORT_SIZE</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>data_length</name> <operator>=</operator> <call><name>att_align_datum</name><argument_list>(<argument><expr><name>data_length</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>data_length</name> <operator>=</operator> <call><name>att_addlength_datum</name><argument_list>(<argument><expr><name>data_length</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>data_length</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Write the given datum beginning at ptr (after advancing to correct
 * alignment, if needed).  Return the pointer incremented by space used.
 */</comment>
<function><type><specifier>static</specifier> <name>Pointer</name></type>
<name>datum_write</name><parameter_list>(<parameter><decl><type><name>Pointer</name></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>datum</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>typbyval</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>typalign</name></decl></parameter>,
			<parameter><decl><type><name>int16</name></type> <name>typlen</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>typstorage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>data_length</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>typbyval</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* pass-by-value */</comment>
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>store_att_byval</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>data_length</name> <operator>=</operator> <name>typlen</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>typlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* varlena */</comment>
		<decl_stmt><decl><type><name>Pointer</name></type>		<name>val</name> <init>= <expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Throw error, because we must never put a toast pointer inside a
			 * range object.  Caller should have detoasted it.
			 */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot store a toast pointer inside a range"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>data_length</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_SHORT</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* no alignment for short varlenas */</comment>
			<expr_stmt><expr><name>data_length</name> <operator>=</operator> <call><name>VARSIZE_SHORT</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>data_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>TYPE_IS_PACKABLE</name><argument_list>(<argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typstorage</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				 <call><name>VARATT_CAN_MAKE_SHORT</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* convert to short varlena -- no alignment */</comment>
			<expr_stmt><expr><name>data_length</name> <operator>=</operator> <call><name>VARATT_CONVERTED_SHORT_SIZE</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_VARSIZE_SHORT</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>data_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>data_length</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* full 4-byte header varlena */</comment>
			<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>data_length</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>data_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>typlen</name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* cstring ... never needs alignment */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>typalign</name> <operator>==</operator> <literal type="char">'c'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>data_length</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>data_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* fixed-length pass-by-reference */</comment>
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>typlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>data_length</name> <operator>=</operator> <name>typlen</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>data_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>data_length</name></expr>;</expr_stmt>

	<return>return <expr><name>ptr</name></expr>;</return>
</block_content>}</block></function>
</unit>
