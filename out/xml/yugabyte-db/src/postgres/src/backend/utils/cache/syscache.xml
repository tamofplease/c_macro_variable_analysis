<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/utils/cache/syscache.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * syscache.c
 *	  System cache management routines
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/utils/cache/syscache.c
 *
 * NOTES
 *	  These routines allow the parser/planner/executor to perform
 *	  rapid lookups on the contents of the system catalogs.
 *
 *	  see utils/syscache.h for a list of the cache IDs
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_aggregate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_amop.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_amproc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_attrdef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_auth_members.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_cast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_conversion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_database.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_db_role_setting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_default_acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_depend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_description.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_enum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_event_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_foreign_data_wrapper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_foreign_server.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_foreign_table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_language.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opclass.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opfamily.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_partitioned_table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_publication.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_publication_rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_range.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_rewrite.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_seclabel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_sequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_shdepend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_shdescription.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_shseclabel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_replication_origin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_statistic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_statistic_ext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_subscription.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_subscription_rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_transform.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_ts_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_ts_config_map.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_ts_dict.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_ts_parser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_ts_template.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_user_mapping.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_yb_tablegroup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/catcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_yb_utils.h"</cpp:file></cpp:include>

<comment type="block">/*---------------------------------------------------------------------------

	Adding system caches:

	Add your new cache to the list in include/utils/syscache.h.
	Keep the list sorted alphabetically.

	Add your entry to the cacheinfo[] array below. All cache lists are
	alphabetical, so add it in the proper place.  Specify the relation OID,
	index OID, number of keys, key attribute numbers, and initial number of
	hash buckets.

	The number of hash buckets must be a power of 2.  It's reasonable to
	set this to the number of entries that might be in the particular cache
	in a medium-size database.

	There must be a unique index underlying each syscache (ie, an index
	whose key is the same as that of the cache).  If there is not one
	already, add definitions for it to include/catalog/indexing.h: you need
	to add a DECLARE_UNIQUE_INDEX macro and a #define for the index OID.
	(Adding an index requires a catversion.h update, while simply
	adding/deleting caches only requires a recompile.)

	Finally, any place your relation gets heap_insert() or
	heap_update() calls, use CatalogTupleInsert() or CatalogTupleUpdate()
	instead, which also update indexes.  The heap_* calls do not do that.

*---------------------------------------------------------------------------
*/</comment>

<comment type="block">/*
 *		struct cachedesc: information defining a single syscache
 */</comment>
<struct>struct <name>cachedesc</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>reloid</name></decl>;</decl_stmt>			<comment type="block">/* OID of the relation being cached */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>indoid</name></decl>;</decl_stmt>			<comment type="block">/* OID of index relation for this cache */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nkeys</name></decl>;</decl_stmt>			<comment type="block">/* # of keys needed for cache lookup */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>key</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>			<comment type="block">/* attribute numbers of key attrs */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbuckets</name></decl>;</decl_stmt>		<comment type="block">/* number of hash buckets for this cache */</comment>
}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>cachedesc</name></name></type> <name><name>cacheinfo</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><name>AggregateRelationId</name></expr>,		<comment type="block">/* AGGFNOID */</comment>
		<expr><name>AggregateFnoidIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_aggregate_aggfnoid</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">16</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>AccessMethodRelationId</name></expr>,	<comment type="block">/* AMNAME */</comment>
		<expr><name>AmNameIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_am_amname</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">4</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>AccessMethodRelationId</name></expr>,	<comment type="block">/* AMOID */</comment>
		<expr><name>AmOidIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>ObjectIdAttributeNumber</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">4</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>AccessMethodOperatorRelationId</name></expr>,	<comment type="block">/* AMOPOPID */</comment>
		<expr><name>AccessMethodOperatorIndexId</name></expr>,
		<expr><literal type="number">3</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_amop_amopopr</name></expr>,
			<expr><name>Anum_pg_amop_amoppurpose</name></expr>,
			<expr><name>Anum_pg_amop_amopfamily</name></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">64</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>AccessMethodOperatorRelationId</name></expr>,	<comment type="block">/* AMOPSTRATEGY */</comment>
		<expr><name>AccessMethodStrategyIndexId</name></expr>,
		<expr><literal type="number">4</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_amop_amopfamily</name></expr>,
			<expr><name>Anum_pg_amop_amoplefttype</name></expr>,
			<expr><name>Anum_pg_amop_amoprighttype</name></expr>,
			<expr><name>Anum_pg_amop_amopstrategy</name></expr>
		}</block></expr>,
		<expr><literal type="number">64</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>AccessMethodProcedureRelationId</name></expr>,	<comment type="block">/* AMPROCNUM */</comment>
		<expr><name>AccessMethodProcedureIndexId</name></expr>,
		<expr><literal type="number">4</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_amproc_amprocfamily</name></expr>,
			<expr><name>Anum_pg_amproc_amproclefttype</name></expr>,
			<expr><name>Anum_pg_amproc_amprocrighttype</name></expr>,
			<expr><name>Anum_pg_amproc_amprocnum</name></expr>
		}</block></expr>,
		<expr><literal type="number">16</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>AttributeRelationId</name></expr>,		<comment type="block">/* ATTNAME */</comment>
		<expr><name>AttributeRelidNameIndexId</name></expr>,
		<expr><literal type="number">2</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_attribute_attrelid</name></expr>,
			<expr><name>Anum_pg_attribute_attname</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">32</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>AttributeRelationId</name></expr>,		<comment type="block">/* ATTNUM */</comment>
		<expr><name>AttributeRelidNumIndexId</name></expr>,
		<expr><literal type="number">2</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_attribute_attrelid</name></expr>,
			<expr><name>Anum_pg_attribute_attnum</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">128</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>AuthMemRelationId</name></expr>,			<comment type="block">/* AUTHMEMMEMROLE */</comment>
		<expr><name>AuthMemMemRoleIndexId</name></expr>,
		<expr><literal type="number">2</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_auth_members_member</name></expr>,
			<expr><name>Anum_pg_auth_members_roleid</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">8</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>AuthMemRelationId</name></expr>,			<comment type="block">/* AUTHMEMROLEMEM */</comment>
		<expr><name>AuthMemRoleMemIndexId</name></expr>,
		<expr><literal type="number">2</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_auth_members_roleid</name></expr>,
			<expr><name>Anum_pg_auth_members_member</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">8</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>AuthIdRelationId</name></expr>,			<comment type="block">/* AUTHNAME */</comment>
		<expr><name>AuthIdRolnameIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_authid_rolname</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">8</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>AuthIdRelationId</name></expr>,			<comment type="block">/* AUTHOID */</comment>
		<expr><name>AuthIdOidIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>ObjectIdAttributeNumber</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">8</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><name>CastRelationId</name></expr>,			<comment type="block">/* CASTSOURCETARGET */</comment>
		<expr><name>CastSourceTargetIndexId</name></expr>,
		<expr><literal type="number">2</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_cast_castsource</name></expr>,
			<expr><name>Anum_pg_cast_casttarget</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">256</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>OperatorClassRelationId</name></expr>,	<comment type="block">/* CLAAMNAMENSP */</comment>
		<expr><name>OpclassAmNameNspIndexId</name></expr>,
		<expr><literal type="number">3</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_opclass_opcmethod</name></expr>,
			<expr><name>Anum_pg_opclass_opcname</name></expr>,
			<expr><name>Anum_pg_opclass_opcnamespace</name></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">8</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>OperatorClassRelationId</name></expr>,	<comment type="block">/* CLAOID */</comment>
		<expr><name>OpclassOidIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>ObjectIdAttributeNumber</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">8</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>CollationRelationId</name></expr>,		<comment type="block">/* COLLNAMEENCNSP */</comment>
		<expr><name>CollationNameEncNspIndexId</name></expr>,
		<expr><literal type="number">3</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_collation_collname</name></expr>,
			<expr><name>Anum_pg_collation_collencoding</name></expr>,
			<expr><name>Anum_pg_collation_collnamespace</name></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">8</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>CollationRelationId</name></expr>,		<comment type="block">/* COLLOID */</comment>
		<expr><name>CollationOidIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>ObjectIdAttributeNumber</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">8</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>ConversionRelationId</name></expr>,		<comment type="block">/* CONDEFAULT */</comment>
		<expr><name>ConversionDefaultIndexId</name></expr>,
		<expr><literal type="number">4</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_conversion_connamespace</name></expr>,
			<expr><name>Anum_pg_conversion_conforencoding</name></expr>,
			<expr><name>Anum_pg_conversion_contoencoding</name></expr>,
			<expr><name>ObjectIdAttributeNumber</name></expr>,
		}</block></expr>,
		<expr><literal type="number">8</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>ConversionRelationId</name></expr>,		<comment type="block">/* CONNAMENSP */</comment>
		<expr><name>ConversionNameNspIndexId</name></expr>,
		<expr><literal type="number">2</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_conversion_conname</name></expr>,
			<expr><name>Anum_pg_conversion_connamespace</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">8</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>ConstraintRelationId</name></expr>,		<comment type="block">/* CONSTROID */</comment>
		<expr><name>ConstraintOidIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>ObjectIdAttributeNumber</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">16</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>ConversionRelationId</name></expr>,		<comment type="block">/* CONVOID */</comment>
		<expr><name>ConversionOidIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>ObjectIdAttributeNumber</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">8</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>DatabaseRelationId</name></expr>,		<comment type="block">/* DATABASEOID */</comment>
		<expr><name>DatabaseOidIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>ObjectIdAttributeNumber</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">4</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>DefaultAclRelationId</name></expr>,		<comment type="block">/* DEFACLROLENSPOBJ */</comment>
		<expr><name>DefaultAclRoleNspObjIndexId</name></expr>,
		<expr><literal type="number">3</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_default_acl_defaclrole</name></expr>,
			<expr><name>Anum_pg_default_acl_defaclnamespace</name></expr>,
			<expr><name>Anum_pg_default_acl_defaclobjtype</name></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">8</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>EnumRelationId</name></expr>,			<comment type="block">/* ENUMOID */</comment>
		<expr><name>EnumOidIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>ObjectIdAttributeNumber</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">8</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>EnumRelationId</name></expr>,			<comment type="block">/* ENUMTYPOIDNAME */</comment>
		<expr><name>EnumTypIdLabelIndexId</name></expr>,
		<expr><literal type="number">2</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_enum_enumtypid</name></expr>,
			<expr><name>Anum_pg_enum_enumlabel</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">8</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>EventTriggerRelationId</name></expr>,	<comment type="block">/* EVENTTRIGGERNAME */</comment>
		<expr><name>EventTriggerNameIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_event_trigger_evtname</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">8</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>EventTriggerRelationId</name></expr>,	<comment type="block">/* EVENTTRIGGEROID */</comment>
		<expr><name>EventTriggerOidIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>ObjectIdAttributeNumber</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">8</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>ForeignDataWrapperRelationId</name></expr>,	<comment type="block">/* FOREIGNDATAWRAPPERNAME */</comment>
		<expr><name>ForeignDataWrapperNameIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_foreign_data_wrapper_fdwname</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">2</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>ForeignDataWrapperRelationId</name></expr>,	<comment type="block">/* FOREIGNDATAWRAPPEROID */</comment>
		<expr><name>ForeignDataWrapperOidIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>ObjectIdAttributeNumber</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">2</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>ForeignServerRelationId</name></expr>,	<comment type="block">/* FOREIGNSERVERNAME */</comment>
		<expr><name>ForeignServerNameIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_foreign_server_srvname</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">2</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>ForeignServerRelationId</name></expr>,	<comment type="block">/* FOREIGNSERVEROID */</comment>
		<expr><name>ForeignServerOidIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>ObjectIdAttributeNumber</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">2</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>ForeignTableRelationId</name></expr>,	<comment type="block">/* FOREIGNTABLEREL */</comment>
		<expr><name>ForeignTableRelidIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_foreign_table_ftrelid</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">4</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>IndexRelationId</name></expr>,			<comment type="block">/* INDEXRELID */</comment>
		<expr><name>IndexRelidIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_index_indexrelid</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">64</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>InheritsRelationId</name></expr>,    <comment type="block">/* INHERITSRELID */</comment>
		<expr><name>InheritsParentIndexId</name></expr>,
		<expr><literal type="number">2</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_inherits_inhparent</name></expr>,
			<expr><name>Anum_pg_inherits_inhrelid</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">32</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>LanguageRelationId</name></expr>,		<comment type="block">/* LANGNAME */</comment>
		<expr><name>LanguageNameIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_language_lanname</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">4</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>LanguageRelationId</name></expr>,		<comment type="block">/* LANGOID */</comment>
		<expr><name>LanguageOidIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>ObjectIdAttributeNumber</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">4</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>NamespaceRelationId</name></expr>,		<comment type="block">/* NAMESPACENAME */</comment>
		<expr><name>NamespaceNameIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_namespace_nspname</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">4</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>NamespaceRelationId</name></expr>,		<comment type="block">/* NAMESPACEOID */</comment>
		<expr><name>NamespaceOidIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>ObjectIdAttributeNumber</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">16</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>OperatorRelationId</name></expr>,		<comment type="block">/* OPERNAMENSP */</comment>
		<expr><name>OperatorNameNspIndexId</name></expr>,
		<expr><literal type="number">4</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_operator_oprname</name></expr>,
			<expr><name>Anum_pg_operator_oprleft</name></expr>,
			<expr><name>Anum_pg_operator_oprright</name></expr>,
			<expr><name>Anum_pg_operator_oprnamespace</name></expr>
		}</block></expr>,
		<expr><literal type="number">256</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>OperatorRelationId</name></expr>,		<comment type="block">/* OPEROID */</comment>
		<expr><name>OperatorOidIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>ObjectIdAttributeNumber</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">32</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>OperatorFamilyRelationId</name></expr>,	<comment type="block">/* OPFAMILYAMNAMENSP */</comment>
		<expr><name>OpfamilyAmNameNspIndexId</name></expr>,
		<expr><literal type="number">3</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_opfamily_opfmethod</name></expr>,
			<expr><name>Anum_pg_opfamily_opfname</name></expr>,
			<expr><name>Anum_pg_opfamily_opfnamespace</name></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">8</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>OperatorFamilyRelationId</name></expr>,	<comment type="block">/* OPFAMILYOID */</comment>
		<expr><name>OpfamilyOidIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>ObjectIdAttributeNumber</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">8</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>PartitionedRelationId</name></expr>,		<comment type="block">/* PARTRELID */</comment>
		<expr><name>PartitionedRelidIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_partitioned_table_partrelid</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">32</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>ProcedureRelationId</name></expr>,		<comment type="block">/* PROCNAMEARGSNSP */</comment>
		<expr><name>ProcedureNameArgsNspIndexId</name></expr>,
		<expr><literal type="number">3</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_proc_proname</name></expr>,
			<expr><name>Anum_pg_proc_proargtypes</name></expr>,
			<expr><name>Anum_pg_proc_pronamespace</name></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">128</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>ProcedureRelationId</name></expr>,		<comment type="block">/* PROCOID */</comment>
		<expr><name>ProcedureOidIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>ObjectIdAttributeNumber</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">128</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>PublicationRelationId</name></expr>,		<comment type="block">/* PUBLICATIONNAME */</comment>
		<expr><name>PublicationNameIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_publication_pubname</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">8</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>PublicationRelationId</name></expr>,		<comment type="block">/* PUBLICATIONOID */</comment>
		<expr><name>PublicationObjectIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>ObjectIdAttributeNumber</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">8</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>PublicationRelRelationId</name></expr>,	<comment type="block">/* PUBLICATIONREL */</comment>
		<expr><name>PublicationRelObjectIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>ObjectIdAttributeNumber</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">64</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>PublicationRelRelationId</name></expr>,	<comment type="block">/* PUBLICATIONRELMAP */</comment>
		<expr><name>PublicationRelPrrelidPrpubidIndexId</name></expr>,
		<expr><literal type="number">2</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_publication_rel_prrelid</name></expr>,
			<expr><name>Anum_pg_publication_rel_prpubid</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">64</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>RangeRelationId</name></expr>,			<comment type="block">/* RANGETYPE */</comment>
		<expr><name>RangeTypidIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_range_rngtypid</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">4</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>RelationRelationId</name></expr>,		<comment type="block">/* RELNAMENSP */</comment>
		<expr><name>ClassNameNspIndexId</name></expr>,
		<expr><literal type="number">2</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_class_relname</name></expr>,
			<expr><name>Anum_pg_class_relnamespace</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">128</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>RelationRelationId</name></expr>,		<comment type="block">/* RELOID */</comment>
		<expr><name>ClassOidIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>ObjectIdAttributeNumber</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">128</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>ReplicationOriginRelationId</name></expr>,	<comment type="block">/* REPLORIGIDENT */</comment>
		<expr><name>ReplicationOriginIdentIndex</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_replication_origin_roident</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">16</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>ReplicationOriginRelationId</name></expr>,	<comment type="block">/* REPLORIGNAME */</comment>
		<expr><name>ReplicationOriginNameIndex</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_replication_origin_roname</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">16</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>RewriteRelationId</name></expr>,			<comment type="block">/* RULERELNAME */</comment>
		<expr><name>RewriteRelRulenameIndexId</name></expr>,
		<expr><literal type="number">2</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_rewrite_ev_class</name></expr>,
			<expr><name>Anum_pg_rewrite_rulename</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">8</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>SequenceRelationId</name></expr>,		<comment type="block">/* SEQRELID */</comment>
		<expr><name>SequenceRelidIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_sequence_seqrelid</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">32</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>StatisticExtRelationId</name></expr>,	<comment type="block">/* STATEXTNAMENSP */</comment>
		<expr><name>StatisticExtNameIndexId</name></expr>,
		<expr><literal type="number">2</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_statistic_ext_stxname</name></expr>,
			<expr><name>Anum_pg_statistic_ext_stxnamespace</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">4</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>StatisticExtRelationId</name></expr>,	<comment type="block">/* STATEXTOID */</comment>
		<expr><name>StatisticExtOidIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>ObjectIdAttributeNumber</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">4</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>StatisticRelationId</name></expr>,		<comment type="block">/* STATRELATTINH */</comment>
		<expr><name>StatisticRelidAttnumInhIndexId</name></expr>,
		<expr><literal type="number">3</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_statistic_starelid</name></expr>,
			<expr><name>Anum_pg_statistic_staattnum</name></expr>,
			<expr><name>Anum_pg_statistic_stainherit</name></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">128</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>SubscriptionRelationId</name></expr>,	<comment type="block">/* SUBSCRIPTIONNAME */</comment>
		<expr><name>SubscriptionNameIndexId</name></expr>,
		<expr><literal type="number">2</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_subscription_subdbid</name></expr>,
			<expr><name>Anum_pg_subscription_subname</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">4</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>SubscriptionRelationId</name></expr>,	<comment type="block">/* SUBSCRIPTIONOID */</comment>
		<expr><name>SubscriptionObjectIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>ObjectIdAttributeNumber</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">4</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>SubscriptionRelRelationId</name></expr>, <comment type="block">/* SUBSCRIPTIONRELMAP */</comment>
		<expr><name>SubscriptionRelSrrelidSrsubidIndexId</name></expr>,
		<expr><literal type="number">2</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_subscription_rel_srrelid</name></expr>,
			<expr><name>Anum_pg_subscription_rel_srsubid</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">64</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>TableSpaceRelationId</name></expr>,		<comment type="block">/* TABLESPACEOID */</comment>
		<expr><name>TablespaceOidIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>ObjectIdAttributeNumber</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
		}</block></expr>,
		<expr><literal type="number">4</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>TransformRelationId</name></expr>,		<comment type="block">/* TRFOID */</comment>
		<expr><name>TransformOidIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>ObjectIdAttributeNumber</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
		}</block></expr>,
		<expr><literal type="number">16</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>TransformRelationId</name></expr>,		<comment type="block">/* TRFTYPELANG */</comment>
		<expr><name>TransformTypeLangIndexId</name></expr>,
		<expr><literal type="number">2</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_transform_trftype</name></expr>,
			<expr><name>Anum_pg_transform_trflang</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
		}</block></expr>,
		<expr><literal type="number">16</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>TSConfigMapRelationId</name></expr>,		<comment type="block">/* TSCONFIGMAP */</comment>
		<expr><name>TSConfigMapIndexId</name></expr>,
		<expr><literal type="number">3</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_ts_config_map_mapcfg</name></expr>,
			<expr><name>Anum_pg_ts_config_map_maptokentype</name></expr>,
			<expr><name>Anum_pg_ts_config_map_mapseqno</name></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">2</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>TSConfigRelationId</name></expr>,		<comment type="block">/* TSCONFIGNAMENSP */</comment>
		<expr><name>TSConfigNameNspIndexId</name></expr>,
		<expr><literal type="number">2</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_ts_config_cfgname</name></expr>,
			<expr><name>Anum_pg_ts_config_cfgnamespace</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">2</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>TSConfigRelationId</name></expr>,		<comment type="block">/* TSCONFIGOID */</comment>
		<expr><name>TSConfigOidIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>ObjectIdAttributeNumber</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">2</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>TSDictionaryRelationId</name></expr>,	<comment type="block">/* TSDICTNAMENSP */</comment>
		<expr><name>TSDictionaryNameNspIndexId</name></expr>,
		<expr><literal type="number">2</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_ts_dict_dictname</name></expr>,
			<expr><name>Anum_pg_ts_dict_dictnamespace</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">2</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>TSDictionaryRelationId</name></expr>,	<comment type="block">/* TSDICTOID */</comment>
		<expr><name>TSDictionaryOidIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>ObjectIdAttributeNumber</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">2</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>TSParserRelationId</name></expr>,		<comment type="block">/* TSPARSERNAMENSP */</comment>
		<expr><name>TSParserNameNspIndexId</name></expr>,
		<expr><literal type="number">2</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_ts_parser_prsname</name></expr>,
			<expr><name>Anum_pg_ts_parser_prsnamespace</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">2</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>TSParserRelationId</name></expr>,		<comment type="block">/* TSPARSEROID */</comment>
		<expr><name>TSParserOidIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>ObjectIdAttributeNumber</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">2</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>TSTemplateRelationId</name></expr>,		<comment type="block">/* TSTEMPLATENAMENSP */</comment>
		<expr><name>TSTemplateNameNspIndexId</name></expr>,
		<expr><literal type="number">2</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_ts_template_tmplname</name></expr>,
			<expr><name>Anum_pg_ts_template_tmplnamespace</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">2</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>TSTemplateRelationId</name></expr>,		<comment type="block">/* TSTEMPLATEOID */</comment>
		<expr><name>TSTemplateOidIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>ObjectIdAttributeNumber</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">2</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>TypeRelationId</name></expr>,			<comment type="block">/* TYPENAMENSP */</comment>
		<expr><name>TypeNameNspIndexId</name></expr>,
		<expr><literal type="number">2</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_type_typname</name></expr>,
			<expr><name>Anum_pg_type_typnamespace</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">64</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>TypeRelationId</name></expr>,			<comment type="block">/* TYPEOID */</comment>
		<expr><name>TypeOidIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>ObjectIdAttributeNumber</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">64</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>UserMappingRelationId</name></expr>,		<comment type="block">/* USERMAPPINGOID */</comment>
		<expr><name>UserMappingOidIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>ObjectIdAttributeNumber</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">2</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>UserMappingRelationId</name></expr>,		<comment type="block">/* USERMAPPINGUSERSERVER */</comment>
		<expr><name>UserMappingUserServerIndexId</name></expr>,
		<expr><literal type="number">2</literal></expr>,
		<expr><block>{
			<expr><name>Anum_pg_user_mapping_umuser</name></expr>,
			<expr><name>Anum_pg_user_mapping_umserver</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><literal type="number">2</literal></expr>
	}</block></expr>,
	<expr><block>{<expr><name>YbTablegroupRelationId</name></expr>,	<comment type="block">/* YBTABLEGROUPOID */</comment>
		<expr><name>YbTablegroupOidIndexId</name></expr>,
		<expr><literal type="number">1</literal></expr>,
		<expr><block>{
			<expr><name>ObjectIdAttributeNumber</name></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
			<expr><literal type="number">0</literal></expr>,
		}</block></expr>,
		<expr><literal type="number">4</literal></expr>
	}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct <name>YbPinnedObjectKey</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type> <name>classid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>objid</name></decl>;</decl_stmt>
}</block></struct></type> <name>YbPinnedObjectKey</name>;</typedef>

<typedef>typedef <type><struct>struct <name>YbPinnedObjectsCacheData</name>
<block>{
	<comment type="block">/* Pinned objects from pg_depend */</comment>
	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>regular</name></decl>;</decl_stmt>
	<comment type="block">/* Pinned objects from pg_shdepend */</comment>
	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>shared</name></decl>;</decl_stmt>
}</block></struct></type> <name>YbPinnedObjectsCacheData</name>;</typedef>

<comment type="block">/* Stores all pinned objects */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>YbPinnedObjectsCacheData</name></type> <name>YbPinnedObjectsCache</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>CatCache</name> <modifier>*</modifier></type><name><name>SysCache</name><index>[<expr><name>SysCacheSize</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>CacheInitialized</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Sorted array of OIDs of tables that have caches on them */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type>	<name><name>SysCacheRelationOid</name><index>[<expr><name>SysCacheSize</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>SysCacheRelationOidSize</name></decl>;</decl_stmt>

<comment type="block">/* Sorted array of OIDs of tables and indexes used by caches */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type>	<name><name>SysCacheSupportingRelOid</name><index>[<expr><name>SysCacheSize</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>SysCacheSupportingRelOidSize</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>oid_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>Bitmapset</name> <modifier>*</modifier></type>
<name>YBSysTablePrimaryKey</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>pkey</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YBPkAddAttribute</name><parameter_list>(<parameter><type><name>attid</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { pkey = bms_add_member(pkey, attid - FirstLowInvalidHeapAttributeNumber); } while (false)</cpp:value></cpp:define>

	<switch>switch <condition>(<expr><name>relid</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AccessMethodOperatorRelationId</name></expr>:</case>
		<case>case <expr><name>AccessMethodProcedureRelationId</name></expr>:</case>
		<case>case <expr><name>AccessMethodRelationId</name></expr>:</case>
		<case>case <expr><name>AggregateRelationId</name></expr>:</case>
		<case>case <expr><name>AttrDefaultRelationId</name></expr>:</case>
		<case>case <expr><name>AuthIdRelationId</name></expr>:</case>
		<case>case <expr><name>CastRelationId</name></expr>:</case>
		<case>case <expr><name>CollationRelationId</name></expr>:</case>
		<case>case <expr><name>ConstraintRelationId</name></expr>:</case>
		<case>case <expr><name>ConversionRelationId</name></expr>:</case>
		<case>case <expr><name>DatabaseRelationId</name></expr>:</case>
		<case>case <expr><name>DefaultAclRelationId</name></expr>:</case>
		<case>case <expr><name>EnumRelationId</name></expr>:</case>
		<case>case <expr><name>EventTriggerRelationId</name></expr>:</case>
		<case>case <expr><name>ForeignDataWrapperRelationId</name></expr>:</case>
		<case>case <expr><name>ForeignServerRelationId</name></expr>:</case>
		<case>case <expr><name>ForeignTableRelationId</name></expr>:</case>
		<case>case <expr><name>LanguageRelationId</name></expr>:</case>
		<case>case <expr><name>NamespaceRelationId</name></expr>:</case>
		<case>case <expr><name>OperatorClassRelationId</name></expr>:</case>
		<case>case <expr><name>OperatorFamilyRelationId</name></expr>:</case>
		<case>case <expr><name>OperatorRelationId</name></expr>:</case>
		<case>case <expr><name>ProcedureRelationId</name></expr>:</case>
		<case>case <expr><name>PublicationRelRelationId</name></expr>:</case>
		<case>case <expr><name>PublicationRelationId</name></expr>:</case>
		<case>case <expr><name>RelationRelationId</name></expr>:</case>
		<case>case <expr><name>RewriteRelationId</name></expr>:</case>
		<case>case <expr><name>StatisticExtRelationId</name></expr>:</case>
		<case>case <expr><name>SubscriptionRelationId</name></expr>:</case>
		<case>case <expr><name>TSConfigRelationId</name></expr>:</case>
		<case>case <expr><name>TSDictionaryRelationId</name></expr>:</case>
		<case>case <expr><name>TSParserRelationId</name></expr>:</case>
		<case>case <expr><name>TSTemplateRelationId</name></expr>:</case>
		<case>case <expr><name>TableSpaceRelationId</name></expr>:</case>
		<case>case <expr><name>TransformRelationId</name></expr>:</case>
		<case>case <expr><name>TypeRelationId</name></expr>:</case>
		<case>case <expr><name>UserMappingRelationId</name></expr>:</case>
		<case>case <expr><name>YbTablegroupRelationId</name></expr>:</case>
			<expr_stmt><expr><call><name>YBPkAddAttribute</name><argument_list>(<argument><expr><name>ObjectIdAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AttributeRelationId</name></expr>:</case>
			<expr_stmt><expr><call><name>YBPkAddAttribute</name><argument_list>(<argument><expr><name>Anum_pg_attribute_attrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>YBPkAddAttribute</name><argument_list>(<argument><expr><name>Anum_pg_attribute_attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AuthMemRelationId</name></expr>:</case>
			<expr_stmt><expr><call><name>YBPkAddAttribute</name><argument_list>(<argument><expr><name>Anum_pg_auth_members_roleid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>YBPkAddAttribute</name><argument_list>(<argument><expr><name>Anum_pg_auth_members_member</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>IndexRelationId</name></expr>:</case>
			<expr_stmt><expr><call><name>YBPkAddAttribute</name><argument_list>(<argument><expr><name>Anum_pg_index_indexrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PartitionedRelationId</name></expr>:</case>
			<expr_stmt><expr><call><name>YBPkAddAttribute</name><argument_list>(<argument><expr><name>Anum_pg_partitioned_table_partrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RangeRelationId</name></expr>:</case>
			<expr_stmt><expr><call><name>YBPkAddAttribute</name><argument_list>(<argument><expr><name>Anum_pg_range_rngtypid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ReplicationOriginRelationId</name></expr>:</case>
			<expr_stmt><expr><call><name>YBPkAddAttribute</name><argument_list>(<argument><expr><name>Anum_pg_replication_origin_roident</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SequenceRelationId</name></expr>:</case>
			<expr_stmt><expr><call><name>YBPkAddAttribute</name><argument_list>(<argument><expr><name>Anum_pg_sequence_seqrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>StatisticRelationId</name></expr>:</case>
			<expr_stmt><expr><call><name>YBPkAddAttribute</name><argument_list>(<argument><expr><name>Anum_pg_statistic_starelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SubscriptionRelRelationId</name></expr>:</case>
			<expr_stmt><expr><call><name>YBPkAddAttribute</name><argument_list>(<argument><expr><name>Anum_pg_subscription_rel_srrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>YBPkAddAttribute</name><argument_list>(<argument><expr><name>Anum_pg_subscription_rel_srsubid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>TSConfigMapRelationId</name></expr>:</case>
			<expr_stmt><expr><call><name>YBPkAddAttribute</name><argument_list>(<argument><expr><name>Anum_pg_ts_config_map_mapcfg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>YBPkAddAttribute</name><argument_list>(<argument><expr><name>Anum_pg_ts_config_map_maptokentype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>YBPkAddAttribute</name><argument_list>(<argument><expr><name>Anum_pg_ts_config_map_mapseqno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default> <break>break;</break>
	</block_content>}</block></switch>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>YBPkAddAttribute</name></cpp:undef>

	<return>return <expr><name>pkey</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Utility function for YugaByte mode. Is used to automatically add entries
 * from common catalog tables to the cache immediately after they are inserted.
 */</comment>
<function><type><name>void</name></type> <name>YbSetSysCacheTuple</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<switch>switch <condition>(<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RelationRelationId</name></expr>:</case>
			<expr_stmt><expr><call><name>SetCatCacheTuple</name><argument_list>(<argument><expr><name><name>SysCache</name><index>[<expr><name>RELOID</name></expr>]</index></name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SetCatCacheTuple</name><argument_list>(<argument><expr><name><name>SysCache</name><index>[<expr><name>RELNAMENSP</name></expr>]</index></name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>TypeRelationId</name></expr>:</case>
			<expr_stmt><expr><call><name>SetCatCacheTuple</name><argument_list>(<argument><expr><name><name>SysCache</name><index>[<expr><name>TYPEOID</name></expr>]</index></name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SetCatCacheTuple</name><argument_list>(<argument><expr><name><name>SysCache</name><index>[<expr><name>TYPENAMENSP</name></expr>]</index></name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ProcedureRelationId</name></expr>:</case>
			<expr_stmt><expr><call><name>SetCatCacheTuple</name><argument_list>(<argument><expr><name><name>SysCache</name><index>[<expr><name>PROCOID</name></expr>]</index></name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SetCatCacheTuple</name><argument_list>(<argument><expr><name><name>SysCache</name><index>[<expr><name>PROCNAMEARGSNSP</name></expr>]</index></name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AttributeRelationId</name></expr>:</case>
			<expr_stmt><expr><call><name>SetCatCacheTuple</name><argument_list>(<argument><expr><name><name>SysCache</name><index>[<expr><name>ATTNUM</name></expr>]</index></name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SetCatCacheTuple</name><argument_list>(<argument><expr><name><name>SysCache</name><index>[<expr><name>ATTNAME</name></expr>]</index></name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PartitionedRelationId</name></expr>:</case>
			<expr_stmt><expr><call><name>SetCatCacheTuple</name><argument_list>(<argument><expr><name><name>SysCache</name><index>[<expr><name>PARTRELID</name></expr>]</index></name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<comment type="block">/* For non-critical tables/indexes nothing to do */</comment>
			<return>return;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * In YugaByte mode preload the given cache with data from master.
 * If no index cache is associated with the given cache (most of the time), its id should be -1.
 */</comment>
<function><type><name>void</name></type>
<name>YbPreloadCatalogCache</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>cache_id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx_cache_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>

	<decl_stmt><decl><type><name>CatCache</name><modifier>*</modifier></type> <name>cache</name>         <init>= <expr><name><name>SysCache</name><index>[<expr><name>cache_id</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatCache</name><modifier>*</modifier></type> <name>idx_cache</name>     <init>= <expr><ternary><condition><expr><name>idx_cache_id</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><name><name>SysCache</name><index>[<expr><name>idx_cache_id</name></expr>]</index></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name><modifier>*</modifier></type>     <name>current_list</name>  <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name><modifier>*</modifier></type>     <name>list_of_lists</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>ntp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>  <name>relation</name>      <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_reloid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name>       <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scandesc</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>relation</name></expr></argument>,
	                                          <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_indexoid</name></name></expr></argument>,
	                                          <argument><expr><name>false</name></expr></argument> <comment type="block">/* indexOK */</comment>,
	                                          <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* snapshot */</comment>,
	                                          <argument><expr><literal type="number">0</literal></expr></argument>  <comment type="block">/* nkeys */</comment>,
	                                          <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* key */</comment>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>ntp</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SetCatCacheTuple</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>ntp</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>idx_cache</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SetCatCacheTuple</name><argument_list>(<argument><expr><name>idx_cache</name></expr></argument>, <argument><expr><name>ntp</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Special handling for the common case of looking up
		 * functions (procedures) by name (i.e. partial key).
		 * We set up the partial cache list for function by-name
		 * lookup on initialization to avoid scanning the large
		 * pg_proc table each time.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>cache_id</name> <operator>==</operator> <name>PROCOID</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>     <name>found_match</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>     <name>is_null</name>     <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>key</name>      <init>= <expr><name><name>idx_cache</name><operator>-&gt;</operator><name>cc_skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>Datum</name></type> <name>ndt</name> <init>= <expr><call><name>heap_getattr</name><argument_list>(<argument><expr><name>ntp</name></expr></argument>, <argument><expr><name><name>key</name><operator>.</operator><name>sk_attno</name></name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>YBC_LOG_WARNING</name><argument_list>(<argument><expr><literal type="string">"Ignoring unexpected null "</literal>
				                <literal type="string">"entry while initializing proc "</literal>
				                <literal type="string">"cache list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Look for an existing list for functions with this name. */</comment>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>list_of_lists</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name>      <modifier>*</modifier></type><name>fnlist</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>HeapTuple</name></type> <name>otp</name>     <init>= <expr><operator>(</operator><name>HeapTuple</name><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>fnlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Datum</name></type>     <name>odt</name>     <init>= <expr><call><name>heap_getattr</name><argument_list>(<argument><expr><name>otp</name></expr></argument>, <argument><expr><name><name>key</name><operator>.</operator><name>sk_attno</name></name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<decl_stmt><decl><type><name>Datum</name></type> <name>test</name> <init>= <expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>.</operator><name>sk_func</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>.</operator><name>sk_collation</name></name></expr></argument>, <argument><expr><name>ndt</name></expr></argument>, <argument><expr><name>odt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>found_match</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><name>test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>found_match</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>fnlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>fnlist</name></expr></argument>, <argument><expr><name>ntp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>lc</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>ptr_value</name></name> <operator>=</operator> <name>fnlist</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found_match</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>new_list</name> <init>= <expr><call><name>lappend</name><argument_list>(<argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>ntp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>list_of_lists</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>list_of_lists</name></expr></argument>, <argument><expr><name>new_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Special handling for pg_rewrite: preload rules list by relation oid.
		 * Note that rules should be ordered by name - which is achieved using
		 * RewriteRelRulenameIndexId index.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>cache_id</name> <operator>==</operator> <name>RULERELNAME</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>current_list</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>current_list</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>ntp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>HeapTuple</name></type>       <name>ltp</name>        <init>= <expr><operator>(</operator><name>HeapTuple</name><operator>)</operator> <call><name>llast</name><argument_list>(<argument><expr><name>current_list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Form_pg_rewrite</name></type> <name>ltp_struct</name> <init>= <expr><operator>(</operator><name>Form_pg_rewrite</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ltp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Form_pg_rewrite</name></type> <name>ntp_struct</name> <init>= <expr><operator>(</operator><name>Form_pg_rewrite</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ntp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>ntp_struct</name><operator>-&gt;</operator><name>ev_class</name></name> <operator>==</operator> <name><name>ltp_struct</name><operator>-&gt;</operator><name>ev_class</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="line">// This rule is for the same table as the last one, continuing the list</comment>
					<expr_stmt><expr><name>current_list</name>  <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>current_list</name></expr></argument>, <argument><expr><name>ntp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="line">// This rule is for another table, changing current list</comment>
					<expr_stmt><expr><name>list_of_lists</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>list_of_lists</name></expr></argument>, <argument><expr><name>current_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>current_list</name>  <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>ntp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>current_list</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>list_of_lists</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>list_of_lists</name></expr></argument>, <argument><expr><name>current_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Load up the lists computed above - if any - into the catalog cache. */</comment>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>list_of_lists</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>current_list</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>cache_id</name> <operator>==</operator> <name>PROCOID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>SetCatCacheList</name><argument_list>(<argument><expr><name>idx_cache</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>current_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>cache_id</name> <operator>==</operator> <name>RULERELNAME</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>SetCatCacheList</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>current_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>list_of_lists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * In YugaByte mode load up the caches with data from some essential tables
 * that are looked up often during regular usage.
 *
 * Used during initdb.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>YBIsEssentialCache</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>cache_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>cache_id</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RELOID</name></expr>:</case>           <expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<case>case <expr><name>TYPEOID</name></expr>:</case>          <expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<case>case <expr><name>ATTNAME</name></expr>:</case>          <expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<case>case <expr><name>PROCOID</name></expr>:</case>          <expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<case>case <expr><name>OPEROID</name></expr>:</case>          <expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<case>case <expr><name>CASTSOURCETARGET</name></expr>:</case> <return>return <expr><name>true</name></expr>;</return>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>YbPreloadCatalogCacheIfEssential</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>cache_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>YBIsEssentialCache</name><argument_list>(<argument><expr><name>cache_id</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>idx_cache_id</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>cache_id</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RELOID</name></expr>:</case>
			<expr_stmt><expr><name>idx_cache_id</name> <operator>=</operator> <name>RELNAMENSP</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>TYPEOID</name></expr>:</case>
			<expr_stmt><expr><name>idx_cache_id</name> <operator>=</operator> <name>TYPENAMENSP</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ATTNAME</name></expr>:</case>
			<expr_stmt><expr><name>idx_cache_id</name> <operator>=</operator> <name>ATTNUM</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PROCOID</name></expr>:</case>
			<expr_stmt><expr><name>idx_cache_id</name> <operator>=</operator> <name>PROCNAMEARGSNSP</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OPEROID</name></expr>:</case>
			<expr_stmt><expr><name>idx_cache_id</name> <operator>=</operator> <name>OPERNAMENSP</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>YbPreloadCatalogCache</name><argument_list>(<argument><expr><name>cache_id</name></expr></argument>, <argument><expr><name>idx_cache_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Preload catalog caches with data from the master to avoid master lookups
 * later.
 *
 * Used during initdb.
 */</comment>
<function><type><name>void</name></type>
<name>YbPreloadCatalogCaches</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CacheInitialized</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Ensure individual caches are initialized */</comment>
	<expr_stmt><expr><call><name>InitCatalogCachePhase2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>cacheId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>cacheId</name> <operator>&lt;</operator> <name>SysCacheSize</name></expr>;</condition> <incr><expr><operator>++</operator><name>cacheId</name></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><call><name>YBIsEssentialCache</name><argument_list>(<argument><expr><name>cacheId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>YbRegisterSysTableForPrefetching</name><argument_list>(<argument><expr><name><name>SysCache</name><index>[<expr><name>cacheId</name></expr>]</index></name><operator>-&gt;</operator><name>cc_reloid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>cacheId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>cacheId</name> <operator>&lt;</operator> <name>SysCacheSize</name></expr>;</condition> <incr><expr><operator>++</operator><name>cacheId</name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>YbPreloadCatalogCacheIfEssential</name><argument_list>(<argument><expr><name>cacheId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>YbFetchPinnedObjectKeyFromPgDepend</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>, <parameter><decl><type><name>YbPinnedObjectKey</name><modifier>*</modifier></type> <name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>dep</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>classid</name></name> <operator>=</operator> <name><name>dep</name><operator>-&gt;</operator><name>refclassid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>objid</name></name> <operator>=</operator> <name><name>dep</name><operator>-&gt;</operator><name>refobjid</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>YbFetchPinnedObjectKeyFromPgShdepend</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>, <parameter><decl><type><name>YbPinnedObjectKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_shdepend</name></type> <name>dep</name> <init>= <expr><operator>(</operator><name>Form_pg_shdepend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>classid</name></name> <operator>=</operator> <name><name>dep</name><operator>-&gt;</operator><name>refclassid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>objid</name></name> <operator>=</operator> <name><name>dep</name><operator>-&gt;</operator><name>refobjid</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to build hash set
 * and fill it from specified relation (pg_depend or pg_shdepend).
 */</comment>
<function><type><specifier>static</specifier> <name>HTAB</name><modifier>*</modifier></type>
<name>YbBuildPinnedObjectCache</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
                         <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>,
                         <parameter><decl><type><name>Oid</name></type> <name>dependRelId</name></decl></parameter>,
                         <parameter><decl><type><name>int</name></type> <name>depTypeAnum</name></decl></parameter>,
                         <parameter><decl><type><name>char</name></type> <name>depTypeValue</name></decl></parameter>,
                         <parameter><function_decl><type><name>void</name></type>(<modifier>*</modifier><name>key_fetcher</name>)<parameter_list>(<parameter><decl><type><name>HeapTuple</name></type></decl></parameter>, <parameter><decl><type><name>YbPinnedObjectKey</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type> <name>ctl</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>YbPinnedObjectKey</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<comment type="block">/* No information associated with key is required. Cache is a set of pinned objects. */</comment>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>YbPinnedObjectKey</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>cache</name> <init>= <expr><call><name>hash_create</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>key</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,
	            <argument><expr><name>depTypeAnum</name></expr></argument>,
	            <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_CHAREQ</name></expr></argument>,
	            <argument><expr><call><name>CharGetDatum</name><argument_list>(<argument><expr><name>depTypeValue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>dependDesc</name> <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name>dependRelId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>dependDesc</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YbPinnedObjectKey</name></type> <name>pinnedKey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tup</name></decl>;</decl_stmt>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>key_fetcher</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pinnedKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pinnedKey</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>dependDesc</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>cache</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>YbLoadPinnedObjectsCache</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>YbPinnedObjectsCacheData</name></type> <name>cache</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>shared</name> <operator>=</operator> <call><name>YbBuildPinnedObjectCache</name><argument_list>(<argument><expr><literal type="string">"Shared pinned objects cache"</literal></expr></argument>,
		                                   <argument><expr><literal type="number">20</literal></expr></argument>, <comment type="block">/* Number of pinned objects in pg_shdepend is 9 */</comment>
		                                   <argument><expr><name>SharedDependRelationId</name></expr></argument>,
		                                   <argument><expr><name>Anum_pg_shdepend_deptype</name></expr></argument>,
		                                   <argument><expr><name>SHARED_DEPENDENCY_PIN</name></expr></argument>,
		                                   <argument><expr><name>YbFetchPinnedObjectKeyFromPgShdepend</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>regular</name> <operator>=</operator> <macro><name>YbBuildPinnedObjectCache</name><argument_list>(<argument><literal type="string">"Pinned objects cache"</literal></argument>,
		                                    <argument><literal type="number">6500</literal></argument>, <comment type="block">/* Number of pinned object is pg_depend 6179 */</comment>
		                                    <argument>DependRelationId</argument>,
		                                    <argument>Anum_pg_depend_deptype</argument>,
		                                    <argument>DEPENDENCY_PIN</argument>,
		                                    <argument>YbFetchPinnedObjectKeyFromPgDepend</argument>)</argument_list></macro></expr>}</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>YbPinnedObjectsCache</name> <operator>=</operator> <name>cache</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Build the cache in case it is not yet ready. */</comment>
<function><type><name>void</name></type>
<name>YbInitPinnedCacheIfNeeded</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Both 'regular' and 'shared' fields are set at same time.
	 * Checking any of them is enough.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>YbPinnedObjectsCache</name><operator>.</operator><name>regular</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>YbPinnedObjectsCache</name><operator>.</operator><name>shared</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>YbLoadPinnedObjectsCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>YbResetPinnedCache</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>YbPinnedObjectsCacheData</name></type> <name>cache</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>shared</name>  <operator>=</operator> <name>NULL</name></expr>,
		<expr><operator>.</operator><name>regular</name> <operator>=</operator> <name>NULL</name></expr>
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YbPinnedObjectsCacheData</name></type> <name>old_cache</name> <init>= <expr><name>YbPinnedObjectsCache</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>YbPinnedObjectsCache</name> <operator>=</operator> <name>cache</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>old_cache</name><operator>.</operator><name>regular</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>old_cache</name><operator>.</operator><name>shared</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name><name>old_cache</name><operator>.</operator><name>regular</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name><name>old_cache</name><operator>.</operator><name>shared</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>YbIsObjectPinned</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>classId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objectId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>shared_dependency</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>YbInitPinnedCacheIfNeeded</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>cache</name> <init>= <expr><ternary><condition><expr><name>shared_dependency</name></expr> ?</condition><then> <expr><name><name>YbPinnedObjectsCache</name><operator>.</operator><name>shared</name></name></expr>
									</then><else>: <expr><name><name>YbPinnedObjectsCache</name><operator>.</operator><name>regular</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YbPinnedObjectKey</name></type> <name>key</name> <init>= <expr><block>{<expr><operator>.</operator><name>classid</name> <operator>=</operator> <name>classId</name></expr>, <expr><operator>.</operator><name>objid</name> <operator>=</operator> <name>objectId</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>hash_search</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Pin a new object using YB pinned objects cache.
 */</comment>
<function><type><name>void</name></type>
<name>YbPinObjectIfNeeded</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>classId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objectId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>shared_dependency</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>cache</name> <init>= <expr><ternary><condition><expr><name>shared_dependency</name></expr> ?</condition><then> <expr><name><name>YbPinnedObjectsCache</name><operator>.</operator><name>shared</name></name></expr>
									</then><else>: <expr><name><name>YbPinnedObjectsCache</name><operator>.</operator><name>regular</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cache</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<decl_stmt><decl><type><name>YbPinnedObjectKey</name></type> <name>key</name> <init>= <expr><block>{<expr><operator>.</operator><name>classid</name> <operator>=</operator> <name>classId</name></expr>, <expr><operator>.</operator><name>objid</name> <operator>=</operator> <name>objectId</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * InitCatalogCache - initialize the caches
 *
 * Note that no database access is done here; we only allocate memory
 * and initialize the cache structure.  Interrogation of the database
 * to complete initialization of a cache happens upon first use
 * of that cache.
 */</comment>
<function><type><name>void</name></type>
<name>InitCatalogCache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>cacheId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>StaticAssertStmt</name><argument_list>(<argument><expr><name>SysCacheSize</name> <operator>==</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>cacheinfo</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><literal type="string">"SysCacheSize does not match syscache.c's array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>CacheInitialized</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>SysCacheRelationOidSize</name> <operator>=</operator> <name>SysCacheSupportingRelOidSize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>cacheId</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cacheId</name> <operator>&lt;</operator> <name>SysCacheSize</name></expr>;</condition> <incr><expr><name>cacheId</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>SysCache</name><index>[<expr><name>cacheId</name></expr>]</index></name> <operator>=</operator> <call><name>InitCatCache</name><argument_list>(<argument><expr><name>cacheId</name></expr></argument>,
										 <argument><expr><name><name>cacheinfo</name><index>[<expr><name>cacheId</name></expr>]</index></name><operator>.</operator><name>reloid</name></expr></argument>,
										 <argument><expr><name><name>cacheinfo</name><index>[<expr><name>cacheId</name></expr>]</index></name><operator>.</operator><name>indoid</name></expr></argument>,
										 <argument><expr><name><name>cacheinfo</name><index>[<expr><name>cacheId</name></expr>]</index></name><operator>.</operator><name>nkeys</name></expr></argument>,
										 <argument><expr><name><name>cacheinfo</name><index>[<expr><name>cacheId</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>,
										 <argument><expr><name><name>cacheinfo</name><index>[<expr><name>cacheId</name></expr>]</index></name><operator>.</operator><name>nbuckets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PointerIsValid</name><argument_list>(<argument><expr><name><name>SysCache</name><index>[<expr><name>cacheId</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not initialize cache %u (%d)"</literal></expr></argument>,
				 <argument><expr><name><name>cacheinfo</name><index>[<expr><name>cacheId</name></expr>]</index></name><operator>.</operator><name>reloid</name></expr></argument>, <argument><expr><name>cacheId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* Accumulate data for OID lists, too */</comment>
		<expr_stmt><expr><name><name>SysCacheRelationOid</name><index>[<expr><name>SysCacheRelationOidSize</name><operator>++</operator></expr>]</index></name> <operator>=</operator>
			<name><name>cacheinfo</name><index>[<expr><name>cacheId</name></expr>]</index></name><operator>.</operator><name>reloid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>SysCacheSupportingRelOid</name><index>[<expr><name>SysCacheSupportingRelOidSize</name><operator>++</operator></expr>]</index></name> <operator>=</operator>
			<name><name>cacheinfo</name><index>[<expr><name>cacheId</name></expr>]</index></name><operator>.</operator><name>reloid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>SysCacheSupportingRelOid</name><index>[<expr><name>SysCacheSupportingRelOidSize</name><operator>++</operator></expr>]</index></name> <operator>=</operator>
			<name><name>cacheinfo</name><index>[<expr><name>cacheId</name></expr>]</index></name><operator>.</operator><name>indoid</name></expr>;</expr_stmt>
		<comment type="block">/* see comments for RelationInvalidatesSnapshotsOnly */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>RelationInvalidatesSnapshotsOnly</name><argument_list>(<argument><expr><name><name>cacheinfo</name><index>[<expr><name>cacheId</name></expr>]</index></name><operator>.</operator><name>reloid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>SysCacheRelationOidSize</name> <operator>&lt;=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>SysCacheRelationOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>SysCacheSupportingRelOidSize</name> <operator>&lt;=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>SysCacheSupportingRelOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Sort and de-dup OID arrays, so we can use binary search. */</comment>
	<expr_stmt><expr><call><name>pg_qsort</name><argument_list>(<argument><expr><name>SysCacheRelationOid</name></expr></argument>, <argument><expr><name>SysCacheRelationOidSize</name></expr></argument>,
			 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>oid_compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr><operator>,</operator> <expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SysCacheRelationOidSize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>SysCacheRelationOid</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>SysCacheRelationOid</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>SysCacheRelationOid</name><index>[<expr><operator>++</operator><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>SysCacheRelationOid</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name>SysCacheRelationOidSize</name> <operator>=</operator> <name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_qsort</name><argument_list>(<argument><expr><name>SysCacheSupportingRelOid</name></expr></argument>, <argument><expr><name>SysCacheSupportingRelOidSize</name></expr></argument>,
			 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>oid_compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr><operator>,</operator> <expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SysCacheSupportingRelOidSize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>SysCacheSupportingRelOid</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>SysCacheSupportingRelOid</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>SysCacheSupportingRelOid</name><index>[<expr><operator>++</operator><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>SysCacheSupportingRelOid</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name>SysCacheSupportingRelOidSize</name> <operator>=</operator> <name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>CacheInitialized</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * InitCatalogCachePhase2 - finish initializing the caches
 *
 * Finish initializing all the caches, including necessary database
 * access.
 *
 * This is *not* essential; normally we allow syscaches to be initialized
 * on first use.  However, it is useful as a mechanism to preload the
 * relcache with entries for the most-commonly-used system catalogs.
 * Therefore, we invoke this routine when we need to write a new relcache
 * init file.
 */</comment>
<function><type><name>void</name></type>
<name>InitCatalogCachePhase2</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>cacheId</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CacheInitialized</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>cacheId</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cacheId</name> <operator>&lt;</operator> <name>SysCacheSize</name></expr>;</condition> <incr><expr><name>cacheId</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InitCatCachePhase2</name><argument_list>(<argument><expr><name><name>SysCache</name><index>[<expr><name>cacheId</name></expr>]</index></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
 * SearchSysCache
 *
 *	A layer on top of SearchCatCache that does the initialization and
 *	key-setting for you.
 *
 *	Returns the cache copy of the tuple if one is found, NULL if not.
 *	The tuple is the 'cache' copy and must NOT be modified!
 *
 *	When the caller is done using the tuple, call ReleaseSysCache()
 *	to release the reference count grabbed by SearchSysCache().  If this
 *	is not done, the tuple will remain locked in cache until end of
 *	transaction, which is tolerable but not desirable.
 *
 *	CAUTION: The tuple that is returned must NOT be freed by the caller!
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>SearchSysCache</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>cacheId</name></decl></parameter>,
			   <parameter><decl><type><name>Datum</name></type> <name>key1</name></decl></parameter>,
			   <parameter><decl><type><name>Datum</name></type> <name>key2</name></decl></parameter>,
			   <parameter><decl><type><name>Datum</name></type> <name>key3</name></decl></parameter>,
			   <parameter><decl><type><name>Datum</name></type> <name>key4</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cacheId</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>cacheId</name> <operator>&lt;</operator> <name>SysCacheSize</name> <operator>&amp;&amp;</operator>
		   <call><name>PointerIsValid</name><argument_list>(<argument><expr><name><name>SysCache</name><index>[<expr><name>cacheId</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>SearchCatCache</name><argument_list>(<argument><expr><name><name>SysCache</name><index>[<expr><name>cacheId</name></expr>]</index></name></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>, <argument><expr><name>key3</name></expr></argument>, <argument><expr><name>key4</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>HeapTuple</name></type>
<name>SearchSysCache1</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>cacheId</name></decl></parameter>,
				<parameter><decl><type><name>Datum</name></type> <name>key1</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cacheId</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>cacheId</name> <operator>&lt;</operator> <name>SysCacheSize</name> <operator>&amp;&amp;</operator>
		   <call><name>PointerIsValid</name><argument_list>(<argument><expr><name><name>SysCache</name><index>[<expr><name>cacheId</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>SysCache</name><index>[<expr><name>cacheId</name></expr>]</index></name><operator>-&gt;</operator><name>cc_nkeys</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>SearchCatCache1</name><argument_list>(<argument><expr><name><name>SysCache</name><index>[<expr><name>cacheId</name></expr>]</index></name></expr></argument>, <argument><expr><name>key1</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>HeapTuple</name></type>
<name>SearchSysCache2</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>cacheId</name></decl></parameter>,
				<parameter><decl><type><name>Datum</name></type> <name>key1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>key2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cacheId</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>cacheId</name> <operator>&lt;</operator> <name>SysCacheSize</name> <operator>&amp;&amp;</operator>
		   <call><name>PointerIsValid</name><argument_list>(<argument><expr><name><name>SysCache</name><index>[<expr><name>cacheId</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>SysCache</name><index>[<expr><name>cacheId</name></expr>]</index></name><operator>-&gt;</operator><name>cc_nkeys</name> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>SearchCatCache2</name><argument_list>(<argument><expr><name><name>SysCache</name><index>[<expr><name>cacheId</name></expr>]</index></name></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>HeapTuple</name></type>
<name>SearchSysCache3</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>cacheId</name></decl></parameter>,
				<parameter><decl><type><name>Datum</name></type> <name>key1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>key2</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>key3</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cacheId</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>cacheId</name> <operator>&lt;</operator> <name>SysCacheSize</name> <operator>&amp;&amp;</operator>
		   <call><name>PointerIsValid</name><argument_list>(<argument><expr><name><name>SysCache</name><index>[<expr><name>cacheId</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>SysCache</name><index>[<expr><name>cacheId</name></expr>]</index></name><operator>-&gt;</operator><name>cc_nkeys</name> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>SearchCatCache3</name><argument_list>(<argument><expr><name><name>SysCache</name><index>[<expr><name>cacheId</name></expr>]</index></name></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>, <argument><expr><name>key3</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>HeapTuple</name></type>
<name>SearchSysCache4</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>cacheId</name></decl></parameter>,
				<parameter><decl><type><name>Datum</name></type> <name>key1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>key2</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>key3</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>key4</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cacheId</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>cacheId</name> <operator>&lt;</operator> <name>SysCacheSize</name> <operator>&amp;&amp;</operator>
		   <call><name>PointerIsValid</name><argument_list>(<argument><expr><name><name>SysCache</name><index>[<expr><name>cacheId</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>SysCache</name><index>[<expr><name>cacheId</name></expr>]</index></name><operator>-&gt;</operator><name>cc_nkeys</name> <operator>==</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>SearchCatCache4</name><argument_list>(<argument><expr><name><name>SysCache</name><index>[<expr><name>cacheId</name></expr>]</index></name></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>, <argument><expr><name>key3</name></expr></argument>, <argument><expr><name>key4</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ReleaseSysCache
 *		Release previously grabbed reference count on a tuple
 */</comment>
<function><type><name>void</name></type>
<name>ReleaseSysCache</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ReleaseCatCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SearchSysCacheCopy
 *
 * A convenience routine that does SearchSysCache and (if successful)
 * returns a modifiable copy of the syscache entry.  The original
 * syscache entry is released before returning.  The caller should
 * heap_freetuple() the result when done with it.
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>SearchSysCacheCopy</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>cacheId</name></decl></parameter>,
				   <parameter><decl><type><name>Datum</name></type> <name>key1</name></decl></parameter>,
				   <parameter><decl><type><name>Datum</name></type> <name>key2</name></decl></parameter>,
				   <parameter><decl><type><name>Datum</name></type> <name>key3</name></decl></parameter>,
				   <parameter><decl><type><name>Datum</name></type> <name>key4</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>,
				<decl><type ref="prev"/><name>newtuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache</name><argument_list>(<argument><expr><name>cacheId</name></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>, <argument><expr><name>key3</name></expr></argument>, <argument><expr><name>key4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>tuple</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>newtuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SearchSysCacheExists
 *
 * A convenience routine that just probes to see if a tuple can be found.
 * No lock is retained on the syscache entry.
 */</comment>
<function><type><name>bool</name></type>
<name>SearchSysCacheExists</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>cacheId</name></decl></parameter>,
					 <parameter><decl><type><name>Datum</name></type> <name>key1</name></decl></parameter>,
					 <parameter><decl><type><name>Datum</name></type> <name>key2</name></decl></parameter>,
					 <parameter><decl><type><name>Datum</name></type> <name>key3</name></decl></parameter>,
					 <parameter><decl><type><name>Datum</name></type> <name>key4</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache</name><argument_list>(<argument><expr><name>cacheId</name></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>, <argument><expr><name>key3</name></expr></argument>, <argument><expr><name>key4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetSysCacheOid
 *
 * A convenience routine that does SearchSysCache and returns the OID
 * of the found tuple, or InvalidOid if no tuple could be found.
 * No lock is retained on the syscache entry.
 */</comment>
<function><type><name>Oid</name></type>
<name>GetSysCacheOid</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>cacheId</name></decl></parameter>,
			   <parameter><decl><type><name>Datum</name></type> <name>key1</name></decl></parameter>,
			   <parameter><decl><type><name>Datum</name></type> <name>key2</name></decl></parameter>,
			   <parameter><decl><type><name>Datum</name></type> <name>key3</name></decl></parameter>,
			   <parameter><decl><type><name>Datum</name></type> <name>key4</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache</name><argument_list>(<argument><expr><name>cacheId</name></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>, <argument><expr><name>key3</name></expr></argument>, <argument><expr><name>key4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SearchSysCacheAttName
 *
 * This routine is equivalent to SearchSysCache on the ATTNAME cache,
 * except that it will return NULL if the found attribute is marked
 * attisdropped.  This is convenient for callers that want to act as
 * though dropped attributes don't exist.
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>SearchSysCacheAttName</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>ATTNAME</name></expr></argument>,
							<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SearchSysCacheCopyAttName
 *
 * As above, an attisdropped-aware version of SearchSysCacheCopy.
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>SearchSysCacheCopyAttName</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>,
				<decl><type ref="prev"/><name>newtuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>tuple</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>newtuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SearchSysCacheExistsAttName
 *
 * As above, an attisdropped-aware version of SearchSysCacheExists.
 */</comment>
<function><type><name>bool</name></type>
<name>SearchSysCacheExistsAttName</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SearchSysCacheAttNum
 *
 * This routine is equivalent to SearchSysCache on the ATTNUM cache,
 * except that it will return NULL if the found attribute is marked
 * attisdropped.  This is convenient for callers that want to act as
 * though dropped attributes don't exist.
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>SearchSysCacheAttNum</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>ATTNUM</name></expr></argument>,
							<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SearchSysCacheCopyAttNum
 *
 * As above, an attisdropped-aware version of SearchSysCacheCopy.
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>SearchSysCacheCopyAttNum</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>,
				<decl><type ref="prev"/><name>newtuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheAttNum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>newtuple</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SysCacheGetAttr
 *
 *		Given a tuple previously fetched by SearchSysCache(),
 *		extract a specific attribute.
 *
 * This is equivalent to using heap_getattr() on a tuple fetched
 * from a non-cached relation.  Usually, this is only used for attributes
 * that could be NULL or variable length; the fixed-size attributes in
 * a system table are accessed just by mapping the tuple onto the C struct
 * declarations from include/catalog/.
 *
 * As with heap_getattr(), if the attribute is of a pass-by-reference type
 * then a pointer into the tuple data area is returned --- the caller must
 * not modify or pfree the datum!
 *
 * Note: it is legal to use SysCacheGetAttr() with a cacheId referencing
 * a different cache for the same catalog the tuple was fetched from.
 */</comment>
<function><type><name>Datum</name></type>
<name>SysCacheGetAttr</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>cacheId</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>,
				<parameter><decl><type><name>AttrNumber</name></type> <name>attributeNumber</name></decl></parameter>,
				<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We just need to get the TupleDesc out of the cache entry, and then we
	 * can apply heap_getattr().  Normally the cache control data is already
	 * valid (because the caller recently fetched the tuple via this same
	 * cache), but there are cases where we have to initialize the cache here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>cacheId</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>cacheId</name> <operator>&gt;=</operator> <name>SysCacheSize</name> <operator>||</operator>
		<operator>!</operator><call><name>PointerIsValid</name><argument_list>(<argument><expr><name><name>SysCache</name><index>[<expr><name>cacheId</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid cache ID: %d"</literal></expr></argument>, <argument><expr><name>cacheId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PointerIsValid</name><argument_list>(<argument><expr><name><name>SysCache</name><index>[<expr><name>cacheId</name></expr>]</index></name><operator>-&gt;</operator><name>cc_tupdesc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>InitCatCachePhase2</name><argument_list>(<argument><expr><name><name>SysCache</name><index>[<expr><name>cacheId</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name><name>SysCache</name><index>[<expr><name>cacheId</name></expr>]</index></name><operator>-&gt;</operator><name>cc_tupdesc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>heap_getattr</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><name>attributeNumber</name></expr></argument>,
						<argument><expr><name><name>SysCache</name><index>[<expr><name>cacheId</name></expr>]</index></name><operator>-&gt;</operator><name>cc_tupdesc</name></expr></argument>,
						<argument><expr><name>isNull</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetSysCacheHashValue
 *
 * Get the hash value that would be used for a tuple in the specified cache
 * with the given search keys.
 *
 * The reason for exposing this as part of the API is that the hash value is
 * exposed in cache invalidation operations, so there are places outside the
 * catcache code that need to be able to compute the hash values.
 */</comment>
<function><type><name>uint32</name></type>
<name>GetSysCacheHashValue</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>cacheId</name></decl></parameter>,
					 <parameter><decl><type><name>Datum</name></type> <name>key1</name></decl></parameter>,
					 <parameter><decl><type><name>Datum</name></type> <name>key2</name></decl></parameter>,
					 <parameter><decl><type><name>Datum</name></type> <name>key3</name></decl></parameter>,
					 <parameter><decl><type><name>Datum</name></type> <name>key4</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>cacheId</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>cacheId</name> <operator>&gt;=</operator> <name>SysCacheSize</name> <operator>||</operator>
		<operator>!</operator><call><name>PointerIsValid</name><argument_list>(<argument><expr><name><name>SysCache</name><index>[<expr><name>cacheId</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid cache ID: %d"</literal></expr></argument>, <argument><expr><name>cacheId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>GetCatCacheHashValue</name><argument_list>(<argument><expr><name><name>SysCache</name><index>[<expr><name>cacheId</name></expr>]</index></name></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>, <argument><expr><name>key3</name></expr></argument>, <argument><expr><name>key4</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * List-search interface
 */</comment>
<function><type><name><name>struct</name> <name>catclist</name></name> <modifier>*</modifier></type>
<name>SearchSysCacheList</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>cacheId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>,
				   <parameter><decl><type><name>Datum</name></type> <name>key1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>key2</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>key3</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>cacheId</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>cacheId</name> <operator>&gt;=</operator> <name>SysCacheSize</name> <operator>||</operator>
		<operator>!</operator><call><name>PointerIsValid</name><argument_list>(<argument><expr><name><name>SysCache</name><index>[<expr><name>cacheId</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid cache ID: %d"</literal></expr></argument>, <argument><expr><name>cacheId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>SearchCatCacheList</name><argument_list>(<argument><expr><name><name>SysCache</name><index>[<expr><name>cacheId</name></expr>]</index></name></expr></argument>, <argument><expr><name>nkeys</name></expr></argument>,
							  <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>, <argument><expr><name>key3</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SysCacheInvalidate
 *
 *	Invalidate entries in the specified cache, given a hash value.
 *	See CatCacheInvalidate() for more info.
 *
 *	This routine is only quasi-public: it should only be used by inval.c.
 */</comment>
<function><type><name>void</name></type>
<name>SysCacheInvalidate</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>cacheId</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashValue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>cacheId</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>cacheId</name> <operator>&gt;=</operator> <name>SysCacheSize</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid cache ID: %d"</literal></expr></argument>, <argument><expr><name>cacheId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* if this cache isn't initialized yet, no need to do anything */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PointerIsValid</name><argument_list>(<argument><expr><name><name>SysCache</name><index>[<expr><name>cacheId</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>CatCacheInvalidate</name><argument_list>(<argument><expr><name><name>SysCache</name><index>[<expr><name>cacheId</name></expr>]</index></name></expr></argument>, <argument><expr><name>hashValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Certain relations that do not have system caches send snapshot invalidation
 * messages in lieu of catcache messages.  This is for the benefit of
 * GetCatalogSnapshot(), which can then reuse its existing MVCC snapshot
 * for scanning one of those catalogs, rather than taking a new one, if no
 * invalidation has been received.
 *
 * Relations that have syscaches need not (and must not) be listed here.  The
 * catcache invalidation messages will also flush the snapshot.  If you add a
 * syscache for one of these relations, remove it from this list.
 */</comment>
<function><type><name>bool</name></type>
<name>RelationInvalidatesSnapshotsOnly</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>relid</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DbRoleSettingRelationId</name></expr>:</case>
		<case>case <expr><name>DependRelationId</name></expr>:</case>
		<case>case <expr><name>SharedDependRelationId</name></expr>:</case>
		<case>case <expr><name>DescriptionRelationId</name></expr>:</case>
		<case>case <expr><name>SharedDescriptionRelationId</name></expr>:</case>
		<case>case <expr><name>SecLabelRelationId</name></expr>:</case>
		<case>case <expr><name>SharedSecLabelRelationId</name></expr>:</case>
			<return>return <expr><name>true</name></expr>;</return>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Test whether a relation has a system cache.
 */</comment>
<function><type><name>bool</name></type>
<name>RelationHasSysCache</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>low</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>high</name> <init>= <expr><name>SysCacheRelationOidSize</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>low</name> <operator>&lt;=</operator> <name>high</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>middle</name> <init>= <expr><name>low</name> <operator>+</operator> <operator>(</operator><name>high</name> <operator>-</operator> <name>low</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>SysCacheRelationOid</name><index>[<expr><name>middle</name></expr>]</index></name> <operator>==</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>SysCacheRelationOid</name><index>[<expr><name>middle</name></expr>]</index></name> <operator>&lt;</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>low</name> <operator>=</operator> <name>middle</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>high</name> <operator>=</operator> <name>middle</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Test whether a relation supports a system cache, ie it is either a
 * cached table or the index used for a cache.
 */</comment>
<function><type><name>bool</name></type>
<name>RelationSupportsSysCache</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>low</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>high</name> <init>= <expr><name>SysCacheSupportingRelOidSize</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>low</name> <operator>&lt;=</operator> <name>high</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>middle</name> <init>= <expr><name>low</name> <operator>+</operator> <operator>(</operator><name>high</name> <operator>-</operator> <name>low</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>SysCacheSupportingRelOid</name><index>[<expr><name>middle</name></expr>]</index></name> <operator>==</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>SysCacheSupportingRelOid</name><index>[<expr><name>middle</name></expr>]</index></name> <operator>&lt;</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>low</name> <operator>=</operator> <name>middle</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>high</name> <operator>=</operator> <name>middle</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * OID comparator for pg_qsort
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>oid_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oa</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Oid</name> <operator>*</operator><operator>)</operator> <name>a</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ob</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Oid</name> <operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>oa</name> <operator>==</operator> <name>ob</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><ternary><condition><expr><operator>(</operator><name>oa</name> <operator>&gt;</operator> <name>ob</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
</unit>
