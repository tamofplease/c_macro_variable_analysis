<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/utils/cache/relcache.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * relcache.c
 *	  POSTGRES relation descriptor cache code
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/utils/cache/relcache.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<comment type="block">/*
 * INTERFACE ROUTINES
 *		RelationCacheInitialize			- initialize relcache (to empty)
 *		RelationCacheInitializePhase2	- initialize shared-catalog entries
 *		RelationCacheInitializePhase3	- finish initializing relcache
 *		RelationIdGetRelation			- get a reldesc by relation id
 *		RelationClose					- close an open relation
 *
 * NOTES
 *		The following code contains many undocumented hacks.  Please be
 *		careful....
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/file.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/multixact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/reloptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupdesc_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/partition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_amproc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_attrdef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_auth_members.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_database.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opclass.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_partitioned_table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_policy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_publication.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_rewrite.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_shseclabel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_statistic_ext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_subscription.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/schemapg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/storage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/yb_catalog_version.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/policy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/prep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/var.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning/partbounds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteDefine.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rowsecurity.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/partcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relmapper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resowner_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_yb_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/yb_scan.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RELCACHE_INIT_FILEMAGIC</name></cpp:macro>		<cpp:value>0x573266</cpp:value></cpp:define>	<comment type="block">/* version ID value */</comment>

<comment type="block">/*
 *		hardcoded tuple descriptors, contents generated by genbki.pl
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>FormData_pg_attribute</name></type> <name><name>Desc_pg_class</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name> <init>= <expr><block>{<expr><name>Schema_pg_class</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>FormData_pg_attribute</name></type> <name><name>Desc_pg_attribute</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name> <init>= <expr><block>{<expr><name>Schema_pg_attribute</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>FormData_pg_attribute</name></type> <name><name>Desc_pg_proc</name><index>[<expr><name>Natts_pg_proc</name></expr>]</index></name> <init>= <expr><block>{<expr><name>Schema_pg_proc</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>FormData_pg_attribute</name></type> <name><name>Desc_pg_type</name><index>[<expr><name>Natts_pg_type</name></expr>]</index></name> <init>= <expr><block>{<expr><name>Schema_pg_type</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>FormData_pg_attribute</name></type> <name><name>Desc_pg_database</name><index>[<expr><name>Natts_pg_database</name></expr>]</index></name> <init>= <expr><block>{<expr><name>Schema_pg_database</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>FormData_pg_attribute</name></type> <name><name>Desc_pg_authid</name><index>[<expr><name>Natts_pg_authid</name></expr>]</index></name> <init>= <expr><block>{<expr><name>Schema_pg_authid</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>FormData_pg_attribute</name></type> <name><name>Desc_pg_auth_members</name><index>[<expr><name>Natts_pg_auth_members</name></expr>]</index></name> <init>= <expr><block>{<expr><name>Schema_pg_auth_members</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>FormData_pg_attribute</name></type> <name><name>Desc_pg_index</name><index>[<expr><name>Natts_pg_index</name></expr>]</index></name> <init>= <expr><block>{<expr><name>Schema_pg_index</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>FormData_pg_attribute</name></type> <name><name>Desc_pg_shseclabel</name><index>[<expr><name>Natts_pg_shseclabel</name></expr>]</index></name> <init>= <expr><block>{<expr><name>Schema_pg_shseclabel</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>FormData_pg_attribute</name></type> <name><name>Desc_pg_subscription</name><index>[<expr><name>Natts_pg_subscription</name></expr>]</index></name> <init>= <expr><block>{<expr><name>Schema_pg_subscription</name></expr>}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 *		Hash tables that index the relation cache
 *
 *		We used to index the cache by both name and OID, but now there
 *		is only an index by OID.
 */</comment>
<typedef>typedef <type><struct>struct <name>relidcacheent</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>reloid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>reldesc</name></decl>;</decl_stmt>
}</block></struct></type> <name>RelIdCacheEnt</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>RelationIdCache</name></decl>;</decl_stmt>

<comment type="block">/*
 * This flag is false until we have prepared the critical relcache entries
 * that are needed to do indexscans on the tables read by relcache building.
 */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>criticalRelcachesBuilt</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * This flag is false until we have prepared the critical relcache entries
 * for shared catalogs (which are the tables needed for login).
 */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>criticalSharedRelcachesBuilt</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * This counter counts relcache inval events received since backend startup
 * (but only for rels that are actually in cache).  Presently, we use it only
 * to detect whether data about to be written by write_relcache_init_file()
 * might already be obsolete.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>relcacheInvalsReceived</name> <init>= <expr><literal type="number">0L</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * eoxact_list[] stores the OIDs of relations that (might) need AtEOXact
 * cleanup work.  This list intentionally has limited size; if it overflows,
 * we fall back to scanning the whole hashtable.  There is no value in a very
 * large list because (1) at some point, a hash_seq_search scan is faster than
 * retail lookups, and (2) the value of this is to reduce EOXact work for
 * short transactions, which can't have dirtied all that many tables anyway.
 * EOXactListAdd() does not bother to prevent duplicate list entries, so the
 * cleanup processing must be idempotent.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_EOXACT_LIST</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type>	<name><name>eoxact_list</name><index>[<expr><name>MAX_EOXACT_LIST</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>eoxact_list_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>eoxact_list_overflowed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EOXactListAdd</name><parameter_list>(<parameter><type><name>rel</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		if (eoxact_list_len &lt; MAX_EOXACT_LIST) \
			eoxact_list[eoxact_list_len++] = (rel)-&gt;rd_id; \
		else \
			eoxact_list_overflowed = true; \
	} while (0)</cpp:value></cpp:define>

<comment type="block">/*
 * EOXactTupleDescArray stores TupleDescs that (might) need AtEOXact
 * cleanup work.  The array expands as needed; there is no hashtable because
 * we don't need to access individual items except at EOXact.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>TupleDesc</name> <modifier>*</modifier></type><name>EOXactTupleDescArray</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>NextEOXactTupleDescNum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>EOXactTupleDescArrayLen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 *		macros to manipulate the lookup hashtable
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RelationCacheInsert</name><parameter_list>(<parameter><type><name>RELATION</name></type></parameter>, <parameter><type><name>replace_allowed</name></type></parameter>)</parameter_list></cpp:macro>	\
<cpp:value>do { \
	RelIdCacheEnt *hentry; bool found; \
	hentry = (RelIdCacheEnt *) hash_search(RelationIdCache, \
										   (void *) &amp;((RELATION)-&gt;rd_id), \
										   HASH_ENTER, &amp;found); \
	if (found) \
	{ \
		<comment type="block">/* see comments in RelationBuildDesc and RelationBuildLocalRelation */</comment> \
		Relation _old_rel = hentry-&gt;reldesc; \
		Assert(replace_allowed); \
		hentry-&gt;reldesc = (RELATION); \
		if (RelationHasReferenceCountZero(_old_rel)) \
			RelationDestroyRelation(_old_rel, false); \
		else if (!IsBootstrapProcessingMode()) \
			elog(WARNING, "leaking still-referenced relcache entry for \"%s\"", \
				 RelationGetRelationName(_old_rel)); \
	} \
	else \
		hentry-&gt;reldesc = (RELATION); \
} while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RelationIdCacheLookup</name><parameter_list>(<parameter><type><name>ID</name></type></parameter>, <parameter><type><name>RELATION</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do { \
	RelIdCacheEnt *hentry; \
	hentry = (RelIdCacheEnt *) hash_search(RelationIdCache, \
										   (void *) &amp;(ID), \
										   HASH_FIND, NULL); \
	if (hentry) \
		RELATION = hentry-&gt;reldesc; \
	else \
		RELATION = NULL; \
} while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RelationCacheDelete</name><parameter_list>(<parameter><type><name>RELATION</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do { \
	RelIdCacheEnt *hentry; \
	hentry = (RelIdCacheEnt *) hash_search(RelationIdCache, \
										   (void *) &amp;((RELATION)-&gt;rd_id), \
										   HASH_REMOVE, NULL); \
	if (hentry == NULL) \
		elog(WARNING, "failed to delete relcache entry for OID %u", \
			 (RELATION)-&gt;rd_id); \
} while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RelCacheInitFileName</name><parameter_list>(<parameter><type><name>filename</name></type></parameter>, <parameter><type><name>shared</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do { \
	if (shared) \
	{ \
		snprintf(filename, sizeof(filename), "global/%s", \
				 RELCACHE_INIT_FILENAME); \
	} \
	else \
	{ \
		if (IsYugaByteEnabled()) \
		{ \
			snprintf(filename, sizeof(filename), "%d_%s", \
			         MyDatabaseId, RELCACHE_INIT_FILENAME); \
		} \
		else \
		{ \
			snprintf(filename, sizeof(filename), "%s/%s", \
			         DatabasePath, RELCACHE_INIT_FILENAME); \
		} \
	} \
} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RelCacheInitTempFileName</name><parameter_list>(<parameter><type><name>filename</name></type></parameter>, <parameter><type><name>shared</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do { \
	if (shared) \
	{ \
		snprintf(filename, sizeof(filename), "global/%s.%d", \
		         RELCACHE_INIT_FILENAME, MyProcPid); \
	} \
	else \
	{ \
		if (IsYugaByteEnabled()) \
		{ \
			snprintf(filename, sizeof(filename), "%d_%s.%d", \
			         MyDatabaseId, RELCACHE_INIT_FILENAME, MyProcPid); \
		} \
		else \
		{ \
			snprintf(filename, sizeof(filename), "%s/%s.%d", \
			         DatabasePath, RELCACHE_INIT_FILENAME, MyProcPid); \
		} \
	} \
} while (0)</cpp:value></cpp:define>


<comment type="block">/*
 * Special cache for opclass-related information
 *
 * Note: only default support procs get cached, ie, those with
 * lefttype = righttype = opcintype.
 */</comment>
<typedef>typedef <type><struct>struct <name>opclasscacheent</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opclassoid</name></decl>;</decl_stmt>		<comment type="block">/* lookup key: OID of opclass */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>valid</name></decl>;</decl_stmt>			<comment type="block">/* set true after successful fill-in */</comment>
	<decl_stmt><decl><type><name>StrategyNumber</name></type> <name>numSupport</name></decl>;</decl_stmt>	<comment type="block">/* max # of support procs (from pg_am) */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opcfamily</name></decl>;</decl_stmt>		<comment type="block">/* OID of opclass's family */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opcintype</name></decl>;</decl_stmt>		<comment type="block">/* OID of opclass's declared input type */</comment>
	<decl_stmt><decl><type><name>RegProcedure</name> <modifier>*</modifier></type><name>supportProcs</name></decl>;</decl_stmt> <comment type="block">/* OIDs of support procedures */</comment>
}</block></struct></type> <name>OpClassCacheEnt</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>OpClassCache</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<comment type="block">/* non-export function prototypes */</comment>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RelationDestroyRelation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>remember_tupdesc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RelationClearRelation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>rebuild</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RelationReloadIndexInfo</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RelationReloadNailed</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RelationFlushRelation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RememberToFreeTupleDescAtEOX</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>td</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AtEOXact_cleanup</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AtEOSubXact_cleanup</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>,
					<parameter><decl><type><name>SubTransactionId</name></type> <name>mySubid</name></decl></parameter>, <parameter><decl><type><name>SubTransactionId</name></type> <name>parentSubid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>load_relcache_init_file</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>shared</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>write_relcache_init_file</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>shared</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>write_item</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>formrdesc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relationName</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationReltype</name></decl></parameter>,
		  <parameter><decl><type><name>bool</name></type> <name>isshared</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>hasoids</name></decl></parameter>,
		  <parameter><decl><type><name>int</name></type> <name>natts</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FormData_pg_attribute</name> <modifier>*</modifier></type><name>attrs</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>HeapTuple</name></type> <name>ScanPgRelation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>targetRelId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>indexOK</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force_non_historic</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Relation</name></type> <name>AllocateRelationDesc</name><parameter_list>(<parameter><decl><type><name>Form_pg_class</name></type> <name>relp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RelationParseRelOptions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RelationBuildTupleDesc</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Relation</name></type> <name>RelationBuildDesc</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>targetRelId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>insertIt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RelationInitPhysicalAddr</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>load_critical_index</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>heapoid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleDesc</name></type> <name>GetPgClassDescriptor</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleDesc</name></type> <name>GetPgIndexDescriptor</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AttrDefaultFetch</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CheckConstraintFetch</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>CheckConstraintCmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>insert_ordered_oid</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>datum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InitIndexAmRoutine</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>IndexSupportInitialize</name><parameter_list>(<parameter><decl><type><name>oidvector</name> <modifier>*</modifier></type><name>indclass</name></decl></parameter>,
					   <parameter><decl><type><name>RegProcedure</name> <modifier>*</modifier></type><name>indexSupport</name></decl></parameter>,
					   <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>opFamily</name></decl></parameter>,
					   <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>opcInType</name></decl></parameter>,
					   <parameter><decl><type><name>StrategyNumber</name></type> <name>maxSupportNumber</name></decl></parameter>,
					   <parameter><decl><type><name>AttrNumber</name></type> <name>maxAttributeNumber</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>OpClassCacheEnt</name> <modifier>*</modifier></type><name>LookupOpclassInfo</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>operatorClassOid</name></decl></parameter>,
				  <parameter><decl><type><name>StrategyNumber</name></type> <name>numSupport</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RelationCacheInitFileRemoveInDir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tblspcpath</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>unlink_initfile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>initfilename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>equalPartitionDescs</name><parameter_list>(<parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>PartitionDesc</name></type> <name>partdesc1</name></decl></parameter>,
					<parameter><decl><type><name>PartitionDesc</name></type> <name>partdesc2</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 *		ScanPgRelation
 *
 *		This is used by RelationBuildDesc to find a pg_class
 *		tuple matching targetRelId.  The caller must hold at least
 *		AccessShareLock on the target relid to prevent concurrent-update
 *		scenarios; it isn't guaranteed that all scans used to build the
 *		relcache entry will use the same snapshot.  If, for example,
 *		an attribute were to be added after scanning pg_class and before
 *		scanning pg_attribute, relnatts wouldn't match.
 *
 *		NB: the returned tuple has been copied into palloc'd storage
 *		and must eventually be freed with heap_freetuple.
 */</comment>
<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>ScanPgRelation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>targetRelId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>indexOK</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force_non_historic</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>pg_class_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_class_desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>pg_class_scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If something goes wrong during backend startup, we might find ourselves
	 * trying to read pg_class before we've selected a database.  That ain't
	 * gonna work, so bail out with a useful error message.  If this happens,
	 * it probably means a relcache entry that needs to be nailed isn't.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"cannot read pg_class without having selected a database"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * form a scan key
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>ObjectIdAttributeNumber</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>targetRelId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Open pg_class and fetch a tuple.  Force heap scan if we haven't yet
	 * built the critical relcache entries (this includes initdb and startup
	 * without a pg_internal.init file).  The caller can also force a heap
	 * scan by setting indexOK == false.
	 */</comment>
	<expr_stmt><expr><name>pg_class_desc</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The caller might need a tuple that's newer than the one the historic
	 * snapshot; currently the only case requiring to do so is looking up the
	 * relfilenode of non mapped system relations during decoding.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>force_non_historic</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>GetNonHistoricCatalogSnapshot</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>GetCatalogSnapshot</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>pg_class_scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_class_desc</name></expr></argument>, <argument><expr><name>ClassOidIndexId</name></expr></argument>,
	                                   <argument><expr><name>indexOK</name> <operator>&amp;&amp;</operator> <name>criticalRelcachesBuilt</name></expr></argument>,
	                                   <argument><expr><name>snapshot</name></expr></argument>,
	                                   <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pg_class_tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>pg_class_scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Must copy tuple before releasing buffer.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>pg_class_tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>pg_class_tuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>pg_class_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* all done */</comment>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>pg_class_scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_class_desc</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>pg_class_tuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		AllocateRelationDesc
 *
 *		This is used to allocate memory for a new relation descriptor
 *		and initialize the rd_rel field from the given pg_class tuple.
 */</comment>
<function><type><specifier>static</specifier> <name>Relation</name></type>
<name>AllocateRelationDesc</name><parameter_list>(<parameter><decl><type><name>Form_pg_class</name></type> <name>relp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>relationForm</name></decl>;</decl_stmt>

	<comment type="block">/* Relcache entries must live in CacheMemoryContext */</comment>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * allocate and zero space for new relation descriptor
	 */</comment>
	<expr_stmt><expr><name>relation</name> <operator>=</operator> <operator>(</operator><name>Relation</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelationData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* make sure relation is marked as having no open file yet */</comment>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_smgr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* YB properties will be loaded lazily */</comment>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>yb_table_properties</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy the relation tuple form
	 *
	 * We only allocate space for the fixed fields, ie, CLASS_TUPLE_SIZE. The
	 * variable-length fields (relacl, reloptions) are NOT stored in the
	 * relcache --- there'd be little point in it, since we don't copy the
	 * tuple's nulls bitmap and hence wouldn't know if the values are valid.
	 * Bottom line is that relacl *cannot* be retrieved from the relcache. Get
	 * it from the syscache if you need it.  The same goes for the original
	 * form of reloptions (however, we do store the parsed form of reloptions
	 * in rd_options).
	 */</comment>
	<expr_stmt><expr><name>relationForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>CLASS_TUPLE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>relationForm</name></expr></argument>, <argument><expr><name>relp</name></expr></argument>, <argument><expr><name>CLASS_TUPLE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* initialize relation tuple form */</comment>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name></name> <operator>=</operator> <name>relationForm</name></expr>;</expr_stmt>

	<comment type="block">/* and allocate attribute tuple form storage */</comment>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name></name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name><name>relationForm</name><operator>-&gt;</operator><name>relnatts</name></name></expr></argument>,
											   <argument><expr><name><name>relationForm</name><operator>-&gt;</operator><name>relhasoids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* which we mark as a reference-counted tupdesc */</comment>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>tdrefcount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>relation</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RelationParseRelOptions
 *		Convert pg_class.reloptions into pre-parsed rd_options
 *
 * tuple is the real pg_class tuple (not rd_rel!) for relation
 *
 * Note: rd_rel and (if an index) rd_amroutine must be valid already
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RelationParseRelOptions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>options</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>amoptions_function</name></type> <name>amoptsfn</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_options</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Look up any AM-specific parse function; fall out if relkind should not
	 * have options.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RELKIND_RELATION</name></expr>:</case>
		<case>case <expr><name>RELKIND_TOASTVALUE</name></expr>:</case>
		<case>case <expr><name>RELKIND_VIEW</name></expr>:</case>
		<case>case <expr><name>RELKIND_MATVIEW</name></expr>:</case>
		<case>case <expr><name>RELKIND_PARTITIONED_TABLE</name></expr>:</case>
			<expr_stmt><expr><name>amoptsfn</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_INDEX</name></expr>:</case>
		<case>case <expr><name>RELKIND_PARTITIONED_INDEX</name></expr>:</case>
			<expr_stmt><expr><name>amoptsfn</name> <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_amroutine</name><operator>-&gt;</operator><name>amoptions</name></name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<return>return;</return>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Fetch reloptions from tuple; have to use a hardwired descriptor because
	 * we might not have any other for pg_class yet (consider executing this
	 * code for pg_class itself)
	 */</comment>
	<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>extractRelOptions</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>GetPgClassDescriptor</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>amoptsfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy parsed data into CacheMemoryContext.  To guard against the
	 * possibility of leaks in the reloptions code, we want to do the actual
	 * parsing in the caller's memory context and copy the results into
	 * CacheMemoryContext after the fact.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>options</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_options</name></name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>,
												  <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_options</name></name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		RelationBuildTupleDesc
 *
 *		Form the relation's tuple descriptor from information in
 *		the pg_attribute, pg_attrdef &amp; pg_constraint system catalogs.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RelationBuildTupleDesc</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>pg_attribute_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_attribute_desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>pg_attribute_scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>need</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleConstr</name> <modifier>*</modifier></type><name>constr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrDefault</name> <modifier>*</modifier></type><name>attrdef</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrMissing</name> <modifier>*</modifier></type><name>attrmiss</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndef</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* copy some fields from pg_class row to rd_att */</comment>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>tdtypeid</name></name> <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>tdtypmod</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* unnecessary, but... */</comment>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>tdhasoid</name></name> <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>constr</name> <operator>=</operator> <operator>(</operator><name>TupleConstr</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>,
												<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TupleConstr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>has_not_null</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Form a scan key that selects only user attributes (attnum &gt; 0).
	 * (Eliminating system attribute rows at the index level is lots faster
	 * than fetching them.)
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_attribute_attrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_attribute_attnum</name></expr></argument>,
				<argument><expr><name>BTGreaterStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT2GT</name></expr></argument>,
				<argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Open pg_attribute and begin a scan.  Force heap scan if we haven't yet
	 * built the critical relcache entries (this includes initdb and startup
	 * without a pg_internal.init file).
	 */</comment>
	<expr_stmt><expr><name>pg_attribute_desc</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pg_attribute_scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_attribute_desc</name></expr></argument>,
										   <argument><expr><name>AttributeRelidNumIndexId</name></expr></argument>,
										   <argument><expr><name>criticalRelcachesBuilt</name></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>,
										   <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * add attribute data to relation-&gt;rd_att
	 */</comment>
	<expr_stmt><expr><name>need</name> <operator>=</operator> <call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>pg_attribute_tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>pg_attribute_scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>attp</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>pg_attribute_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>attp</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>attnum</name> <operator>&gt;</operator> <call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid attribute number %d for %s"</literal></expr></argument>,
			     <argument><expr><name><name>attp</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>attp</name><operator>-&gt;</operator><name>attnum</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
		       <argument><expr><name>attp</name></expr></argument>,
		       <argument><expr><name>ATTRIBUTE_FIXED_PART_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Update constraint/default info */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>attp</name><operator>-&gt;</operator><name>attnotnull</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>has_not_null</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* If the column has a default, fill it into the attrdef array */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>attp</name><operator>-&gt;</operator><name>atthasdef</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>attrdef</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>attrdef</name> <operator>=</operator> <operator>(</operator><name>AttrDefault</name> <operator>*</operator><operator>)</operator>
					<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>,
										   <argument><expr><call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call> <operator>*</operator>
										   <sizeof>sizeof<argument_list>(<argument><expr><name>AttrDefault</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>attrdef</name><index>[<expr><name>ndef</name></expr>]</index></name><operator>.</operator><name>adnum</name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>attrdef</name><index>[<expr><name>ndef</name></expr>]</index></name><operator>.</operator><name>adbin</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>ndef</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Likewise for a missing value */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>attp</name><operator>-&gt;</operator><name>atthasmissing</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>missingval</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>missingNull</name></decl>;</decl_stmt>

			<comment type="block">/* Do we have a missing value? */</comment>
			<expr_stmt><expr><name>missingval</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>pg_attribute_tuple</name></expr></argument>,
									  <argument><expr><name>Anum_pg_attribute_attmissingval</name></expr></argument>,
									  <argument><expr><name><name>pg_attribute_desc</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>missingNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>missingNull</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Yes, fetch from the array */</comment>
				<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>is_null</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>one</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Datum</name></type>		<name>missval</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>attrmiss</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>attrmiss</name> <operator>=</operator> <operator>(</operator><name>AttrMissing</name> <operator>*</operator><operator>)</operator>
						<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>,
											   <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnatts</name></name> <operator>*</operator>
											   <sizeof>sizeof<argument_list>(<argument><expr><name>AttrMissing</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>missval</name> <operator>=</operator> <call><name>array_get_element</name><argument_list>(<argument><expr><name>missingval</name></expr></argument>,
											<argument><expr><literal type="number">1</literal></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>one</name></expr></argument>,
											<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
											<argument><expr><name><name>attp</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>,
											<argument><expr><name><name>attp</name><operator>-&gt;</operator><name>attbyval</name></name></expr></argument>,
											<argument><expr><name><name>attp</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>attp</name><operator>-&gt;</operator><name>attbyval</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* for copy by val just copy the datum direct */</comment>
					<expr_stmt><expr><name><name>attrmiss</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>am_value</name> <operator>=</operator> <name>missval</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* otherwise copy in the correct context */</comment>
					<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>attrmiss</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>am_value</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name>missval</name></expr></argument>,
															  <argument><expr><name><name>attp</name><operator>-&gt;</operator><name>attbyval</name></name></expr></argument>,
															  <argument><expr><name><name>attp</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<expr_stmt><expr><name><name>attrmiss</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>am_present</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>need</name><operator>--</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>need</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * end the scan and close the attribute relation
	 */</comment>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>pg_attribute_scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_attribute_desc</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>need</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"catalog is missing %d attribute(s) for relid %u"</literal></expr></argument>,
			 <argument><expr><name>need</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The attcacheoff values we read from pg_attribute should all be -1
	 * ("unknown").  Verify this if assert checking is on.  They will be
	 * computed when and if needed during tuple access.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attcacheoff</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * However, we can easily set the attcacheoff value for the first
	 * attribute: it must be zero.  This eliminates the need for special cases
	 * for attnum=1 that used to exist in fastgetattr() and index_getattr().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attcacheoff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Set up constraint/default info
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>constr</name><operator>-&gt;</operator><name>has_not_null</name></name> <operator>||</operator> <name>ndef</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<name>attrmiss</name> <operator>||</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relchecks</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name> <operator>=</operator> <name>constr</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>ndef</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>			<comment type="block">/* DEFAULTs */</comment>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>ndef</name> <operator>&lt;</operator> <call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>defval</name></name> <operator>=</operator> <operator>(</operator><name>AttrDefault</name> <operator>*</operator><operator>)</operator>
					<call><name>repalloc</name><argument_list>(<argument><expr><name>attrdef</name></expr></argument>, <argument><expr><name>ndef</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrDefault</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>defval</name></name> <operator>=</operator> <name>attrdef</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>num_defval</name></name> <operator>=</operator> <name>ndef</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AttrDefaultFetch</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>num_defval</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>missing</name></name> <operator>=</operator> <name>attrmiss</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relchecks</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>	<comment type="block">/* CHECKs */</comment>
		<block>{<block_content>
			<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>num_check</name></name> <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relchecks</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>check</name></name> <operator>=</operator> <operator>(</operator><name>ConstrCheck</name> <operator>*</operator><operator>)</operator>
				<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>,
									   <argument><expr><name><name>constr</name><operator>-&gt;</operator><name>num_check</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ConstrCheck</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CheckConstraintFetch</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>num_check</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>constr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * A special version of RelationBuildRuleLock (initializes rewrite rules for a relation).
 *
 * Its only difference from the original is that instead of doing a direct scan
 * on RewriteRelationId, it uses partial query against RULERELNAME cache
 * (which we pre-initialized in YBPreloadRelCache).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>YBRelationBuildRuleLock</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>rulescxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rewrite_desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>rewrite_tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RuleLock</name>   <modifier>*</modifier></type><name>rulelock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numlocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RewriteRule</name> <modifier>*</modifier><modifier>*</modifier></type><name>rules</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxlocks</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Make the private context.  Assume it'll not contain much data.
	 */</comment>
	<expr_stmt><expr><name>rulescxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>,
									 <argument><expr><literal type="string">"relation rules"</literal></expr></argument>,
									 <argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rulescxt</name></name> <operator>=</operator> <name>rulescxt</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextCopyAndSetIdentifier</name><argument_list>(<argument><expr><name>rulescxt</name></expr></argument>,
									  <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * allocate an array to hold the rewrite rules (the array is extended if
	 * necessary)
	 */</comment>
	<expr_stmt><expr><name>maxlocks</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>rules</name> <operator>=</operator> <operator>(</operator><name>RewriteRule</name> <operator>*</operator><operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>rulescxt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RewriteRule</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>maxlocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>numlocks</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * # ORIGINAL POSTGRES COMMENT:
	 *
	 * open pg_rewrite and begin a scan
	 *
	 * Note: since we scan the rules using RewriteRelRulenameIndexId, we will
	 * be reading the rules in name order, except possibly during
	 * emergency-recovery operations (ie, IgnoreSystemIndexes). This in turn
	 * ensures that rules will be fired in name order.
	 *
	 *
	 * # YB NOTE (alex):
	 *
	 * Instead of full scan, we're doing partial cache lookup. This cache is also using
	 * RewriteRelRulenameIndexId, so the order persists.
	 */</comment>
	<expr_stmt><expr><name>rewrite_desc</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RewriteRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rewrite_tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rewrite_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>CatCList</name><modifier>*</modifier></type> <name>rewrite_list</name> <init>= <expr><call><name>SearchSysCacheList1</name><argument_list>(<argument><expr><name>RULERELNAME</name></expr></argument>,
												 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>rewrite_list</name><operator>-&gt;</operator><name>n_members</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>       <name>rewrite_tuple</name> <init>= <expr><operator>&amp;</operator><name><name>rewrite_list</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tuple</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_rewrite</name></type> <name>rewrite_form</name>  <init>= <expr><operator>(</operator><name>Form_pg_rewrite</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>rewrite_tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>rule_datum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>		<modifier>*</modifier></type><name>rule_str</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RewriteRule</name> <modifier>*</modifier></type><name>rule</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rule</name> <operator>=</operator> <operator>(</operator><name>RewriteRule</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>rulescxt</name></expr></argument>,
												  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RewriteRule</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>rule</name><operator>-&gt;</operator><name>ruleId</name></name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>rewrite_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>rule</name><operator>-&gt;</operator><name>event</name></name> <operator>=</operator> <name><name>rewrite_form</name><operator>-&gt;</operator><name>ev_type</name></name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rule</name><operator>-&gt;</operator><name>enabled</name></name> <operator>=</operator> <name><name>rewrite_form</name><operator>-&gt;</operator><name>ev_enabled</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rule</name><operator>-&gt;</operator><name>isInstead</name></name> <operator>=</operator> <name><name>rewrite_form</name><operator>-&gt;</operator><name>is_instead</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Must use heap_getattr to fetch ev_action and ev_qual.  Also, the
		 * rule strings are often large enough to be toasted.  To avoid
		 * leaking memory in the caller's context, do the detoasting here so
		 * we can free the detoasted version.
		 */</comment>
		<expr_stmt><expr><name>rule_datum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>rewrite_tuple</name></expr></argument>,
								  <argument><expr><name>Anum_pg_rewrite_ev_action</name></expr></argument>,
								  <argument><expr><name>rewrite_tupdesc</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rule_str</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>rule_datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>rulescxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rule</name><operator>-&gt;</operator><name>actions</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name>rule_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rule_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>rule_datum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>rewrite_tuple</name></expr></argument>,
								  <argument><expr><name>Anum_pg_rewrite_ev_qual</name></expr></argument>,
								  <argument><expr><name>rewrite_tupdesc</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rule_str</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>rule_datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>rulescxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rule</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name>rule_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rule_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We want the rule's table references to be checked as though by the
		 * table owner, not the user referencing the rule.  Therefore, scan
		 * through the rule's actions and set the checkAsUser field on all
		 * rtable entries.  We have to look at the qual as well, in case it
		 * contains sublinks.
		 *
		 * The reason for doing this when the rule is loaded, rather than when
		 * it is stored, is that otherwise ALTER TABLE OWNER would have to
		 * grovel through stored rules to update checkAsUser fields. Scanning
		 * the rule tree during load is relatively cheap (compared to
		 * constructing it in the first place), so we do it here.
		 */</comment>
		<expr_stmt><expr><call><name>setRuleCheckAsUser</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rule</name><operator>-&gt;</operator><name>actions</name></name></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relowner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>setRuleCheckAsUser</name><argument_list>(<argument><expr><name><name>rule</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relowner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>numlocks</name> <operator>&gt;=</operator> <name>maxlocks</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>maxlocks</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>rules</name> <operator>=</operator> <operator>(</operator><name>RewriteRule</name> <operator>*</operator><operator>*</operator><operator>)</operator>
				<call><name>repalloc</name><argument_list>(<argument><expr><name>rules</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RewriteRule</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>maxlocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>rules</name><index>[<expr><name>numlocks</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>rule</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * We don't use those preloaded pg_rewrite partial-match lists anywhere else in the code,
	 * so there's no point of keeping them in memory.
	 * We mark them dead so that ReleaseCatCacheList would evict them.
	 */</comment>
	<expr_stmt><expr><name><name>rewrite_list</name><operator>-&gt;</operator><name>dead</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseCatCacheList</name><argument_list>(<argument><expr><name>rewrite_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rewrite_desc</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * there might not be any rules (if relhasrules is out-of-date)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numlocks</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rules</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rulescxt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>rulescxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * form a RuleLock and insert into relation
	 */</comment>
	<expr_stmt><expr><name>rulelock</name> <operator>=</operator> <operator>(</operator><name>RuleLock</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>rulescxt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RuleLock</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rulelock</name><operator>-&gt;</operator><name>numLocks</name></name> <operator>=</operator> <name>numlocks</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rulelock</name><operator>-&gt;</operator><name>rules</name></name> <operator>=</operator> <name>rules</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rules</name></name> <operator>=</operator> <name>rulelock</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		RelationBuildRuleLock
 *
 *		Form the relation's rewrite rules from information in
 *		the pg_rewrite system catalog.
 *
 * Note: The rule parsetrees are potentially very complex node structures.
 * To allow these trees to be freed when the relcache entry is flushed,
 * we make a private memory context to hold the RuleLock information for
 * each relcache entry that has associated rules.  The context is used
 * just for rule info, not for any other subsidiary data of the relcache
 * entry, because that keeps the update logic in RelationClearRelation()
 * manageable.  The other subsidiary data structures are simple enough
 * to be easy to free explicitly, anyway.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RelationBuildRuleLock</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>rulescxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>rewrite_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rewrite_desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>rewrite_tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>rewrite_scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RuleLock</name>   <modifier>*</modifier></type><name>rulelock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numlocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RewriteRule</name> <modifier>*</modifier><modifier>*</modifier></type><name>rules</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxlocks</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Make the private context.  Assume it'll not contain much data.
	 */</comment>
	<expr_stmt><expr><name>rulescxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>,
									 <argument><expr><literal type="string">"relation rules"</literal></expr></argument>,
									 <argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rulescxt</name></name> <operator>=</operator> <name>rulescxt</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextCopyAndSetIdentifier</name><argument_list>(<argument><expr><name>rulescxt</name></expr></argument>,
									  <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * allocate an array to hold the rewrite rules (the array is extended if
	 * necessary)
	 */</comment>
	<expr_stmt><expr><name>maxlocks</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>rules</name> <operator>=</operator> <operator>(</operator><name>RewriteRule</name> <operator>*</operator><operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>rulescxt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RewriteRule</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>maxlocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>numlocks</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * form a scan key
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,
				<argument><expr><name>Anum_pg_rewrite_ev_class</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * open pg_rewrite and begin a scan
	 *
	 * Note: since we scan the rules using RewriteRelRulenameIndexId, we will
	 * be reading the rules in name order, except possibly during
	 * emergency-recovery operations (ie, IgnoreSystemIndexes). This in turn
	 * ensures that rules will be fired in name order.
	 */</comment>
	<expr_stmt><expr><name>rewrite_desc</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RewriteRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rewrite_tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rewrite_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rewrite_scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rewrite_desc</name></expr></argument>,
									  <argument><expr><name>RewriteRelRulenameIndexId</name></expr></argument>,
									  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									  <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>rewrite_tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>rewrite_scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_rewrite</name></type> <name>rewrite_form</name> <init>= <expr><operator>(</operator><name>Form_pg_rewrite</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>rewrite_tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>rule_datum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rule_str</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RewriteRule</name> <modifier>*</modifier></type><name>rule</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rule</name> <operator>=</operator> <operator>(</operator><name>RewriteRule</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>rulescxt</name></expr></argument>,
												  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RewriteRule</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>rule</name><operator>-&gt;</operator><name>ruleId</name></name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>rewrite_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>rule</name><operator>-&gt;</operator><name>event</name></name> <operator>=</operator> <name><name>rewrite_form</name><operator>-&gt;</operator><name>ev_type</name></name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rule</name><operator>-&gt;</operator><name>enabled</name></name> <operator>=</operator> <name><name>rewrite_form</name><operator>-&gt;</operator><name>ev_enabled</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rule</name><operator>-&gt;</operator><name>isInstead</name></name> <operator>=</operator> <name><name>rewrite_form</name><operator>-&gt;</operator><name>is_instead</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Must use heap_getattr to fetch ev_action and ev_qual.  Also, the
		 * rule strings are often large enough to be toasted.  To avoid
		 * leaking memory in the caller's context, do the detoasting here so
		 * we can free the detoasted version.
		 */</comment>
		<expr_stmt><expr><name>rule_datum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>rewrite_tuple</name></expr></argument>,
								  <argument><expr><name>Anum_pg_rewrite_ev_action</name></expr></argument>,
								  <argument><expr><name>rewrite_tupdesc</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rule_str</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>rule_datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>rulescxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rule</name><operator>-&gt;</operator><name>actions</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name>rule_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rule_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>rule_datum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>rewrite_tuple</name></expr></argument>,
								  <argument><expr><name>Anum_pg_rewrite_ev_qual</name></expr></argument>,
								  <argument><expr><name>rewrite_tupdesc</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rule_str</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>rule_datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>rulescxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rule</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name>rule_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rule_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We want the rule's table references to be checked as though by the
		 * table owner, not the user referencing the rule.  Therefore, scan
		 * through the rule's actions and set the checkAsUser field on all
		 * rtable entries.  We have to look at the qual as well, in case it
		 * contains sublinks.
		 *
		 * The reason for doing this when the rule is loaded, rather than when
		 * it is stored, is that otherwise ALTER TABLE OWNER would have to
		 * grovel through stored rules to update checkAsUser fields. Scanning
		 * the rule tree during load is relatively cheap (compared to
		 * constructing it in the first place), so we do it here.
		 */</comment>
		<expr_stmt><expr><call><name>setRuleCheckAsUser</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rule</name><operator>-&gt;</operator><name>actions</name></name></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relowner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>setRuleCheckAsUser</name><argument_list>(<argument><expr><name><name>rule</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relowner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>numlocks</name> <operator>&gt;=</operator> <name>maxlocks</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>maxlocks</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>rules</name> <operator>=</operator> <operator>(</operator><name>RewriteRule</name> <operator>*</operator><operator>*</operator><operator>)</operator>
				<call><name>repalloc</name><argument_list>(<argument><expr><name>rules</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RewriteRule</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>maxlocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>rules</name><index>[<expr><name>numlocks</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>rule</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * end the scan and close the attribute relation
	 */</comment>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>rewrite_scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rewrite_desc</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * there might not be any rules (if relhasrules is out-of-date)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numlocks</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rules</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rulescxt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>rulescxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * form a RuleLock and insert into relation
	 */</comment>
	<expr_stmt><expr><name>rulelock</name> <operator>=</operator> <operator>(</operator><name>RuleLock</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>rulescxt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RuleLock</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rulelock</name><operator>-&gt;</operator><name>numLocks</name></name> <operator>=</operator> <name>numlocks</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rulelock</name><operator>-&gt;</operator><name>rules</name></name> <operator>=</operator> <name>rules</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rules</name></name> <operator>=</operator> <name>rulelock</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		equalRuleLocks
 *
 *		Determine whether two RuleLocks are equivalent
 *
 *		Probably this should be in the rules code someplace...
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>equalRuleLocks</name><parameter_list>(<parameter><decl><type><name>RuleLock</name> <modifier>*</modifier></type><name>rlock1</name></decl></parameter>, <parameter><decl><type><name>RuleLock</name> <modifier>*</modifier></type><name>rlock2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * As of 7.3 we assume the rule ordering is repeatable, because
	 * RelationBuildRuleLock should read 'em in a consistent order.  So just
	 * compare corresponding slots.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>rlock1</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>rlock2</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>rlock1</name><operator>-&gt;</operator><name>numLocks</name></name> <operator>!=</operator> <name><name>rlock2</name><operator>-&gt;</operator><name>numLocks</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>rlock1</name><operator>-&gt;</operator><name>numLocks</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RewriteRule</name> <modifier>*</modifier></type><name>rule1</name> <init>= <expr><name><name>rlock1</name><operator>-&gt;</operator><name>rules</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RewriteRule</name> <modifier>*</modifier></type><name>rule2</name> <init>= <expr><name><name>rlock2</name><operator>-&gt;</operator><name>rules</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>rule1</name><operator>-&gt;</operator><name>ruleId</name></name> <operator>!=</operator> <name><name>rule2</name><operator>-&gt;</operator><name>ruleId</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>rule1</name><operator>-&gt;</operator><name>event</name></name> <operator>!=</operator> <name><name>rule2</name><operator>-&gt;</operator><name>event</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>rule1</name><operator>-&gt;</operator><name>enabled</name></name> <operator>!=</operator> <name><name>rule2</name><operator>-&gt;</operator><name>enabled</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>rule1</name><operator>-&gt;</operator><name>isInstead</name></name> <operator>!=</operator> <name><name>rule2</name><operator>-&gt;</operator><name>isInstead</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name><name>rule1</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><name><name>rule2</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name><name>rule1</name><operator>-&gt;</operator><name>actions</name></name></expr></argument>, <argument><expr><name><name>rule2</name><operator>-&gt;</operator><name>actions</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>rlock2</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		equalPolicy
 *
 *		Determine whether two policies are equivalent
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>equalPolicy</name><parameter_list>(<parameter><decl><type><name>RowSecurityPolicy</name> <modifier>*</modifier></type><name>policy1</name></decl></parameter>, <parameter><decl><type><name>RowSecurityPolicy</name> <modifier>*</modifier></type><name>policy2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>r1</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>r2</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>policy1</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>policy2</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>policy1</name><operator>-&gt;</operator><name>polcmd</name></name> <operator>!=</operator> <name><name>policy2</name><operator>-&gt;</operator><name>polcmd</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>policy1</name><operator>-&gt;</operator><name>hassublinks</name></name> <operator>!=</operator> <name><name>policy2</name><operator>-&gt;</operator><name>hassublinks</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>policy1</name><operator>-&gt;</operator><name>policy_name</name></name></expr></argument>, <argument><expr><name><name>policy2</name><operator>-&gt;</operator><name>policy_name</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name><name>policy1</name><operator>-&gt;</operator><name>roles</name></name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>!=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name><name>policy2</name><operator>-&gt;</operator><name>roles</name></name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>r1</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name><name>policy1</name><operator>-&gt;</operator><name>roles</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>r2</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name><name>policy2</name><operator>-&gt;</operator><name>roles</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name><name>policy1</name><operator>-&gt;</operator><name>roles</name></name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>r1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>r2</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name><name>policy1</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><name><name>policy2</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name><name>policy1</name><operator>-&gt;</operator><name>with_check_qual</name></name></expr></argument>, <argument><expr><name><name>policy2</name><operator>-&gt;</operator><name>with_check_qual</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>policy2</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		equalRSDesc
 *
 *		Determine whether two RowSecurityDesc's are equivalent
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>equalRSDesc</name><parameter_list>(<parameter><decl><type><name>RowSecurityDesc</name> <modifier>*</modifier></type><name>rsdesc1</name></decl></parameter>, <parameter><decl><type><name>RowSecurityDesc</name> <modifier>*</modifier></type><name>rsdesc2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>rc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>rsdesc1</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>rsdesc2</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rsdesc1</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>rsdesc2</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>rsdesc1</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>rsdesc2</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rsdesc1</name><operator>-&gt;</operator><name>policies</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rsdesc2</name><operator>-&gt;</operator><name>policies</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* RelationBuildRowSecurity should build policies in order */</comment>
	<macro><name>forboth</name><argument_list>(<argument>lc</argument>, <argument>rsdesc1-&gt;policies</argument>, <argument>rc</argument>, <argument>rsdesc2-&gt;policies</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RowSecurityPolicy</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><operator>(</operator><name>RowSecurityPolicy</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RowSecurityPolicy</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><operator>(</operator><name>RowSecurityPolicy</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equalPolicy</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * equalPartitionDescs
 *		Compare two partition descriptors for logical equality
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>equalPartitionDescs</name><parameter_list>(<parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>PartitionDesc</name></type> <name>partdesc1</name></decl></parameter>,
					<parameter><decl><type><name>PartitionDesc</name></type> <name>partdesc2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>partdesc1</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>partdesc2</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>partdesc1</name><operator>-&gt;</operator><name>nparts</name></name> <operator>!=</operator> <name><name>partdesc2</name><operator>-&gt;</operator><name>nparts</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>key</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name><name>partdesc1</name><operator>-&gt;</operator><name>nparts</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Same oids? If the partitioning structure did not change, that is,
		 * no partitions were added or removed to the relation, the oids array
		 * should still match element-by-element.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>partdesc1</name><operator>-&gt;</operator><name>nparts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>partdesc1</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>partdesc2</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Now compare partition bound collections.  The logic to iterate over
		 * the collections is private to partition.c.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>partdesc1</name><operator>-&gt;</operator><name>boundinfo</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>partdesc2</name><operator>-&gt;</operator><name>boundinfo</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>partition_bounds_equal</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttyplen</name></name></expr></argument>,
										<argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypbyval</name></name></expr></argument>,
										<argument><expr><name><name>partdesc1</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></argument>,
										<argument><expr><name><name>partdesc2</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>partdesc2</name><operator>-&gt;</operator><name>boundinfo</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>partdesc2</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>YBLoadRelationsResult</name> <block>{
	<decl_stmt><decl><type><name>bool</name></type> <name>sys_relations_update_required</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>has_partitioned_tables</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>has_relations_with_trigger</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>has_relations_with_row_security</name></decl>;</decl_stmt>
}</block></struct></type> <name>YBLoadRelationsResult</name>;</typedef>

<comment type="block">/*
 * YugaByte-mode only utility used to load up the relcache on initialization
 * to minimize the number on YB-master queries needed.
 * It is based on (and similar to) RelationBuildDesc but does all relations
 * at once.
 * It works in three steps:
 *  1. Load up all the data pg_class using one full scan iteration. The
 *  relations after this point will all be loaded but incomplete (e.g. no
 *  attribute info set).
 *  2. Load all the data from pg_attribute using one full scan. Then update
 *  each corresponding relation once all attributes for it were retrieved.
 *  3. Load all the data from pg_partitioned_table using one full scan. Then
 *  update each corresponding relation with the attributes fetched during
 *  the second phase. This is because updating the partition information requires attribute
 *  information to be loaded for pg_partitioned_table, pg_type etc.
 *
 *  Note: We assume that any error happening here will fatal so as to not end
 *  up with partial information in the cache.
 */</comment>
<function><type><specifier>static</specifier> <name>YBLoadRelationsResult</name></type>
<name>YBLoadRelations</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>YBLoadRelationsResult</name></type> <name>result</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>pg_class_desc</name> <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scandesc</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(
	    <argument><expr><name>pg_class_desc</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* indexOk */</comment>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>pg_class_tuple</name></decl>;</decl_stmt>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>pg_class_tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name> <init>= <expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>pg_class_tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Insert newly created relation into relcache hash table if needed:
		 * a. If it's not already there (e.g. new table or initialization).
		 * b. If it's a regular (non-system) table it could be changed (e.g. by an 'ALTER').
		 */</comment>
		<decl_stmt><decl><type><name>Relation</name></type> <name>tmp_rel</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>RelationIdCacheLookup</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>tmp_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Ignore update of existing sys relation as it can't be changed without DB upgrade. */</comment>
		<if_stmt><if>if <condition>(<expr><name>tmp_rel</name> <operator>&amp;&amp;</operator> <call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>tmp_rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<comment type="block">/* get information from the pg_class_tuple */</comment>
		<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>relp</name>  <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>pg_class_tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * allocate storage for the relation descriptor, and copy pg_class_tuple
		 * to relation-&gt;rd_rel.
		 */</comment>
		<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>AllocateRelationDesc</name><argument_list>(<argument><expr><name>relp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* initialize the relation's relation id (relation-&gt;rd_id) */</comment>
		<expr_stmt><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * normal relations are not nailed into the cache; nor can a pre-existing
		 * relation be new.  It could be temp though.  (Actually, it could be new
		 * too, but it's okay to forget that fact if forced to flush the entry.)
		 */</comment>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_refcnt</name></name>              <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_isnailed</name></name>            <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_createSubid</name></name>         <operator>=</operator> <name>InvalidSubTransactionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_newRelfilenodeSubid</name></name> <operator>=</operator> <name>InvalidSubTransactionId</name></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>RELPERSISTENCE_UNLOGGED</name></expr>:</case>
			<case>case <expr><name>RELPERSISTENCE_PERMANENT</name></expr>:</case>
				<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_backend</name></name>     <operator>=</operator> <name>InvalidBackendId</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_islocaltemp</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RELPERSISTENCE_TEMP</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>isTempOrTempToastNamespace</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_backend</name></name>     <operator>=</operator> <call><name>BackendIdForTempRelations</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_islocaltemp</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * If it's a temp table, but not one of ours,
					 * we set rd_backend to the invalid backend id.
					 */</comment>
					<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_backend</name></name> <operator>=</operator> <name>InvalidBackendId</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_islocaltemp</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid relpersistence: %c"</literal></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<comment type="block">/* foreign key data is not loaded till asked for */</comment>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_fkeylist</name></name>  <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_fkeyvalid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * For now, update all partition information to be null, this will
		 * be populated later for partitioned tables
		 */</comment>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_partkeycxt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_partkey</name></name>    <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_partdesc</name></name>   <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_pdcxt</name></name>      <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/* if it's an index, initialize index-related information */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>RelationInitIndexAccessInfo</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* extract reloptions if any */</comment>
		<expr_stmt><expr><call><name>RelationParseRelOptions</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>pg_class_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* initialize the relation lock manager information */</comment>
		<expr_stmt><expr><call><name>RelationInitLockInfo</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* see lmgr.c */</comment>

		<comment type="block">/* initialize physical addressing information for the relation */</comment>
		<expr_stmt><expr><call><name>RelationInitPhysicalAddr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* make sure relation is marked as having no open file yet */</comment>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_smgr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>RelationCacheInsert</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* It's fully valid */</comment>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_isvalid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<comment type="block">/* Sys relation update is required in case at least one new sys relation has been loaded. */</comment>
		<expr_stmt><expr><name><name>result</name><operator>.</operator><name>sys_relations_update_required</name></name> <operator>=</operator> <name><name>result</name><operator>.</operator><name>sys_relations_update_required</name></name> <operator>||</operator>
		                                       <call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>result</name><operator>.</operator><name>has_relations_with_trigger</name></name> <operator>=</operator> <name><name>result</name><operator>.</operator><name>has_relations_with_trigger</name></name> <operator>||</operator>
		                                    <name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhastriggers</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>result</name><operator>.</operator><name>has_relations_with_row_security</name></name> <operator>=</operator> <name><name>result</name><operator>.</operator><name>has_relations_with_row_security</name></name> <operator>||</operator>
		                                         <name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relrowsecurity</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>result</name><operator>.</operator><name>has_partitioned_tables</name></name> <operator>=</operator> <name><name>result</name><operator>.</operator><name>has_partitioned_tables</name></name> <operator>||</operator>
		                                <name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_class_desc</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>YbAttrProcessorState</name> <block>{
	<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>need</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ndef</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleConstr</name> <modifier>*</modifier></type><name>constr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrDefault</name> <modifier>*</modifier></type><name>attrdef</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrMissing</name> <modifier>*</modifier></type><name>attrmiss</name></decl>;</decl_stmt>
}</block></struct></type> <name>YbAttrProcessorState</name>;</typedef>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>YbIsAttrProcessingStarted</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>YbAttrProcessorState</name><modifier>*</modifier></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>YbIsAttrProcessingRequired</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>YbAttrProcessorState</name><modifier>*</modifier></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><name><name>state</name><operator>-&gt;</operator><name>relation</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>YbApplyAttr</name><parameter_list>(<parameter><decl><type><name>YbAttrProcessorState</name><modifier>*</modifier></type> <name>state</name></decl></parameter>,
            <parameter><decl><type><name>Relation</name></type> <name>attrel</name></decl></parameter>,
            <parameter><decl><type><name>HeapTuple</name></type> <name>htup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attp</name> <init>= <expr><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>YbIsAttrProcessingStarted</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>state</name><operator>-&gt;</operator><name>relid</name></name> <operator>!=</operator> <name><name>attp</name><operator>-&gt;</operator><name>attrelid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>YbIsAttrProcessingRequired</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Skip system attributes */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>attp</name><operator>-&gt;</operator><name>attnum</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>relation</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>attp</name><operator>-&gt;</operator><name>attnum</name></name> <operator>&gt;</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnatts</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
		     <argument><expr><literal type="string">"invalid attribute number %d for %s"</literal></expr></argument>,
		     <argument><expr><name><name>attp</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>,
		     <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name><name>attp</name><operator>-&gt;</operator><name>attnum</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attp</name></expr></argument>, <argument><expr><name>ATTRIBUTE_FIXED_PART_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update constraint/default info */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>attp</name><operator>-&gt;</operator><name>attnotnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>has_not_null</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>attp</name><operator>-&gt;</operator><name>atthasdef</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>attrdef</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>attrdef</name></name> <operator>=</operator> <operator>(</operator><name>AttrDefault</name><operator>*</operator><operator>)</operator> <call><name>MemoryContextAllocZero</name><argument_list>(
			    <argument><expr><name>CacheMemoryContext</name></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnatts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrDefault</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<decl_stmt><decl><type><name>AttrDefault</name> <modifier>*</modifier></type><name>attrdef</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>attrdef</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>attrdef</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>ndef</name></name></expr>]</index></name><operator>.</operator><name>adnum</name> <operator>=</operator> <name><name>attp</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>attrdef</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>ndef</name></name></expr>]</index></name><operator>.</operator><name>adbin</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>++</operator><name><name>state</name><operator>-&gt;</operator><name>ndef</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Likewise for a missing value */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>attp</name><operator>-&gt;</operator><name>atthasmissing</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>missingNull</name></decl>;</decl_stmt>

		<comment type="block">/* Do we have a missing value? */</comment>
		<decl_stmt><decl><type><name>Datum</name></type> <name>missingval</name> <init>= <expr><call><name>heap_getattr</name><argument_list>(<argument><expr><name>htup</name></expr></argument>,
		                                <argument><expr><name>Anum_pg_attribute_attmissingval</name></expr></argument>,
		                                <argument><expr><name><name>attrel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>,
		                                <argument><expr><operator>&amp;</operator><name>missingNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>missingNull</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Yes, fetch from the array */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>attrmiss</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>attrmiss</name></name> <operator>=</operator> <operator>(</operator><name>AttrMissing</name> <operator>*</operator><operator>)</operator><call><name>MemoryContextAllocZero</name><argument_list>(
				    <argument><expr><name>CacheMemoryContext</name></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnatts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrMissing</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>is_null</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>one</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type> <name>missval</name> <init>= <expr><call><name>array_get_element</name><argument_list>(
			    <argument><expr><name>missingval</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>one</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>attp</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>, <argument><expr><name><name>attp</name><operator>-&gt;</operator><name>attbyval</name></name></expr></argument>, <argument><expr><name><name>attp</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>AttrMissing</name> <modifier>*</modifier></type><name>attrmiss</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>attrmiss</name></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>attp</name><operator>-&gt;</operator><name>attbyval</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* for copy by val just copy the datum direct */</comment>
				<expr_stmt><expr><name><name>attrmiss</name><index>[<expr><name><name>attp</name><operator>-&gt;</operator><name>attnum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>am_value</name> <operator>=</operator> <name>missval</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* otherwise copy in the correct context */</comment>
				<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name><name>attrmiss</name><index>[<expr><name><name>attp</name><operator>-&gt;</operator><name>attnum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>am_value</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(
				    <argument><expr><name>missval</name></expr></argument>, <argument><expr><name><name>attp</name><operator>-&gt;</operator><name>attbyval</name></name></expr></argument>, <argument><expr><name><name>attp</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><name><name>attrmiss</name><index>[<expr><name><name>attp</name><operator>-&gt;</operator><name>attnum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>am_present</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>--</operator><name><name>state</name><operator>-&gt;</operator><name>need</name></name></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>YbStartNewAttrProcessing</name><parameter_list>(<parameter><decl><type><name>YbAttrProcessorState</name><modifier>*</modifier></type> <name>state</name></decl></parameter>,
                         <parameter><decl><type><name>bool</name></type> <name>sys_rel_update_required</name></decl></parameter>,
                         <parameter><decl><type><name>Relation</name></type> <name>attrel</name></decl></parameter>,
                         <parameter><decl><type><name>HeapTuple</name></type> <name>htup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>YbIsAttrProcessingStarted</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attp</name> <init>= <expr><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>attp</name><operator>-&gt;</operator><name>attrelid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name><name>attp</name><operator>-&gt;</operator><name>attrelid</name></name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>RelationIdCacheLookup</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>relation</name> <operator>||</operator> <operator>(</operator><operator>!</operator><name>sys_rel_update_required</name> <operator>&amp;&amp;</operator> <call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>relation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>need</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnatts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>constr</name></name> <operator>=</operator> <operator>(</operator><name>TupleConstr</name><operator>*</operator><operator>)</operator> <call><name>MemoryContextAllocZero</name><argument_list>(
		<argument><expr><name>CacheMemoryContext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TupleConstr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>applied</name> <init>= <expr><call><name>YbApplyAttr</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>attrel</name></expr></argument>, <argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>applied</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>applied</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>YbCompleteAttrProcessingImpl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>YbAttrProcessorState</name><modifier>*</modifier></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>need</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"catalog is missing %d attribute(s) for relid %u"</literal></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>need</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>relation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleConstr</name> <modifier>*</modifier></type><name>constr</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>constr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrDefault</name> <modifier>*</modifier></type><name>attrdef</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>attrdef</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrMissing</name> <modifier>*</modifier></type><name>attrmiss</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>attrmiss</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ndef</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>ndef</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* copy some fields from pg_class row to rd_att */</comment>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>tdtypeid</name></name> <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>tdtypmod</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* unnecessary, but... */</comment>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>tdhasoid</name></name> <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * However, we can easily set the attcacheoff value for the first
	 * attribute: it must be zero.  This eliminates the need for special cases
	 * for attnum=1 that used to exist in fastgetattr() and index_getattr().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attcacheoff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Set up constraint/default info */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>constr</name><operator>-&gt;</operator><name>has_not_null</name></name> <operator>||</operator> <name>ndef</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>attrmiss</name> <operator>||</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relchecks</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name> <operator>=</operator> <name>constr</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>ndef</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>            <comment type="block">/* DEFAULTs */</comment>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>ndef</name> <operator>&lt;</operator> <call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>defval</name></name> <operator>=</operator> <operator>(</operator><name>AttrDefault</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>attrdef</name></expr></argument>, <argument><expr><name>ndef</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrDefault</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>defval</name></name> <operator>=</operator> <name>attrdef</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>num_defval</name></name> <operator>=</operator> <name>ndef</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AttrDefaultFetch</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>num_defval</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>missing</name></name> <operator>=</operator> <name>attrmiss</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relchecks</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>    <comment type="block">/* CHECKs */</comment>
		<block>{<block_content>
			<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>num_check</name></name> <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relchecks</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>check</name></name> <operator>=</operator> <operator>(</operator><name>ConstrCheck</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAllocZero</name><argument_list>(
			    <argument><expr><name>CacheMemoryContext</name></expr></argument>, <argument><expr><name><name>constr</name><operator>-&gt;</operator><name>num_check</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ConstrCheck</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CheckConstraintFetch</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>num_check</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>constr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Fetch rules and triggers that affect this relation */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasrules</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>YBRelationBuildRuleLock</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rules</name></name>    <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rulescxt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhastriggers</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RelationBuildTriggers</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>trigdesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relrowsecurity</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RelationBuildRowSecurity</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rsdesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>YbCompleteAttrProcessing</name><parameter_list>(<parameter><decl><type><name>YbAttrProcessorState</name><modifier>*</modifier></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>YbIsAttrProcessingStarted</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>YbIsAttrProcessingRequired</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>YbCompleteAttrProcessingImpl</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>state</name> <operator>=</operator> <operator>(</operator>struct <name>YbAttrProcessorState</name><operator>)</operator><block>{<expr><literal type="number">0</literal></expr>}</block></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>YBUpdateRelationsAttributes</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>sys_relations_update_required</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Open pg_attribute and begin a scan.  Force heap scan if we haven't yet
	 * built the critical relcache entries (this includes initdb and startup
	 * without a pg_internal.init file).
	 * We are scanning through the entire pg_attribute table to get all the attributes (columns)
	 * for all the relations. All the attributes for a relation are contiguous, so we maintain the
	 * current relation and, when we finish processing its attributes (detected when we read a
	 * different relation_id which is first range key of pg_attribute), we load up the retrieved
	 * info into the Relation entry, which among other things, sets up then constraint and default
	 * info.
	 */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>attrel</name> <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scandesc</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(
		<argument><expr><name>attrel</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* indexOk */</comment>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YbAttrProcessorState</name></type> <name>state</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>htup</name></decl>;</decl_stmt>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>YbApplyAttr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>attrel</name></expr></argument>, <argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>YbCompleteAttrProcessing</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>YbStartNewAttrProcessing</name><argument_list>(
			    <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>sys_relations_update_required</name></expr></argument>, <argument><expr><name>attrel</name></expr></argument>, <argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>YbCompleteAttrProcessing</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>YBUpdateRelationsPartitioning</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>sys_relations_update_required</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>partrel</name> <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name>PartitionedRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scandesc</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(
	    <argument><expr><name>partrel</name></expr></argument>, <argument><expr><name>PartitionedRelationId</name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* indexOk */</comment>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>htup</name></decl>;</decl_stmt>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_partitioned_table</name></type> <name>part_table_form</name> <init>=
		    <expr><operator>(</operator><name>Form_pg_partitioned_table</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>RelationIdCacheLookup</name><argument_list>(<argument><expr><name><name>part_table_form</name><operator>-&gt;</operator><name>partrelid</name></name></expr></argument>, <argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>relation</name> <operator>&amp;&amp;</operator>
		    <name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator>
		    <operator>(</operator><name>sys_relations_update_required</name> <operator>||</operator> <operator>!</operator><call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Initialize key and partition descriptor info */</comment>
			<expr_stmt><expr><call><name>RelationBuildPartitionKey</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>RelationBuildPartitionDesc</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>YbIndexProcessorState</name> <block>{
	<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>	<name>oidIndex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>	<name>pkeyIndex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>	<name>candidateIndex</name></decl>;</decl_stmt>
}</block></struct></type> <name>YbIndexProcessorState</name>;</typedef>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>YbIsIndexProcessingStarted</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>YbIndexProcessorState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>YbIsIndexProcessingRequired</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>YbIndexProcessorState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>state</name><operator>-&gt;</operator><name>relation</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>YbApplyIndex</name><parameter_list>(<parameter><decl><type><name>YbIndexProcessorState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>htup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>index</name> <init>= <expr><operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>YbIsIndexProcessingStarted</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>state</name><operator>-&gt;</operator><name>relid</name></name> <operator>!=</operator> <name><name>index</name><operator>-&gt;</operator><name>indrelid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>YbIsIndexProcessingRequired</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Further code is copy-paste from the RelationGetIndexList function */</comment>

	<comment type="block">/* Add index's OID to result list in the proper order */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <call><name>insert_ordered_oid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>result</name></name></expr></argument>, <argument><expr><name><name>index</name><operator>-&gt;</operator><name>indexrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * indclass cannot be referenced directly through the C struct,
	 * because it comes after the variable-width indkey field.  Must
	 * extract the datum the hard way...
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>indclassDatum</name> <init>= <expr><call><name>heap_getattr</name><argument_list>(
		<argument><expr><name>htup</name></expr></argument>, <argument><expr><name>Anum_pg_index_indclass</name></expr></argument>, <argument><expr><call><name>GetPgIndexDescriptor</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>oidvector</name> <modifier>*</modifier></type><name>indclass</name> <init>= <expr><operator>(</operator><name>oidvector</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>indclassDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Invalid, non-unique, non-immediate or predicate indexes aren't
	 * interesting for either oid indexes or replication identity indexes,
	 * so don't check them.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IndexIsValid</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><name><name>index</name><operator>-&gt;</operator><name>indisunique</name></name> <operator>||</operator>
		<operator>!</operator><name><name>index</name><operator>-&gt;</operator><name>indimmediate</name></name> <operator>||</operator>
		<operator>!</operator><call><name>heap_attisnull</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><name>Anum_pg_index_indpred</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Check to see if is a usable btree index on OID */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>indnatts</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
		<name><name>index</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>ObjectIdAttributeNumber</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>indclass</name><operator>-&gt;</operator><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>OID_BTREE_OPS_OID</name> <operator>||</operator>
		 <name><name>indclass</name><operator>-&gt;</operator><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>OID_LSM_OPS_OID</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>oidIndex</name></name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>indexrelid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* remember primary key index if any */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>indisprimary</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>pkeyIndex</name></name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>indexrelid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* remember explicitly chosen replica index */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>indisreplident</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>candidateIndex</name></name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>indexrelid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>YbCompleteIndexProcessingImpl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>YbIndexProcessorState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>YbIsIndexProcessingRequired</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>relation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>oidIndex</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>oidIndex</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>pkeyIndex</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>pkeyIndex</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>candidateIndex</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>candidateIndex</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>result</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>replident</name> <init>= <expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relreplident</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Further code is copy-paste from the RelationGetIndexList function */</comment>

	<comment type="block">/* Now save a copy of the completed list in the relcache entry. */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>oldlist</name> <init>= <expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexlist</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexlist</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_oidindex</name></name> <operator>=</operator> <name>oidIndex</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_pkindex</name></name> <operator>=</operator> <name>pkeyIndex</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>replident</name> <operator>==</operator> <name>REPLICA_IDENTITY_DEFAULT</name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>pkeyIndex</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_replidindex</name></name> <operator>=</operator> <name>pkeyIndex</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>replident</name> <operator>==</operator> <name>REPLICA_IDENTITY_INDEX</name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>candidateIndex</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_replidindex</name></name> <operator>=</operator> <name>candidateIndex</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_replidindex</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexvalid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Don't leak the old list, if there is one */</comment>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>oldlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>YbCompleteIndexProcessing</name><parameter_list>(<parameter><decl><type><name>YbIndexProcessorState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>YbIsIndexProcessingStarted</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>YbIsIndexProcessingRequired</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>YbCompleteIndexProcessingImpl</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>state</name> <operator>=</operator> <operator>(</operator>struct <name>YbIndexProcessorState</name><operator>)</operator><block>{<expr><literal type="number">0</literal></expr>}</block></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>YbStartNewIndexProcessing</name><parameter_list>(<parameter><decl><type><name>YbIndexProcessorState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
                          <parameter><decl><type><name>bool</name></type> <name>sys_rel_update_required</name></decl></parameter>,
                          <parameter><decl><type><name>HeapTuple</name></type> <name>htup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>YbIsIndexProcessingStarted</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>index</name> <init>= <expr><operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>indrelid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>indrelid</name></name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>RelationIdCacheLookup</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>relation</name> <operator>||</operator> <operator>(</operator><operator>!</operator><name>sys_rel_update_required</name> <operator>&amp;&amp;</operator> <call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>relation</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>applied</name> <init>= <expr><call><name>YbApplyIndex</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>applied</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>applied</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * YBUpdateRelationsIndicies updates the rd_indexlist field for all relations.
 * The result of calling this function is identical to call the
 * RelationGetIndexList postgres' native function for each relation.
 * But such implementation is not an optimal due to system table preloading
 * mechanism.
 * The RelationGetIndexList function updates the rd_indexlist field for
 * particular relation and it make a search for entries in the rd_index system
 * table by specifying relation's id as a key. But due to system table
 * preloading mechanism search in rd_index system will return all the rows from
 * pg_index and YSQL layer will filter rows which much
 * specified key (i.e. relation's id).
 * As a result in case we have M relation and N rows in pg_index YSQL will have
 * to build and process M * N tuples.
 * The current implementation processes all the rows in pg_index once.
 * As a result the complexity is O(N) instead of O(N * M).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>YBUpdateRelationsIndicies</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>sys_relations_update_required</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>indrel</name> <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name>IndexRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>indscan</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(
		<argument><expr><name>indrel</name></expr></argument>, <argument><expr><name>IndexIndrelidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* indexOk */</comment>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>htup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YbIndexProcessorState</name></type> <name>state</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>indscan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>index</name> <init>= <expr><operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/*
		 * Ignore any indexes that are currently being dropped.  This will
		 * prevent them from being searched, inserted into, or considered in
		 * HOT-safety decisions.  It's unsafe to touch such an index at all
		 * since its catalog entries could disappear at any instant.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IndexIsLive</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>YbApplyIndex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>YbCompleteIndexProcessing</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>YbStartNewIndexProcessing</name><argument_list>(
				<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>sys_relations_update_required</name></expr></argument>, <argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>YbCompleteIndexProcessing</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>indscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>indrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>YBIsDBConnectionValid</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * DB connection is not valid anymore in case:
	 * - The name is already dropped from the cache.
	 * - The name is still in the cache, but it is not associated with MyDatabaseId anymore
	 *   (i.e. invalid or new DB).
	 * - Any kind of error is raised. The reason of this case is sys table preloading mechanism.
	 *   To reduce the total number of RPC postgres will send multiple read operations in single RPC.
	 *   And these read operations tries to read data from MyDatabaseId tables. As a result in case
	 *   the MyDatabaseId DB is dropped these read operations will fail due to "Not found" error.
	 */</comment>

	<decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbname</name> <init>= <expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>dbname</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>get_database_oid</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>MyDatabaseId</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>YBPreloadRelCache</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * During the cache loading process postgres reads the data from multiple sys tables.
	 * It is reasonable to prefetch all these tables in one shot.
	 */</comment>
	<expr_stmt><expr><call><name>YbTryRegisterCatalogVersionTableForPrefetching</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>YbRegisterSysTableForPrefetching</name><argument_list>(<argument><expr><name>DatabaseRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>              <comment type="line">// pg_database</comment>
	<expr_stmt><expr><call><name>YbRegisterSysTableForPrefetching</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>              <comment type="line">// pg_class</comment>
	<expr_stmt><expr><call><name>YbRegisterSysTableForPrefetching</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>             <comment type="line">// pg_attribute</comment>
	<expr_stmt><expr><call><name>YbRegisterSysTableForPrefetching</name><argument_list>(<argument><expr><name>OperatorClassRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>         <comment type="line">// pg_opclass</comment>
	<expr_stmt><expr><call><name>YbRegisterSysTableForPrefetching</name><argument_list>(<argument><expr><name>AccessMethodRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>          <comment type="line">// pg_am</comment>
	<expr_stmt><expr><call><name>YbRegisterSysTableForPrefetching</name><argument_list>(<argument><expr><name>AccessMethodProcedureRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// pg_amproc</comment>
	<expr_stmt><expr><call><name>YbRegisterSysTableForPrefetching</name><argument_list>(<argument><expr><name>IndexRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                 <comment type="line">// pg_index</comment>
	<expr_stmt><expr><call><name>YbRegisterSysTableForPrefetching</name><argument_list>(<argument><expr><name>RewriteRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>               <comment type="line">// pg_rewrite</comment>
	<expr_stmt><expr><call><name>YbRegisterSysTableForPrefetching</name><argument_list>(<argument><expr><name>AttrDefaultRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>           <comment type="line">// pg_attrdef</comment>
	<expr_stmt><expr><call><name>YbRegisterSysTableForPrefetching</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            <comment type="line">// pg_constraint</comment>
	<expr_stmt><expr><call><name>YbRegisterSysTableForPrefetching</name><argument_list>(<argument><expr><name>PartitionedRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>           <comment type="line">// pg_partitioned_table</comment>
	<expr_stmt><expr><call><name>YbRegisterSysTableForPrefetching</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                  <comment type="line">// pg_type</comment>
	<expr_stmt><expr><call><name>YbRegisterSysTableForPrefetching</name><argument_list>(<argument><expr><name>NamespaceRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>             <comment type="line">// pg_namespace</comment>
	<expr_stmt><expr><call><name>YbRegisterSysTableForPrefetching</name><argument_list>(<argument><expr><name>AuthIdRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                <comment type="line">// pg_authid</comment>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>YBIsDBConnectionValid</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
		        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
		         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Could not reconnect to database"</literal></expr></argument>)</argument_list></call><operator>,</operator>
		         <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Database might have been dropped by another user"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The preloading catalog cache before processing relations will help to avoid
	 * sequential scans over prefetched data.
	 * In case postgres tries to read row from the cache by a key and there is
	 * no such row in it, postgres will sent request to read particular row
	 * from a particular system table. But in case table was prefetched all the
	 * rows will be returned from in-memory cache in spite of the fact only single
	 * one was requested. And required row will be found by filtering out all rows
	 * which doesn't match specified key (i.e. sequential scan).
	 * In case particular table has N rows and it is required to load all of them
	 * N * N tuples will be built and analyzed from already prefetched data.
	 * The more effective approach is to build entire cache first. In this case
	 * only N tuples will be built.
	 */</comment>
	<expr_stmt><expr><call><name>YbPreloadCatalogCache</name><argument_list>(<argument><expr><name>DATABASEOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>             <comment type="line">// pg_database</comment>
	<expr_stmt><expr><call><name>YbPreloadCatalogCache</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>RELNAMENSP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>          <comment type="line">// pg_class</comment>
	<expr_stmt><expr><call><name>YbPreloadCatalogCache</name><argument_list>(<argument><expr><name>ATTNAME</name></expr></argument>, <argument><expr><name>ATTNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>             <comment type="line">// pg_attribute</comment>
	<expr_stmt><expr><call><name>YbPreloadCatalogCache</name><argument_list>(<argument><expr><name>CLAOID</name></expr></argument>, <argument><expr><name>CLAAMNAMENSP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="line">// pg_opclass</comment>
	<expr_stmt><expr><call><name>YbPreloadCatalogCache</name><argument_list>(<argument><expr><name>AMOID</name></expr></argument>, <argument><expr><name>AMNAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>               <comment type="line">// pg_am</comment>
	<expr_stmt><expr><call><name>YbPreloadCatalogCache</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>              <comment type="line">// pg_index</comment>
	<expr_stmt><expr><call><name>YbPreloadCatalogCache</name><argument_list>(<argument><expr><name>RULERELNAME</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>             <comment type="line">// pg_rewrite</comment>
	<expr_stmt><expr><call><name>YbPreloadCatalogCache</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>               <comment type="line">// pg_constraint</comment>
	<expr_stmt><expr><call><name>YbPreloadCatalogCache</name><argument_list>(<argument><expr><name>PARTRELID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>               <comment type="line">// pg_partitioned_table</comment>
	<expr_stmt><expr><call><name>YbPreloadCatalogCache</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><name>TYPENAMENSP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="line">// pg_type</comment>
	<expr_stmt><expr><call><name>YbPreloadCatalogCache</name><argument_list>(<argument><expr><name>NAMESPACEOID</name></expr></argument>, <argument><expr><name>NAMESPACENAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// pg_namespace</comment>
	<expr_stmt><expr><call><name>YbPreloadCatalogCache</name><argument_list>(<argument><expr><name>AUTHOID</name></expr></argument>, <argument><expr><name>AUTHNAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>           <comment type="line">// pg_authid</comment>

	<decl_stmt><decl><type><name>YBLoadRelationsResult</name></type> <name>relations_result</name> <init>= <expr><call><name>YBLoadRelations</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Preload other tables if needed.
	 * This is the optimization to prevent master node from being overloaded with lots of fat read
	 * requests (request which reads too much tables) in case there are lots of opened connections.
	 * Some of our tests has such setup. Reading all the tables in one request on a debug build
	 * under heavy load may spend up to 5-6 secs.
	 * This optimization can be removed after the request cache for sys catalog will be
	 * introduced (#10821). It will be possible to load all the tables with a single request as the
	 * number of such fat requests will be significantly decreased.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relations_result</name><operator>.</operator><name>has_relations_with_trigger</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>YbRegisterSysTableForPrefetching</name><argument_list>(<argument><expr><name>TriggerRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>   <comment type="line">// pg_trigger</comment>

	<if_stmt><if>if <condition>(<expr><name><name>relations_result</name><operator>.</operator><name>has_relations_with_row_security</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>YbRegisterSysTableForPrefetching</name><argument_list>(<argument><expr><name>PolicyRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>    <comment type="line">// pg_policy</comment>

	<if_stmt><if>if <condition>(<expr><name><name>relations_result</name><operator>.</operator><name>has_partitioned_tables</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>YbRegisterSysTableForPrefetching</name><argument_list>(<argument><expr><name>ProcedureRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// pg_proc</comment>
		<expr_stmt><expr><call><name>YbRegisterSysTableForPrefetching</name><argument_list>(<argument><expr><name>InheritsRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="line">// pg_inherits</comment>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>YBUpdateRelationsAttributes</name><argument_list>(<argument><expr><name><name>relations_result</name><operator>.</operator><name>sys_relations_update_required</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>YBUpdateRelationsPartitioning</name><argument_list>(<argument><expr><name><name>relations_result</name><operator>.</operator><name>sys_relations_update_required</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>relations_result</name><operator>.</operator><name>has_partitioned_tables</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>YbPreloadCatalogCache</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>PROCNAMEARGSNSP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// pg_proc</comment>
		<expr_stmt><expr><call><name>YbPreloadCatalogCache</name><argument_list>(<argument><expr><name>INHERITSRELID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="line">// pg_inherits</comment>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>YBUpdateRelationsIndicies</name><argument_list>(<argument><expr><name><name>relations_result</name><operator>.</operator><name>sys_relations_update_required</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * The first request after the cache refresh will call the
	 * recomputeNamespacePath function. And this function will try to find
	 * namespace equal to username. In spite of the fact that we have already
	 * loaded caches for the `pg_namespace` table such finding may initiate read
	 * RPC to a master in case such namespace doesn't exists. In this case cache
	 * will create negative entry. To avoid this RPC we try to find namespace
	 * here. As far as data for the `pg_namespace` table is preloaded no RPC will
	 * be sent a master and negative cache entry will be created for a future use.
	 */</comment>
	<expr_stmt><expr><call><name>get_namespace_oid</name><argument_list>(<argument><expr><call><name>GetUserNameFromId</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>YbUpdateCatalogCacheVersion</name><argument_list>(<argument><expr><call><name>YbGetMasterCatalogVersion</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		RelationBuildDesc
 *
 *		Build a relation descriptor.  The caller must hold at least
 *		AccessShareLock on the target relid.
 *
 *		The new descriptor is inserted into the hash table if insertIt is true.
 *
 *		Returns NULL if no pg_class row could be found for the given relid
 *		(suggesting we are trying to access a just-deleted relation).
 *		Any other error is reported via elog.
 */</comment>
<function><type><specifier>static</specifier> <name>Relation</name></type>
<name>RelationBuildDesc</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>targetRelId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>insertIt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>pg_class_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>relp</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * find the tuple in pg_class corresponding to the given relation id
	 */</comment>
	<expr_stmt><expr><name>pg_class_tuple</name> <operator>=</operator> <call><name>ScanPgRelation</name><argument_list>(<argument><expr><name>targetRelId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * if no such tuple exists, return NULL
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>pg_class_tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * get information from the pg_class_tuple
	 */</comment>
	<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>pg_class_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>relp</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>pg_class_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>relid</name> <operator>==</operator> <name>targetRelId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * allocate storage for the relation descriptor, and copy pg_class_tuple
	 * to relation-&gt;rd_rel.
	 */</comment>
	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>AllocateRelationDesc</name><argument_list>(<argument><expr><name>relp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * initialize the relation's relation id (relation-&gt;rd_id)
	 */</comment>
	<expr_stmt><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * normal relations are not nailed into the cache; nor can a pre-existing
	 * relation be new.  It could be temp though.  (Actually, it could be new
	 * too, but it's okay to forget that fact if forced to flush the entry.)
	 */</comment>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_refcnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_isnailed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_createSubid</name></name> <operator>=</operator> <name>InvalidSubTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_newRelfilenodeSubid</name></name> <operator>=</operator> <name>InvalidSubTransactionId</name></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RELPERSISTENCE_UNLOGGED</name></expr>:</case>
		<case>case <expr><name>RELPERSISTENCE_PERMANENT</name></expr>:</case>
			<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_backend</name></name> <operator>=</operator> <name>InvalidBackendId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_islocaltemp</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELPERSISTENCE_TEMP</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>isTempOrTempToastNamespace</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_backend</name></name> <operator>=</operator> <call><name>BackendIdForTempRelations</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_islocaltemp</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * If it's a temp table, but not one of ours, we have to use
				 * the slow, grotty method to figure out the owning backend.
				 *
				 * Note: it's possible that rd_backend gets set to MyBackendId
				 * here, in case we are looking at a pg_class entry left over
				 * from a crashed backend that coincidentally had the same
				 * BackendId we're using.  We should *not* consider such a
				 * table to be "ours"; this is why we need the separate
				 * rd_islocaltemp flag.  The pg_class entry will get flushed
				 * if/when we clean out the corresponding temp table namespace
				 * in preparation for using it.
				 */</comment>
				<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_backend</name></name> <operator>=</operator>
					<call><name>GetTempNamespaceBackendId</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_backend</name></name> <operator>!=</operator> <name>InvalidBackendId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_islocaltemp</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid relpersistence: %c"</literal></expr></argument>,
				 <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * initialize the tuple descriptor (relation-&gt;rd_att).
	 */</comment>
	<expr_stmt><expr><call><name>RelationBuildTupleDesc</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fetch rules and triggers that affect this relation
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasrules</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RelationBuildRuleLock</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rules</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rulescxt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhastriggers</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RelationBuildTriggers</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>trigdesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relrowsecurity</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RelationBuildRowSecurity</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rsdesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* foreign key data is not loaded till asked for */</comment>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_fkeylist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_fkeyvalid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* if a partitioned table, initialize key and partition descriptor info */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RelationBuildPartitionKey</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RelationBuildPartitionDesc</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_partkeycxt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_partkey</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_partdesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_pdcxt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * if it's an index, initialize index-related information
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RelationInitIndexAccessInfo</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* extract reloptions if any */</comment>
	<expr_stmt><expr><call><name>RelationParseRelOptions</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>pg_class_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * initialize the relation lock manager information
	 */</comment>
	<expr_stmt><expr><call><name>RelationInitLockInfo</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* see lmgr.c */</comment>

	<comment type="block">/*
	 * initialize physical addressing information for the relation
	 */</comment>
	<expr_stmt><expr><call><name>RelationInitPhysicalAddr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* make sure relation is marked as having no open file yet */</comment>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_smgr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * now we can free the memory allocated for pg_class_tuple
	 */</comment>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>pg_class_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Insert newly created relation into relcache hash table, if requested.
	 *
	 * There is one scenario in which we might find a hashtable entry already
	 * present, even though our caller failed to find it: if the relation is a
	 * system catalog or index that's used during relcache load, we might have
	 * recursively created the same relcache entry during the preceding steps.
	 * So allow RelationCacheInsert to delete any already-present relcache
	 * entry for the same OID.  The already-present entry should have refcount
	 * zero (else somebody forgot to close it); in the event that it doesn't,
	 * we'll elog a WARNING and leak the already-present entry.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>insertIt</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RelationCacheInsert</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* It's fully valid */</comment>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_isvalid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><name>relation</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the physical addressing info (RelFileNode) for a relcache entry
 *
 * Note: at the physical level, relations in the pg_global tablespace must
 * be treated as shared, even if relisshared isn't set.  Hence we do not
 * look at relisshared here.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RelationInitPhysicalAddr</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltablespace</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name> <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltablespace</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name> <operator>=</operator> <name>MyDatabaseTableSpace</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name> <operator>==</operator> <name>GLOBALTABLESPACE_OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsYBRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	  <return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relfilenode</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Even if we are using a decoding snapshot that doesn't represent the
		 * current state of the catalog we need to make sure the filenode
		 * points to the current file since the older file will be gone (or
		 * truncated). The new file will still contain older rows so lookups
		 * in them will work correctly. This wouldn't work correctly if
		 * rewrites were allowed to change the schema in an incompatible way,
		 * but those are prevented both on catalog tables and on user tables
		 * declared as additional catalog tables.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>HistoricSnapshotActive</name><argument_list>()</argument_list></call>
			<operator>&amp;&amp;</operator> <call><name>RelationIsAccessibleInLogicalDecoding</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call>
			<operator>&amp;&amp;</operator> <call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>phys_tuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>physrel</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>phys_tuple</name> <operator>=</operator> <call><name>ScanPgRelation</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ClassOidIndexId</name></expr></argument>,
										<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>phys_tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find pg_class entry for %u"</literal></expr></argument>,
					 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>physrel</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>phys_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltablespace</name></name> <operator>=</operator> <name><name>physrel</name><operator>-&gt;</operator><name>reltablespace</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relfilenode</name></name> <operator>=</operator> <name><name>physrel</name><operator>-&gt;</operator><name>relfilenode</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>phys_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name> <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relfilenode</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Consult the relation mapper */</comment>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name> <operator>=</operator>
			<call><name>RelationMapOidToFilenode</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>,
									 <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relisshared</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find relation mapping for relation \"%s\", OID %u"</literal></expr></argument>,
				 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Fill in the IndexAmRoutine for an index relation.
 *
 * relation's rd_amhandler and rd_indexcxt must be valid already.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitIndexAmRoutine</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexAmRoutine</name> <modifier>*</modifier></type><name>cached</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Call the amhandler in current, short-lived memory context, just in case
	 * it leaks anything (it probably won't, but let's be paranoid).
	 */</comment>
	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>GetIndexAmRoutine</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_amhandler</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* OK, now transfer the data into relation's rd_indexcxt. */</comment>
	<expr_stmt><expr><name>cached</name> <operator>=</operator> <operator>(</operator><name>IndexAmRoutine</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexcxt</name></name></expr></argument>,
												   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexAmRoutine</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>cached</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexAmRoutine</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_amroutine</name></name> <operator>=</operator> <name>cached</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize index-access-method support data for an index relation
 */</comment>
<function><type><name>void</name></type>
<name>RelationInitIndexAccessInfo</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_am</name></type>	<name>aform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>indcollDatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>indclassDatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>indoptionDatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>indcoll</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>indclass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int2vector</name> <modifier>*</modifier></type><name>indoption</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>indexcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>indnatts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>indnkeyatts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>amsupport</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Make a copy of the pg_index entry for the index.  Since pg_index
	 * contains variable-length and possibly-null fields, we have to do this
	 * honestly rather than just treating it as a Form_pg_index struct.
	 */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>,
							<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indextuple</name></name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_index</name></name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indextuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Look up the index's access method, save the OID of its handler function
	 */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AMOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for access method %u"</literal></expr></argument>,
			 <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>aform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_am</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_amhandler</name></name> <operator>=</operator> <name><name>aform</name><operator>-&gt;</operator><name>amhandler</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>indnatts</name> <operator>=</operator> <call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>indnatts</name> <operator>!=</operator> <call><name>IndexRelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"relnatts disagrees with indnatts for index %u"</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>indnkeyatts</name> <operator>=</operator> <call><name>IndexRelationGetNumberOfKeyAttributes</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make the private context to hold index access info.  The reason we need
	 * a context, and not just a couple of pallocs, is so that we won't leak
	 * any subsidiary info attached to fmgr lookup records.
	 */</comment>
	<expr_stmt><expr><name>indexcxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>,
									 <argument><expr><literal type="string">"index info"</literal></expr></argument>,
									 <argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexcxt</name></name> <operator>=</operator> <name>indexcxt</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextCopyAndSetIdentifier</name><argument_list>(<argument><expr><name>indexcxt</name></expr></argument>,
									  <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now we can fetch the index AM's API struct
	 */</comment>
	<expr_stmt><expr><call><name>InitIndexAmRoutine</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate arrays to hold data. Opclasses are not used for included
	 * columns, so allocate them for indnkeyatts only.
	 */</comment>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_opfamily</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>indexcxt</name></expr></argument>, <argument><expr><name>indnkeyatts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_opcintype</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>indexcxt</name></expr></argument>, <argument><expr><name>indnkeyatts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>amsupport</name> <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_amroutine</name><operator>-&gt;</operator><name>amsupport</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>amsupport</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>nsupport</name> <init>= <expr><name>indnatts</name> <operator>*</operator> <name>amsupport</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_support</name></name> <operator>=</operator> <operator>(</operator><name>RegProcedure</name> <operator>*</operator><operator>)</operator>
			<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>indexcxt</name></expr></argument>, <argument><expr><name>nsupport</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RegProcedure</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_supportinfo</name></name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator>
			<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>indexcxt</name></expr></argument>, <argument><expr><name>nsupport</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_support</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_supportinfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indcollation</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>indexcxt</name></expr></argument>, <argument><expr><name>indnkeyatts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indoption</name></name> <operator>=</operator> <operator>(</operator><name>int16</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>indexcxt</name></expr></argument>, <argument><expr><name>indnkeyatts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * indcollation cannot be referenced directly through the C struct,
	 * because it comes after the variable-width indkey field.  Must extract
	 * the datum the hard way...
	 */</comment>
	<expr_stmt><expr><name>indcollDatum</name> <operator>=</operator> <call><name>fastgetattr</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indextuple</name></name></expr></argument>,
							   <argument><expr><name>Anum_pg_index_indcollation</name></expr></argument>,
							   <argument><expr><call><name>GetPgIndexDescriptor</name><argument_list>()</argument_list></call></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>indcoll</name> <operator>=</operator> <operator>(</operator><name>oidvector</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>indcollDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indcollation</name></name></expr></argument>, <argument><expr><name><name>indcoll</name><operator>-&gt;</operator><name>values</name></name></expr></argument>, <argument><expr><name>indnkeyatts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * indclass cannot be referenced directly through the C struct, because it
	 * comes after the variable-width indkey field.  Must extract the datum
	 * the hard way...
	 */</comment>
	<expr_stmt><expr><name>indclassDatum</name> <operator>=</operator> <call><name>fastgetattr</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indextuple</name></name></expr></argument>,
								<argument><expr><name>Anum_pg_index_indclass</name></expr></argument>,
								<argument><expr><call><name>GetPgIndexDescriptor</name><argument_list>()</argument_list></call></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>indclass</name> <operator>=</operator> <operator>(</operator><name>oidvector</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>indclassDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fill the support procedure OID array, as well as the info about
	 * opfamilies and opclass input types.  (aminfo and supportinfo are left
	 * as zeroes, and are filled on-the-fly when used)
	 */</comment>
	<expr_stmt><expr><call><name>IndexSupportInitialize</name><argument_list>(<argument><expr><name>indclass</name></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_support</name></name></expr></argument>,
						   <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_opfamily</name></name></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_opcintype</name></name></expr></argument>,
						   <argument><expr><name>amsupport</name></expr></argument>, <argument><expr><name>indnkeyatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Similarly extract indoption and copy it to the cache entry
	 */</comment>
	<expr_stmt><expr><name>indoptionDatum</name> <operator>=</operator> <call><name>fastgetattr</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indextuple</name></name></expr></argument>,
								 <argument><expr><name>Anum_pg_index_indoption</name></expr></argument>,
								 <argument><expr><call><name>GetPgIndexDescriptor</name><argument_list>()</argument_list></call></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>indoption</name> <operator>=</operator> <operator>(</operator><name>int2vector</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>indoptionDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indoption</name></name></expr></argument>, <argument><expr><name><name>indoption</name><operator>-&gt;</operator><name>values</name></name></expr></argument>, <argument><expr><name>indnkeyatts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * expressions, predicate, exclusion caches will be filled later
	 */</comment>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexprs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indpred</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_exclops</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_exclprocs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_exclstrats</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_amcache</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * IndexSupportInitialize
 *		Initializes an index's cached opclass information,
 *		given the index's pg_index.indclass entry.
 *
 * Data is returned into *indexSupport, *opFamily, and *opcInType,
 * which are arrays allocated by the caller.
 *
 * The caller also passes maxSupportNumber and maxAttributeNumber, since these
 * indicate the size of the arrays it has allocated --- but in practice these
 * numbers must always match those obtainable from the system catalog entries
 * for the index and access method.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>IndexSupportInitialize</name><parameter_list>(<parameter><decl><type><name>oidvector</name> <modifier>*</modifier></type><name>indclass</name></decl></parameter>,
					   <parameter><decl><type><name>RegProcedure</name> <modifier>*</modifier></type><name>indexSupport</name></decl></parameter>,
					   <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>opFamily</name></decl></parameter>,
					   <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>opcInType</name></decl></parameter>,
					   <parameter><decl><type><name>StrategyNumber</name></type> <name>maxSupportNumber</name></decl></parameter>,
					   <parameter><decl><type><name>AttrNumber</name></type> <name>maxAttributeNumber</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>attIndex</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>attIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attIndex</name> <operator>&lt;</operator> <name>maxAttributeNumber</name></expr>;</condition> <incr><expr><name>attIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OpClassCacheEnt</name> <modifier>*</modifier></type><name>opcentry</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>indclass</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>attIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus pg_index tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* look up the info for this opclass, using a cache */</comment>
		<expr_stmt><expr><name>opcentry</name> <operator>=</operator> <call><name>LookupOpclassInfo</name><argument_list>(<argument><expr><name><name>indclass</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>attIndex</name></expr>]</index></name></expr></argument>,
									 <argument><expr><name>maxSupportNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* copy cached data into relcache entry */</comment>
		<expr_stmt><expr><name><name>opFamily</name><index>[<expr><name>attIndex</name></expr>]</index></name> <operator>=</operator> <name><name>opcentry</name><operator>-&gt;</operator><name>opcfamily</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opcInType</name><index>[<expr><name>attIndex</name></expr>]</index></name> <operator>=</operator> <name><name>opcentry</name><operator>-&gt;</operator><name>opcintype</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>maxSupportNumber</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>indexSupport</name><index>[<expr><name>attIndex</name> <operator>*</operator> <name>maxSupportNumber</name></expr>]</index></name></expr></argument>,
				   <argument><expr><name><name>opcentry</name><operator>-&gt;</operator><name>supportProcs</name></name></expr></argument>,
				   <argument><expr><name>maxSupportNumber</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RegProcedure</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * LookupOpclassInfo
 *
 * This routine maintains a per-opclass cache of the information needed
 * by IndexSupportInitialize().  This is more efficient than relying on
 * the catalog cache, because we can load all the info about a particular
 * opclass in a single indexscan of pg_amproc.
 *
 * The information from pg_am about expected range of support function
 * numbers is passed in, rather than being looked up, mainly because the
 * caller will have it already.
 *
 * Note there is no provision for flushing the cache.  This is OK at the
 * moment because there is no way to ALTER any interesting properties of an
 * existing opclass --- all you can do is drop it, which will result in
 * a useless but harmless dead entry in the cache.  To support altering
 * opclass membership (not the same as opfamily membership!), we'd need to
 * be able to flush this cache as well as the contents of relcache entries
 * for indexes.
 */</comment>
<function><type><specifier>static</specifier> <name>OpClassCacheEnt</name> <modifier>*</modifier></type>
<name>LookupOpclassInfo</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>operatorClassOid</name></decl></parameter>,
				  <parameter><decl><type><name>StrategyNumber</name></type> <name>numSupport</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OpClassCacheEnt</name> <modifier>*</modifier></type><name>opcentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>htup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>indexOK</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>OpClassCache</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* First time through: initialize the opclass cache */</comment>
		<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>ctl</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OpClassCacheEnt</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name>OpClassCache</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Operator class cache"</literal></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Also make sure CacheMemoryContext exists */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>CacheMemoryContext</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CreateCacheMemoryContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>opcentry</name> <operator>=</operator> <operator>(</operator><name>OpClassCacheEnt</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>OpClassCache</name></expr></argument>,
											   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>operatorClassOid</name></expr></argument>,
											   <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Need to allocate memory for new entry */</comment>
		<expr_stmt><expr><name><name>opcentry</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* until known OK */</comment>
		<expr_stmt><expr><name><name>opcentry</name><operator>-&gt;</operator><name>numSupport</name></name> <operator>=</operator> <name>numSupport</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>numSupport</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>opcentry</name><operator>-&gt;</operator><name>supportProcs</name></name> <operator>=</operator> <operator>(</operator><name>RegProcedure</name> <operator>*</operator><operator>)</operator>
				<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>,
									   <argument><expr><name>numSupport</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RegProcedure</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>opcentry</name><operator>-&gt;</operator><name>supportProcs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numSupport</name> <operator>==</operator> <name><name>opcentry</name><operator>-&gt;</operator><name>numSupport</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * When testing for cache-flush hazards, we intentionally disable the
	 * operator class cache and force reloading of the info on each call. This
	 * is helpful because we want to test the case where a cache flush occurs
	 * while we are loading the info, and it's very hard to provoke that if
	 * this happens only once per opclass per backend.
	 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CLOBBER_CACHE_ALWAYS</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><name><name>opcentry</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name><name>opcentry</name><operator>-&gt;</operator><name>valid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>opcentry</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Need to fill in new entry.
	 *
	 * To avoid infinite recursion during startup, force heap scans if we're
	 * looking up info for the opclasses used by the indexes we would like to
	 * reference here.
	 */</comment>
	<expr_stmt><expr><name>indexOK</name> <operator>=</operator> <name>criticalRelcachesBuilt</name> <operator>||</operator>
		<operator>(</operator><name>operatorClassOid</name> <operator>!=</operator> <name>OID_BTREE_OPS_OID</name> <operator>&amp;&amp;</operator>
		 <name>operatorClassOid</name> <operator>!=</operator> <name>OID_LSM_OPS_OID</name> <operator>&amp;&amp;</operator>
		 <name>operatorClassOid</name> <operator>!=</operator> <name>INT2_BTREE_OPS_OID</name> <operator>&amp;&amp;</operator>
		 <name>operatorClassOid</name> <operator>!=</operator> <name>INT2_LSM_OPS_OID</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * We have to fetch the pg_opclass row to determine its opfamily and
	 * opcintype, which are needed to look up related operators and functions.
	 * It'd be convenient to use the syscache here, but that probably doesn't
	 * work while bootstrapping.
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>ObjectIdAttributeNumber</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>operatorClassOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>OperatorClassRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>OpclassOidIndexId</name></expr></argument>, <argument><expr><name>indexOK</name></expr></argument>,
	                          <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_opclass</name></type> <name>opclassform</name> <init>= <expr><operator>(</operator><name>Form_pg_opclass</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>opcentry</name><operator>-&gt;</operator><name>opcfamily</name></name> <operator>=</operator> <name><name>opclassform</name><operator>-&gt;</operator><name>opcfamily</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opcentry</name><operator>-&gt;</operator><name>opcintype</name></name> <operator>=</operator> <name><name>opclassform</name><operator>-&gt;</operator><name>opcintype</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find tuple for opclass %u"</literal></expr></argument>, <argument><expr><name>operatorClassOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan pg_amproc to obtain support procs for the opclass.  We only fetch
	 * the default ones (those with lefttype = righttype = opcintype).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numSupport</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>Anum_pg_amproc_amprocfamily</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>opcentry</name><operator>-&gt;</operator><name>opcfamily</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>Anum_pg_amproc_amproclefttype</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>opcentry</name><operator>-&gt;</operator><name>opcintype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>Anum_pg_amproc_amprocrighttype</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>opcentry</name><operator>-&gt;</operator><name>opcintype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AccessMethodProcedureRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessMethodProcedureIndexId</name></expr></argument>, <argument><expr><name>indexOK</name></expr></argument>,
		                          <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_amproc</name></type> <name>amprocform</name> <init>= <expr><operator>(</operator><name>Form_pg_amproc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>amprocform</name><operator>-&gt;</operator><name>amprocnum</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
					<operator>(</operator><name>StrategyNumber</name><operator>)</operator> <name><name>amprocform</name><operator>-&gt;</operator><name>amprocnum</name></name> <operator>&gt;</operator> <name>numSupport</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid amproc number %d for opclass %u"</literal></expr></argument>,
				     <argument><expr><name><name>amprocform</name><operator>-&gt;</operator><name>amprocnum</name></name></expr></argument>, <argument><expr><name>operatorClassOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>opcentry</name><operator>-&gt;</operator><name>supportProcs</name><index>[<expr><name><name>amprocform</name><operator>-&gt;</operator><name>amprocnum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
					<name><name>amprocform</name><operator>-&gt;</operator><name>amproc</name></name></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>opcentry</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<return>return <expr><name>opcentry</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *		formrdesc
 *
 *		This is a special cut-down version of RelationBuildDesc(),
 *		used while initializing the relcache.
 *		The relation descriptor is built just from the supplied parameters,
 *		without actually looking at any system table entries.  We cheat
 *		quite a lot since we only need to work for a few basic system
 *		catalogs.
 *
 * The catalogs this is used for can't have constraints (except attnotnull),
 * default values, rules, or triggers, since we don't cope with any of that.
 * (Well, actually, this only matters for properties that need to be valid
 * during bootstrap or before RelationCacheInitializePhase3 runs, and none of
 * these properties matter then...)
 *
 * NOTE: we assume we are already switched into CacheMemoryContext.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>formrdesc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relationName</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationReltype</name></decl></parameter>,
		  <parameter><decl><type><name>bool</name></type> <name>isshared</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>hasoids</name></decl></parameter>,
		  <parameter><decl><type><name>int</name></type> <name>natts</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FormData_pg_attribute</name> <modifier>*</modifier></type><name>attrs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_not_null</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * allocate new relation desc, clear all fields of reldesc
	 */</comment>
	<expr_stmt><expr><name>relation</name> <operator>=</operator> <operator>(</operator><name>Relation</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelationData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* make sure relation is marked as having no open file yet */</comment>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_smgr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * initialize reference count: 1 because it is nailed in cache
	 */</comment>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_refcnt</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * all entries built with this routine are nailed-in-cache; none are for
	 * new or temp relations.
	 */</comment>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_isnailed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_createSubid</name></name> <operator>=</operator> <name>InvalidSubTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_newRelfilenodeSubid</name></name> <operator>=</operator> <name>InvalidSubTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_backend</name></name> <operator>=</operator> <name>InvalidBackendId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_islocaltemp</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * initialize relation tuple form
	 *
	 * The data we insert here is pretty incomplete/bogus, but it'll serve to
	 * get us launched.  RelationCacheInitializePhase3() will read the real
	 * data from pg_class and replace what we've done here.  Note in
	 * particular that relowner is left as zero; this cues
	 * RelationCacheInitializePhase3 that the real data isn't there yet.
	 */</comment>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name></name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>CLASS_TUPLE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnamespace</name></name> <operator>=</operator> <name>PG_CATALOG_NAMESPACE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name> <operator>=</operator> <name>relationReltype</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * It's important to distinguish between shared and non-shared relations,
	 * even at bootstrap time, to make sure we know where they are stored.
	 */</comment>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relisshared</name></name> <operator>=</operator> <name>isshared</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isshared</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltablespace</name></name> <operator>=</operator> <name>GLOBALTABLESPACE_OID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* formrdesc is used only for permanent relations */</comment>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>=</operator> <name>RELPERSISTENCE_PERMANENT</name></expr>;</expr_stmt>

	<comment type="block">/* ... and they're always populated, too */</comment>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispopulated</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relreplident</name></name> <operator>=</operator> <name>REPLICA_IDENTITY_NOTHING</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpages</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relallvisible</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name>RELKIND_RELATION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name> <operator>=</operator> <name>hasoids</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnatts</name></name> <operator>=</operator> <operator>(</operator><name>int16</name><operator>)</operator> <name>natts</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * initialize attribute tuple form
	 *
	 * Unlike the case with the relation tuple, this data had better be right
	 * because it will never be replaced.  The data comes from
	 * src/include/catalog/ headers via genbki.pl.
	 */</comment>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name></name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>natts</name></expr></argument>, <argument><expr><name>hasoids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>tdrefcount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* mark as refcounted */</comment>

	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>tdtypeid</name></name> <operator>=</operator> <name>relationReltype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>tdtypmod</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* unnecessary, but... */</comment>

	<comment type="block">/*
	 * initialize tuple desc info
	 */</comment>
	<expr_stmt><expr><name>has_not_null</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><operator>&amp;</operator><name><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
			   <argument><expr><name>ATTRIBUTE_FIXED_PART_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>has_not_null</name> <operator>|=</operator> <name><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>attnotnull</name></expr>;</expr_stmt>
		<comment type="block">/* make sure attcacheoff is valid */</comment>
		<expr_stmt><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attcacheoff</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* initialize first attribute's attcacheoff, cf RelationBuildTupleDesc */</comment>
	<expr_stmt><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attcacheoff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* mark not-null status */</comment>
	<if_stmt><if>if <condition>(<expr><name>has_not_null</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleConstr</name> <modifier>*</modifier></type><name>constr</name> <init>= <expr><operator>(</operator><name>TupleConstr</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TupleConstr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>has_not_null</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name> <operator>=</operator> <name>constr</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * initialize relation id from info in att array (my, this is ugly)
	 */</comment>
	<expr_stmt><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attrelid</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * All relations made with formrdesc are mapped.  This is necessarily so
	 * because there is no other way to know what filenode they currently
	 * have.  In bootstrap mode, add them to the initial relation mapper data,
	 * specifying that the initial filenode is the same as the OID.
	 */</comment>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relfilenode</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RelationMapUpdateMap</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>isshared</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * initialize the relation lock manager information
	 */</comment>
	<expr_stmt><expr><call><name>RelationInitLockInfo</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* see lmgr.c */</comment>

	<comment type="block">/*
	 * initialize physical addressing information for the relation
	 */</comment>
	<expr_stmt><expr><call><name>RelationInitPhysicalAddr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * initialize the rel-has-index flag, using hardwired knowledge
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* In bootstrap mode, we have no indexes */</comment>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasindex</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Otherwise, all the rels formrdesc is used for have indexes */</comment>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasindex</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * add new reldesc to relcache
	 */</comment>
	<expr_stmt><expr><call><name>RelationCacheInsert</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* It's fully valid */</comment>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_isvalid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 *				 Relation Descriptor Lookup Interface
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/*
 *		RelationIdGetRelation
 *
 *		Lookup a reldesc by OID; make one if not already in cache.
 *
 *		Returns NULL if no pg_class row could be found for the given relid
 *		(suggesting we are trying to access a just-deleted relation).
 *		Any other error is reported via elog.
 *
 *		NB: caller should already have at least AccessShareLock on the
 *		relation ID, else there are nasty race conditions.
 *
 *		NB: relation ref count is incremented, or set to 1 if new entry.
 *		Caller should eventually decrement count.  (Usually,
 *		that happens by calling RelationClose().)
 */</comment>
<function><type><name>Relation</name></type>
<name>RelationIdGetRelation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rd</name></decl>;</decl_stmt>

	<comment type="block">/* Make sure we're in an xact, even if this ends up being a cache hit */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * first try to find reldesc in the cache
	 */</comment>
	<expr_stmt><expr><call><name>RelationIdCacheLookup</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RelationIsValid</name><argument_list>(<argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RelationIncrementReferenceCount</name><argument_list>(<argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* revalidate cache entry if necessary */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rd</name><operator>-&gt;</operator><name>rd_isvalid</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Indexes only have a limited number of possible schema changes,
			 * and we don't want to use the full-blown procedure because it's
			 * a headache for indexes that reload itself depends on.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rd</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
				<name><name>rd</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>RelationReloadIndexInfo</name><argument_list>(<argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>RelationClearRelation</name><argument_list>(<argument><expr><name>rd</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/*
			 * Normally entries need to be valid here, but before the relcache
			 * has been initialized, not enough infrastructure exists to
			 * perform pg_class lookups. The structure of such entries doesn't
			 * change, but we still want to update the rd_rel entry. So
			 * rd_isvalid = false is left in place for a later lookup.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rd</name><operator>-&gt;</operator><name>rd_isvalid</name></name> <operator>||</operator>
				   <operator>(</operator><name><name>rd</name><operator>-&gt;</operator><name>rd_isnailed</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>criticalRelcachesBuilt</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>rd</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * YB note:
	 * These would lead to an infinite recursion and should never be possible.
	 * See how RelationCacheInvalidate works.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>relationId</name> <operator>==</operator> <name>RelationRelationId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"pg_class cache is queried before it's initalized!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>relationId</name> <operator>==</operator> <name>ClassOidIndexId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"pg_class_oid_index is queried before it's initalized!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * no reldesc in the cache, so have RelationBuildDesc() build one and add
	 * it.
	 */</comment>
	<expr_stmt><expr><name>rd</name> <operator>=</operator> <call><name>RelationBuildDesc</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>RelationIsValid</name><argument_list>(<argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RelationIncrementReferenceCount</name><argument_list>(<argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>rd</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *				cache invalidation support routines
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * RelationIncrementReferenceCount
 *		Increments relation reference count.
 *
 * Note: bootstrap mode has its own weird ideas about relation refcount
 * behavior; we ought to fix it someday, but for now, just disable
 * reference count ownership tracking in bootstrap mode.
 */</comment>
<function><type><name>void</name></type>
<name>RelationIncrementReferenceCount</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ResourceOwnerEnlargeRelationRefs</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_refcnt</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResourceOwnerRememberRelationRef</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RelationDecrementReferenceCount
 *		Decrements relation reference count.
 */</comment>
<function><type><name>void</name></type>
<name>RelationDecrementReferenceCount</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_refcnt</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_refcnt</name></name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResourceOwnerForgetRelationRef</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RelationClose - close an open relation
 *
 *	Actually, we just decrement the refcount.
 *
 *	NOTE: if compiled with -DRELCACHE_FORCE_RELEASE then relcache entries
 *	will be freed as soon as their refcount goes to zero.  In combination
 *	with aset.c's CLOBBER_FREED_MEMORY option, this provides a good test
 *	to catch references to already-released relcache entries.  It slows
 *	things down quite a bit, however.
 */</comment>
<function><type><name>void</name></type>
<name>RelationClose</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Note: no locking manipulations needed */</comment>
	<expr_stmt><expr><call><name>RelationDecrementReferenceCount</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RELCACHE_FORCE_RELEASE</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><call><name>RelationHasReferenceCountZero</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name><name>relation</name><operator>-&gt;</operator><name>rd_createSubid</name></name> <operator>==</operator> <name>InvalidSubTransactionId</name> <operator>&amp;&amp;</operator>
		<name><name>relation</name><operator>-&gt;</operator><name>rd_newRelfilenodeSubid</name></name> <operator>==</operator> <name>InvalidSubTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RelationClearRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * RelationReloadIndexInfo - reload minimal information for an open index
 *
 *	This function is used only for indexes.  A relcache inval on an index
 *	can mean that its pg_class or pg_index row changed.  There are only
 *	very limited changes that are allowed to an existing index's schema,
 *	so we can update the relcache entry without a complete rebuild; which
 *	is fortunate because we can't rebuild an index entry that is "nailed"
 *	and/or in active use.  We support full replacement of the pg_class row,
 *	as well as updates of a few simple fields of the pg_index row.
 *
 *	We can't necessarily reread the catalog rows right away; we might be
 *	in a failed transaction when we receive the SI notification.  If so,
 *	RelationClearRelation just marks the entry as invalid by setting
 *	rd_isvalid to false.  This routine is called to fix the entry when it
 *	is next needed.
 *
 *	We assume that at the time we are called, we have at least AccessShareLock
 *	on the target index.  (Note: in the calls from RelationClearRelation,
 *	this is legitimate because we know the rel has positive refcount.)
 *
 *	If the target index is an index on pg_class or pg_index, we'd better have
 *	previously gotten at least AccessShareLock on its underlying catalog,
 *	else we are at risk of deadlock against someone trying to exclusive-lock
 *	the heap and index in that order.  This is ensured in current usage by
 *	only applying this to indexes being opened or having positive refcount.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RelationReloadIndexInfo</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>indexOK</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>pg_class_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>relp</name></decl>;</decl_stmt>

	<comment type="block">/* Should be called only for invalidated indexes */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
			<name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name><operator>)</operator> <operator>&amp;&amp;</operator>
		   <operator>!</operator><name><name>relation</name><operator>-&gt;</operator><name>rd_isvalid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Ensure it's closed at smgr level */</comment>
	<expr_stmt><expr><call><name>RelationCloseSmgr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Must free any AM cached data upon relcache flush */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_amcache</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_amcache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_amcache</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it's a shared index, we might be called before backend startup has
	 * finished selecting a database, in which case we have no way to read
	 * pg_class yet.  However, a shared index can never have any significant
	 * schema updates, so it's okay to ignore the invalidation signal.  Just
	 * mark it valid and return without doing anything more.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relisshared</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>criticalRelcachesBuilt</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_isvalid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Read the pg_class row
	 *
	 * Don't try to use an indexscan of pg_class_oid_index to reload the info
	 * for pg_class_oid_index ...
	 */</comment>
	<expr_stmt><expr><name>indexOK</name> <operator>=</operator> <operator>(</operator><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ClassOidIndexId</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>pg_class_tuple</name> <operator>=</operator> <call><name>ScanPgRelation</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>indexOK</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>pg_class_tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find pg_class tuple for index %u"</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>relp</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>pg_class_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name></name></expr></argument>, <argument><expr><name>relp</name></expr></argument>, <argument><expr><name>CLASS_TUPLE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Reload reloptions in case they changed */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_options</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>RelationParseRelOptions</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>pg_class_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* done with pg_class tuple */</comment>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>pg_class_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* We must recalculate physical address in case it changed */</comment>
	<expr_stmt><expr><call><name>RelationInitPhysicalAddr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For a non-system index, there are fields of the pg_index row that are
	 * allowed to change, so re-read that row and update the relcache entry.
	 * Most of the info derived from pg_index (such as support function lookup
	 * info) cannot change, and indeed the whole point of this routine is to
	 * update the relcache entry without clobbering that data; so wholesale
	 * replacement is not appropriate.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>index</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>,
								<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>,
				 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>index</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Basically, let's just copy all the bool fields.  There are one or
		 * two of these that can't actually change in the current code, but
		 * it's not worth it to track exactly which ones they are.  None of
		 * the array fields are allowed to change, though.
		 */</comment>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisunique</name></name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>indisunique</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisprimary</name></name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>indisprimary</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisexclusion</name></name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>indisexclusion</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indimmediate</name></name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>indimmediate</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisclustered</name></name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>indisclustered</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisvalid</name></name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>indisvalid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indcheckxmin</name></name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>indcheckxmin</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisready</name></name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>indisready</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indislive</name></name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>indislive</name></name></expr>;</expr_stmt>

		<comment type="block">/* Copy xmin too, as that is needed to make sense of indcheckxmin */</comment>
		<expr_stmt><expr><call><name>HeapTupleHeaderSetXmin</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indextuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>,
							   <argument><expr><call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Okay, now it's valid again */</comment>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_isvalid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RelationReloadNailed - reload minimal information for nailed relations.
 *
 * The structure of a nailed relation can never change (which is good, because
 * we rely on knowing their structure to be able to read catalog content). But
 * some parts, e.g. pg_class.relfrozenxid, are still important to have
 * accurate content for. Therefore those need to be reloaded after the arrival
 * of invalidations.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RelationReloadNailed</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_isnailed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Redo RelationInitPhysicalAddr in case it is a mapped relation whose
	 * mapping changed.
	 */</comment>
	<expr_stmt><expr><call><name>RelationInitPhysicalAddr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* flag as needing to be revalidated */</comment>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_isvalid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Can only reread catalog contents if in a transaction.  If the relation
	 * is currently open (not counting the nailed refcount), do so
	 * immediately. Otherwise we've already marked the entry as possibly
	 * invalid, and it'll be fixed when next opened.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsTransactionState</name><argument_list>()</argument_list></call> <operator>||</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_refcnt</name></name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_INDEX</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If it's a nailed-but-not-mapped index, then we need to re-read the
		 * pg_class row to see if its relfilenode changed.
		 */</comment>
		<expr_stmt><expr><call><name>RelationReloadIndexInfo</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Reload a non-index entry.  We can't easily do so if relcaches
		 * aren't yet built, but that's fine because at that stage the
		 * attributes that need to be current (like relfrozenxid) aren't yet
		 * accessed.  To ensure the entry will later be revalidated, we leave
		 * it in invalid state, but allow use (cf. RelationIdGetRelation()).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>criticalRelcachesBuilt</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>pg_class_tuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>relp</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * NB: Mark the entry as valid before starting to scan, to avoid
			 * self-recursion when re-building pg_class.
			 */</comment>
			<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_isvalid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>pg_class_tuple</name> <operator>=</operator> <call><name>ScanPgRelation</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>relp</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>pg_class_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name></name></expr></argument>, <argument><expr><name>relp</name></expr></argument>, <argument><expr><name>CLASS_TUPLE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>pg_class_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Again mark as valid, to protect against concurrently arriving
			 * invalidations.
			 */</comment>
			<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_isvalid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RelationDestroyRelation
 *
 *	Physically delete a relation cache entry and all subsidiary data.
 *	Caller must already have unhooked the entry from the hash table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RelationDestroyRelation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>remember_tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationHasReferenceCountZero</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure smgr and lower levels close the relation's files, if they
	 * weren't closed already.  (This was probably done by caller, but let's
	 * just be real sure.)
	 */</comment>
	<expr_stmt><expr><call><name>RelationCloseSmgr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Free all the subsidiary data structures of the relcache entry, then the
	 * entry itself.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* can't use DecrTupleDescRefCount here */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>tdrefcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>--</operator><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>tdrefcount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we Rebuilt a relcache entry during a transaction then its
		 * possible we did that because the TupDesc changed as the result of
		 * an ALTER TABLE that ran at less than AccessExclusiveLock. It's
		 * possible someone copied that TupDesc, in which case the copy would
		 * point to free'd memory. So if we rebuild an entry we keep the
		 * TupDesc around until end of transaction, to be safe.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>remember_tupdesc</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>RememberToFreeTupleDescAtEOX</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FreeTupleDesc</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>FreeTriggerDesc</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>trigdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_fkeylist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_statlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexattr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_projindexattr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_keyattr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_pkattr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_idattr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_projidx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_pubactions</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_pubactions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_options</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indextuple</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indextuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexcxt</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rulescxt</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rulescxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rsdesc</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rsdesc</name><operator>-&gt;</operator><name>rscxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_partkeycxt</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_partkeycxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_pdcxt</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_pdcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_partcheck</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_partcheck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_fdwroutine</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_fdwroutine</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RelationClearRelation
 *
 *	 Physically blow away a relation cache entry, or reset it and rebuild
 *	 it from scratch (that is, from catalog entries).  The latter path is
 *	 used when we are notified of a change to an open relation (one with
 *	 refcount &gt; 0).
 *
 *	 NB: when rebuilding, we'd better hold some lock on the relation,
 *	 else the catalog data we need to read could be changing under us.
 *	 Also, a rel to be rebuilt had better have refcnt &gt; 0.  This is because
 *	 a sinval reset could happen while we're accessing the catalogs, and
 *	 the rel would get blown away underneath us by RelationCacheInvalidate
 *	 if it has zero refcnt.
 *
 *	 The "rebuild" parameter is redundant in current usage because it has
 *	 to match the relation's refcnt status, but we keep it as a crosscheck
 *	 that we're doing what the caller expects.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RelationClearRelation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>rebuild</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * As per notes above, a rel to be rebuilt MUST have refcnt &gt; 0; while of
	 * course it would be an equally bad idea to blow away one with nonzero
	 * refcnt, since that would leave someone somewhere with a dangling
	 * pointer.  All callers are expected to have verified that this holds.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><ternary><condition><expr><name>rebuild</name></expr> ?</condition><then>
		   <expr><operator>!</operator><call><name>RelationHasReferenceCountZero</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr> </then><else>:
		   <expr><call><name>RelationHasReferenceCountZero</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure smgr and lower levels close the relation's files, if they
	 * weren't closed already.  If the relation is not getting deleted, the
	 * next smgr access should reopen the files automatically.  This ensures
	 * that the low-level file access state is updated after, say, a vacuum
	 * truncation.
	 */</comment>
	<expr_stmt><expr><call><name>RelationCloseSmgr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Treat nailed-in system relations separately, they always need to be
	 * accessible, so we can't blow them away.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_isnailed</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RelationReloadNailed</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Even non-system indexes should not be blown away if they are open and
	 * have valid index support information.  This avoids problems with active
	 * use of the index support information.  As with nailed indexes, we
	 * re-read the pg_class row to handle possible physical relocation of the
	 * index, and we check for pg_index updates too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
		 <name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<name><name>relation</name><operator>-&gt;</operator><name>rd_refcnt</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name><name>relation</name><operator>-&gt;</operator><name>rd_indexcxt</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_isvalid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* needs to be revalidated */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>RelationReloadIndexInfo</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Mark it invalid until we've finished rebuild */</comment>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_isvalid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we're really done with the relcache entry, blow it away. But if
	 * someone is still using it, reconstruct the whole deal without moving
	 * the physical RelationData record (so that the someone's pointer is
	 * still valid).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rebuild</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Remove it from the hash table */</comment>
		<expr_stmt><expr><call><name>RelationCacheDelete</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* And release storage */</comment>
		<expr_stmt><expr><call><name>RelationDestroyRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we're not inside a valid transaction, we can't do any catalog
		 * access so it's not possible to rebuild yet.  Just exit, leaving
		 * rd_isvalid = false so that the rebuild will occur when the entry is
		 * next opened.
		 *
		 * Note: it's possible that we come here during subtransaction abort,
		 * and the reason for wanting to rebuild is that the rel is open in
		 * the outer transaction.  In that case it might seem unsafe to not
		 * rebuild immediately, since whatever code has the rel already open
		 * will keep on using the relcache entry as-is.  However, in such a
		 * case the outer transaction should be holding a lock that's
		 * sufficient to prevent any significant change in the rel's schema,
		 * so the existing entry contents should be good enough for its
		 * purposes; at worst we might be behind on statistics updates or the
		 * like.  (See also CheckTableNotInUse() and its callers.)	These same
		 * remarks also apply to the cases above where we exit without having
		 * done RelationReloadIndexInfo() yet.
		 */</comment>
		<return>return;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Our strategy for rebuilding an open relcache entry is to build a
		 * new entry from scratch, swap its contents with the old entry, and
		 * finally delete the new entry (along with any infrastructure swapped
		 * over from the old entry).  This is to avoid trouble in case an
		 * error causes us to lose control partway through.  The old entry
		 * will still be marked !rd_isvalid, so we'll try to rebuild it again
		 * on next access.  Meanwhile it's not any less valid than it was
		 * before, so any code that might expect to continue accessing it
		 * isn't hurt by the rebuild failure.  (Consider for example a
		 * subtransaction that ALTERs a table and then gets canceled partway
		 * through the cache entry rebuild.  The outer transaction should
		 * still see the not-modified cache entry as valid.)  The worst
		 * consequence of an error is leaking the necessarily-unreferenced new
		 * entry, and this shouldn't happen often enough for that to be a big
		 * problem.
		 *
		 * When rebuilding an open relcache entry, we must preserve ref count,
		 * rd_createSubid/rd_newRelfilenodeSubid, and rd_toastoid state.  Also
		 * attempt to preserve the pg_class entry (rd_rel), tupledesc,
		 * rewrite-rule, partition key, and partition descriptor substructures
		 * in place, because various places assume that these structures won't
		 * move while they are working with an open relcache entry.  (Note:
		 * the refcount mechanism for tupledescs might someday allow us to
		 * remove this hack for the tupledesc.)
		 *
		 * Note that this process does not touch CurrentResourceOwner; which
		 * is good because whatever ref counts the entry may have do not
		 * necessarily belong to that resource owner.
		 */</comment>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>newrel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>save_relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>keep_tupdesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>keep_rules</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>keep_policies</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>keep_partkey</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>keep_partdesc</name></decl>;</decl_stmt>

		<comment type="block">/* Build temporary entry, but don't link it into hashtable */</comment>
		<expr_stmt><expr><name>newrel</name> <operator>=</operator> <call><name>RelationBuildDesc</name><argument_list>(<argument><expr><name>save_relid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newrel</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We can validly get here, if we're using a historic snapshot in
			 * which a relation, accessed from outside logical decoding, is
			 * still invisible. In that case it's fine to just mark the
			 * relation as invalid and return - it'll fully get reloaded by
			 * the cache reset at the end of logical decoding (or at the next
			 * access).  During normal processing we don't want to ignore this
			 * case as it shouldn't happen there, as explained below.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>HistoricSnapshotActive</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * This shouldn't happen as dropping a relation is intended to be
			 * impossible if still referenced (cf. CheckTableNotInUse()). But
			 * if we get here anyway, we can't just delete the relcache entry,
			 * as it possibly could get accessed later (as e.g. the error
			 * might get trapped and handled via a subtransaction rollback).
			 */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"relation %u deleted while still in use"</literal></expr></argument>, <argument><expr><name>save_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>keep_tupdesc</name> <operator>=</operator> <call><name>equalTupleDescs</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name><name>newrel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>keep_rules</name> <operator>=</operator> <call><name>equalRuleLocks</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rules</name></name></expr></argument>, <argument><expr><name><name>newrel</name><operator>-&gt;</operator><name>rd_rules</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>keep_policies</name> <operator>=</operator> <call><name>equalRSDesc</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rsdesc</name></name></expr></argument>, <argument><expr><name><name>newrel</name><operator>-&gt;</operator><name>rd_rsdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* partkey is immutable once set up, so we can always keep it */</comment>
		<expr_stmt><expr><name>keep_partkey</name> <operator>=</operator> <operator>(</operator><name><name>relation</name><operator>-&gt;</operator><name>rd_partkey</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>keep_partdesc</name> <operator>=</operator> <call><name>equalPartitionDescs</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_partkey</name></name></expr></argument>,
											<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_partdesc</name></name></expr></argument>,
											<argument><expr><name><name>newrel</name><operator>-&gt;</operator><name>rd_partdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Perform swapping of the relcache entry contents.  Within this
		 * process the old entry is momentarily invalid, so there *must* be no
		 * possibility of CHECK_FOR_INTERRUPTS within this sequence. Do it in
		 * all-in-line code for safety.
		 *
		 * Since the vast majority of fields should be swapped, our method is
		 * to swap the whole structures and then re-swap those few fields we
		 * didn't want swapped.
		 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SWAPFIELD</name><parameter_list>(<parameter><type><name>fldtype</name></type></parameter>, <parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
		<cpp:value>do { \
			fldtype _tmp = newrel-&gt;fldname; \
			newrel-&gt;fldname = relation-&gt;fldname; \
			relation-&gt;fldname = _tmp; \
		} while (0)</cpp:value></cpp:define>

		<comment type="block">/* swap all Relation struct fields */</comment>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RelationData</name></type> <name>tmpstruct</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpstruct</name></expr></argument>, <argument><expr><name>newrel</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelationData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newrel</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelationData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmpstruct</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelationData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* rd_smgr must not be swapped, due to back-links from smgr level */</comment>
		<expr_stmt><expr><call><name>SWAPFIELD</name><argument_list>(<argument><expr><name>SMgrRelation</name></expr></argument>, <argument><expr><name>rd_smgr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* rd_refcnt must be preserved */</comment>
		<expr_stmt><expr><call><name>SWAPFIELD</name><argument_list>(<argument><expr><name>int</name></expr></argument>, <argument><expr><name>rd_refcnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* isnailed shouldn't change */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>newrel</name><operator>-&gt;</operator><name>rd_isnailed</name></name> <operator>==</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_isnailed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* creation sub-XIDs must be preserved */</comment>
		<expr_stmt><expr><call><name>SWAPFIELD</name><argument_list>(<argument><expr><name>SubTransactionId</name></expr></argument>, <argument><expr><name>rd_createSubid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SWAPFIELD</name><argument_list>(<argument><expr><name>SubTransactionId</name></expr></argument>, <argument><expr><name>rd_newRelfilenodeSubid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* un-swap rd_rel pointers, swap contents instead */</comment>
		<expr_stmt><expr><call><name>SWAPFIELD</name><argument_list>(<argument><expr><name>Form_pg_class</name></expr></argument>, <argument><expr><name>rd_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* ... but actually, we don't have to update newrel-&gt;rd_rel */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name></name></expr></argument>, <argument><expr><name><name>newrel</name><operator>-&gt;</operator><name>rd_rel</name></name></expr></argument>, <argument><expr><name>CLASS_TUPLE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* preserve old tupledesc, rules, policies if no logical change */</comment>
		<if_stmt><if>if <condition>(<expr><name>keep_tupdesc</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SWAPFIELD</name><argument_list>(<argument><expr><name>TupleDesc</name></expr></argument>, <argument><expr><name>rd_att</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>keep_rules</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>SWAPFIELD</name><argument_list>(<argument><expr><name>RuleLock</name> <operator>*</operator></expr></argument>, <argument><expr><name>rd_rules</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SWAPFIELD</name><argument_list>(<argument><expr><name>MemoryContext</name></expr></argument>, <argument><expr><name>rd_rulescxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>keep_policies</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SWAPFIELD</name><argument_list>(<argument><expr><name>RowSecurityDesc</name> <operator>*</operator></expr></argument>, <argument><expr><name>rd_rsdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* toast OID override must be preserved */</comment>
		<expr_stmt><expr><call><name>SWAPFIELD</name><argument_list>(<argument><expr><name>Oid</name></expr></argument>, <argument><expr><name>rd_toastoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* pgstat_info must be preserved */</comment>
		<expr_stmt><expr><call><name>SWAPFIELD</name><argument_list>(<argument><expr>struct <name>PgStat_TableStatus</name> <operator>*</operator></expr></argument>, <argument><expr><name>pgstat_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* preserve old partitioning info if no logical change */</comment>
		<if_stmt><if>if <condition>(<expr><name>keep_partkey</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>SWAPFIELD</name><argument_list>(<argument><expr><name>PartitionKey</name></expr></argument>, <argument><expr><name>rd_partkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SWAPFIELD</name><argument_list>(<argument><expr><name>MemoryContext</name></expr></argument>, <argument><expr><name>rd_partkeycxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>keep_partdesc</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>SWAPFIELD</name><argument_list>(<argument><expr><name>PartitionDesc</name></expr></argument>, <argument><expr><name>rd_partdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SWAPFIELD</name><argument_list>(<argument><expr><name>MemoryContext</name></expr></argument>, <argument><expr><name>rd_pdcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SWAPFIELD</name></cpp:undef>

		<comment type="block">/* And now we can throw away the temporary entry */</comment>
		<expr_stmt><expr><call><name>RelationDestroyRelation</name><argument_list>(<argument><expr><name>newrel</name></expr></argument>, <argument><expr><operator>!</operator><name>keep_tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RelationFlushRelation
 *
 *	 Rebuild the relation if it is open (refcount &gt; 0), else blow it away.
 *	 This is used when we receive a cache invalidation event for the rel.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RelationFlushRelation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_createSubid</name></name> <operator>!=</operator> <name>InvalidSubTransactionId</name> <operator>||</operator>
		<name><name>relation</name><operator>-&gt;</operator><name>rd_newRelfilenodeSubid</name></name> <operator>!=</operator> <name>InvalidSubTransactionId</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * New relcache entries are always rebuilt, not flushed; else we'd
		 * forget the "new" status of the relation, which is a useful
		 * optimization to have.  Ditto for the new-relfilenode status.
		 *
		 * The rel could have zero refcnt here, so temporarily increment the
		 * refcnt to ensure it's safe to rebuild it.  We can assume that the
		 * current transaction has some lock on the rel already.
		 */</comment>
		<expr_stmt><expr><call><name>RelationIncrementReferenceCount</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RelationClearRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RelationDecrementReferenceCount</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Pre-existing rels can be dropped from the relcache if not open.
		 */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>rebuild</name> <init>= <expr><operator>!</operator><call><name>RelationHasReferenceCountZero</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>RelationClearRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>rebuild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RelationForgetRelation - unconditionally remove a relcache entry
 *
 *		   External interface for destroying a relcache entry when we
 *		   drop the relation.
 */</comment>
<function><type><name>void</name></type>
<name>RelationForgetRelation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>rid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>RelationIdCacheLookup</name><argument_list>(<argument><expr><name>rid</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* not in cache, nothing to do */</comment>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationHasReferenceCountZero</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"relation %u is still open"</literal></expr></argument>, <argument><expr><name>rid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Unconditionally destroy the relcache entry */</comment>
	<expr_stmt><expr><call><name>RelationClearRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		RelationCacheInvalidateEntry
 *
 *		This routine is invoked for SI cache flush messages.
 *
 * Any relcache entry matching the relid must be flushed.  (Note: caller has
 * already determined that the relid belongs to our database or is a shared
 * relation.)
 *
 * We used to skip local relations, on the grounds that they could
 * not be targets of cross-backend SI update messages; but it seems
 * safer to process them, so that our *own* SI update messages will
 * have the same effects during CommandCounterIncrement for both
 * local and nonlocal relations.
 */</comment>
<function><type><name>void</name></type>
<name>RelationCacheInvalidateEntry</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>RelationIdCacheLookup</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>relcacheInvalsReceived</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RelationFlushRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RelationCacheInvalidate
 *	 Blow away cached relation descriptors that have zero reference counts,
 *	 and rebuild those with positive reference counts.  Also reset the smgr
 *	 relation cache and re-read relation mapping data.
 *
 *	 This is currently used only to recover from SI message buffer overflow,
 *	 so we do not touch new-in-transaction relations; they cannot be targets
 *	 of cross-backend SI updates (and our own updates now go through a
 *	 separate linked list that isn't limited by the SI message buffer size).
 *	 Likewise, we need not discard new-relfilenode-in-transaction hints,
 *	 since any invalidation of those would be a local event.
 *
 *	 We do this in two phases: the first pass deletes deletable items, and
 *	 the second one rebuilds the rebuildable items.  This is essential for
 *	 safety, because hash_seq_search only copes with concurrent deletion of
 *	 the element it is currently visiting.  If a second SI overflow were to
 *	 occur while we are walking the table, resulting in recursive entry to
 *	 this routine, we could crash because the inner invocation blows away
 *	 the entry next to be visited by the outer scan.  But this way is OK,
 *	 because (a) during the first pass we won't process any more SI messages,
 *	 so hash_seq_search will complete safely; (b) during the second pass we
 *	 only hold onto pointers to nondeletable entries.
 *
 *	 The two-phase approach also makes it easy to update relfilenodes for
 *	 mapped relations before we do anything else, and to ensure that the
 *	 second pass processes nailed-in-cache items before other nondeletable
 *	 items.  This should ensure that system catalogs are up to date before
 *	 we attempt to use them to reload information about other open relations.
 */</comment>
<function><type><name>void</name></type>
<name>RelationCacheInvalidate</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelIdCacheEnt</name> <modifier>*</modifier></type><name>idhentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rebuildFirstList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rebuildList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Reload relation mapping data before starting to reconstruct cache.
	 */</comment>
	<expr_stmt><expr><call><name>RelationMapInvalidateAll</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Phase 1 */</comment>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>RelationIdCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>idhentry</name> <operator>=</operator> <operator>(</operator><name>RelIdCacheEnt</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>relation</name> <operator>=</operator> <name><name>idhentry</name><operator>-&gt;</operator><name>reldesc</name></name></expr>;</expr_stmt>

		<comment type="block">/* Must close all smgr references to avoid leaving dangling ptrs */</comment>
		<expr_stmt><expr><call><name>RelationCloseSmgr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Ignore new relations; no other backend will manipulate them before
		 * we commit.  Likewise, before replacing a relation's relfilenode, we
		 * shall have acquired AccessExclusiveLock and drained any applicable
		 * pending invalidations.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_createSubid</name></name> <operator>!=</operator> <name>InvalidSubTransactionId</name> <operator>||</operator>
			<name><name>relation</name><operator>-&gt;</operator><name>rd_newRelfilenodeSubid</name></name> <operator>!=</operator> <name>InvalidSubTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>relcacheInvalsReceived</name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>RelationHasReferenceCountZero</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Delete this entry immediately */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>relation</name><operator>-&gt;</operator><name>rd_isnailed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>RelationClearRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * If it's a mapped relation, immediately update its rd_node in
			 * case its relfilenode changed.  We must do this during phase 1
			 * in case the relation is consulted during rebuild of other
			 * relcache entries in phase 2.  It's safe since consulting the
			 * map doesn't involve any access to relcache entries.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>RelationIsMapped</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>RelationInitPhysicalAddr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Add this entry to list of stuff to rebuild in second pass.
			 * pg_class goes to the front of rebuildFirstList while
			 * pg_class_oid_index goes to the back of rebuildFirstList, so
			 * they are done first and second respectively.  Other nailed
			 * relations go to the front of rebuildList, so they'll be done
			 * next in no particular order; and everything else goes to the
			 * back of rebuildList.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RelationRelationId</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>rebuildFirstList</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>rebuildFirstList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ClassOidIndexId</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>rebuildFirstList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rebuildFirstList</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_isnailed</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>rebuildList</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>rebuildList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>rebuildList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rebuildList</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Now zap any remaining smgr cache entries.  This must happen before we
	 * start to rebuild entries, since that may involve catalog fetches which
	 * will re-open catalog files.
	 */</comment>
	<expr_stmt><expr><call><name>smgrcloseall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Phase 2: rebuild the items found to need rebuild in phase 1 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>rebuildFirstList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>relation</name> <operator>=</operator> <operator>(</operator><name>Relation</name><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RelationClearRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>rebuildFirstList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>rebuildList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>relation</name> <operator>=</operator> <operator>(</operator><name>Relation</name><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RelationClearRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>rebuildList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RelationCloseSmgrByOid - close a relcache entry's smgr link
 *
 * Needed in some cases where we are changing a relation's physical mapping.
 * The link will be automatically reopened on next use.
 */</comment>
<function><type><name>void</name></type>
<name>RelationCloseSmgrByOid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>RelationIdCacheLookup</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* not in cache, nothing to do */</comment>

	<expr_stmt><expr><call><name>RelationCloseSmgr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>RememberToFreeTupleDescAtEOX</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>td</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>EOXactTupleDescArray</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>EOXactTupleDescArray</name> <operator>=</operator> <operator>(</operator><name>TupleDesc</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><literal type="number">16</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TupleDesc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>EOXactTupleDescArrayLen</name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>NextEOXactTupleDescNum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>NextEOXactTupleDescNum</name> <operator>&gt;=</operator> <name>EOXactTupleDescArrayLen</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type>		<name>newlen</name> <init>= <expr><name>EOXactTupleDescArrayLen</name> <operator>*</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>EOXactTupleDescArrayLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>EOXactTupleDescArray</name> <operator>=</operator> <operator>(</operator><name>TupleDesc</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>EOXactTupleDescArray</name></expr></argument>,
													  <argument><expr><name>newlen</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TupleDesc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>EOXactTupleDescArrayLen</name> <operator>=</operator> <name>newlen</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>EOXactTupleDescArray</name><index>[<expr><name>NextEOXactTupleDescNum</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>td</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AtEOXact_RelationCache
 *
 *	Clean up the relcache at main-transaction commit or abort.
 *
 * Note: this must be called *before* processing invalidation messages.
 * In the case of abort, we don't want to try to rebuild any invalidated
 * cache entries (since we can't safely do database accesses).  Therefore
 * we must reset refcnts before handling pending invalidations.
 *
 * As of PostgreSQL 8.1, relcache refcnts should get released by the
 * ResourceOwner mechanism.  This routine just does a debugging
 * cross-check that no pins remain.  However, we also need to do special
 * cleanup when the current transaction created any relations or made use
 * of forced index lists.
 */</comment>
<function><type><name>void</name></type>
<name>AtEOXact_RelationCache</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelIdCacheEnt</name> <modifier>*</modifier></type><name>idhentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Unless the eoxact_list[] overflowed, we only need to examine the rels
	 * listed in it.  Otherwise fall back on a hash_seq_search scan.
	 *
	 * For simplicity, eoxact_list[] entries are not deleted till end of
	 * top-level transaction, even though we could remove them at
	 * subtransaction end in some cases, or remove relations from the list if
	 * they are cleared for other reasons.  Therefore we should expect the
	 * case that list entries are not found in the hashtable; if not, there's
	 * nothing to do for them.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>eoxact_list_overflowed</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>RelationIdCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>idhentry</name> <operator>=</operator> <operator>(</operator><name>RelIdCacheEnt</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>AtEOXact_cleanup</name><argument_list>(<argument><expr><name><name>idhentry</name><operator>-&gt;</operator><name>reldesc</name></name></expr></argument>, <argument><expr><name>isCommit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>eoxact_list_len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>idhentry</name> <operator>=</operator> <operator>(</operator><name>RelIdCacheEnt</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>RelationIdCache</name></expr></argument>,
													 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>eoxact_list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
													 <argument><expr><name>HASH_FIND</name></expr></argument>,
													 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>idhentry</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>AtEOXact_cleanup</name><argument_list>(<argument><expr><name><name>idhentry</name><operator>-&gt;</operator><name>reldesc</name></name></expr></argument>, <argument><expr><name>isCommit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>EOXactTupleDescArrayLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>EOXactTupleDescArray</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NextEOXactTupleDescNum</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FreeTupleDesc</name><argument_list>(<argument><expr><name><name>EOXactTupleDescArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>EOXactTupleDescArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>EOXactTupleDescArray</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Now we're out of the transaction and can clear the lists */</comment>
	<expr_stmt><expr><name>eoxact_list_len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>eoxact_list_overflowed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>NextEOXactTupleDescNum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>EOXactTupleDescArrayLen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AtEOXact_cleanup
 *
 *	Clean up a single rel at main-transaction commit or abort
 *
 * NB: this processing must be idempotent, because EOXactListAdd() doesn't
 * bother to prevent duplicate entries in eoxact_list[].
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AtEOXact_cleanup</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * The relcache entry's ref count should be back to its normal
	 * not-in-a-transaction state: 0 unless it's nailed in cache.
	 *
	 * In bootstrap mode, this is NOT true, so don't check it --- the
	 * bootstrap code expects relations to stay open across start/commit
	 * transaction calls.  (That seems bogus, but it's not worth fixing.)
	 *
	 * Note: ideally this check would be applied to every relcache entry, not
	 * just those that have eoxact work to do.  But it's not worth forcing a
	 * scan of the whole relcache just for this.  (Moreover, doing so would
	 * mean that assert-enabled testing never tests the hash_search code path
	 * above, which seems a bad idea.)
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>expected_refcnt</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>expected_refcnt</name> <operator>=</operator> <ternary><condition><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_isnailed</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_refcnt</name></name> <operator>==</operator> <name>expected_refcnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Is it a relation created in the current transaction?
	 *
	 * During commit, reset the flag to zero, since we are now out of the
	 * creating transaction.  During abort, simply delete the relcache entry
	 * --- it isn't interesting any longer.  (NOTE: if we have forgotten the
	 * new-ness of a new relation due to a forced cache flush, the entry will
	 * get deleted anyway by shared-cache-inval processing of the aborted
	 * pg_class insertion.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_createSubid</name></name> <operator>!=</operator> <name>InvalidSubTransactionId</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>isCommit</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_createSubid</name></name> <operator>=</operator> <name>InvalidSubTransactionId</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>RelationHasReferenceCountZero</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>RelationClearRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Hmm, somewhere there's a (leaked?) reference to the relation.
			 * We daren't remove the entry for fear of dereferencing a
			 * dangling pointer later.  Bleat, and mark it as not belonging to
			 * the current transaction.  Hopefully it'll get cleaned up
			 * eventually.  This must be just a WARNING to avoid
			 * error-during-error-recovery loops.
			 */</comment>
			<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_createSubid</name></name> <operator>=</operator> <name>InvalidSubTransactionId</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"cannot remove relcache entry for \"%s\" because it has nonzero refcount"</literal></expr></argument>,
				 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Likewise, reset the hint about the relfilenode being new.
	 */</comment>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_newRelfilenodeSubid</name></name> <operator>=</operator> <name>InvalidSubTransactionId</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Flush any temporary index list.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexvalid</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_oidindex</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_pkindex</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_replidindex</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexvalid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AtEOSubXact_RelationCache
 *
 *	Clean up the relcache at sub-transaction commit or abort.
 *
 * Note: this must be called *before* processing invalidation messages.
 */</comment>
<function><type><name>void</name></type>
<name>AtEOSubXact_RelationCache</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>, <parameter><decl><type><name>SubTransactionId</name></type> <name>mySubid</name></decl></parameter>,
						  <parameter><decl><type><name>SubTransactionId</name></type> <name>parentSubid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelIdCacheEnt</name> <modifier>*</modifier></type><name>idhentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Unless the eoxact_list[] overflowed, we only need to examine the rels
	 * listed in it.  Otherwise fall back on a hash_seq_search scan.  Same
	 * logic as in AtEOXact_RelationCache.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>eoxact_list_overflowed</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>RelationIdCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>idhentry</name> <operator>=</operator> <operator>(</operator><name>RelIdCacheEnt</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>AtEOSubXact_cleanup</name><argument_list>(<argument><expr><name><name>idhentry</name><operator>-&gt;</operator><name>reldesc</name></name></expr></argument>, <argument><expr><name>isCommit</name></expr></argument>,
								<argument><expr><name>mySubid</name></expr></argument>, <argument><expr><name>parentSubid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>eoxact_list_len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>idhentry</name> <operator>=</operator> <operator>(</operator><name>RelIdCacheEnt</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>RelationIdCache</name></expr></argument>,
													 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>eoxact_list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
													 <argument><expr><name>HASH_FIND</name></expr></argument>,
													 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>idhentry</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>AtEOSubXact_cleanup</name><argument_list>(<argument><expr><name><name>idhentry</name><operator>-&gt;</operator><name>reldesc</name></name></expr></argument>, <argument><expr><name>isCommit</name></expr></argument>,
									<argument><expr><name>mySubid</name></expr></argument>, <argument><expr><name>parentSubid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Don't reset the list; we still need more cleanup later */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * AtEOSubXact_cleanup
 *
 *	Clean up a single rel at subtransaction commit or abort
 *
 * NB: this processing must be idempotent, because EOXactListAdd() doesn't
 * bother to prevent duplicate entries in eoxact_list[].
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AtEOSubXact_cleanup</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>,
					<parameter><decl><type><name>SubTransactionId</name></type> <name>mySubid</name></decl></parameter>, <parameter><decl><type><name>SubTransactionId</name></type> <name>parentSubid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Is it a relation created in the current subtransaction?
	 *
	 * During subcommit, mark it as belonging to the parent, instead. During
	 * subabort, simply delete the relcache entry.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_createSubid</name></name> <operator>==</operator> <name>mySubid</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>isCommit</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_createSubid</name></name> <operator>=</operator> <name>parentSubid</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>RelationHasReferenceCountZero</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>RelationClearRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Hmm, somewhere there's a (leaked?) reference to the relation.
			 * We daren't remove the entry for fear of dereferencing a
			 * dangling pointer later.  Bleat, and transfer it to the parent
			 * subtransaction so we can try again later.  This must be just a
			 * WARNING to avoid error-during-error-recovery loops.
			 */</comment>
			<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_createSubid</name></name> <operator>=</operator> <name>parentSubid</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"cannot remove relcache entry for \"%s\" because it has nonzero refcount"</literal></expr></argument>,
				 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Likewise, update or drop any new-relfilenode-in-subtransaction hint.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_newRelfilenodeSubid</name></name> <operator>==</operator> <name>mySubid</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>isCommit</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_newRelfilenodeSubid</name></name> <operator>=</operator> <name>parentSubid</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_newRelfilenodeSubid</name></name> <operator>=</operator> <name>InvalidSubTransactionId</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Flush any temporary index list.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexvalid</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_oidindex</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_pkindex</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_replidindex</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexvalid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		RelationBuildLocalRelation
 *			Build a relcache entry for an about-to-be-created relation,
 *			and enter it into the relcache.
 */</comment>
<function><type><name>Relation</name></type>
<name>RelationBuildLocalRelation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name></decl></parameter>,
						   <parameter><decl><type><name>Oid</name></type> <name>relnamespace</name></decl></parameter>,
						   <parameter><decl><type><name>TupleDesc</name></type> <name>tupDesc</name></decl></parameter>,
						   <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>,
						   <parameter><decl><type><name>Oid</name></type> <name>relfilenode</name></decl></parameter>,
						   <parameter><decl><type><name>Oid</name></type> <name>reltablespace</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>shared_relation</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>mapped_relation</name></decl></parameter>,
						   <parameter><decl><type><name>char</name></type> <name>relpersistence</name></decl></parameter>,
						   <parameter><decl><type><name>char</name></type> <name>relkind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>natts</name> <init>= <expr><name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_not_null</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>nailit</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>natts</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * check for creation of a rel that must be nailed in cache.
	 *
	 * XXX this list had better match the relations specially handled in
	 * RelationCacheInitializePhase2/3.
	 */</comment>
	<switch>switch <condition>(<expr><name>relid</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DatabaseRelationId</name></expr>:</case>
		<case>case <expr><name>AuthIdRelationId</name></expr>:</case>
		<case>case <expr><name>AuthMemRelationId</name></expr>:</case>
		<case>case <expr><name>RelationRelationId</name></expr>:</case>
		<case>case <expr><name>AttributeRelationId</name></expr>:</case>
		<case>case <expr><name>ProcedureRelationId</name></expr>:</case>
		<case>case <expr><name>TypeRelationId</name></expr>:</case>
			<expr_stmt><expr><name>nailit</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>nailit</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * check that hardwired list of shared rels matches what's in the
	 * bootstrap .bki file.  If you get a failure here during initdb, you
	 * probably need to fix IsSharedRelation() to match whatever you've done
	 * to the set of shared relations.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>shared_relation</name> <operator>!=</operator> <call><name>IsSharedRelation</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>yb_test_system_catalogs_creation</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"shared_relation flag for \"%s\" does not match IsSharedRelation(%u)"</literal></expr></argument>,
			 <argument><expr><name>relname</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* (Non-YB) shared relations had better be mapped, too */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>||</operator>
		   <operator>(</operator><name>mapped_relation</name> <operator>||</operator> <operator>!</operator><name>shared_relation</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * switch to the cache context to create the relcache entry.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>CacheMemoryContext</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CreateCacheMemoryContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * allocate a new relation descriptor and fill in basic state fields.
	 */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <operator>(</operator><name>Relation</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelationData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* make sure relation is marked as having no open file yet */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* mark it nailed if appropriate */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_isnailed</name></name> <operator>=</operator> <name>nailit</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_refcnt</name></name> <operator>=</operator> <ternary><condition><expr><name>nailit</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* it's being created in this transaction */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_createSubid</name></name> <operator>=</operator> <call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_newRelfilenodeSubid</name></name> <operator>=</operator> <name>InvalidSubTransactionId</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * create a new tuple descriptor from the one passed in.  We do this
	 * partly to copy it into the cache context, and partly because the new
	 * relation can't have any defaults or constraints yet; they have to be
	 * added in later steps, because they require additions to multiple system
	 * catalogs.  We can copy attnotnull constraints here, however.
	 */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>tdrefcount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* mark as refcounted */</comment>
	<expr_stmt><expr><name>has_not_null</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>satt</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>datt</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>datt</name><operator>-&gt;</operator><name>attidentity</name></name> <operator>=</operator> <name><name>satt</name><operator>-&gt;</operator><name>attidentity</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>datt</name><operator>-&gt;</operator><name>attnotnull</name></name> <operator>=</operator> <name><name>satt</name><operator>-&gt;</operator><name>attnotnull</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>has_not_null</name> <operator>|=</operator> <name><name>satt</name><operator>-&gt;</operator><name>attnotnull</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>has_not_null</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleConstr</name> <modifier>*</modifier></type><name>constr</name> <init>= <expr><operator>(</operator><name>TupleConstr</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TupleConstr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>has_not_null</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name> <operator>=</operator> <name>constr</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * initialize relation tuple form (caller may add/override data later)
	 */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name></name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>CLASS_TUPLE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnamespace</name></name> <operator>=</operator> <name>relnamespace</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name>relkind</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>tdhasoid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnatts</name></name> <operator>=</operator> <name>natts</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<comment type="block">/* needed when bootstrapping: */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relowner</name></name> <operator>=</operator> <name>BOOTSTRAP_SUPERUSERID</name></expr>;</expr_stmt>

	<comment type="block">/* set up persistence and relcache fields dependent on it */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>=</operator> <name>relpersistence</name></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>relpersistence</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RELPERSISTENCE_UNLOGGED</name></expr>:</case>
		<case>case <expr><name>RELPERSISTENCE_PERMANENT</name></expr>:</case>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_backend</name></name> <operator>=</operator> <name>InvalidBackendId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_islocaltemp</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELPERSISTENCE_TEMP</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>isTempOrTempToastNamespace</name><argument_list>(<argument><expr><name>relnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_backend</name></name> <operator>=</operator> <call><name>BackendIdForTempRelations</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_islocaltemp</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid relpersistence: %c"</literal></expr></argument>, <argument><expr><name>relpersistence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* if it's a materialized view, it's not populated initially */</comment>
	<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispopulated</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispopulated</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* system relations and non-table objects don't have one */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsSystemNamespace</name><argument_list>(<argument><expr><name>relnamespace</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
		 <name>relkind</name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
		 <name>relkind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relreplident</name></name> <operator>=</operator> <name>REPLICA_IDENTITY_DEFAULT</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relreplident</name></name> <operator>=</operator> <name>REPLICA_IDENTITY_NOTHING</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Insert relation physical and logical identifiers (OIDs) into the right
	 * places.  For a mapped relation, we set relfilenode to zero and rely on
	 * RelationInitPhysicalAddr to consult the map.
	 */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relisshared</name></name> <operator>=</operator> <name>shared_relation</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attrelid</name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltablespace</name></name> <operator>=</operator> <name>reltablespace</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>mapped_relation</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relfilenode</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsYBRelation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Add it to the active mapping information */</comment>
			<expr_stmt><expr><call><name>RelationMapUpdateMap</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>relfilenode</name></expr></argument>, <argument><expr><name>shared_relation</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relfilenode</name></name> <operator>=</operator> <name>relfilenode</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>RelationInitLockInfo</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* see lmgr.c */</comment>

	<expr_stmt><expr><call><name>RelationInitPhysicalAddr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Okay to insert into the relcache hash table.
	 *
	 * Ordinarily, there should certainly not be an existing hash entry for
	 * the same OID; but during bootstrap, when we create a "real" relcache
	 * entry for one of the bootstrap relations, we'll be overwriting the
	 * phony one created with formrdesc.  So allow that to happen for nailed
	 * rels.
	 */</comment>
	<expr_stmt><expr><call><name>RelationCacheInsert</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>nailit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Flag relation as needing eoxact cleanup (to clear rd_createSubid). We
	 * can't do this before storing relid in it.
	 */</comment>
	<expr_stmt><expr><call><name>EOXactListAdd</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * done building relcache entry.
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* It's fully valid */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_isvalid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Caller expects us to pin the returned entry.
	 */</comment>
	<expr_stmt><expr><call><name>RelationIncrementReferenceCount</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rel</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RelationSetNewRelfilenode
 *
 * Assign a new relfilenode (physical file name) to the relation.
 *
 * This allows a full rewrite of the relation to be done with transactional
 * safety (since the filenode assignment can be rolled back).  Note however
 * that there is no simple way to access the relation's old data for the
 * remainder of the current transaction.  This limits the usefulness to cases
 * such as TRUNCATE or rebuilding an index from scratch.
 *
 * Caller must already hold exclusive lock on the relation.
 *
 * The relation is marked with relfrozenxid = freezeXid (InvalidTransactionId
 * must be passed for indexes and sequences).  This should be a lower bound on
 * the XIDs that will be put into the new relation contents.
 *
 * The new filenode's persistence is set to the given value.  This is useful
 * for the cases that are changing the relation's persistence; other callers
 * need to pass the original relpersistence value.
 */</comment>
<function><type><name>void</name></type>
<name>RelationSetNewRelfilenode</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>persistence</name></decl></parameter>,
						  <parameter><decl><type><name>TransactionId</name></type> <name>freezeXid</name></decl></parameter>, <parameter><decl><type><name>MultiXactId</name></type> <name>minmulti</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>newrelfilenode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNodeBackend</name></type> <name>newrnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_class</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classform</name></decl>;</decl_stmt>

	<comment type="block">/* Indexes, sequences must have Invalid frozenxid; other rels must not */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
			<name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_SEQUENCE</name><operator>)</operator></expr> ?</condition><then>
		   <expr><name>freezeXid</name> <operator>==</operator> <name>InvalidTransactionId</name></expr> </then><else>:
		   <expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>freezeXid</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>freezeXid</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MultiXactIdIsValid</name><argument_list>(<argument><expr><name>minmulti</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allocate a new relfilenode */</comment>
	<expr_stmt><expr><name>newrelfilenode</name> <operator>=</operator> <call><name>GetNewRelFileNode</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltablespace</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									   <argument><expr><name>persistence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get a writable copy of the pg_class tuple for the given relation.
	 */</comment>
	<expr_stmt><expr><name>pg_class</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>,
								<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find tuple for relation %u"</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>classform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create storage for the main fork of the new relfilenode.
	 *
	 * NOTE: any conflict in relfilenode value will be caught here, if
	 * GetNewRelFileNode messes up for any reason.
	 */</comment>
	<expr_stmt><expr><name><name>newrnode</name><operator>.</operator><name>node</name></name> <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_node</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newrnode</name><operator>.</operator><name>node</name><operator>.</operator><name>relNode</name></name> <operator>=</operator> <name>newrelfilenode</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newrnode</name><operator>.</operator><name>backend</name></name> <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_backend</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RelationCreateStorage</name><argument_list>(<argument><expr><name><name>newrnode</name><operator>.</operator><name>node</name></name></expr></argument>, <argument><expr><name>persistence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>smgrclosenode</name><argument_list>(<argument><expr><name>newrnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Schedule unlinking of the old storage at transaction commit.
	 */</comment>
	<expr_stmt><expr><call><name>RelationDropStorage</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now update the pg_class row.  However, if we're dealing with a mapped
	 * index, pg_class.relfilenode doesn't change; instead we have to send the
	 * update to the relation mapper.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationIsMapped</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RelationMapUpdateMap</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>newrelfilenode</name></expr></argument>,
							 <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relisshared</name></name></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>classform</name><operator>-&gt;</operator><name>relfilenode</name></name> <operator>=</operator> <name>newrelfilenode</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* These changes are safe even for a mapped relation */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>classform</name><operator>-&gt;</operator><name>relpages</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* it's empty until further notice */</comment>
		<expr_stmt><expr><name><name>classform</name><operator>-&gt;</operator><name>reltuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>classform</name><operator>-&gt;</operator><name>relallvisible</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>classform</name><operator>-&gt;</operator><name>relfrozenxid</name></name> <operator>=</operator> <name>freezeXid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>classform</name><operator>-&gt;</operator><name>relminmxid</name></name> <operator>=</operator> <name>minmulti</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>classform</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>=</operator> <name>persistence</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make the pg_class row change visible, as well as the relation map
	 * change if any.  This will cause the relcache entry to get updated, too.
	 */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Mark the rel as having been given a new relfilenode in the current
	 * (sub) transaction.  This is a hint that can be used to optimize later
	 * operations on the rel in the same transaction.
	 */</comment>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_newRelfilenodeSubid</name></name> <operator>=</operator> <call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Flag relation as needing eoxact cleanup (to remove the hint) */</comment>
	<expr_stmt><expr><call><name>EOXactListAdd</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		RelationCacheInitialize
 *
 *		This initializes the relation descriptor cache.  At the time
 *		that this is invoked, we can't do database access yet (mainly
 *		because the transaction subsystem is not up); all we are doing
 *		is making an empty cache hashtable.  This must be done before
 *		starting the initialization transaction, because otherwise
 *		AtEOXact_RelationCache would crash if that transaction aborts
 *		before we can get the relcache set up.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INITRELCACHESIZE</name></cpp:macro>		<cpp:value>400</cpp:value></cpp:define>

<function><type><name>void</name></type>
<name>RelationCacheInitialize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>ctl</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * make sure cache memory context exists
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>CacheMemoryContext</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CreateCacheMemoryContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * create hashtable that indexes the relcache
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RelIdCacheEnt</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>RelationIdCache</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Relcache by OID"</literal></expr></argument>, <argument><expr><name>INITRELCACHESIZE</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * relation mapper needs to be initialized too
	 */</comment>
	<expr_stmt><expr><call><name>RelationMapInitialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		RelationCacheInitializePhase2
 *
 *		This is called to prepare for access to shared catalogs during startup.
 *		We must at least set up nailed reldescs for pg_database, pg_authid,
 *		pg_auth_members, and pg_shseclabel. Ideally we'd like to have reldescs
 *		for their indexes, too.  We attempt to load this information from the
 *		shared relcache init file.  If that's missing or broken, just make
 *		phony entries for the catalogs themselves.
 *		RelationCacheInitializePhase3 will clean up as needed.
 */</comment>
<function><type><name>void</name></type>
<name>RelationCacheInitializePhase2</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

	<comment type="block">/* We do not use a relation map file in YugaByte mode yet */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * relation mapper needs initialized too
		 */</comment>
		<expr_stmt><expr><call><name>RelationMapInitializePhase2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * In bootstrap mode, the shared catalogs aren't there yet anyway, so do
	 * nothing.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * switch to cache memory context
	 */</comment>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Try to load the shared relcache cache file.  If unsuccessful, bootstrap
	 * the cache with pre-made descriptors for the critical shared catalogs.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>load_relcache_init_file</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>formrdesc</name><argument_list>(<argument><expr><literal type="string">"pg_database"</literal></expr></argument>, <argument><expr><name>DatabaseRelation_Rowtype_Id</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
				  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>Natts_pg_database</name></expr></argument>, <argument><expr><name>Desc_pg_database</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>formrdesc</name><argument_list>(<argument><expr><literal type="string">"pg_authid"</literal></expr></argument>, <argument><expr><name>AuthIdRelation_Rowtype_Id</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
				  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>Natts_pg_authid</name></expr></argument>, <argument><expr><name>Desc_pg_authid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>formrdesc</name><argument_list>(<argument><expr><literal type="string">"pg_auth_members"</literal></expr></argument>, <argument><expr><name>AuthMemRelation_Rowtype_Id</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
				  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>Natts_pg_auth_members</name></expr></argument>, <argument><expr><name>Desc_pg_auth_members</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>formrdesc</name><argument_list>(<argument><expr><literal type="string">"pg_shseclabel"</literal></expr></argument>, <argument><expr><name>SharedSecLabelRelation_Rowtype_Id</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
				  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>Natts_pg_shseclabel</name></expr></argument>, <argument><expr><name>Desc_pg_shseclabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>formrdesc</name><argument_list>(<argument><expr><literal type="string">"pg_subscription"</literal></expr></argument>, <argument><expr><name>SubscriptionRelation_Rowtype_Id</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
				  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>Natts_pg_subscription</name></expr></argument>, <argument><expr><name>Desc_pg_subscription</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_CRITICAL_SHARED_RELS</name></cpp:macro>	<cpp:value>5</cpp:value></cpp:define>	<comment type="block">/* fix if you change list above */</comment>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		RelationCacheInitializePhase3
 *
 *		This is called as soon as the catcache and transaction system
 *		are functional and we have determined MyDatabaseId.  At this point
 *		we can actually read data from the database's system catalogs.
 *		We first try to read pre-computed relcache entries from the local
 *		relcache init file.  If that's missing or broken, make phony entries
 *		for the minimum set of nailed-in-cache relations.  Then (unless
 *		bootstrapping) make sure we have entries for the critical system
 *		indexes.  Once we've done all this, we have enough infrastructure to
 *		open any system catalog or use any catcache.  The last step is to
 *		rewrite the cache files if needed.
 */</comment>
<function><type><name>void</name></type>
<name>RelationCacheInitializePhase3</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelIdCacheEnt</name> <modifier>*</modifier></type><name>idhentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needNewCacheFile</name> <init>= <expr><operator>!</operator><name>criticalSharedRelcachesBuilt</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* We do not use a relation map file in YugaByte mode yet */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
	  <comment type="block">/*
	   * relation mapper needs initialized too
	   */</comment>
	  <expr_stmt><expr><call><name>RelationMapInitializePhase3</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * switch to cache memory context
	 */</comment>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Try to load the local relcache cache file.  If unsuccessful, bootstrap
	 * the cache with pre-made descriptors for the critical "nailed-in" system
	 * catalogs.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call> <operator>||</operator>
		<operator>!</operator><call><name>load_relcache_init_file</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>needNewCacheFile</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>formrdesc</name><argument_list>(<argument><expr><literal type="string">"pg_class"</literal></expr></argument>, <argument><expr><name>RelationRelation_Rowtype_Id</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
				  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>Natts_pg_class</name></expr></argument>, <argument><expr><name>Desc_pg_class</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>formrdesc</name><argument_list>(<argument><expr><literal type="string">"pg_attribute"</literal></expr></argument>, <argument><expr><name>AttributeRelation_Rowtype_Id</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
				  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>Natts_pg_attribute</name></expr></argument>, <argument><expr><name>Desc_pg_attribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>formrdesc</name><argument_list>(<argument><expr><literal type="string">"pg_proc"</literal></expr></argument>, <argument><expr><name>ProcedureRelation_Rowtype_Id</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
				  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>Natts_pg_proc</name></expr></argument>, <argument><expr><name>Desc_pg_proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>formrdesc</name><argument_list>(<argument><expr><literal type="string">"pg_type"</literal></expr></argument>, <argument><expr><name>TypeRelation_Rowtype_Id</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
				  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>Natts_pg_type</name></expr></argument>, <argument><expr><name>Desc_pg_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_CRITICAL_LOCAL_RELS</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>	<comment type="block">/* fix if you change list above */</comment>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* In bootstrap mode, the faked-up formrdesc info is all we'll have */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * In YB mode initialize the relache at the beginning so that we need
	 * fewer cache lookups in steady state.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>needNewCacheFile</name> <operator>||</operator> <call><name>YBCIsInitDbModeEnvVarSet</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>YBPreloadRelCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we didn't get the critical system indexes loaded into relcache, do
	 * so now.  These are critical because the catcache and/or opclass cache
	 * depend on them for fetches done during relcache load.  Thus, we have an
	 * infinite-recursion problem.  We can break the recursion by doing
	 * heapscans instead of indexscans at certain key spots. To avoid hobbling
	 * performance, we only want to do that until we have the critical indexes
	 * loaded into relcache.  Thus, the flag criticalRelcachesBuilt is used to
	 * decide whether to do heapscan or indexscan at the key spots, and we set
	 * it true after we've loaded the critical indexes.
	 *
	 * The critical indexes are marked as "nailed in cache", partly to make it
	 * easy for load_relcache_init_file to count them, but mainly because we
	 * cannot flush and rebuild them once we've set criticalRelcachesBuilt to
	 * true.  (NOTE: perhaps it would be possible to reload them by
	 * temporarily setting criticalRelcachesBuilt to false again.  For now,
	 * though, we just nail 'em in.)
	 *
	 * RewriteRelRulenameIndexId and TriggerRelidNameIndexId are not critical
	 * in the same way as the others, because the critical catalogs don't
	 * (currently) have any rules or triggers, and so these indexes can be
	 * rebuilt without inducing recursion.  However they are used during
	 * relcache load when a rel does have rules or triggers, so we choose to
	 * nail them for performance reasons.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>criticalRelcachesBuilt</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>load_critical_index</name><argument_list>(<argument><expr><name>ClassOidIndexId</name></expr></argument>,
							<argument><expr><name>RelationRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>load_critical_index</name><argument_list>(<argument><expr><name>AttributeRelidNumIndexId</name></expr></argument>,
							<argument><expr><name>AttributeRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>load_critical_index</name><argument_list>(<argument><expr><name>IndexRelidIndexId</name></expr></argument>,
							<argument><expr><name>IndexRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>load_critical_index</name><argument_list>(<argument><expr><name>OpclassOidIndexId</name></expr></argument>,
							<argument><expr><name>OperatorClassRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>load_critical_index</name><argument_list>(<argument><expr><name>AccessMethodProcedureIndexId</name></expr></argument>,
							<argument><expr><name>AccessMethodProcedureRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>load_critical_index</name><argument_list>(<argument><expr><name>RewriteRelRulenameIndexId</name></expr></argument>,
							<argument><expr><name>RewriteRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>load_critical_index</name><argument_list>(<argument><expr><name>TriggerRelidNameIndexId</name></expr></argument>,
							<argument><expr><name>TriggerRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_CRITICAL_LOCAL_INDEXES</name></cpp:macro>	<cpp:value>7</cpp:value></cpp:define>	<comment type="block">/* fix if you change list above */</comment>

		<expr_stmt><expr><name>criticalRelcachesBuilt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Process critical shared indexes too.
	 *
	 * DatabaseNameIndexId isn't critical for relcache loading, but rather for
	 * initial lookup of MyDatabaseId, without which we'll never find any
	 * non-shared catalogs at all.  Autovacuum calls InitPostgres with a
	 * database OID, so it instead depends on DatabaseOidIndexId.  We also
	 * need to nail up some indexes on pg_authid and pg_auth_members for use
	 * during client authentication.  SharedSecLabelObjectIndexId isn't
	 * critical for the core system, but authentication hooks might be
	 * interested in it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>criticalSharedRelcachesBuilt</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>load_critical_index</name><argument_list>(<argument><expr><name>DatabaseNameIndexId</name></expr></argument>,
							<argument><expr><name>DatabaseRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>load_critical_index</name><argument_list>(<argument><expr><name>DatabaseOidIndexId</name></expr></argument>,
							<argument><expr><name>DatabaseRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>load_critical_index</name><argument_list>(<argument><expr><name>AuthIdRolnameIndexId</name></expr></argument>,
							<argument><expr><name>AuthIdRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>load_critical_index</name><argument_list>(<argument><expr><name>AuthIdOidIndexId</name></expr></argument>,
							<argument><expr><name>AuthIdRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>load_critical_index</name><argument_list>(<argument><expr><name>AuthMemMemRoleIndexId</name></expr></argument>,
							<argument><expr><name>AuthMemRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>load_critical_index</name><argument_list>(<argument><expr><name>SharedSecLabelObjectIndexId</name></expr></argument>,
							<argument><expr><name>SharedSecLabelRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_CRITICAL_SHARED_INDEXES</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>	<comment type="block">/* fix if you change list above */</comment>

		<expr_stmt><expr><name>criticalSharedRelcachesBuilt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now, scan all the relcache entries and update anything that might be
	 * wrong in the results from formrdesc or the relcache cache file. If we
	 * faked up relcache entries using formrdesc, then read the real pg_class
	 * rows and replace the fake entries with them. Also, if any of the
	 * relcache entries have rules, triggers, or security policies, load that
	 * info the hard way since it isn't recorded in the cache file.
	 *
	 * Whenever we access the catalogs to read data, there is a possibility of
	 * a shared-inval cache flush causing relcache entries to be removed.
	 * Since hash_seq_search only guarantees to still work after the *current*
	 * entry is removed, it's unsafe to continue the hashtable scan afterward.
	 * We handle this by restarting the scan from scratch after each access.
	 * This is theoretically O(N^2), but the number of entries that actually
	 * need to be fixed is small enough that it doesn't matter.
	 */</comment>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>RelationIdCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>idhentry</name> <operator>=</operator> <operator>(</operator><name>RelIdCacheEnt</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name> <init>= <expr><name><name>idhentry</name><operator>-&gt;</operator><name>reldesc</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>restart</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Make sure *this* entry doesn't get flushed while we work with it.
		 */</comment>
		<expr_stmt><expr><call><name>RelationIncrementReferenceCount</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If it's a faked-up entry, read the real pg_class tuple.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relowner</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>htup</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>relp</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>htup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>,
								   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>,
					 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>relp</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Copy tuple to relation-&gt;rd_rel. (See notes in
			 * AllocateRelationDesc())
			 */</comment>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>relp</name></expr></argument>, <argument><expr><name>CLASS_TUPLE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Update rd_options while we have the tuple */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_options</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>RelationParseRelOptions</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Check the values in rd_att were set up correctly.  (We cannot
			 * just copy them over now: formrdesc must have set up the rd_att
			 * data correctly to start with, because it may already have been
			 * copied into one or more catcache entries.)
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>tdtypeid</name></name> <operator>==</operator> <name><name>relp</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>tdtypmod</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>tdhasoid</name></name> <operator>==</operator> <name><name>relp</name><operator>-&gt;</operator><name>relhasoids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* relowner had better be OK now, else we'll loop forever */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relowner</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid relowner in pg_class entry for \"%s\""</literal></expr></argument>,
					 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>restart</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Fix data that isn't saved in relcache cache file.
		 *
		 * relhasrules or relhastriggers could possibly be wrong or out of
		 * date.  If we don't actually find any rules or triggers, clear the
		 * local copy of the flag so that we don't get into an infinite loop
		 * here.  We don't make any attempt to fix the pg_class entry, though.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasrules</name></name> <operator>&amp;&amp;</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_rules</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>RelationBuildRuleLock</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rules</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasrules</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>restart</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhastriggers</name></name> <operator>&amp;&amp;</operator> <name><name>relation</name><operator>-&gt;</operator><name>trigdesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>RelationBuildTriggers</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>trigdesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhastriggers</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>restart</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Re-load the row security policies if the relation has them, since
		 * they are not preserved in the cache.  Note that we can never NOT
		 * have a policy while relrowsecurity is true,
		 * RelationBuildRowSecurity will create a single default-deny policy
		 * if there is no policy defined in pg_policy.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relrowsecurity</name></name> <operator>&amp;&amp;</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_rsdesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>RelationBuildRowSecurity</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rsdesc</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>restart</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Reload the partition key and descriptor for a partitioned table.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator>
			<name><name>relation</name><operator>-&gt;</operator><name>rd_partkey</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>RelationBuildPartitionKey</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_partkey</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>restart</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator>
			<name><name>relation</name><operator>-&gt;</operator><name>rd_partdesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>RelationBuildPartitionDesc</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_partdesc</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>restart</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Release hold on the relation */</comment>
		<expr_stmt><expr><call><name>RelationDecrementReferenceCount</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Now, restart the hashtable scan if needed */</comment>
		<if_stmt><if>if <condition>(<expr><name>restart</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>hash_seq_term</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>RelationIdCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Lastly, write out new relcache cache files if needed.  We don't bother
	 * to distinguish cases where only one of the two needs an update.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>needNewCacheFile</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Force all the catcaches to finish initializing and thereby open the
		 * catalogs and indexes they use.  This will preload the relcache with
		 * entries for all the most important system catalogs and indexes, so
		 * that the init files will be most useful for future backends.
		 */</comment>
		<expr_stmt><expr><call><name>InitCatalogCachePhase2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* now write the files */</comment>
		<expr_stmt><expr><call><name>write_relcache_init_file</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>write_relcache_init_file</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * During initdb also preload catalog caches (not just relation cache) as
	 * they will be used heavily.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>YBCIsInitDbModeEnvVarSet</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>YbPreloadCatalogCaches</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Load one critical system index into the relcache
 *
 * indexoid is the OID of the target index, heapoid is the OID of the catalog
 * it belongs to.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>load_critical_index</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>heapoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>ird</name></decl>;</decl_stmt>
	<comment type="block">/*
	 * We must lock the underlying catalog before locking the index to avoid
	 * deadlock, since RelationBuildDesc might well need to read the catalog,
	 * and if anyone else is exclusive-locking this catalog and index they'll
	 * be doing it in that order.
	 */</comment>

	<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>heapoid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RelationIdCacheLookup</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>, <argument><expr><name>ird</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>ird</name> <operator>=</operator> <call><name>RelationBuildDesc</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>ird</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"could not open critical system index %u"</literal></expr></argument>, <argument><expr><name>indexoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>ird</name><operator>-&gt;</operator><name>rd_isnailed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ird</name><operator>-&gt;</operator><name>rd_refcnt</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name>heapoid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * GetPgClassDescriptor -- get a predefined tuple descriptor for pg_class
 * GetPgIndexDescriptor -- get a predefined tuple descriptor for pg_index
 *
 * We need this kluge because we have to be able to access non-fixed-width
 * fields of pg_class and pg_index before we have the standard catalog caches
 * available.  We use predefined data that's set up in just the same way as
 * the bootstrapped reldescs used by formrdesc().  The resulting tupdesc is
 * not 100% kosher: it does not have the correct rowtype OID in tdtypeid, nor
 * does it have a TupleConstr field.  But it's good enough for the purpose of
 * extracting fields.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleDesc</name></type>
<name>BuildHardcodedDescriptor</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>natts</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FormData_pg_attribute</name> <modifier>*</modifier></type><name>attrs</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>hasoids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>natts</name></expr></argument>, <argument><expr><name>hasoids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>tdtypeid</name></name> <operator>=</operator> <name>RECORDOID</name></expr>;</expr_stmt>	<comment type="block">/* not right, but we don't care */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>tdtypmod</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>ATTRIBUTE_FIXED_PART_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* make sure attcacheoff is valid */</comment>
		<expr_stmt><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attcacheoff</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* initialize first attribute's attcacheoff, cf RelationBuildTupleDesc */</comment>
	<expr_stmt><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attcacheoff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Note: we don't bother to set up a TupleConstr entry */</comment>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TupleDesc</name></type>
<name>GetPgClassDescriptor</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>TupleDesc</name></type> <name>pgclassdesc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Already done? */</comment>
	<if_stmt><if>if <condition>(<expr><name>pgclassdesc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>pgclassdesc</name> <operator>=</operator> <call><name>BuildHardcodedDescriptor</name><argument_list>(<argument><expr><name>Natts_pg_class</name></expr></argument>,
											   <argument><expr><name>Desc_pg_class</name></expr></argument>,
											   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>pgclassdesc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TupleDesc</name></type>
<name>GetPgIndexDescriptor</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>TupleDesc</name></type> <name>pgindexdesc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Already done? */</comment>
	<if_stmt><if>if <condition>(<expr><name>pgindexdesc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>pgindexdesc</name> <operator>=</operator> <call><name>BuildHardcodedDescriptor</name><argument_list>(<argument><expr><name>Natts_pg_index</name></expr></argument>,
											   <argument><expr><name>Desc_pg_index</name></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>pgindexdesc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Load any default attribute value definitions for the relation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AttrDefaultFetch</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AttrDefault</name> <modifier>*</modifier></type><name>attrdef</name> <init>= <expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>defval</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndef</name> <init>= <expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>num_defval</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>adrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>adscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>skey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>htup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>,
				<argument><expr><name>Anum_pg_attrdef_adrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>adrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AttrDefaultRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>adscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>adrel</name></expr></argument>, <argument><expr><name>AttrDefaultIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>adscan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attrdef</name></type> <name>adform</name> <init>= <expr><operator>(</operator><name>Form_pg_attrdef</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name><name>adform</name><operator>-&gt;</operator><name>adnum</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndef</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>adform</name><operator>-&gt;</operator><name>adnum</name></name> <operator>!=</operator> <name><name>attrdef</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>adnum</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>attrdef</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>adbin</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"multiple attrdef records found for attr %s of rel %s"</literal></expr></argument>,
					 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>found</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>fastgetattr</name><argument_list>(<argument><expr><name>htup</name></expr></argument>,
							  <argument><expr><name>Anum_pg_attrdef_adbin</name></expr></argument>,
							  <argument><expr><name><name>adrel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"null adbin for attr %s of rel %s"</literal></expr></argument>,
					 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* detoast and convert to cstring in caller's context */</comment>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>attrdef</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>adbin</name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>ndef</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"unexpected attrdef record found for attr %d of rel %s"</literal></expr></argument>,
				 <argument><expr><name><name>adform</name><operator>-&gt;</operator><name>adnum</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>adscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>adrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Load any check constraints for the relation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CheckConstraintFetch</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ConstrCheck</name> <modifier>*</modifier></type><name>check</name> <init>= <expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>check</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ncheck</name> <init>= <expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>num_check</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>conrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>conscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>htup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>found</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_conrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>conrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>conscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>ConstraintRelidTypidNameIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>conscan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>conform</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>val</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

		<comment type="block">/* We want check constraints only */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>conform</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTRAINT_CHECK</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>found</name> <operator>&gt;=</operator> <name>ncheck</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected constraint record found for rel %s"</literal></expr></argument>,
				 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>check</name><index>[<expr><name>found</name></expr>]</index></name><operator>.</operator><name>ccvalid</name> <operator>=</operator> <name><name>conform</name><operator>-&gt;</operator><name>convalidated</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>check</name><index>[<expr><name>found</name></expr>]</index></name><operator>.</operator><name>ccnoinherit</name> <operator>=</operator> <name><name>conform</name><operator>-&gt;</operator><name>connoinherit</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>check</name><index>[<expr><name>found</name></expr>]</index></name><operator>.</operator><name>ccname</name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>,
												  <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>conform</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Grab and test conbin is actually set */</comment>
		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>fastgetattr</name><argument_list>(<argument><expr><name>htup</name></expr></argument>,
						  <argument><expr><name>Anum_pg_constraint_conbin</name></expr></argument>,
						  <argument><expr><name><name>conrel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null conbin for rel %s"</literal></expr></argument>,
				 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* detoast and convert to cstring in caller's context */</comment>
		<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>check</name><index>[<expr><name>found</name></expr>]</index></name><operator>.</operator><name>ccbin</name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>found</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>conscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>found</name> <operator>!=</operator> <name>ncheck</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"%d constraint record(s) missing for rel %s"</literal></expr></argument>,
			 <argument><expr><name>ncheck</name> <operator>-</operator> <name>found</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Sort the records so that CHECKs are applied in a deterministic order */</comment>
	<if_stmt><if>if <condition>(<expr><name>ncheck</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>check</name></expr></argument>, <argument><expr><name>ncheck</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ConstrCheck</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>CheckConstraintCmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * qsort comparator to sort ConstrCheck entries by name
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CheckConstraintCmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ConstrCheck</name> <modifier>*</modifier></type><name>ca</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>ConstrCheck</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ConstrCheck</name> <modifier>*</modifier></type><name>cb</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>ConstrCheck</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>ca</name><operator>-&gt;</operator><name>ccname</name></name></expr></argument>, <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>ccname</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RelationGetFKeyList -- get a list of foreign key info for the relation
 *
 * Returns a list of ForeignKeyCacheInfo structs, one per FK constraining
 * the given relation.  This data is a direct copy of relevant fields from
 * pg_constraint.  The list items are in no particular order.
 *
 * CAUTION: the returned list is part of the relcache's data, and could
 * vanish in a relcache entry reset.  Callers must inspect or copy it
 * before doing anything that might trigger a cache flush, such as
 * system catalog accesses.  copyObject() can be used if desired.
 * (We define it this way because current callers want to filter and
 * modify the list entries anyway, so copying would be a waste of time.)
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>RelationGetFKeyList</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>conrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>conscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>skey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>htup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>oldlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

	<comment type="block">/* Quick exit if we already computed the list. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_fkeyvalid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>relation</name><operator>-&gt;</operator><name>rd_fkeylist</name></name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Fast path: non-partitioned tables without triggers can't have FKs */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhastriggers</name></name> <operator>&amp;&amp;</operator>
		<name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We build the list we intend to return (in the caller's context) while
	 * doing the scan.  After successfully completing the scan, we copy that
	 * list into the relcache entry.  This avoids cache-context memory leakage
	 * if we get some sort of error partway through.
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/* Prepare to scan pg_constraint for entries having conrelid = this rel. */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_conrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>conrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>conscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>ConstraintRelidTypidNameIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>conscan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>constraint</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ForeignKeyCacheInfo</name> <modifier>*</modifier></type><name>info</name></decl>;</decl_stmt>

		<comment type="block">/* consider only foreign keys */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTRAINT_FOREIGN</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ForeignKeyCacheInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>conoid</name></name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>conrelid</name></name> <operator>=</operator> <name><name>constraint</name><operator>-&gt;</operator><name>conrelid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>confrelid</name></name> <operator>=</operator> <name><name>constraint</name><operator>-&gt;</operator><name>confrelid</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>DeconstructFkConstraintRow</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>nkeys</name></name></expr></argument>,
								   <argument><expr><name><name>info</name><operator>-&gt;</operator><name>conkey</name></name></expr></argument>,
								   <argument><expr><name><name>info</name><operator>-&gt;</operator><name>confkey</name></name></expr></argument>,
								   <argument><expr><name><name>info</name><operator>-&gt;</operator><name>conpfeqop</name></name></expr></argument>,
								   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Add FK's node to the result list */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>conscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now save a copy of the completed list in the relcache entry. */</comment>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldlist</name> <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_fkeylist</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_fkeylist</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_fkeyvalid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Don't leak the old list, if there is one */</comment>
	<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>oldlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RelationGetIndexList -- get a list of OIDs of indexes on this relation
 *
 * The index list is created only if someone requests it.  We scan pg_index
 * to find relevant indexes, and add the list to the relcache entry so that
 * we won't have to compute it again.  Note that shared cache inval of a
 * relcache entry will delete the old list and set rd_indexvalid to 0,
 * so that we must recompute the index list on next request.  This handles
 * creation or deletion of an index.
 *
 * Indexes that are marked not IndexIsLive are omitted from the returned list.
 * Such indexes are expected to be dropped momentarily, and should not be
 * touched at all by any caller of this function.
 *
 * The returned list is guaranteed to be sorted in order by OID.  This is
 * needed by the executor, since for index types that we obtain exclusive
 * locks on when updating the index, all backends must lock the indexes in
 * the same order or we will get deadlocks (see ExecOpenIndices()).  Any
 * consistent ordering would do, but ordering by OID is easy.
 *
 * Since shared cache inval causes the relcache's copy of the list to go away,
 * we return a copy of the list palloc'd in the caller's context.  The caller
 * may list_free() the returned list after scanning it. This is necessary
 * since the caller will typically be doing syscache lookups on the relevant
 * indexes, and syscache lookup could cause SI messages to be processed!
 *
 * We also update rd_oidindex, which this module treats as effectively part
 * of the index list.  rd_oidindex is valid when rd_indexvalid isn't zero;
 * it is the pg_class OID of a unique index on OID when the relation has one,
 * and InvalidOid if there is no such index.
 *
 * In exactly the same way, we update rd_pkindex, which is the OID of the
 * relation's primary key index if any, else InvalidOid; and rd_replidindex,
 * which is the pg_class OID of an index to be used as the relation's
 * replication identity index, or InvalidOid if there is no such index.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>RelationGetIndexList</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>indrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>indscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>skey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>htup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>oldlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>replident</name> <init>= <expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relreplident</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oidIndex</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>pkeyIndex</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>candidateIndex</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

	<comment type="block">/* Quick exit if we already computed the list. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexvalid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexlist</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We build the list we intend to return (in the caller's context) while
	 * doing the scan.  After successfully completing the scan, we copy that
	 * list into the relcache entry.  This avoids cache-context memory leakage
	 * if we get some sort of error partway through.
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oidIndex</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

	<comment type="block">/* Prepare to scan pg_index for entries having indrelid = this rel. */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>,
				<argument><expr><name>Anum_pg_index_indrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>indrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>IndexRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>indscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>indrel</name></expr></argument>, <argument><expr><name>IndexIndrelidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>indscan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>index</name> <init>= <expr><operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>indclassDatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>indclass</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Ignore any indexes that are currently being dropped.  This will
		 * prevent them from being searched, inserted into, or considered in
		 * HOT-safety decisions.  It's unsafe to touch such an index at all
		 * since its catalog entries could disappear at any instant.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IndexIsLive</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Add index's OID to result list in the proper order */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>insert_ordered_oid</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>index</name><operator>-&gt;</operator><name>indexrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * indclass cannot be referenced directly through the C struct,
		 * because it comes after the variable-width indkey field.  Must
		 * extract the datum the hard way...
		 */</comment>
		<expr_stmt><expr><name>indclassDatum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>htup</name></expr></argument>,
									 <argument><expr><name>Anum_pg_index_indclass</name></expr></argument>,
									 <argument><expr><call><name>GetPgIndexDescriptor</name><argument_list>()</argument_list></call></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>indclass</name> <operator>=</operator> <operator>(</operator><name>oidvector</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>indclassDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Invalid, non-unique, non-immediate or predicate indexes aren't
		 * interesting for either oid indexes or replication identity indexes,
		 * so don't check them.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IndexIsValid</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><name><name>index</name><operator>-&gt;</operator><name>indisunique</name></name> <operator>||</operator>
			<operator>!</operator><name><name>index</name><operator>-&gt;</operator><name>indimmediate</name></name> <operator>||</operator>
			<operator>!</operator><call><name>heap_attisnull</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><name>Anum_pg_index_indpred</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Check to see if is a usable btree index on OID */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>indnatts</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
			<name><name>index</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>ObjectIdAttributeNumber</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>indclass</name><operator>-&gt;</operator><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>OID_BTREE_OPS_OID</name> <operator>||</operator>
			 <name><name>indclass</name><operator>-&gt;</operator><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>OID_LSM_OPS_OID</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>oidIndex</name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>indexrelid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* remember primary key index if any */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>indisprimary</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>pkeyIndex</name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>indexrelid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* remember explicitly chosen replica index */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>indisreplident</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>candidateIndex</name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>indexrelid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>indscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>indrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now save a copy of the completed list in the relcache entry. */</comment>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldlist</name> <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_indexlist</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexlist</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_oidindex</name></name> <operator>=</operator> <name>oidIndex</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_pkindex</name></name> <operator>=</operator> <name>pkeyIndex</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>replident</name> <operator>==</operator> <name>REPLICA_IDENTITY_DEFAULT</name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>pkeyIndex</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_replidindex</name></name> <operator>=</operator> <name>pkeyIndex</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>replident</name> <operator>==</operator> <name>REPLICA_IDENTITY_INDEX</name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>candidateIndex</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_replidindex</name></name> <operator>=</operator> <name>candidateIndex</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_replidindex</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexvalid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Don't leak the old list, if there is one */</comment>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>oldlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RelationGetStatExtList
 *		get a list of OIDs of statistics objects on this relation
 *
 * The statistics list is created only if someone requests it, in a way
 * similar to RelationGetIndexList().  We scan pg_statistic_ext to find
 * relevant statistics, and add the list to the relcache entry so that we
 * won't have to compute it again.  Note that shared cache inval of a
 * relcache entry will delete the old list and set rd_statvalid to 0,
 * so that we must recompute the statistics list on next request.  This
 * handles creation or deletion of a statistics object.
 *
 * The returned list is guaranteed to be sorted in order by OID, although
 * this is not currently needed.
 *
 * Since shared cache inval causes the relcache's copy of the list to go away,
 * we return a copy of the list palloc'd in the caller's context.  The caller
 * may list_free() the returned list after scanning it. This is necessary
 * since the caller will typically be doing syscache lookups on the relevant
 * statistics, and syscache lookup could cause SI messages to be processed!
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>RelationGetStatExtList</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>indrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>indscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>skey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>htup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>oldlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

	<comment type="block">/* Quick exit if we already computed the list. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_statvalid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_statlist</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We build the list we intend to return (in the caller's context) while
	 * doing the scan.  After successfully completing the scan, we copy that
	 * list into the relcache entry.  This avoids cache-context memory leakage
	 * if we get some sort of error partway through.
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prepare to scan pg_statistic_ext for entries having stxrelid = this
	 * rel.
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>,
				<argument><expr><name>Anum_pg_statistic_ext_stxrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>indrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>StatisticExtRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>indscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>indrel</name></expr></argument>, <argument><expr><name>StatisticExtRelidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>indscan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>insert_ordered_oid</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>indscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>indrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now save a copy of the completed list in the relcache entry. */</comment>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldlist</name> <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_statlist</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_statlist</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_statvalid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Don't leak the old list, if there is one */</comment>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>oldlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * insert_ordered_oid
 *		Insert a new Oid into a sorted list of Oids, preserving ordering
 *
 * Building the ordered list this way is O(N^2), but with a pretty small
 * constant, so for the number of entries we expect it will probably be
 * faster than trying to apply qsort().  Most tables don't have very many
 * indexes...
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>insert_ordered_oid</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>

	<comment type="block">/* Does the datum belong at the front? */</comment>
	<if_stmt><if>if <condition>(<expr><name>list</name> <operator>==</operator> <name>NIL</name> <operator>||</operator> <name>datum</name> <operator>&lt;</operator> <call><name>linitial_oid</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>lcons_oid</name><argument_list>(<argument><expr><name>datum</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* No, so find the entry it belongs after */</comment>
	<expr_stmt><expr><name>prev</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>curr</name> <init>= <expr><call><name>lnext</name><argument_list>(<argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>curr</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>datum</name> <operator>&lt;</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* it belongs after 'prev', before 'curr' */</comment>

		<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>curr</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Insert datum into list after 'prev' */</comment>
	<expr_stmt><expr><call><name>lappend_cell_oid</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RelationSetIndexList -- externally force the index list contents
 *
 * This is used to temporarily override what we think the set of valid
 * indexes is (including the presence or absence of an OID index).
 * The forcing will be valid only until transaction commit or abort.
 *
 * This should only be applied to nailed relations, because in a non-nailed
 * relation the hacked index list could be lost at any time due to SI
 * messages.  In practice it is only used on pg_class (see REINDEX).
 *
 * It is up to the caller to make sure the given list is correctly ordered.
 *
 * We deliberately do not change rd_indexattr here: even when operating
 * with a temporary partial index list, HOT-update decisions must be made
 * correctly with respect to the full index set.  It is up to the caller
 * to ensure that a correct rd_indexattr set has been cached before first
 * calling RelationSetIndexList; else a subsequent inquiry might cause a
 * wrong rd_indexattr set to get computed and cached.  Likewise, we do not
 * touch rd_keyattr, rd_pkattr or rd_idattr.
 */</comment>
<function><type><name>void</name></type>
<name>RelationSetIndexList</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexIds</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oidIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_isnailed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Copy the list into the cache context (could fail for lack of mem) */</comment>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>indexIds</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>indexIds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Okay to replace old list */</comment>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexlist</name></name> <operator>=</operator> <name>indexIds</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_oidindex</name></name> <operator>=</operator> <name>oidIndex</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * For the moment, assume the target rel hasn't got a pk or replica index.
	 * We'll load them on demand in the API that wraps access to them.
	 */</comment>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_pkindex</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_replidindex</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexvalid</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>	<comment type="block">/* mark list as forced */</comment>
	<comment type="block">/* Flag relation as needing eoxact cleanup (to reset the list) */</comment>
	<expr_stmt><expr><call><name>EOXactListAdd</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RelationGetOidIndex -- get the pg_class OID of the relation's OID index
 *
 * Returns InvalidOid if there is no such index.
 */</comment>
<function><type><name>Oid</name></type>
<name>RelationGetOidIndex</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>ilist</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If relation doesn't have OIDs at all, caller is probably confused. (We
	 * could just silently return InvalidOid, but it seems better to throw an
	 * assertion.)
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexvalid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* RelationGetIndexList does the heavy lifting. */</comment>
		<expr_stmt><expr><name>ilist</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>ilist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexvalid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>relation</name><operator>-&gt;</operator><name>rd_oidindex</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RelationGetPrimaryKeyIndex -- get OID of the relation's primary key index
 *
 * Returns InvalidOid if there is no such index.
 */</comment>
<function><type><name>Oid</name></type>
<name>RelationGetPrimaryKeyIndex</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>ilist</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexvalid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* RelationGetIndexList does the heavy lifting. */</comment>
		<expr_stmt><expr><name>ilist</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>ilist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexvalid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>relation</name><operator>-&gt;</operator><name>rd_pkindex</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RelationGetReplicaIndex -- get OID of the relation's replica identity index
 *
 * Returns InvalidOid if there is no such index.
 */</comment>
<function><type><name>Oid</name></type>
<name>RelationGetReplicaIndex</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>ilist</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexvalid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* RelationGetIndexList does the heavy lifting. */</comment>
		<expr_stmt><expr><name>ilist</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>ilist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexvalid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>relation</name><operator>-&gt;</operator><name>rd_replidindex</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RelationGetIndexExpressions -- get the index expressions for an index
 *
 * We cache the result of transforming pg_index.indexprs into a node tree.
 * If the rel is not an index or has no expressional columns, we return NIL.
 * Otherwise, the returned tree is copied into the caller's memory context.
 * (We don't want to return a pointer to the relcache copy, since it could
 * disappear due to relcache invalidation.)
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>RelationGetIndexExpressions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>exprsDatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>exprsString</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

	<comment type="block">/* Quick exit if we already computed the result. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexprs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexprs</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Quick exit if there is nothing to do. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indextuple</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<call><name>heap_attisnull</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indextuple</name></name></expr></argument>, <argument><expr><name>Anum_pg_index_indexprs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We build the tree we intend to return in the caller's context. After
	 * successfully completing the work, we copy it into the relcache entry.
	 * This avoids problems if we get some sort of error partway through.
	 */</comment>
	<expr_stmt><expr><name>exprsDatum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indextuple</name></name></expr></argument>,
							  <argument><expr><name>Anum_pg_index_indexprs</name></expr></argument>,
							  <argument><expr><call><name>GetPgIndexDescriptor</name><argument_list>()</argument_list></call></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>exprsString</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>exprsDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name>exprsString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>exprsString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Run the expressions through eval_const_expressions. This is not just an
	 * optimization, but is necessary, because the planner will be comparing
	 * them to similarly-processed qual clauses, and may fail to detect valid
	 * matches without this.  We must not use canonicalize_qual, however,
	 * since these aren't qual expressions.
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* May as well fix opfuncids too */</comment>
	<expr_stmt><expr><call><name>fix_opfuncids</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now save a copy of the completed tree in the relcache entry. */</comment>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexprs</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RelationGetIndexPredicate -- get the index predicate for an index
 *
 * We cache the result of transforming pg_index.indpred into an implicit-AND
 * node tree (suitable for use in planning).
 * If the rel is not an index or has no predicate, we return NIL.
 * Otherwise, the returned tree is copied into the caller's memory context.
 * (We don't want to return a pointer to the relcache copy, since it could
 * disappear due to relcache invalidation.)
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>RelationGetIndexPredicate</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>predDatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>predString</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

	<comment type="block">/* Quick exit if we already computed the result. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indpred</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indpred</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Quick exit if there is nothing to do. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indextuple</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<call><name>heap_attisnull</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indextuple</name></name></expr></argument>, <argument><expr><name>Anum_pg_index_indpred</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We build the tree we intend to return in the caller's context. After
	 * successfully completing the work, we copy it into the relcache entry.
	 * This avoids problems if we get some sort of error partway through.
	 */</comment>
	<expr_stmt><expr><name>predDatum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indextuple</name></name></expr></argument>,
							 <argument><expr><name>Anum_pg_index_indpred</name></expr></argument>,
							 <argument><expr><call><name>GetPgIndexDescriptor</name><argument_list>()</argument_list></call></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>predString</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>predDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name>predString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>predString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Run the expression through const-simplification and canonicalization.
	 * This is not just an optimization, but is necessary, because the planner
	 * will be comparing it to similarly-processed qual clauses, and may fail
	 * to detect valid matches without this.  This must match the processing
	 * done to qual clauses in preprocess_expression()!  (We can skip the
	 * stuff involving subqueries, however, since we don't allow any in index
	 * predicates.)
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>canonicalize_qual</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>result</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Also convert to implicit-AND format */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>make_ands_implicit</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* May as well fix opfuncids too */</comment>
	<expr_stmt><expr><call><name>fix_opfuncids</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now save a copy of the completed tree in the relcache entry. */</comment>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indpred</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEURISTIC_MAX_HOT_RECHECK_EXPR_COST</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>

<comment type="block">/*
 * Check if functional index is projection: index expression returns some subset
 * of its argument values. During HOT update check we handle projection indexes
 * differently: instead of checking if any of attributes used in indexed
 * expression were updated, we calculate and compare values of index expression
 * for old and new tuple values.
 *
 * Decision made by this function is based on two sources:
 * 1. Calculated cost of index expression: if greater than some heuristic limit
	  then extra comparison of index expression values is expected to be too
	  expensive, so we don't attempt it by default.
 * 2. "recheck_on_update" index option explicitly set by user, which overrides 1)
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsProjectionFunctionalIndex</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_projection</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><call><name>RelationGetIndexExpressions</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>reloptions</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>QualCost</name></type>	<name>index_expr_cost</name></decl>;</decl_stmt>

		<comment type="block">/* by default functional index is considered as non-injective */</comment>
		<expr_stmt><expr><name>is_projection</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>cost_qual_eval</name><argument_list>(<argument><expr><operator>&amp;</operator><name>index_expr_cost</name></expr></argument>, <argument><expr><call><name>RelationGetIndexExpressions</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If index expression is too expensive, then disable projection
		 * optimization, because extra evaluation of index expression is
		 * expected to be more expensive than index update.  Currently the
		 * projection optimization has to calculate index expression twice
		 * when the value of index expression has not changed and three times
		 * when values differ because the expression is recalculated when
		 * inserting a new index entry for the changed value.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>index_expr_cost</name><operator>.</operator><name>startup</name></name> <operator>+</operator> <name><name>index_expr_cost</name><operator>.</operator><name>per_tuple</name></name><operator>)</operator> <operator>&gt;</operator>
			<name>HEURISTIC_MAX_HOT_RECHECK_EXPR_COST</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>is_projection</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>reloptions</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
									 <argument><expr><name>Anum_pg_class_reloptions</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>GenericIndexOpts</name> <modifier>*</modifier></type><name>idxopts</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>idxopts</name> <operator>=</operator> <operator>(</operator><name>GenericIndexOpts</name> <operator>*</operator><operator>)</operator> <call><name>index_generic_reloptions</name><argument_list>(<argument><expr><name>reloptions</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>idxopts</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>is_projection</name> <operator>=</operator> <name><name>idxopts</name><operator>-&gt;</operator><name>recheck_on_update</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>idxopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>is_projection</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>CheckUpdateExprOrPred</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>updated_attrs</name></decl></parameter>,
                      <parameter><decl><type><name>Relation</name></type> <name>indexDesc</name></decl></parameter>,
                      <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>Anum_pg_index</name></decl></parameter>,
                      <parameter><decl><type><name>AttrNumber</name></type> <name>attr_offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>bool</name></type>      <name>isnull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Datum</name></type> <name>datum</name> <init>= <expr><call><name>heap_getattr</name><argument_list>(
      <argument><expr><name><name>indexDesc</name><operator>-&gt;</operator><name>rd_indextuple</name></name></expr></argument>, <argument><expr><name>Anum_pg_index</name></expr></argument>, <argument><expr><call><name>GetPgIndexDescriptor</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

  <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>indexNode</name> <init>= <expr><call><name>stringToNode</name><argument_list>(<argument><expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>indexattrs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>pull_varattnos_min_attr</name><argument_list>(<argument><expr><name>indexNode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>indexattrs</name></expr></argument>, <argument><expr><name>attr_offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name>updated_attrs</name></expr></argument>, <argument><expr><name>indexattrs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * CheckIndexForUpdate -- Given Oid of an Index corresponding to a specific
 * relation and the set of attributes that are updated because of an SQL
 * statement, this function returns true of the Index needs to be updated and
 * vice versa.
 */</comment>
<function><type><name>bool</name></type>
<name>CheckIndexForUpdate</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>updated_attrs</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attr_offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>Relation</name></type>  <name>indexDesc</name>          <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>indexattrs</name>        <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type> <name>need_update</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/*
   * We first check updates affect the current index by iterating over the
   * columns associated with an index to see if the updated attributes affects
   * the index. If it does, we return true.
   */</comment>
  <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>indexDesc</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indnatts</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
  <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>attrnum</name> <init>= <expr><name><name>indexDesc</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>attrnum</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>bms_is_member</name><argument_list>(<argument><expr><name>attrnum</name> <operator>-</operator> <name>attr_offset</name></expr></argument>, <argument><expr><name>updated_attrs</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>need_update</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <comment type="block">/* If none of the columns are affected, we check for IndexExpressions and IndexPredicates */</comment>
  <expr_stmt><expr><name>need_update</name> <operator>=</operator> <name>need_update</name>
                <operator>||</operator> <call><name>CheckUpdateExprOrPred</name><argument_list>(<argument><expr><name>updated_attrs</name></expr></argument>, <argument><expr><name>indexDesc</name></expr></argument>, <argument><expr><name>Anum_pg_index_indexprs</name></expr></argument>, <argument><expr><name>attr_offset</name></expr></argument>)</argument_list></call>
                <operator>||</operator> <call><name>CheckUpdateExprOrPred</name><argument_list>(<argument><expr><name>updated_attrs</name></expr></argument>, <argument><expr><name>indexDesc</name></expr></argument>, <argument><expr><name>Anum_pg_index_indpred</name></expr></argument>, <argument><expr><name>attr_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>indexattrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexDesc</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>need_update</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RelationGetIndexAttrBitmap -- get a bitmap of index attribute numbers
 *
 * The result has a bit set for each attribute used anywhere in the index
 * definitions of all the indexes on this relation.  (This includes not only
 * simple index keys, but attributes used in expressions and partial-index
 * predicates.)
 *
 * Depending on attrKind, a bitmap covering the attnums for all index columns,
 * for all potential foreign key columns, or for all columns in the configured
 * replica identity index is returned.
 *
 * Attribute numbers are offset by FirstLowInvalidHeapAttributeNumber so that
 * we can include system attributes (e.g., OID) in the bitmap representation.
 *
 * Caller had better hold at least RowExclusiveLock on the target relation
 * to ensure it is safe (deadlock-free) for us to take locks on the relation's
 * indexes.  Note that since the introduction of CREATE INDEX CONCURRENTLY,
 * that lock level doesn't guarantee a stable set of indexes, so we have to
 * be prepared to retry here in case of a change in the set of indexes.
 *
 * The returned result is palloc'd in the caller's memory context and should
 * be bms_free'd when not needed anymore.
 */</comment>
<function><type><name>Bitmapset</name> <modifier>*</modifier></type>
<name>RelationGetIndexAttrBitmap</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>IndexAttrBitmapKind</name></type> <name>attrKind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>indexattrs</name></decl>;</decl_stmt>		<comment type="block">/* columns used in non-projection indexes */</comment>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>projindexattrs</name></decl>;</decl_stmt> <comment type="block">/* columns used in projection indexes */</comment>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>uindexattrs</name></decl>;</decl_stmt>	<comment type="block">/* columns in unique indexes */</comment>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>pkindexattrs</name></decl>;</decl_stmt>	<comment type="block">/* columns in the primary index */</comment>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>idindexattrs</name></decl>;</decl_stmt>	<comment type="block">/* columns in the replica identity */</comment>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>projindexes</name></decl>;</decl_stmt>	<comment type="block">/* projection indexes */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexoidlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newindexoidlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relpkindex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relreplindex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>indexno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>attr_offset</name></decl>;</decl_stmt>

	<comment type="block">/* Quick exit if we already computed the result. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexattr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>attrKind</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>INDEX_ATTR_BITMAP_HOT</name></expr>:</case>
				<return>return <expr><call><name>bms_copy</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexattr</name></name></expr></argument>)</argument_list></call></expr>;</return>
			<case>case <expr><name>INDEX_ATTR_BITMAP_PROJ</name></expr>:</case>
				<return>return <expr><call><name>bms_copy</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_projindexattr</name></name></expr></argument>)</argument_list></call></expr>;</return>
			<case>case <expr><name>INDEX_ATTR_BITMAP_KEY</name></expr>:</case>
				<return>return <expr><call><name>bms_copy</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_keyattr</name></name></expr></argument>)</argument_list></call></expr>;</return>
			<case>case <expr><name>INDEX_ATTR_BITMAP_PRIMARY_KEY</name></expr>:</case>
				<return>return <expr><call><name>bms_copy</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_pkattr</name></name></expr></argument>)</argument_list></call></expr>;</return>
			<case>case <expr><name>INDEX_ATTR_BITMAP_IDENTITY_KEY</name></expr>:</case>
				<return>return <expr><call><name>bms_copy</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_idattr</name></name></expr></argument>)</argument_list></call></expr>;</return>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown attrKind %u"</literal></expr></argument>, <argument><expr><name>attrKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Fast path if definitely no indexes */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>relhasindex</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Get cached list of index OIDs. If we have to start over, we do so here.
	 */</comment>
<label><name>restart</name>:</label>
	<expr_stmt><expr><name>indexoidlist</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fall out if no indexes (but relhasindex was set) */</comment>
	<if_stmt><if>if <condition>(<expr><name>indexoidlist</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Copy the rd_pkindex and rd_replidindex values computed by
	 * RelationGetIndexList before proceeding.  This is needed because a
	 * relcache flush could occur inside index_open below, resetting the
	 * fields managed by RelationGetIndexList.  We need to do the work with
	 * stable values of these fields.
	 */</comment>
	<expr_stmt><expr><name>relpkindex</name> <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_pkindex</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>relreplindex</name> <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_replidindex</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * For each index, add referenced attributes to indexattrs.
	 *
	 * Note: we consider all indexes returned by RelationGetIndexList, even if
	 * they are not indisready or indisvalid.  This is important because an
	 * index for which CREATE INDEX CONCURRENTLY has just started must be
	 * included in HOT-safety decisions (see README.HOT).  If a DROP INDEX
	 * CONCURRENTLY is far enough along that we should ignore the index, it
	 * won't be returned at all by RelationGetIndexList.
	 */</comment>
	<expr_stmt><expr><name>indexattrs</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>projindexattrs</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>uindexattrs</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pkindexattrs</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>idindexattrs</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>projindexes</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>indexno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>attr_offset</name> <operator>=</operator> <call><name>YBGetFirstLowInvalidAttributeNumber</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>indexoidlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>indexOid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>indexDesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>indexExpressions</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>indexPredicate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isKey</name></decl>;</decl_stmt>		<comment type="block">/* candidate key */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isPK</name></decl>;</decl_stmt>		<comment type="block">/* primary key */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isIDKey</name></decl>;</decl_stmt>	<comment type="block">/* replica identity index */</comment>

		<expr_stmt><expr><name>indexDesc</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Extract index expressions and index predicate.  Note: Don't use
		 * RelationGetIndexExpressions()/RelationGetIndexPredicate(), because
		 * those might run constant expressions evaluation, which needs a
		 * snapshot, which we might not have here.  (Also, it's probably more
		 * sound to collect the bitmaps before any transformations that might
		 * eliminate columns, but the practical impact of this is limited.)
		 */</comment>

		<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name><name>indexDesc</name><operator>-&gt;</operator><name>rd_indextuple</name></name></expr></argument>, <argument><expr><name>Anum_pg_index_indexprs</name></expr></argument>,
							 <argument><expr><call><name>GetPgIndexDescriptor</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>indexExpressions</name> <operator>=</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>indexExpressions</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name><name>indexDesc</name><operator>-&gt;</operator><name>rd_indextuple</name></name></expr></argument>, <argument><expr><name>Anum_pg_index_indpred</name></expr></argument>,
							 <argument><expr><call><name>GetPgIndexDescriptor</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>indexPredicate</name> <operator>=</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>indexPredicate</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Can this index be referenced by a foreign key? */</comment>
		<expr_stmt><expr><name>isKey</name> <operator>=</operator> <name><name>indexDesc</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisunique</name></name> <operator>&amp;&amp;</operator>
			<name>indexExpressions</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name>indexPredicate</name> <operator>==</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/* Is this a primary key? */</comment>
		<expr_stmt><expr><name>isPK</name> <operator>=</operator> <operator>(</operator><name>indexOid</name> <operator>==</operator> <name>relpkindex</name><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/* Is this index the configured (or default) replica identity? */</comment>
		<expr_stmt><expr><name>isIDKey</name> <operator>=</operator> <operator>(</operator><name>indexOid</name> <operator>==</operator> <name>relreplindex</name><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/* Collect simple attribute references */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>indexDesc</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indnatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>attrnum</name> <init>= <expr><name><name>indexDesc</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Since we have covering indexes with non-key columns, we must
			 * handle them accurately here. non-key columns must be added into
			 * indexattrs, since they are in index, and HOT-update shouldn't
			 * miss them. Obviously, non-key columns couldn't be referenced by
			 * foreign key or identity key. Hence we do not include them into
			 * uindexattrs, pkindexattrs and idindexattrs bitmaps.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>attrnum</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>indexattrs</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>indexattrs</name></expr></argument>, <argument><expr><name>attrnum</name> <operator>-</operator> <name>attr_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>isKey</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>indexDesc</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indnkeyatts</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>uindexattrs</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>uindexattrs</name></expr></argument>, <argument><expr><name>attrnum</name> <operator>-</operator> <name>attr_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>isPK</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>indexDesc</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indnkeyatts</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>pkindexattrs</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>pkindexattrs</name></expr></argument>, <argument><expr><name>attrnum</name> <operator>-</operator> <name>attr_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>isIDKey</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>indexDesc</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indnkeyatts</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>idindexattrs</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>idindexattrs</name></expr></argument>, <argument><expr><name>attrnum</name> <operator>-</operator> <name>attr_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Collect attributes used in expressions, too */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsProjectionFunctionalIndex</name><argument_list>(<argument><expr><name>indexDesc</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>projindexes</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>projindexes</name></expr></argument>, <argument><expr><name>indexno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pull_varattnos_min_attr</name><argument_list>(<argument><expr><name>indexExpressions</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>projindexattrs</name></expr></argument>, <argument><expr><name>attr_offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Collect all attributes used in expressions, too */</comment>
			<expr_stmt><expr><call><name>pull_varattnos_min_attr</name><argument_list>(<argument><expr><name>indexExpressions</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>indexattrs</name></expr></argument>, <argument><expr><name>attr_offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<comment type="block">/* Collect all attributes in the index predicate, too */</comment>
		<expr_stmt><expr><call><name>pull_varattnos_min_attr</name><argument_list>(<argument><expr><name>indexPredicate</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>indexattrs</name></expr></argument>, <argument><expr><name>attr_offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexDesc</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>indexno</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * During one of the index_opens in the above loop, we might have received
	 * a relcache flush event on this relcache entry, which might have been
	 * signaling a change in the rel's index list.  If so, we'd better start
	 * over to ensure we deliver up-to-date attribute bitmaps.
	 */</comment>
	<expr_stmt><expr><name>newindexoidlist</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>indexoidlist</name></expr></argument>, <argument><expr><name>newindexoidlist</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name>relpkindex</name> <operator>==</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_pkindex</name></name> <operator>&amp;&amp;</operator>
		<name>relreplindex</name> <operator>==</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_replidindex</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Still the same index set, so proceed */</comment>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>newindexoidlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>indexoidlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Gotta do it over ... might as well not leak memory */</comment>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>newindexoidlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>indexoidlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>uindexattrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>pkindexattrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>idindexattrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>indexattrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>projindexattrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>projindexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<goto>goto <name>restart</name>;</goto>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Don't leak the old values of these bitmaps, if any */</comment>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexattr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexattr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_projindexattr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_projindexattr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_keyattr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_keyattr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_pkattr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_pkattr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_idattr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_idattr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_projidx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_projidx</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now save copies of the bitmaps in the relcache entry.  We intentionally
	 * set rd_indexattr last, because that's the one that signals validity of
	 * the values; if we run out of memory before making that copy, we won't
	 * leave the relcache entry looking like the other ones are valid but
	 * empty.
	 */</comment>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_keyattr</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>uindexattrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_pkattr</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>pkindexattrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_idattr</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>idindexattrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_indexattr</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>indexattrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_projindexattr</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>projindexattrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_projidx</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>projindexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We return our original working copy for caller to play with */</comment>
	<switch>switch <condition>(<expr><name>attrKind</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INDEX_ATTR_BITMAP_HOT</name></expr>:</case>
			<return>return <expr><name>indexattrs</name></expr>;</return>
		<case>case <expr><name>INDEX_ATTR_BITMAP_PROJ</name></expr>:</case>
			<return>return <expr><name>projindexattrs</name></expr>;</return>
		<case>case <expr><name>INDEX_ATTR_BITMAP_KEY</name></expr>:</case>
			<return>return <expr><name>uindexattrs</name></expr>;</return>
		<case>case <expr><name>INDEX_ATTR_BITMAP_PRIMARY_KEY</name></expr>:</case>
			<return>return <expr><name>pkindexattrs</name></expr>;</return>
		<case>case <expr><name>INDEX_ATTR_BITMAP_IDENTITY_KEY</name></expr>:</case>
			<return>return <expr><name>idindexattrs</name></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown attrKind %u"</literal></expr></argument>, <argument><expr><name>attrKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * RelationGetExclusionInfo -- get info about index's exclusion constraint
 *
 * This should be called only for an index that is known to have an
 * associated exclusion constraint.  It returns arrays (palloc'd in caller's
 * context) of the exclusion operator OIDs, their underlying functions'
 * OIDs, and their strategy numbers in the index's opclasses.  We cache
 * all this information since it requires a fair amount of work to get.
 */</comment>
<function><type><name>void</name></type>
<name>RelationGetExclusionInfo</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>indexRelation</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name> <modifier>*</modifier><modifier>*</modifier></type><name>operators</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name> <modifier>*</modifier><modifier>*</modifier></type><name>procs</name></decl></parameter>,
						 <parameter><decl><type><name>uint16</name> <modifier>*</modifier><modifier>*</modifier></type><name>strategies</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>indnkeyatts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>ops</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>funcs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name>	   <modifier>*</modifier></type><name>strats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>conrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>conscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>htup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>indnkeyatts</name> <operator>=</operator> <call><name>IndexRelationGetNumberOfKeyAttributes</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allocate result space in caller context */</comment>
	<expr_stmt><expr><operator>*</operator><name>operators</name> <operator>=</operator> <name>ops</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>indnkeyatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>procs</name> <operator>=</operator> <name>funcs</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>indnkeyatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>strategies</name> <operator>=</operator> <name>strats</name> <operator>=</operator> <operator>(</operator><name>uint16</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>indnkeyatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Quick exit if we have the data cached already */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_exclstrats</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ops</name></expr></argument>, <argument><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_exclops</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>indnkeyatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>funcs</name></expr></argument>, <argument><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_exclprocs</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>indnkeyatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>strats</name></expr></argument>, <argument><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_exclstrats</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>indnkeyatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Search pg_constraint for the constraint associated with the index. To
	 * make this not too painfully slow, we use the index on conrelid; that
	 * will hold the parent relation's OID not the index's own OID.
	 *
	 * Note: if we wanted to rely on the constraint name matching the index's
	 * name, we could just do a direct lookup using pg_constraint's unique
	 * index.  For the moment it doesn't seem worth requiring that.
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_conrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indrelid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>conrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>conscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>ConstraintRelidTypidNameIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>conscan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>conform</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>val</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nelem</name></decl>;</decl_stmt>

		<comment type="block">/* We want the exclusion constraint owning the index */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>conform</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTRAINT_EXCLUSION</name> <operator>||</operator>
			<name><name>conform</name><operator>-&gt;</operator><name>conindid</name></name> <operator>!=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* There should be only one */</comment>
		<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected exclusion constraint record found for rel %s"</literal></expr></argument>,
				 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/* Extract the operator OIDS from conexclop */</comment>
		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>fastgetattr</name><argument_list>(<argument><expr><name>htup</name></expr></argument>,
						  <argument><expr><name>Anum_pg_constraint_conexclop</name></expr></argument>,
						  <argument><expr><name><name>conrel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null conexclop for rel %s"</literal></expr></argument>,
				 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>arr</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* ensure not toasted */</comment>
		<expr_stmt><expr><name>nelem</name> <operator>=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
			<name>nelem</name> <operator>!=</operator> <name>indnkeyatts</name> <operator>||</operator>
			<call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>OIDOID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"conexclop is not a 1-D Oid array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ops</name></expr></argument>, <argument><expr><call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>indnkeyatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>conscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"exclusion constraint record missing for rel %s"</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* We need the func OIDs and strategy numbers too */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>indnkeyatts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>funcs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_opcode</name><argument_list>(<argument><expr><name><name>ops</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>strats</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_op_opfamily_strategy</name><argument_list>(<argument><expr><name><name>ops</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
											 <argument><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_opfamily</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* shouldn't fail, since it was checked at index creation */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>strats</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>InvalidStrategy</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find strategy for operator %u in family %u"</literal></expr></argument>,
				 <argument><expr><name><name>ops</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_opfamily</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Save a copy of the results in the relcache entry. */</comment>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_indexcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_exclops</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>indnkeyatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_exclprocs</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>indnkeyatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_exclstrats</name></name> <operator>=</operator> <operator>(</operator><name>uint16</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>indnkeyatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_exclops</name></name></expr></argument>, <argument><expr><name>ops</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>indnkeyatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_exclprocs</name></name></expr></argument>, <argument><expr><name>funcs</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>indnkeyatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_exclstrats</name></name></expr></argument>, <argument><expr><name>strats</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>indnkeyatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get publication actions for the given relation.
 */</comment>
<function><type><name><name>struct</name> <name>PublicationActions</name></name> <modifier>*</modifier></type>
<name>GetRelationPublicationActions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>puboids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PublicationActions</name> <modifier>*</modifier></type><name>pubactions</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PublicationActions</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_pubactions</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pubactions</name></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_pubactions</name></name></expr></argument>,
					  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PublicationActions</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Fetch the publication membership info. */</comment>
	<expr_stmt><expr><name>puboids</name> <operator>=</operator> <call><name>GetRelationPublications</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>puboids</name> <operator>=</operator> <call><name>list_concat_unique_oid</name><argument_list>(<argument><expr><name>puboids</name></expr></argument>, <argument><expr><call><name>GetAllTablesPublications</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>puboids</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>pubid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_publication</name></type> <name>pubform</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PUBLICATIONOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>pubid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for publication %u"</literal></expr></argument>, <argument><expr><name>pubid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>pubform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_publication</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>pubactions</name><operator>-&gt;</operator><name>pubinsert</name></name> <operator>|=</operator> <name><name>pubform</name><operator>-&gt;</operator><name>pubinsert</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pubactions</name><operator>-&gt;</operator><name>pubupdate</name></name> <operator>|=</operator> <name><name>pubform</name><operator>-&gt;</operator><name>pubupdate</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pubactions</name><operator>-&gt;</operator><name>pubdelete</name></name> <operator>|=</operator> <name><name>pubform</name><operator>-&gt;</operator><name>pubdelete</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pubactions</name><operator>-&gt;</operator><name>pubtruncate</name></name> <operator>|=</operator> <name><name>pubform</name><operator>-&gt;</operator><name>pubtruncate</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we know everything is replicated, there is no point to check for
		 * other publications.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pubactions</name><operator>-&gt;</operator><name>pubinsert</name></name> <operator>&amp;&amp;</operator> <name><name>pubactions</name><operator>-&gt;</operator><name>pubupdate</name></name> <operator>&amp;&amp;</operator>
			<name><name>pubactions</name><operator>-&gt;</operator><name>pubdelete</name></name> <operator>&amp;&amp;</operator> <name><name>pubactions</name><operator>-&gt;</operator><name>pubtruncate</name></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_pubactions</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_pubactions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_pubactions</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Now save copy of the actions in the relcache entry. */</comment>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_pubactions</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PublicationActions</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_pubactions</name></name></expr></argument>, <argument><expr><name>pubactions</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PublicationActions</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>pubactions</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Routines to support ereport() reports of relation-related errors
 *
 * These could have been put into elog.c, but it seems like a module layering
 * violation to have elog.c calling relcache or syscache stuff --- and we
 * definitely don't want elog.h including rel.h.  So we put them here.
 */</comment>

<comment type="block">/*
 * errtable --- stores schema_name and table_name of a table
 * within the current errordata.
 */</comment>
<function><type><name>int</name></type>
<name>errtable</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>err_generic_string</name><argument_list>(<argument><expr><name>PG_DIAG_SCHEMA_NAME</name></expr></argument>,
					   <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>err_generic_string</name><argument_list>(<argument><expr><name>PG_DIAG_TABLE_NAME</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>					<comment type="block">/* return value does not matter */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * errtablecol --- stores schema_name, table_name and column_name
 * of a table column within the current errordata.
 *
 * The column is specified by attribute number --- for most callers, this is
 * easier and less error-prone than getting the column name for themselves.
 */</comment>
<function><type><name>int</name></type>
<name>errtablecol</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>reldesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl>;</decl_stmt>

	<comment type="block">/* Use reldesc if it's a user attribute, else consult the catalogs */</comment>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>attnum</name> <operator>&lt;=</operator> <name><name>reldesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>reldesc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>get_attname</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><call><name>errtablecolname</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * errtablecolname --- stores schema_name, table_name and column_name
 * of a table column within the current errordata, where the column name is
 * given directly rather than extracted from the relation's catalog data.
 *
 * Don't use this directly unless errtablecol() is inconvenient for some
 * reason.  This might possibly be needed during intermediate states in ALTER
 * TABLE, for instance.
 */</comment>
<function><type><name>int</name></type>
<name>errtablecolname</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>errtable</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>err_generic_string</name><argument_list>(<argument><expr><name>PG_DIAG_COLUMN_NAME</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>					<comment type="block">/* return value does not matter */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * errtableconstraint --- stores schema_name, table_name and constraint_name
 * of a table-related constraint within the current errordata.
 */</comment>
<function><type><name>int</name></type>
<name>errtableconstraint</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>conname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>errtable</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>err_generic_string</name><argument_list>(<argument><expr><name>PG_DIAG_CONSTRAINT_NAME</name></expr></argument>, <argument><expr><name>conname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>					<comment type="block">/* return value does not matter */</comment>
</block_content>}</block></function>


<comment type="block">/*
 *	load_relcache_init_file, write_relcache_init_file
 *
 *		In late 1992, we started regularly having databases with more than
 *		a thousand classes in them.  With this number of classes, it became
 *		critical to do indexed lookups on the system catalogs.
 *
 *		Bootstrapping these lookups is very hard.  We want to be able to
 *		use an index on pg_attribute, for example, but in order to do so,
 *		we must have read pg_attribute for the attributes in the index,
 *		which implies that we need to use the index.
 *
 *		In order to get around the problem, we do the following:
 *
 *		   +  When the database system is initialized (at initdb time), we
 *			  don't use indexes.  We do sequential scans.
 *
 *		   +  When the backend is started up in normal mode, we load an image
 *			  of the appropriate relation descriptors, in internal format,
 *			  from an initialization file in the data/base/... directory.
 *
 *		   +  If the initialization file isn't there, then we create the
 *			  relation descriptors using sequential scans and write 'em to
 *			  the initialization file for use by subsequent backends.
 *
 *		As of Postgres 9.0, there is one local initialization file in each
 *		database, plus one shared initialization file for shared catalogs.
 *
 *		We could dispense with the initialization files and just build the
 *		critical reldescs the hard way on every backend startup, but that
 *		slows down backend startup noticeably.
 *
 *		We can in fact go further, and save more relcache entries than
 *		just the ones that are absolutely critical; this allows us to speed
 *		up backend startup by not having to build such entries the hard way.
 *		Presently, all the catalog and index entries that are referred to
 *		by catcaches are stored in the initialization files.
 *
 *		The same mechanism that detects when catcache and relcache entries
 *		need to be invalidated (due to catalog updates) also arranges to
 *		unlink the initialization files when the contents may be out of date.
 *		The files will then be rebuilt during the next backend startup.
 */</comment>

<comment type="block">/*
 * load_relcache_init_file -- attempt to load cache from the shared
 * or local cache init file
 *
 * If successful, return true and set criticalRelcachesBuilt or
 * criticalSharedRelcachesBuilt to true.
 * If not successful, return false.
 *
 * NOTE: we assume we are already switched into CacheMemoryContext.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>load_relcache_init_file</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>shared</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>initfilename</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name>   <modifier>*</modifier></type><name>rels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>relno</name></decl>,
				<decl><type ref="prev"/><name>num_rels</name></decl>,
				<decl><type ref="prev"/><name>max_rels</name></decl>,
				<decl><type ref="prev"/><name>nailed_rels</name></decl>,
				<decl><type ref="prev"/><name>nailed_indexes</name></decl>,
				<decl><type ref="prev"/><name>magic</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>      <name>ybc_stored_cache_version</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Disable shared init file in per database catalog version mode because
	 * MyDatabaseId isn't known yet and different databases have different
	 * catalog versions of their own. At this time we cannot compose the
	 * correct init file name for the to-be-resolved MyDatabaseId.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>shared</name> <operator>&amp;&amp;</operator> <call><name>YBIsDBCatalogVersionMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>RelCacheInitFileName</name><argument_list>(<argument><expr><name>initfilename</name></expr></argument>, <argument><expr><name>shared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>initfilename</name></expr></argument>, <argument><expr><name>PG_BINARY_R</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Read the index relcache entries from the file.  Note we will not enter
	 * any of them into the cache if the read fails partway through; this
	 * helps to guard against broken init files.
	 */</comment>
	<expr_stmt><expr><name>max_rels</name> <operator>=</operator> <literal type="number">100</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>rels</name> <operator>=</operator> <operator>(</operator><name>Relation</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>max_rels</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Relation</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_rels</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>nailed_rels</name> <operator>=</operator> <name>nailed_indexes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* check for correct magic number (compatible version) */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>magic</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>magic</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>magic</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>read_failed</name>;</goto></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>magic</name> <operator>!=</operator> <name>RELCACHE_INIT_FILEMAGIC</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>read_failed</name>;</goto></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Read the stored catalog version number */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ybc_stored_cache_version</name></expr></argument>,
		          <argument><expr><literal type="number">1</literal></expr></argument>,
		          <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ybc_stored_cache_version</name></expr></argument>)</argument_list></sizeof></expr></argument>,
		          <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ybc_stored_cache_version</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
		<block>{<block_content>
			<goto>goto <name>read_failed</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If we already have a newer cache version (e.g. from reading the
		 * shared init file) or master has newer catalog version then this file is too old.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>YbGetCatalogCacheVersion</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name>ybc_stored_cache_version</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>unlink_initfile</name><argument_list>(<argument><expr><name>initfilename</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>read_failed</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>relno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init><condition>;</condition> <incr><expr><name>relno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>		<name>len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type>		<name>nread</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>relform</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>has_not_null</name></decl>;</decl_stmt>

		<comment type="block">/* first read the relation descriptor length */</comment>
		<expr_stmt><expr><name>nread</name> <operator>=</operator> <call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>nread</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>nread</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* end of file */</comment>
			<goto>goto <name>read_failed</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* safety check for incompatible relcache layout */</comment>
		<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RelationData</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>read_failed</name>;</goto></block_content></block></if></if_stmt>

		<comment type="block">/* allocate another relcache header */</comment>
		<if_stmt><if>if <condition>(<expr><name>num_rels</name> <operator>&gt;=</operator> <name>max_rels</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>max_rels</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>rels</name> <operator>=</operator> <operator>(</operator><name>Relation</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>rels</name></expr></argument>, <argument><expr><name>max_rels</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Relation</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>rel</name> <operator>=</operator> <name><name>rels</name><index>[<expr><name>num_rels</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Relation</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* then, read the Relation structure */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>read_failed</name>;</goto></block_content></block></if></if_stmt>

		<comment type="block">/* next read the relation tuple form */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>read_failed</name>;</goto></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>relform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><name>relform</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>read_failed</name>;</goto></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name></name> <operator>=</operator> <name>relform</name></expr>;</expr_stmt>

		<comment type="block">/* initialize attribute tuple forms */</comment>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name><name>relform</name><operator>-&gt;</operator><name>relnatts</name></name></expr></argument>,
											  <argument><expr><name><name>relform</name><operator>-&gt;</operator><name>relhasoids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>tdrefcount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* mark as refcounted */</comment>

		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>tdtypeid</name></name> <operator>=</operator> <name><name>relform</name><operator>-&gt;</operator><name>reltype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>tdtypmod</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* unnecessary, but... */</comment>

		<comment type="block">/* next read all the attribute tuple form data entries */</comment>
		<expr_stmt><expr><name>has_not_null</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>relform</name><operator>-&gt;</operator><name>relnatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>read_failed</name>;</goto></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <name>ATTRIBUTE_FIXED_PART_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>read_failed</name>;</goto></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><name>attr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>read_failed</name>;</goto></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>has_not_null</name> <operator>|=</operator> <name><name>attr</name><operator>-&gt;</operator><name>attnotnull</name></name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* next read the access method specific field */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>read_failed</name>;</goto></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_options</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_options</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>read_failed</name>;</goto></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_options</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>read_failed</name>;</goto></block_content></block></if></if_stmt>	<comment type="block">/* sanity check */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_options</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* mark not-null status */</comment>
		<if_stmt><if>if <condition>(<expr><name>has_not_null</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TupleConstr</name> <modifier>*</modifier></type><name>constr</name> <init>= <expr><operator>(</operator><name>TupleConstr</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TupleConstr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>has_not_null</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name> <operator>=</operator> <name>constr</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If it's an index, there's more to do.  Note we explicitly ignore
		 * partitioned indexes here.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_INDEX</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>indexcxt</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>opfamily</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>opcintype</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RegProcedure</name> <modifier>*</modifier></type><name>support</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>nsupport</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int16</name>	   <modifier>*</modifier></type><name>indoption</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>indcollation</name></decl>;</decl_stmt>

			<comment type="block">/* Count nailed indexes to ensure we have 'em all */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_isnailed</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>nailed_indexes</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* next, read the pg_index tuple */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>read_failed</name>;</goto></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_indextuple</name></name> <operator>=</operator> <operator>(</operator><name>HeapTuple</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_indextuple</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>read_failed</name>;</goto></block_content></block></if></if_stmt>

			<comment type="block">/* Fix up internal pointers in the tuple -- see heap_copytuple */</comment>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_indextuple</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_indextuple</name></name> <operator>+</operator> <name>HEAPTUPLESIZE</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_index</name></name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_indextuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * prepare index info context --- parameters should match
			 * RelationInitIndexAccessInfo
			 */</comment>
			<expr_stmt><expr><name>indexcxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>,
											 <argument><expr><literal type="string">"index info"</literal></expr></argument>,
											 <argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_indexcxt</name></name> <operator>=</operator> <name>indexcxt</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextCopyAndSetIdentifier</name><argument_list>(<argument><expr><name>indexcxt</name></expr></argument>,
											  <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Now we can fetch the index AM's API struct.  (We can't store
			 * that in the init file, since it contains function pointers that
			 * might vary across server executions.  Fortunately, it should be
			 * safe to call the amhandler even while bootstrapping indexes.)
			 */</comment>
			<expr_stmt><expr><call><name>InitIndexAmRoutine</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* next, read the vector of opfamily OIDs */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>read_failed</name>;</goto></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>opfamily</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>indexcxt</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>read_failed</name>;</goto></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_opfamily</name></name> <operator>=</operator> <name>opfamily</name></expr>;</expr_stmt>

			<comment type="block">/* next, read the vector of opcintype OIDs */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>read_failed</name>;</goto></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>opcintype</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>indexcxt</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><name>opcintype</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>read_failed</name>;</goto></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_opcintype</name></name> <operator>=</operator> <name>opcintype</name></expr>;</expr_stmt>

			<comment type="block">/* next, read the vector of support procedure OIDs */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>read_failed</name>;</goto></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>support</name> <operator>=</operator> <operator>(</operator><name>RegProcedure</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>indexcxt</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><name>support</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>read_failed</name>;</goto></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_support</name></name> <operator>=</operator> <name>support</name></expr>;</expr_stmt>

			<comment type="block">/* next, read the vector of collation OIDs */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>read_failed</name>;</goto></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>indcollation</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>indexcxt</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><name>indcollation</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>read_failed</name>;</goto></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_indcollation</name></name> <operator>=</operator> <name>indcollation</name></expr>;</expr_stmt>

			<comment type="block">/* finally, read the vector of indoption values */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>read_failed</name>;</goto></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>indoption</name> <operator>=</operator> <operator>(</operator><name>int16</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>indexcxt</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><name>indoption</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>read_failed</name>;</goto></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_indoption</name></name> <operator>=</operator> <name>indoption</name></expr>;</expr_stmt>

			<comment type="block">/* set up zeroed fmgr-info vector */</comment>
			<expr_stmt><expr><name>nsupport</name> <operator>=</operator> <name><name>relform</name><operator>-&gt;</operator><name>relnatts</name></name> <operator>*</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_amroutine</name><operator>-&gt;</operator><name>amsupport</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_supportinfo</name></name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator>
				<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>indexcxt</name></expr></argument>, <argument><expr><name>nsupport</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Count nailed rels to ensure we have 'em all */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_isnailed</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>nailed_rels</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_index</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_indextuple</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_indexcxt</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_amroutine</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_opfamily</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_opcintype</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_support</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_supportinfo</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_indoption</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_indcollation</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Rules and triggers are not saved (mainly because the internal
		 * format is complex and subject to change).  They must be rebuilt if
		 * needed by RelationCacheInitializePhase3.  This is not expected to
		 * be a big performance hit since few system catalogs have such. Ditto
		 * for RLS policy data, index expressions, predicates, exclusion info,
		 * and FDW info.
		 */</comment>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rules</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rulescxt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>trigdesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rsdesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_partkeycxt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_partkey</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_pdcxt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_partdesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_partcheck</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_indexprs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_indpred</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_exclops</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_exclprocs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_exclstrats</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_fdwroutine</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Reset transient-state fields in the relcache entry
		 */</comment>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_isnailed</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_refcnt</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_refcnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_indexvalid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_fkeylist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_fkeyvalid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_indexlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_oidindex</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_pkindex</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_replidindex</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_indexattr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_projindexattr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_keyattr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_pkattr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_idattr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_projidx</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_pubactions</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_statvalid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_statlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_createSubid</name></name> <operator>=</operator> <name>InvalidSubTransactionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_newRelfilenodeSubid</name></name> <operator>=</operator> <name>InvalidSubTransactionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_amcache</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rel</name><operator>-&gt;</operator><name>pgstat_info</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>pgstat_info</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Recompute lock and physical addressing info.  This is needed in
		 * case the pg_internal.init file was copied from some other database
		 * by CREATE DATABASE.
		 */</comment>
		<expr_stmt><expr><call><name>RelationInitLockInfo</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RelationInitPhysicalAddr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * We reached the end of the init file without apparent problem.  Did we
	 * get the right number of nailed items?  This is a useful crosscheck in
	 * case the set of critical rels or indexes changes.  However, that should
	 * not happen in a normally-running system, so let's bleat if it does.
	 *
	 * For the shared init file, we're called before client authentication is
	 * done, which means that elog(WARNING) will go only to the postmaster
	 * log, where it's easily missed.  To ensure that developers notice bad
	 * values of NUM_CRITICAL_SHARED_RELS/NUM_CRITICAL_SHARED_INDEXES, we put
	 * an Assert(false) there.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>num_critical_shared_indexes</name> <init>= <expr><name>NUM_CRITICAL_SHARED_INDEXES</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>num_critical_local_indexes</name> <init>= <expr><name>NUM_CRITICAL_LOCAL_INDEXES</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>shared</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>nailed_rels</name> <operator>!=</operator> <name>NUM_CRITICAL_SHARED_RELS</name> <operator>||</operator>
			<name>nailed_indexes</name> <operator>!=</operator> <name>num_critical_shared_indexes</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"found %d nailed shared rels and %d nailed shared indexes in init file, but expected %d and %d respectively"</literal></expr></argument>,
				 <argument><expr><name>nailed_rels</name></expr></argument>, <argument><expr><name>nailed_indexes</name></expr></argument>,
				 <argument><expr><name>NUM_CRITICAL_SHARED_RELS</name></expr></argument>, <argument><expr><name>num_critical_shared_indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Make sure we get developers' attention about this */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* In production builds, recover by bootstrapping the relcache */</comment>
			<goto>goto <name>read_failed</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>nailed_rels</name> <operator>!=</operator> <name>NUM_CRITICAL_LOCAL_RELS</name> <operator>||</operator>
			<name>nailed_indexes</name> <operator>!=</operator> <name>num_critical_local_indexes</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"found %d nailed rels and %d nailed indexes in init file, but expected %d and %d respectively"</literal></expr></argument>,
				 <argument><expr><name>nailed_rels</name></expr></argument>, <argument><expr><name>nailed_indexes</name></expr></argument>,
				 <argument><expr><name>NUM_CRITICAL_LOCAL_RELS</name></expr></argument>, <argument><expr><name>num_critical_local_indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* We don't need an Assert() in this case */</comment>
			<goto>goto <name>read_failed</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * OK, all appears well.
	 *
	 * Now insert all the new relcache entries into the cache.
	 */</comment>
	<for>for <control>(<init><expr><name>relno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>relno</name> <operator>&lt;</operator> <name>num_rels</name></expr>;</condition> <incr><expr><name>relno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RelationCacheInsert</name><argument_list>(<argument><expr><name><name>rels</name><index>[<expr><name>relno</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Set the catalog version if needed.
		 * The checks above will ensure that if it is already initialized then
		 * we should leave it unchanged (see also comment in pg_yb_utils.h).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>YbGetCatalogCacheVersion</name><argument_list>()</argument_list></call> <operator>==</operator> <name>YB_CATCACHE_VERSION_UNINITIALIZED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>YbUpdateCatalogCacheVersion</name><argument_list>(<argument><expr><name>ybc_stored_cache_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>shared</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>criticalSharedRelcachesBuilt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>criticalRelcachesBuilt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>

	<comment type="block">/*
	 * init file is broken, so do it the hard way.  We don't bother trying to
	 * free the clutter we just allocated; it's not in the relcache so it
	 * won't hurt.
	 */</comment>
<label><name>read_failed</name>:</label>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Write out a new initialization file with the current contents
 * of the relcache (either shared rels or local rels, as indicated).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_relcache_init_file</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>shared</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>tempfilename</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>finalfilename</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>magic</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelIdCacheEnt</name> <modifier>*</modifier></type><name>idhentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Disable shared init file in per database catalog version mode because
	 * it will never be read in load_relcache_init_file.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>shared</name> <operator>&amp;&amp;</operator> <call><name>YBIsDBCatalogVersionMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we have already received any relcache inval events, there's no
	 * chance of succeeding so we may as well skip the whole thing.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>relcacheInvalsReceived</name> <operator>!=</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We must write a temporary file and rename it into place. Otherwise,
	 * another backend starting at about the same time might crash trying to
	 * read the partially-complete file.
	 */</comment>
	<expr_stmt><expr><call><name>RelCacheInitTempFileName</name><argument_list>(<argument><expr><name>tempfilename</name></expr></argument>, <argument><expr><name>shared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RelCacheInitFileName</name><argument_list>(<argument><expr><name>finalfilename</name></expr></argument>, <argument><expr><name>shared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>tempfilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* in case it exists w/wrong permissions */</comment>

	<expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>tempfilename</name></expr></argument>, <argument><expr><name>PG_BINARY_W</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fp</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We used to consider this a fatal error, but we might as well
		 * continue with backend startup ...
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create relation-cache initialization file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>tempfilename</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Continuing anyway, but there's something wrong."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Write a magic number to serve as a file version identifier.  We can
	 * change the magic number whenever the relcache layout changes.
	 */</comment>
	<expr_stmt><expr><name>magic</name> <operator>=</operator> <name>RELCACHE_INIT_FILEMAGIC</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><operator>&amp;</operator><name>magic</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>magic</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>magic</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"could not write init file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Write the ysql_catalog_version */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>catalog_cache_version</name> <init>= <expr><call><name>YbGetCatalogCacheVersion</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><operator>&amp;</operator><name>catalog_cache_version</name></expr></argument>,
		           <argument><expr><literal type="number">1</literal></expr></argument>,
		           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>catalog_cache_version</name></expr></argument>)</argument_list></sizeof></expr></argument>,
		           <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>catalog_cache_version</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"could not write init file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Write all the appropriate reldescs (in no particular order).
	 */</comment>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>RelationIdCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>idhentry</name> <operator>=</operator> <operator>(</operator><name>RelIdCacheEnt</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name><name>idhentry</name><operator>-&gt;</operator><name>reldesc</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>relform</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* ignore if not correct group */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>relform</name><operator>-&gt;</operator><name>relisshared</name></name> <operator>!=</operator> <name>shared</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Ignore if not supposed to be in init file.  We can allow any shared
		 * relation that's been loaded so far to be in the shared init file,
		 * but unshared relations must be ones that should be in the local
		 * file per RelationIdIsInInitFile.  (Note: if you want to change the
		 * criterion for rels to be kept in the init file, see also inval.c.
		 * The reason for filtering here is to be sure that we don't put
		 * anything into the local init file for which a relcache inval would
		 * not cause invalidation of that init file.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>shared</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>RelationIdIsInInitFile</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Nailed rels had better get stored. */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_isnailed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* first write the relcache entry proper */</comment>
		<expr_stmt><expr><call><name>write_item</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelationData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* next write the relation tuple form */</comment>
		<expr_stmt><expr><call><name>write_item</name><argument_list>(<argument><expr><name>relform</name></expr></argument>, <argument><expr><name>CLASS_TUPLE_SIZE</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* next, do all the attribute tuple form data entries */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>relform</name><operator>-&gt;</operator><name>relnatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>write_item</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name>ATTRIBUTE_FIXED_PART_SIZE</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* next, do the access method specific field */</comment>
		<expr_stmt><expr><call><name>write_item</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_options</name></name></expr></argument>,
				   <argument><expr><operator>(</operator><ternary><condition><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_options</name></name></expr> ?</condition><then> <expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_options</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>,
				   <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If it's an index, there's more to do. Note we explicitly ignore
		 * partitioned indexes here.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_INDEX</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* write the pg_index tuple */</comment>
			<comment type="block">/* we assume this was created by heap_copytuple! */</comment>
			<expr_stmt><expr><call><name>write_item</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_indextuple</name></name></expr></argument>,
					   <argument><expr><name>HEAPTUPLESIZE</name> <operator>+</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_indextuple</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>,
					   <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* next, write the vector of opfamily OIDs */</comment>
			<expr_stmt><expr><call><name>write_item</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_opfamily</name></name></expr></argument>,
					   <argument><expr><name><name>relform</name><operator>-&gt;</operator><name>relnatts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					   <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* next, write the vector of opcintype OIDs */</comment>
			<expr_stmt><expr><call><name>write_item</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_opcintype</name></name></expr></argument>,
					   <argument><expr><name><name>relform</name><operator>-&gt;</operator><name>relnatts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					   <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* next, write the vector of support procedure OIDs */</comment>
			<expr_stmt><expr><call><name>write_item</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_support</name></name></expr></argument>,
					   <argument><expr><name><name>relform</name><operator>-&gt;</operator><name>relnatts</name></name> <operator>*</operator> <operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_amroutine</name><operator>-&gt;</operator><name>amsupport</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RegProcedure</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>,
					   <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* next, write the vector of collation OIDs */</comment>
			<expr_stmt><expr><call><name>write_item</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_indcollation</name></name></expr></argument>,
					   <argument><expr><name><name>relform</name><operator>-&gt;</operator><name>relnatts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					   <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* finally, write the vector of indoption values */</comment>
			<expr_stmt><expr><call><name>write_item</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_indoption</name></name></expr></argument>,
					   <argument><expr><name><name>relform</name><operator>-&gt;</operator><name>relnatts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					   <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"could not write init file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Now we have to check whether the data we've so painstakingly
	 * accumulated is already obsolete due to someone else's just-committed
	 * catalog changes.  If so, we just delete the temp file and leave it to
	 * the next backend to try again.  (Our own relcache entries will be
	 * updated by SI message processing, but we can't be sure whether what we
	 * wrote out was up-to-date.)
	 *
	 * This mustn't run concurrently with the code that unlinks an init file
	 * and sends SI messages, so grab a serialization lock for the duration.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>RelCacheInitLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure we have seen all incoming SI messages */</comment>
	<expr_stmt><expr><call><name>AcceptInvalidationMessages</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we have received any SI relcache invals since backend start, assume
	 * we may have written out-of-date data.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>relcacheInvalsReceived</name> <operator>==</operator> <literal type="number">0L</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * OK, rename the temp file to its final name, deleting any
		 * previously-existing init file.
		 *
		 * Note: a failure here is possible under Cygwin, if some other
		 * backend is holding open an unlinked-but-not-yet-gone init file. So
		 * treat this as a noncritical failure; just remove the useless temp
		 * file on failure.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>rename</name><argument_list>(<argument><expr><name>tempfilename</name></expr></argument>, <argument><expr><name>finalfilename</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>tempfilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Delete the already-obsolete temp file */</comment>
		<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>tempfilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>RelCacheInitLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* write a chunk of data preceded by its length */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_item</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"could not write init file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"could not write init file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Determine whether a given relation (identified by OID) is one of the ones
 * we should store in a relcache init file.
 *
 * We must cache all nailed rels, and for efficiency we should cache every rel
 * that supports a syscache.  The former set is almost but not quite a subset
 * of the latter. The special cases are relations where
 * RelationCacheInitializePhase2/3 chooses to nail for efficiency reasons, but
 * which do not support any syscache.
 */</comment>
<function><type><name>bool</name></type>
<name>RelationIdIsInInitFile</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>relationId</name> <operator>==</operator> <name>SharedSecLabelRelationId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>TriggerRelidNameIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>DatabaseNameIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>SharedSecLabelObjectIndexId</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If this Assert fails, we don't need the applicable special case
		 * anymore.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>RelationSupportsSysCache</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>RelationSupportsSysCache</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Tells whether any index for the relation is unlogged.
 *
 * Note: There doesn't seem to be any way to have an unlogged index attached
 * to a permanent table, but it seems best to keep this general so that it
 * returns sensible results even when they seem obvious (like for an unlogged
 * table) and to handle possible future unlogged indexes on permanent tables.
 */</comment>
<function><type><name>bool</name></type>
<name>RelationHasUnloggedIndex</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexoidlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>indexoidscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>indexoidlist</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>indexoidscan</argument>, <argument>indexoidlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>indexoid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>indexoidscan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>reltup</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>indexoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>reltup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>reltup</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_UNLOGGED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>true</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>indexoidlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Invalidate (remove) the init file during commit of a transaction that
 * changed one or more of the relation cache entries that are kept in the
 * local init file.
 *
 * To be safe against concurrent inspection or rewriting of the init file,
 * we must take RelCacheInitLock, then remove the old init file, then send
 * the SI messages that include relcache inval for such relations, and then
 * release RelCacheInitLock.  This serializes the whole affair against
 * write_relcache_init_file, so that we can be sure that any other process
 * that's concurrently trying to create a new init file won't move an
 * already-stale version into place after we unlink.  Also, because we unlink
 * before sending the SI messages, a backend that's currently starting cannot
 * read the now-obsolete init file and then miss the SI messages that will
 * force it to update its relcache entries.  (This works because the backend
 * startup sequence gets into the sinval array before trying to load the init
 * file.)
 *
 * We take the lock and do the unlink in RelationCacheInitFilePreInvalidate,
 * then release the lock in RelationCacheInitFilePostInvalidate.  Caller must
 * send any pending SI messages between those calls.
 */</comment>
<function><type><name>void</name></type>
<name>RelationCacheInitFilePreInvalidate</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>localinitfname</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>sharedinitfname</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>DatabasePath</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RelCacheInitFileName</name><argument_list>(<argument><expr><name>localinitfname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>RelCacheInitFileName</name><argument_list>(<argument><expr><name>sharedinitfname</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>RelCacheInitLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The files might not be there if no backend has been started since the
	 * last removal.  But complain about failures other than ENOENT with
	 * ERROR.  Fortunately, it's not too late to abort the transaction if we
	 * can't get rid of the would-be-obsolete init file.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>DatabasePath</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>unlink_initfile</name><argument_list>(<argument><expr><name>localinitfname</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>unlink_initfile</name><argument_list>(<argument><expr><name>sharedinitfname</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>RelationCacheInitFilePostInvalidate</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>RelCacheInitLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Remove the init files during postmaster startup.
 *
 * We used to keep the init files across restarts, but that is unsafe in PITR
 * scenarios, and even in simple crash-recovery cases there are windows for
 * the init files to become out-of-sync with the database.  So now we just
 * remove them during startup and expect the first backend launch to rebuild
 * them.  Of course, this has to happen in each database of the cluster.
 */</comment>
<function><type><name>void</name></type>
<name>RelationCacheInitFileRemove</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tblspcdir</name> <init>= <expr><literal type="string">"pg_tblspc"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>dir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name> <operator>+</operator> <literal type="number">10</literal> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TABLESPACE_VERSION_DIRECTORY</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * In YugaByte mode we anyway do a cache version check on each backend init
	 * so no need to preemptively clean up the init files here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"global/%s"</literal></expr></argument>,
			 <argument><expr><name>RELCACHE_INIT_FILENAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unlink_initfile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Scan everything in the default tablespace */</comment>
	<expr_stmt><expr><call><name>RelationCacheInitFileRemoveInDir</name><argument_list>(<argument><expr><literal type="string">"base"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Scan the tablespace link directory to find non-default tablespaces */</comment>
	<expr_stmt><expr><name>dir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><name>tblspcdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>ReadDirExtended</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>tblspcdir</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strspn</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"0123456789"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Scan the tablespace dir for per-database dirs */</comment>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s/%s"</literal></expr></argument>,
					 <argument><expr><name>tblspcdir</name></expr></argument>, <argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>TABLESPACE_VERSION_DIRECTORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>RelationCacheInitFileRemoveInDir</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Process one per-tablespace directory for RelationCacheInitFileRemove */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RelationCacheInitFileRemoveInDir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tblspcpath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>dir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>initfilename</name><index>[<expr><name>MAXPGPATH</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* Scan the tablespace directory to find per-database directories */</comment>
	<expr_stmt><expr><name>dir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><name>tblspcpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>ReadDirExtended</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>tblspcpath</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strspn</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"0123456789"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Try to remove the init file in each database */</comment>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>initfilename</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>initfilename</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s/%s"</literal></expr></argument>,
					 <argument><expr><name>tblspcpath</name></expr></argument>, <argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>RELCACHE_INIT_FILENAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>unlink_initfile</name><argument_list>(<argument><expr><name>initfilename</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>unlink_initfile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>initfilename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>initfilename</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* It might not be there, but log any error other than ENOENT */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove cache file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>initfilename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
</unit>
