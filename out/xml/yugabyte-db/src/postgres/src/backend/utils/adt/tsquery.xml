<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/utils/adt/tsquery.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * tsquery.c
 *	  I/O functions for tsquery
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 *
 *
 * IDENTIFICATION
 *	  src/backend/utils/adt/tsquery.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tsearch/ts_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tsearch/ts_locale.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tsearch/ts_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_crc.h"</cpp:file></cpp:include>

<comment type="block">/* FTS operator priorities, see ts_type.h */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type>	<name><name>tsearch_op_priority</name><index>[<expr><name>OP_COUNT</name></expr>]</index></name> <init>=
<expr><block>{
	<expr><literal type="number">4</literal></expr>,							<comment type="block">/* OP_NOT */</comment>
	<expr><literal type="number">2</literal></expr>,							<comment type="block">/* OP_AND */</comment>
	<expr><literal type="number">1</literal></expr>,							<comment type="block">/* OP_OR */</comment>
	<expr><literal type="number">3</literal></expr>							<comment type="block">/* OP_PHRASE */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * parser's states
 */</comment>
<typedef>typedef <type><enum>enum
<block>{
	<decl><name>WAITOPERAND</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
	<decl><name>WAITOPERATOR</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,
	<decl><name>WAITFIRSTOPERAND</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>
}</block></enum></type> <name>ts_parserstate</name>;</typedef>

<comment type="block">/*
 * token types for parsing
 */</comment>
<typedef>typedef <type><enum>enum
<block>{
	<decl><name>PT_END</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
	<decl><name>PT_ERR</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
	<decl><name>PT_VAL</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,
	<decl><name>PT_OPR</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>,
	<decl><name>PT_OPEN</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>,
	<decl><name>PT_CLOSE</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>
}</block></enum></type> <name>ts_tokentype</name>;</typedef>

<comment type="block">/*
 * get token from query string
 *
 * *operator is filled in with OP_* when return values is PT_OPR,
 * but *weight could contain a distance value in case of phrase operator.
 * *strval, *lenval and *weight are filled in when return value is PT_VAL
 *
 */</comment>
<typedef>typedef <function_decl><type><name>ts_tokentype</name></type> (<modifier>*</modifier><name>ts_tokenizer</name>) <parameter_list>(<parameter><decl><type><name>TSQueryParserState</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>int8</name> <modifier>*</modifier></type><name>operator</name></decl></parameter>,
									  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>lenval</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>strval</name></decl></parameter>,
									  <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>weight</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<struct>struct <name>TSQueryParserStateData</name>
<block>{
	<comment type="block">/* Tokenizer used for parsing tsquery */</comment>
	<decl_stmt><decl><type><name>ts_tokenizer</name></type> <name>gettoken</name></decl>;</decl_stmt>

	<comment type="block">/* State of tokenizer function */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>			<comment type="block">/* entire string we are scanning */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>			<comment type="block">/* current scan point */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name></decl>;</decl_stmt>			<comment type="block">/* nesting count, incremented by (,
								 * decremented by ) */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>in_quotes</name></decl>;</decl_stmt>		<comment type="block">/* phrase in quotes "" */</comment>
	<decl_stmt><decl><type><name>ts_parserstate</name></type> <name>state</name></decl>;</decl_stmt>

	<comment type="block">/* polish (prefix) notation in list, filled in by push* functions */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>polstr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Strings from operands are collected in op. curop is a pointer to the
	 * end of used space of op.
	 */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>op</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>curop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>lenop</name></decl>;</decl_stmt>			<comment type="block">/* allocated size of op */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>sumlen</name></decl>;</decl_stmt>			<comment type="block">/* used size of op */</comment>

	<comment type="block">/* state for value's parser */</comment>
	<decl_stmt><decl><type><name>TSVectorParseState</name></type> <name>valstate</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
 * subroutine to parse the modifiers (weight and prefix flag currently)
 * part, like ':AB*' of a query.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_modifiers</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>weight</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>weight</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>prefix</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>t_iseq</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>buf</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>buf</name><operator>++</operator></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>*</operator><name>buf</name> <operator>&amp;&amp;</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><operator>*</operator><name>buf</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'a'</literal></expr>:</case>
			<case>case <expr><literal type="char">'A'</literal></expr>:</case>
				<expr_stmt><expr><operator>*</operator><name>weight</name> <operator>|=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">3</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'b'</literal></expr>:</case>
			<case>case <expr><literal type="char">'B'</literal></expr>:</case>
				<expr_stmt><expr><operator>*</operator><name>weight</name> <operator>|=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'c'</literal></expr>:</case>
			<case>case <expr><literal type="char">'C'</literal></expr>:</case>
				<expr_stmt><expr><operator>*</operator><name>weight</name> <operator>|=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'d'</literal></expr>:</case>
			<case>case <expr><literal type="char">'D'</literal></expr>:</case>
				<expr_stmt><expr><operator>*</operator><name>weight</name> <operator>|=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'*'</literal></expr>:</case>
				<expr_stmt><expr><operator>*</operator><name>prefix</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<return>return <expr><name>buf</name></expr>;</return>
		</block_content>}</block></switch>
		<expr_stmt><expr><name>buf</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Parse phrase operator. The operator
 * may take the following forms:
 *
 *		a &lt;N&gt; b (distance is exactly N lexemes)
 *		a &lt;-&gt; b (default distance = 1)
 *
 * The buffer should begin with '&lt;' char
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>parse_phrase_operator</name><parameter_list>(<parameter><decl><type><name>TSQueryParserState</name></type> <name>pstate</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>distance</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<enum>enum
	<block>{
		<decl><name>PHRASE_OPEN</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
		<decl><name>PHRASE_DIST</name></decl>,
		<decl><name>PHRASE_CLOSE</name></decl>,
		<decl><name>PHRASE_FINISH</name></decl>
	}</block>			<decl><name>state</name> <init>= <expr><name>PHRASE_OPEN</name></expr></init></decl>;</enum>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name><name>pstate</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>l</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>			<comment type="block">/* default distance */</comment>

	<while>while <condition>(<expr><operator>*</operator><name>ptr</name></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>state</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PHRASE_OPEN</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>t_iseq</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="char">'&lt;'</literal></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <name>PHRASE_DIST</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
				<break>break;</break>

			<case>case <expr><name>PHRASE_DIST</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>t_iseq</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <name>PHRASE_CLOSE</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>t_isdigit</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>endptr</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ERANGE</name> <operator>||</operator> <name><name>l</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>l</name></expr></argument> &gt;</argument_list></name> <name>MAXENTRYPOS</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"distance in phrase operator should not be greater than %d"</literal></expr></argument>,
									<argument><expr><name>MAXENTRYPOS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <name>PHRASE_CLOSE</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>endptr</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>

			<case>case <expr><name>PHRASE_CLOSE</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>t_iseq</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="char">'&gt;'</literal></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <name>PHRASE_FINISH</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
				<break>break;</break>

			<case>case <expr><name>PHRASE_FINISH</name></expr>:</case>
				<expr_stmt><expr><operator>*</operator><name>distance</name> <operator>=</operator> <operator>(</operator><name>int16</name><operator>)</operator> <name>l</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></switch>
	</block_content>}</block></while>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Parse OR operator used in websearch_to_tsquery(), returns true if we
 * believe that "OR" literal could be an operator OR
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>parse_or_operator</name><parameter_list>(<parameter><decl><type><name>TSQueryParserState</name></type> <name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name><name>pstate</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>in_quotes</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* it should begin with "OR" literal */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="string">"or"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * it shouldn't be a part of any word but somewhere later it should be
	 * some operand
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>			<comment type="block">/* no operand */</comment>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* it shouldn't be a part of any word */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>t_iseq</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>t_iseq</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="char">'_'</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>t_isalpha</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>t_isdigit</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* got end of string without operand */</comment>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Suppose, we found an operand, but could be a not correct operand.
		 * So we still treat OR literal as operation with possibly incorrect
		 * operand and  will not search it as lexeme
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>t_isspace</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>buf</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ts_tokentype</name></type>
<name>gettoken_query_standard</name><parameter_list>(<parameter><decl><type><name>TSQueryParserState</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>int8</name> <modifier>*</modifier></type><name>operator</name></decl></parameter>,
						<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>lenval</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>strval</name></decl></parameter>,
						<parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>weight</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>weight</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>prefix</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>WAITFIRSTOPERAND</name></expr>:</case>
			<case>case <expr><name>WAITOPERAND</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>t_iseq</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="char">'!'</literal></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name></name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WAITOPERAND</name></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>operator</name> <operator>=</operator> <name>OP_NOT</name></expr>;</expr_stmt>
					<return>return <expr><name>PT_OPR</name></expr>;</return>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><call><name>t_iseq</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name></name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WAITOPERAND</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
					<return>return <expr><name>PT_OPEN</name></expr>;</return>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><call><name>t_iseq</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"syntax error in tsquery: \"%s\""</literal></expr></argument>,
									<argument><expr><name><name>state</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>t_isspace</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * We rely on the tsvector parser to parse the value for
					 * us
					 */</comment>
					<expr_stmt><expr><call><name>reset_tsvector_parser</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>valstate</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>gettoken_tsvector</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>valstate</name></name></expr></argument>, <argument><expr><name>strval</name></expr></argument>, <argument><expr><name>lenval</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <call><name>get_modifiers</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>weight</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WAITOPERATOR</name></expr>;</expr_stmt>
						<return>return <expr><name>PT_VAL</name></expr>;</return>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>WAITFIRSTOPERAND</name></expr>)</condition>
					<block>{<block_content>
						<return>return <expr><name>PT_END</name></expr>;</return>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no operand in tsquery: \"%s\""</literal></expr></argument>,
										<argument><expr><name><name>state</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><name>WAITOPERATOR</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>t_iseq</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="char">'&amp;'</literal></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name></name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WAITOPERAND</name></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>operator</name> <operator>=</operator> <name>OP_AND</name></expr>;</expr_stmt>
					<return>return <expr><name>PT_OPR</name></expr>;</return>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><call><name>t_iseq</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="char">'|'</literal></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name></name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WAITOPERAND</name></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>operator</name> <operator>=</operator> <name>OP_OR</name></expr>;</expr_stmt>
					<return>return <expr><name>PT_OPR</name></expr>;</return>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><call><name>parse_phrase_operator</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>weight</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* weight var is used as storage for distance */</comment>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WAITOPERAND</name></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>operator</name> <operator>=</operator> <name>OP_PHRASE</name></expr>;</expr_stmt>
					<return>return <expr><name>PT_OPR</name></expr>;</return>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><call><name>t_iseq</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name></name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>count</name></name><operator>--</operator></expr>;</expr_stmt>
					<return>return <expr><ternary><condition><expr><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>count</name></name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>PT_ERR</name></expr> </then><else>: <expr><name>PT_CLOSE</name></expr></else></ternary></expr>;</return>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><operator>*</operator><name><name>state</name><operator>-&gt;</operator><name>buf</name></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
				<block>{<block_content>
					<return>return <expr><ternary><condition><expr><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>count</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>PT_ERR</name></expr> </then><else>: <expr><name>PT_END</name></expr></else></ternary></expr>;</return>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>t_isspace</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<return>return <expr><name>PT_ERR</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name></name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ts_tokentype</name></type>
<name>gettoken_query_websearch</name><parameter_list>(<parameter><decl><type><name>TSQueryParserState</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>int8</name> <modifier>*</modifier></type><name>operator</name></decl></parameter>,
						 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>lenval</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>strval</name></decl></parameter>,
						 <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>weight</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>weight</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>prefix</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>WAITFIRSTOPERAND</name></expr>:</case>
			<case>case <expr><name>WAITOPERAND</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>t_iseq</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name></name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WAITOPERAND</name></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>in_quotes</name></name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<expr_stmt><expr><operator>*</operator><name>operator</name> <operator>=</operator> <name>OP_NOT</name></expr>;</expr_stmt>
					<return>return <expr><name>PT_OPR</name></expr>;</return>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><call><name>t_iseq</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name></name><operator>++</operator></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>in_quotes</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WAITOPERAND</name></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* quoted text should be ordered &lt;-&gt; */</comment>
							<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>in_quotes</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<return>return <expr><name>PT_OPEN</name></expr>;</return>
						</block_content>}</block></if></if_stmt>

						<comment type="block">/* web search tolerates missing quotes */</comment>
						<continue>continue;</continue>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* we have to provide an operand */</comment>
						<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>in_quotes</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WAITOPERATOR</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>pushStop</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return <expr><name>PT_CLOSE</name></expr>;</return>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><call><name>ISOPERATOR</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* or else gettoken_tsvector() will raise an error */</comment>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name></name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WAITOPERAND</name></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>t_isspace</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * We rely on the tsvector parser to parse the value for
					 * us
					 */</comment>
					<expr_stmt><expr><call><name>reset_tsvector_parser</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>valstate</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>gettoken_tsvector</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>valstate</name></name></expr></argument>, <argument><expr><name>strval</name></expr></argument>, <argument><expr><name>lenval</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WAITOPERATOR</name></expr>;</expr_stmt>
						<return>return <expr><name>PT_VAL</name></expr>;</return>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>WAITFIRSTOPERAND</name></expr>)</condition>
					<block>{<block_content>
						<return>return <expr><name>PT_END</name></expr>;</return>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* finally, we have to provide an operand */</comment>
						<expr_stmt><expr><call><name>pushStop</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return <expr><name>PT_END</name></expr>;</return>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><name>WAITOPERATOR</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>t_iseq</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>in_quotes</name></name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * put implicit AND after an operand and handle this
						 * quote in WAITOPERAND
						 */</comment>
						<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WAITOPERAND</name></expr>;</expr_stmt>
						<expr_stmt><expr><operator>*</operator><name>operator</name> <operator>=</operator> <name>OP_AND</name></expr>;</expr_stmt>
						<return>return <expr><name>PT_OPR</name></expr>;</return>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name></name><operator>++</operator></expr>;</expr_stmt>

						<comment type="block">/* just close quotes */</comment>
						<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>in_quotes</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<return>return <expr><name>PT_CLOSE</name></expr>;</return>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><call><name>parse_or_operator</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WAITOPERAND</name></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>operator</name> <operator>=</operator> <name>OP_OR</name></expr>;</expr_stmt>
					<return>return <expr><name>PT_OPR</name></expr>;</return>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><operator>*</operator><name><name>state</name><operator>-&gt;</operator><name>buf</name></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
				<block>{<block_content>
					<return>return <expr><name>PT_END</name></expr>;</return>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>t_isspace</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>in_quotes</name></name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* put implicit &lt;-&gt; after an operand */</comment>
						<expr_stmt><expr><operator>*</operator><name>operator</name> <operator>=</operator> <name>OP_PHRASE</name></expr>;</expr_stmt>
						<expr_stmt><expr><operator>*</operator><name>weight</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* put implicit AND after an operand */</comment>
						<expr_stmt><expr><operator>*</operator><name>operator</name> <operator>=</operator> <name>OP_AND</name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>

					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WAITOPERAND</name></expr>;</expr_stmt>
					<return>return <expr><name>PT_OPR</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name></name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ts_tokentype</name></type>
<name>gettoken_query_plain</name><parameter_list>(<parameter><decl><type><name>TSQueryParserState</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>int8</name> <modifier>*</modifier></type><name>operator</name></decl></parameter>,
					 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>lenval</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>strval</name></decl></parameter>,
					 <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>weight</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>weight</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>prefix</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>state</name><operator>-&gt;</operator><name>buf</name></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PT_END</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>strval</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>buf</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>lenval</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name></name> <operator>+=</operator> <operator>*</operator><name>lenval</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
	<return>return <expr><name>PT_VAL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Push an operator to state-&gt;polstr
 */</comment>
<function><type><name>void</name></type>
<name>pushOperator</name><parameter_list>(<parameter><decl><type><name>TSQueryParserState</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>int8</name></type> <name>oper</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>distance</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>QueryOperator</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>oper</name> <operator>==</operator> <name>OP_NOT</name> <operator>||</operator> <name>oper</name> <operator>==</operator> <name>OP_AND</name> <operator>||</operator> <name>oper</name> <operator>==</operator> <name>OP_OR</name> <operator>||</operator> <name>oper</name> <operator>==</operator> <name>OP_PHRASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>(</operator><name>QueryOperator</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>QueryOperator</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>QI_OPR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>oper</name></name> <operator>=</operator> <name>oper</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>distance</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>oper</name> <operator>==</operator> <name>OP_PHRASE</name><operator>)</operator></expr> ?</condition><then> <expr><name>distance</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
	<comment type="block">/* left is filled in later with findoprnd */</comment>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>polstr</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>polstr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pushValue_internal</name><parameter_list>(<parameter><decl><type><name>TSQueryParserState</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>pg_crc32</name></type> <name>valcrc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>distance</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lenval</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>weight</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>QueryOperand</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>distance</name> <operator>&gt;=</operator> <name>MAXSTRPOS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"value is too big in tsquery: \"%s\""</literal></expr></argument>,
						<argument><expr><name><name>state</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>lenval</name> <operator>&gt;=</operator> <name>MAXSTRLEN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operand is too long in tsquery: \"%s\""</literal></expr></argument>,
						<argument><expr><name><name>state</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>(</operator><name>QueryOperand</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>QueryOperand</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>QI_VAL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>weight</name></name> <operator>=</operator> <name>weight</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>prefix</name></name> <operator>=</operator> <name>prefix</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>valcrc</name></name> <operator>=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <name>valcrc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <name>lenval</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>distance</name></name> <operator>=</operator> <name>distance</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>polstr</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>polstr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Push an operand to state-&gt;polstr.
 *
 * strval must point to a string equal to state-&gt;curop. lenval is the length
 * of the string.
 */</comment>
<function><type><name>void</name></type>
<name>pushValue</name><parameter_list>(<parameter><decl><type><name>TSQueryParserState</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>strval</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lenval</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>weight</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pg_crc32</name></type>	<name>valcrc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>lenval</name> <operator>&gt;=</operator> <name>MAXSTRLEN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"word is too long in tsquery: \"%s\""</literal></expr></argument>,
						<argument><expr><name><name>state</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>INIT_LEGACY_CRC32</name><argument_list>(<argument><expr><name>valcrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMP_LEGACY_CRC32</name><argument_list>(<argument><expr><name>valcrc</name></expr></argument>, <argument><expr><name>strval</name></expr></argument>, <argument><expr><name>lenval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FIN_LEGACY_CRC32</name><argument_list>(<argument><expr><name>valcrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pushValue_internal</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>valcrc</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>curop</name></name> <operator>-</operator> <name><name>state</name><operator>-&gt;</operator><name>op</name></name></expr></argument>, <argument><expr><name>lenval</name></expr></argument>, <argument><expr><name>weight</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* append the value string to state.op, enlarging buffer if needed first */</comment>
	<while>while <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>curop</name></name> <operator>-</operator> <name><name>state</name><operator>-&gt;</operator><name>op</name></name> <operator>+</operator> <name>lenval</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>lenop</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>used</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>curop</name></name> <operator>-</operator> <name><name>state</name><operator>-&gt;</operator><name>op</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lenop</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>op</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>lenop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>curop</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>op</name></name> <operator>+</operator> <name>used</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>curop</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>strval</name></expr></argument>, <argument><expr><name>lenval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>curop</name></name> <operator>+=</operator> <name>lenval</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>curop</name></name><operator>)</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>curop</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>sumlen</name></name> <operator>+=</operator> <name>lenval</name> <operator>+</operator> <literal type="number">1</literal></expr> <comment type="block">/* \0 */</comment> ;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Push a stopword placeholder to state-&gt;polstr
 */</comment>
<function><type><name>void</name></type>
<name>pushStop</name><parameter_list>(<parameter><decl><type><name>TSQueryParserState</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>QueryOperand</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>(</operator><name>QueryOperand</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>QueryOperand</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>QI_VALSTOP</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>polstr</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>polstr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STACKDEPTH</name></cpp:macro>	<cpp:value>32</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>OperatorElement</name>
<block>{
	<decl_stmt><decl><type><name>int8</name></type>		<name>op</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>distance</name></decl>;</decl_stmt>
}</block></struct></type> <name>OperatorElement</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pushOpStack</name><parameter_list>(<parameter><decl><type><name>OperatorElement</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>lenstack</name></decl></parameter>, <parameter><decl><type><name>int8</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>distance</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>lenstack</name> <operator>==</operator> <name>STACKDEPTH</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* internal error */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"tsquery stack too small"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>stack</name><index>[<expr><operator>*</operator><name>lenstack</name></expr>]</index></name><operator>.</operator><name>op</name> <operator>=</operator> <name>op</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stack</name><index>[<expr><operator>*</operator><name>lenstack</name></expr>]</index></name><operator>.</operator><name>distance</name> <operator>=</operator> <name>distance</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><operator>*</operator><name>lenstack</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>cleanOpStack</name><parameter_list>(<parameter><decl><type><name>TSQueryParserState</name></type> <name>state</name></decl></parameter>,
			 <parameter><decl><type><name>OperatorElement</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>lenstack</name></decl></parameter>, <parameter><decl><type><name>int8</name></type> <name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>opPriority</name> <init>= <expr><call><name>OP_PRIORITY</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><operator>*</operator><name>lenstack</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* NOT is right associative unlike to others */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>op</name> <operator>!=</operator> <name>OP_NOT</name> <operator>&amp;&amp;</operator> <name>opPriority</name> <operator>&gt;</operator> <call><name>OP_PRIORITY</name><argument_list>(<argument><expr><name><name>stack</name><index>[<expr><operator>*</operator><name>lenstack</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>op</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name>op</name> <operator>==</operator> <name>OP_NOT</name> <operator>&amp;&amp;</operator> <name>opPriority</name> <operator>&gt;=</operator> <call><name>OP_PRIORITY</name><argument_list>(<argument><expr><name><name>stack</name><index>[<expr><operator>*</operator><name>lenstack</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>op</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>lenstack</name><operator>)</operator><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pushOperator</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>stack</name><index>[<expr><operator>*</operator><name>lenstack</name></expr>]</index></name><operator>.</operator><name>op</name></expr></argument>,
					 <argument><expr><name><name>stack</name><index>[<expr><operator>*</operator><name>lenstack</name></expr>]</index></name><operator>.</operator><name>distance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Make polish (prefix) notation of query.
 *
 * See parse_tsquery for explanation of pushval.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>makepol</name><parameter_list>(<parameter><decl><type><name>TSQueryParserState</name></type> <name>state</name></decl></parameter>,
		<parameter><decl><type><name>PushFunction</name></type> <name>pushval</name></decl></parameter>,
		<parameter><decl><type><name>Datum</name></type> <name>opaque</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int8</name></type>		<name>operator</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ts_tokentype</name></type> <name>type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>lenval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>strval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OperatorElement</name></type> <name><name>opstack</name><index>[<expr><name>STACKDEPTH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>lenstack</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>weight</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>prefix</name></decl>;</decl_stmt>

	<comment type="block">/* since this function recurses, it could be driven to stack overflow */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>type</name> <operator>=</operator> <call><name><name>state</name><operator>-&gt;</operator><name>gettoken</name></name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>operator</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>lenval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>strval</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>weight</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prefix</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>PT_END</name></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>type</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PT_VAL</name></expr>:</case>
				<expr_stmt><expr><call><name>pushval</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>strval</name></expr></argument>, <argument><expr><name>lenval</name></expr></argument>, <argument><expr><name>weight</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>PT_OPR</name></expr>:</case>
				<expr_stmt><expr><call><name>cleanOpStack</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>opstack</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lenstack</name></expr></argument>, <argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pushOpStack</name><argument_list>(<argument><expr><name>opstack</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lenstack</name></expr></argument>, <argument><expr><name>operator</name></expr></argument>, <argument><expr><name>weight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>PT_OPEN</name></expr>:</case>
				<expr_stmt><expr><call><name>makepol</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>pushval</name></expr></argument>, <argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>PT_CLOSE</name></expr>:</case>
				<expr_stmt><expr><call><name>cleanOpStack</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>opstack</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lenstack</name></expr></argument>, <argument><expr><name>OP_OR</name></expr></argument> <comment type="block">/* lowest */</comment> )</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			<case>case <expr><name>PT_ERR</name></expr>:</case>
			<default>default:</default>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"syntax error in tsquery: \"%s\""</literal></expr></argument>,
								<argument><expr><name><name>state</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>cleanOpStack</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>opstack</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lenstack</name></expr></argument>, <argument><expr><name>OP_OR</name></expr></argument> <comment type="block">/* lowest */</comment> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>findoprnd_recurse</name><parameter_list>(<parameter><decl><type><name>QueryItem</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>pos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nnodes</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>needcleanup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* since this function recurses, it could be driven to stack overflow. */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pos</name> <operator>&gt;=</operator> <name>nnodes</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"malformed tsquery: operand not found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ptr</name><index>[<expr><operator>*</operator><name>pos</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>QI_VAL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>pos</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>ptr</name><index>[<expr><operator>*</operator><name>pos</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>QI_VALSTOP</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>needcleanup</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* we'll have to remove stop words */</comment>
		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>pos</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ptr</name><index>[<expr><operator>*</operator><name>pos</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>QI_OPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ptr</name><index>[<expr><operator>*</operator><name>pos</name></expr>]</index></name><operator>.</operator><name><name>qoperator</name><operator>.</operator><name>oper</name></name> <operator>==</operator> <name>OP_NOT</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>ptr</name><index>[<expr><operator>*</operator><name>pos</name></expr>]</index></name><operator>.</operator><name><name>qoperator</name><operator>.</operator><name>left</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* fixed offset */</comment>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>pos</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>

			<comment type="block">/* process the only argument */</comment>
			<expr_stmt><expr><call><name>findoprnd_recurse</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>nnodes</name></expr></argument>, <argument><expr><name>needcleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>QueryOperator</name> <modifier>*</modifier></type><name>curitem</name> <init>= <expr><operator>&amp;</operator><name><name>ptr</name><index>[<expr><operator>*</operator><name>pos</name></expr>]</index></name><operator>.</operator><name>qoperator</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>tmp</name> <init>= <expr><operator>*</operator><name>pos</name></expr></init></decl>;</decl_stmt> <comment type="block">/* save current position */</comment>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>curitem</name><operator>-&gt;</operator><name>oper</name></name> <operator>==</operator> <name>OP_AND</name> <operator>||</operator>
				   <name><name>curitem</name><operator>-&gt;</operator><name>oper</name></name> <operator>==</operator> <name>OP_OR</name> <operator>||</operator>
				   <name><name>curitem</name><operator>-&gt;</operator><name>oper</name></name> <operator>==</operator> <name>OP_PHRASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>pos</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>

			<comment type="block">/* process RIGHT argument */</comment>
			<expr_stmt><expr><call><name>findoprnd_recurse</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>nnodes</name></expr></argument>, <argument><expr><name>needcleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>curitem</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <operator>*</operator><name>pos</name> <operator>-</operator> <name>tmp</name></expr>;</expr_stmt> <comment type="block">/* set LEFT arg's offset */</comment>

			<comment type="block">/* process LEFT argument */</comment>
			<expr_stmt><expr><call><name>findoprnd_recurse</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>nnodes</name></expr></argument>, <argument><expr><name>needcleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Fill in the left-fields previously left unfilled.
 * The input QueryItems must be in polish (prefix) notation.
 * Also, set *needcleanup to true if there are any QI_VALSTOP nodes.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>findoprnd</name><parameter_list>(<parameter><decl><type><name>QueryItem</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>needcleanup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>pos</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>needcleanup</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>findoprnd_recurse</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pos</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>needcleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>!=</operator> <name>size</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"malformed tsquery: extra nodes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Each value (operand) in the query is passed to pushval. pushval can
 * transform the simple value to an arbitrarily complex expression using
 * pushValue and pushOperator. It must push a single value with pushValue,
 * a complete expression with all operands, or a stopword placeholder
 * with pushStop, otherwise the prefix notation representation will be broken,
 * having an operator with no operand.
 *
 * opaque is passed on to pushval as is, pushval can use it to store its
 * private state.
 */</comment>
<function><type><name>TSQuery</name></type>
<name>parse_tsquery</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
			  <parameter><decl><type><name>PushFunction</name></type> <name>pushval</name></decl></parameter>,
			  <parameter><decl><type><name>Datum</name></type> <name>opaque</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>TSQueryParserStateData</name></name></type> <name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TSQuery</name></type>		<name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>commonlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QueryItem</name>  <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needcleanup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tsv_flags</name> <init>= <expr><name>P_TSV_OPR_IS_DELIM</name> <operator>|</operator> <name>P_TSV_IS_TSQUERY</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* plain should not be used with web */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>P_TSQ_PLAIN</name> <operator>|</operator> <name>P_TSQ_WEB</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <operator>(</operator><name>P_TSQ_PLAIN</name> <operator>|</operator> <name>P_TSQ_WEB</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* select suitable tokenizer */</comment>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>P_TSQ_PLAIN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>state</name><operator>.</operator><name>gettoken</name></name> <operator>=</operator> <name>gettoken_query_plain</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>P_TSQ_WEB</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>.</operator><name>gettoken</name></name> <operator>=</operator> <name>gettoken_query_websearch</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>tsv_flags</name> <operator>|=</operator> <name>P_TSV_IS_WEB</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>state</name><operator>.</operator><name>gettoken</name></name> <operator>=</operator> <name>gettoken_query_standard</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* init state */</comment>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>buffer</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>in_quotes</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>WAITFIRSTOPERAND</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>polstr</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/* init value parser's state */</comment>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>valstate</name></name> <operator>=</operator> <call><name>init_tsvector_parser</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>tsv_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* init list of operand */</comment>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>sumlen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>lenop</name></name> <operator>=</operator> <literal type="number">64</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>curop</name></name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>op</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>lenop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>state</name><operator>.</operator><name>curop</name></name><operator>)</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<comment type="block">/* parse query &amp; make polish notation (postfix, but in reverse order) */</comment>
	<expr_stmt><expr><call><name>makepol</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>pushval</name></expr></argument>, <argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>close_tsvector_parser</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>valstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>polstr</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"text-search query doesn't contain lexemes: \"%s\""</literal></expr></argument>,
						<argument><expr><name><name>state</name><operator>.</operator><name>buffer</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>query</name> <operator>=</operator> <operator>(</operator><name>TSQuery</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>HDRSIZETQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>HDRSIZETQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>query</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TSQUERY_TOO_BIG</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>polstr</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>state</name><operator>.</operator><name>sumlen</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tsquery is too large"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>commonlen</name> <operator>=</operator> <call><name>COMPUTESIZE</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>polstr</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>state</name><operator>.</operator><name>sumlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Pack the QueryItems in the final TSQuery struct to return to caller */</comment>
	<expr_stmt><expr><name>query</name> <operator>=</operator> <operator>(</operator><name>TSQuery</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>commonlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>commonlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>polstr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>GETQUERY</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy QueryItems to TSQuery */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>state.polstr</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>QueryItem</name>  <modifier>*</modifier></type><name>item</name> <init>= <expr><operator>(</operator><name>QueryItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>QI_VAL</name></expr>:</case>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>QueryOperand</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>QI_VALSTOP</name></expr>:</case>
				<expr_stmt><expr><name><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>=</operator> <name>QI_VALSTOP</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>QI_OPR</name></expr>:</case>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>QueryOperator</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized QueryItem type: %d"</literal></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Copy all the operand strings to TSQuery */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>GETOPERAND</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>state</name><operator>.</operator><name>op</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>.</operator><name>sumlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>op</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set left operand pointers for every operator.  While we're at it,
	 * detect whether there are any QI_VALSTOP nodes.
	 */</comment>
	<expr_stmt><expr><call><name>findoprnd</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>needcleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there are QI_VALSTOP nodes, delete them and simplify the tree.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>needcleanup</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>cleanup_tsquery_stopwords</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>query</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pushval_asis</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>opaque</name></decl></parameter>, <parameter><decl><type><name>TSQueryParserState</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>strval</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lenval</name></decl></parameter>,
			 <parameter><decl><type><name>int16</name></type> <name>weight</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pushValue</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>strval</name></expr></argument>, <argument><expr><name>lenval</name></expr></argument>, <argument><expr><name>weight</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * in without morphology
 */</comment>
<function><type><name>Datum</name></type>
<name>tsqueryin</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>in</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TSQUERY</name><argument_list>(<argument><expr><call><name>parse_tsquery</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><name>pushval_asis</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * out function
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>QueryItem</name>  <modifier>*</modifier></type><name>curpol</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>op</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>buflen</name></decl>;</decl_stmt>
}</block></struct></type> <name>INFIX</name>;</typedef>

<comment type="block">/* Makes sure inf-&gt;buf is large enough for adding 'addsize' bytes */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESIZEBUF</name><parameter_list>(<parameter><type><name>inf</name></type></parameter>, <parameter><type><name>addsize</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>while( ( (inf)-&gt;cur - (inf)-&gt;buf ) + (addsize) + 1 &gt;= (inf)-&gt;buflen ) \
{ \
	int len = (inf)-&gt;cur - (inf)-&gt;buf; \
	(inf)-&gt;buflen *= 2; \
	(inf)-&gt;buf = (char*) repalloc( (void*)(inf)-&gt;buf, (inf)-&gt;buflen ); \
	(inf)-&gt;cur = (inf)-&gt;buf + len; \
}</cpp:value></cpp:define>

<comment type="block">/*
 * recursively traverse the tree and
 * print it in infix (human-readable) form
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>infix</name><parameter_list>(<parameter><decl><type><name>INFIX</name> <modifier>*</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>parentPriority</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>rightPhraseOp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* since this function recurses, it could be driven to stack overflow. */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>in</name><operator>-&gt;</operator><name>curpol</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>QI_VAL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>QueryOperand</name> <modifier>*</modifier></type><name>curpol</name> <init>= <expr><operator>&amp;</operator><name><name>in</name><operator>-&gt;</operator><name>curpol</name><operator>-&gt;</operator><name>qoperand</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>op</name> <init>= <expr><name><name>in</name><operator>-&gt;</operator><name>op</name></name> <operator>+</operator> <name><name>curpol</name><operator>-&gt;</operator><name>distance</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>clen</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>RESIZEBUF</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><name><name>curpol</name><operator>-&gt;</operator><name>length</name></name> <operator>*</operator> <operator>(</operator><call><name>pg_database_encoding_max_length</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>in</name><operator>-&gt;</operator><name>cur</name></name><operator>)</operator> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>in</name><operator>-&gt;</operator><name>cur</name></name><operator>++</operator></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>*</operator><name>op</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>t_iseq</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>in</name><operator>-&gt;</operator><name>cur</name></name><operator>)</operator> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>in</name><operator>-&gt;</operator><name>cur</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>t_iseq</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>in</name><operator>-&gt;</operator><name>cur</name></name><operator>)</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>in</name><operator>-&gt;</operator><name>cur</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>COPYCHAR</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>cur</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>clen</name> <operator>=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>op</name> <operator>+=</operator> <name>clen</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>in</name><operator>-&gt;</operator><name>cur</name></name> <operator>+=</operator> <name>clen</name></expr>;</expr_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>in</name><operator>-&gt;</operator><name>cur</name></name><operator>)</operator> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>in</name><operator>-&gt;</operator><name>cur</name></name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>curpol</name><operator>-&gt;</operator><name>weight</name></name> <operator>||</operator> <name><name>curpol</name><operator>-&gt;</operator><name>prefix</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>in</name><operator>-&gt;</operator><name>cur</name></name><operator>)</operator> <operator>=</operator> <literal type="char">':'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>in</name><operator>-&gt;</operator><name>cur</name></name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>curpol</name><operator>-&gt;</operator><name>prefix</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>in</name><operator>-&gt;</operator><name>cur</name></name><operator>)</operator> <operator>=</operator> <literal type="char">'*'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>in</name><operator>-&gt;</operator><name>cur</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>curpol</name><operator>-&gt;</operator><name>weight</name></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>in</name><operator>-&gt;</operator><name>cur</name></name><operator>)</operator> <operator>=</operator> <literal type="char">'A'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>in</name><operator>-&gt;</operator><name>cur</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>curpol</name><operator>-&gt;</operator><name>weight</name></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>in</name><operator>-&gt;</operator><name>cur</name></name><operator>)</operator> <operator>=</operator> <literal type="char">'B'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>in</name><operator>-&gt;</operator><name>cur</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>curpol</name><operator>-&gt;</operator><name>weight</name></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>in</name><operator>-&gt;</operator><name>cur</name></name><operator>)</operator> <operator>=</operator> <literal type="char">'C'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>in</name><operator>-&gt;</operator><name>cur</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>curpol</name><operator>-&gt;</operator><name>weight</name></name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>in</name><operator>-&gt;</operator><name>cur</name></name><operator>)</operator> <operator>=</operator> <literal type="char">'D'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>in</name><operator>-&gt;</operator><name>cur</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>in</name><operator>-&gt;</operator><name>cur</name></name><operator>)</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>in</name><operator>-&gt;</operator><name>curpol</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>in</name><operator>-&gt;</operator><name>curpol</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>oper</name></name> <operator>==</operator> <name>OP_NOT</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>priority</name> <init>= <expr><call><name>QO_PRIORITY</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>curpol</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>priority</name> <operator>&lt;</operator> <name>parentPriority</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>RESIZEBUF</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>cur</name></name></expr></argument>, <argument><expr><literal type="string">"( "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>in</name><operator>-&gt;</operator><name>cur</name></name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>cur</name></name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>RESIZEBUF</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>in</name><operator>-&gt;</operator><name>cur</name></name><operator>)</operator> <operator>=</operator> <literal type="char">'!'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>in</name><operator>-&gt;</operator><name>cur</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>in</name><operator>-&gt;</operator><name>cur</name></name><operator>)</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>in</name><operator>-&gt;</operator><name>curpol</name></name><operator>++</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>infix</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><name>priority</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>priority</name> <operator>&lt;</operator> <name>parentPriority</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>RESIZEBUF</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>cur</name></name></expr></argument>, <argument><expr><literal type="string">" )"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>in</name><operator>-&gt;</operator><name>cur</name></name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>cur</name></name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int8</name></type>		<name>op</name> <init>= <expr><name><name>in</name><operator>-&gt;</operator><name>curpol</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>oper</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>priority</name> <init>= <expr><call><name>QO_PRIORITY</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>curpol</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type>		<name>distance</name> <init>= <expr><name><name>in</name><operator>-&gt;</operator><name>curpol</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>distance</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>INFIX</name></type>		<name>nrm</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>needParenthesis</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>in</name><operator>-&gt;</operator><name>curpol</name></name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>priority</name> <operator>&lt;</operator> <name>parentPriority</name> <operator>||</operator>
		<comment type="block">/* phrase operator depends on order */</comment>
			<operator>(</operator><name>op</name> <operator>==</operator> <name>OP_PHRASE</name> <operator>&amp;&amp;</operator> <name>rightPhraseOp</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>needParenthesis</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>RESIZEBUF</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>cur</name></name></expr></argument>, <argument><expr><literal type="string">"( "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>in</name><operator>-&gt;</operator><name>cur</name></name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>cur</name></name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>nrm</name><operator>.</operator><name>curpol</name></name> <operator>=</operator> <name><name>in</name><operator>-&gt;</operator><name>curpol</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nrm</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name><name>in</name><operator>-&gt;</operator><name>op</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nrm</name><operator>.</operator><name>buflen</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nrm</name><operator>.</operator><name>cur</name></name> <operator>=</operator> <name><name>nrm</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>nrm</name><operator>.</operator><name>buflen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* get right operand */</comment>
		<expr_stmt><expr><call><name>infix</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nrm</name></expr></argument>, <argument><expr><name>priority</name></expr></argument>, <argument><expr><operator>(</operator><name>op</name> <operator>==</operator> <name>OP_PHRASE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* get &amp; print left operand */</comment>
		<expr_stmt><expr><name><name>in</name><operator>-&gt;</operator><name>curpol</name></name> <operator>=</operator> <name><name>nrm</name><operator>.</operator><name>curpol</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>infix</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><name>priority</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* print operator &amp; right operand */</comment>
		<expr_stmt><expr><call><name>RESIZEBUF</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><literal type="number">3</literal> <operator>+</operator> <operator>(</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">10</literal> <comment type="block">/* distance */</comment> <operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>nrm</name><operator>.</operator><name>cur</name></name> <operator>-</operator> <name><name>nrm</name><operator>.</operator><name>buf</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name>op</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>OP_OR</name></expr>:</case>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>cur</name></name></expr></argument>, <argument><expr><literal type="string">" | %s"</literal></expr></argument>, <argument><expr><name><name>nrm</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>OP_AND</name></expr>:</case>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>cur</name></name></expr></argument>, <argument><expr><literal type="string">" &amp; %s"</literal></expr></argument>, <argument><expr><name><name>nrm</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>OP_PHRASE</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>distance</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>cur</name></name></expr></argument>, <argument><expr><literal type="string">" &lt;%d&gt; %s"</literal></expr></argument>, <argument><expr><name>distance</name></expr></argument>, <argument><expr><name><name>nrm</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>cur</name></name></expr></argument>, <argument><expr><literal type="string">" &lt;-&gt; %s"</literal></expr></argument>, <argument><expr><name><name>nrm</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			<default>default:</default>
				<comment type="block">/* OP_NOT is handled in above if-branch */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized operator type: %d"</literal></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
		<expr_stmt><expr><name><name>in</name><operator>-&gt;</operator><name>cur</name></name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>cur</name></name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>nrm</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>needParenthesis</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>RESIZEBUF</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>cur</name></name></expr></argument>, <argument><expr><literal type="string">" )"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>in</name><operator>-&gt;</operator><name>cur</name></name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>cur</name></name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>tsqueryout</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TSQuery</name></type>		<name>query</name> <init>= <expr><call><name>PG_GETARG_TSQUERY</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>INFIX</name></type>		<name>nrm</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><operator>*</operator><name>b</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>nrm</name><operator>.</operator><name>curpol</name></name> <operator>=</operator> <call><name>GETQUERY</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nrm</name><operator>.</operator><name>buflen</name></name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nrm</name><operator>.</operator><name>cur</name></name> <operator>=</operator> <name><name>nrm</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>nrm</name><operator>.</operator><name>buflen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>nrm</name><operator>.</operator><name>cur</name></name><operator>)</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nrm</name><operator>.</operator><name>op</name></name> <operator>=</operator> <call><name>GETOPERAND</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>infix</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nrm</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* lowest priority */</comment> , <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name><name>nrm</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Binary Input / Output functions. The binary format is as follows:
 *
 * uint32	 number of operators/operands in the query
 *
 * Followed by the operators and operands, in prefix notation. For each
 * operand:
 *
 * uint8	type, QI_VAL
 * uint8	weight
 *			operand text in client encoding, null-terminated
 * uint8	prefix
 *
 * For each operator:
 * uint8	type, QI_OPR
 * uint8	operator, one of OP_AND, OP_PHRASE OP_OR, OP_NOT.
 * uint16	distance (only for OP_PHRASE)
 */</comment>
<function><type><name>Datum</name></type>
<name>tsquerysend</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TSQuery</name></type>		<name>query</name> <init>= <expr><call><name>PG_GETARG_TSQUERY</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QueryItem</name>  <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>GETQUERY</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>query</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pq_sendint8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>QI_VAL</name></expr>:</case>
				<expr_stmt><expr><call><name>pq_sendint8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>qoperand</name><operator>.</operator><name>weight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pq_sendint8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>qoperand</name><operator>.</operator><name>prefix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pq_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>GETOPERAND</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>item</name><operator>-&gt;</operator><name>qoperand</name><operator>.</operator><name>distance</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>QI_OPR</name></expr>:</case>
				<expr_stmt><expr><call><name>pq_sendint8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>oper</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>oper</name></name> <operator>==</operator> <name>OP_PHRASE</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>distance</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized tsquery node type: %d"</literal></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
		<expr_stmt><expr><name>item</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>tsqueryrecv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TSQuery</name></type>		<name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QueryItem</name>  <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>datalen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>operands</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needcleanup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;</operator> <operator>(</operator><name>MaxAllocSize</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>QueryItem</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid size of tsquery"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Allocate space to temporarily hold operand strings */</comment>
	<expr_stmt><expr><name>operands</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>size</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allocate space for all the QueryItems. */</comment>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <name>HDRSIZETQ</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>QueryItem</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>query</name> <operator>=</operator> <operator>(</operator><name>TSQuery</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>GETQUERY</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>datalen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <operator>(</operator><name>int8</name><operator>)</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int8</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>QI_VAL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>size_t</name></type>		<name>val_len</name></decl>;</decl_stmt>	<comment type="block">/* length after recoding to server
									 * encoding */</comment>
			<decl_stmt><decl><type><name>uint8</name></type>		<name>weight</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint8</name></type>		<name>prefix</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>pg_crc32</name></type>	<name>valcrc</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>weight</name> <operator>=</operator> <operator>(</operator><name>uint8</name><operator>)</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint8</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>prefix</name> <operator>=</operator> <operator>(</operator><name>uint8</name><operator>)</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint8</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>pq_getmsgstring</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>val_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Sanity checks */</comment>

			<if_stmt><if>if <condition>(<expr><name>weight</name> <operator>&gt;</operator> <literal type="number">0xF</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid tsquery: invalid weight bitmap"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>val_len</name> <operator>&gt;</operator> <name>MAXSTRLEN</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid tsquery: operand too long"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>datalen</name> <operator>&gt;</operator> <name>MAXSTRPOS</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid tsquery: total operand length exceeded"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Looks valid. */</comment>

			<expr_stmt><expr><call><name>INIT_LEGACY_CRC32</name><argument_list>(<argument><expr><name>valcrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>COMP_LEGACY_CRC32</name><argument_list>(<argument><expr><name>valcrc</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>val_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FIN_LEGACY_CRC32</name><argument_list>(<argument><expr><name>valcrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>qoperand</name><operator>.</operator><name>weight</name></name> <operator>=</operator> <name>weight</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>qoperand</name><operator>.</operator><name>prefix</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>prefix</name><operator>)</operator></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>qoperand</name><operator>.</operator><name>valcrc</name></name> <operator>=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <name>valcrc</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>qoperand</name><operator>.</operator><name>length</name></name> <operator>=</operator> <name>val_len</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>qoperand</name><operator>.</operator><name>distance</name></name> <operator>=</operator> <name>datalen</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Operand strings are copied to the final struct after this loop;
			 * here we just collect them to an array
			 */</comment>
			<expr_stmt><expr><name><name>operands</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>datalen</name> <operator>+=</operator> <name>val_len</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* + 1 for the '\0' terminator */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>QI_OPR</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int8</name></type>		<name>oper</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>oper</name> <operator>=</operator> <operator>(</operator><name>int8</name><operator>)</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int8</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>oper</name> <operator>!=</operator> <name>OP_NOT</name> <operator>&amp;&amp;</operator> <name>oper</name> <operator>!=</operator> <name>OP_OR</name> <operator>&amp;&amp;</operator> <name>oper</name> <operator>!=</operator> <name>OP_AND</name> <operator>&amp;&amp;</operator> <name>oper</name> <operator>!=</operator> <name>OP_PHRASE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid tsquery: unrecognized operator type %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>oper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>size</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid pointer to right operand"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>oper</name></name> <operator>=</operator> <name>oper</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>oper</name> <operator>==</operator> <name>OP_PHRASE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>distance</name></name> <operator>=</operator> <operator>(</operator><name>int16</name><operator>)</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized tsquery node type: %d"</literal></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>item</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Enlarge buffer to make room for the operand values. */</comment>
	<expr_stmt><expr><name>query</name> <operator>=</operator> <operator>(</operator><name>TSQuery</name><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>GETQUERY</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>GETOPERAND</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fill in the left-pointers. Checks that the tree is well-formed as a
	 * side-effect.
	 */</comment>
	<expr_stmt><expr><call><name>findoprnd</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>needcleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Can't have found any QI_VALSTOP nodes */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>needcleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy operands to output struct */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>QI_VAL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>operands</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>qoperand</name><operator>.</operator><name>length</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name><name>item</name><operator>-&gt;</operator><name>qoperand</name><operator>.</operator><name>length</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>item</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>operands</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ptr</name> <operator>-</operator> <call><name>GETOPERAND</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TSQUERY</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * debug function, used only for view query
 * which will be executed in non-leaf pages in index
 */</comment>
<function><type><name>Datum</name></type>
<name>tsquerytree</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TSQuery</name></type>		<name>query</name> <init>= <expr><call><name>PG_GETARG_TSQUERY</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>INFIX</name></type>		<name>nrm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QueryItem</name>  <modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <operator>(</operator><name>text</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>clean_NOT</name><argument_list>(<argument><expr><call><name>GETQUERY</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>q</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><literal type="string">"T"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>nrm</name><operator>.</operator><name>curpol</name></name> <operator>=</operator> <name>q</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nrm</name><operator>.</operator><name>buflen</name></name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nrm</name><operator>.</operator><name>cur</name></name> <operator>=</operator> <name><name>nrm</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>nrm</name><operator>.</operator><name>buflen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>nrm</name><operator>.</operator><name>cur</name></name><operator>)</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nrm</name><operator>.</operator><name>op</name></name> <operator>=</operator> <call><name>GETOPERAND</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>infix</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nrm</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>nrm</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>nrm</name><operator>.</operator><name>cur</name></name> <operator>-</operator> <name><name>nrm</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
