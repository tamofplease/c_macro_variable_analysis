<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/utils/adt/nabstime.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nabstime.c
 *	  Utilities for the built-in type "AbsoluteTime".
 *	  Functions for the built-in type "RelativeTime".
 *	  Functions for the built-in type "TimeInterval".
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/utils/adt/nabstime.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;float.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datetime.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/nabstime.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_DAYNUM</name></cpp:macro> <cpp:value>(-24856)</cpp:value></cpp:define>		<comment type="block">/* December 13, 1901 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_DAYNUM</name></cpp:macro> <cpp:value>24854</cpp:value></cpp:define>		<comment type="block">/* January 18, 2038 */</comment>

<comment type="block">/*
 * Unix epoch is Jan  1 00:00:00 1970.
 * Postgres knows about times sixty-eight years on either side of that
 * for these 4-byte types.
 *
 * "tinterval" is two 4-byte fields.
 * Definitions for parsing tinterval.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IsSpace</name><parameter_list>(<parameter><type><name>C</name></type></parameter>)</parameter_list></cpp:macro>				<cpp:value>((C) == ' ')</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>T_INTERVAL_INVAL</name></cpp:macro>   <cpp:value>0</cpp:value></cpp:define>	<comment type="block">/* data represents no valid tinterval */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>T_INTERVAL_VALID</name></cpp:macro>   <cpp:value>1</cpp:value></cpp:define>	<comment type="block">/* data represents a valid tinterval */</comment>
<comment type="block">/*
 * ['Mon May 10 23:59:12 1943 PST' 'Sun Jan 14 03:14:21 1973 PST']
 * 0		1		  2			3		  4			5		  6
 * 1234567890123456789012345678901234567890123456789012345678901234
 *
 * we allocate some extra -- timezones are usually 3 characters but
 * this is not in the POSIX standard...
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>T_INTERVAL_LEN</name></cpp:macro>					<cpp:value>80</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALID_INTERVAL_STR</name></cpp:macro>			<cpp:value>"Undefined Range"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALID_INTERVAL_STR_LEN</name></cpp:macro>		<cpp:value>(sizeof(INVALID_INTERVAL_STR)-1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ABSTIMEMIN</name><parameter_list>(<parameter><type><name>t1</name></type></parameter>, <parameter><type><name>t2</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(DatumGetBool(DirectFunctionCall2(abstimele, \
				  AbsoluteTimeGetDatum(t1), \
				  AbsoluteTimeGetDatum(t2))) ? (t1) : (t2))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ABSTIMEMAX</name><parameter_list>(<parameter><type><name>t1</name></type></parameter>, <parameter><type><name>t2</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(DatumGetBool(DirectFunctionCall2(abstimelt, \
				  AbsoluteTimeGetDatum(t1), \
				  AbsoluteTimeGetDatum(t2))) ? (t2) : (t1))</cpp:value></cpp:define>


<comment type="block">/*
 * Function prototypes -- internal to this file only
 */</comment>

<function_decl><type><specifier>static</specifier> <name>AbsoluteTime</name></type> <name>tm2abstime</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tz</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>reltime2tm</name><parameter_list>(<parameter><decl><type><name>RelativeTime</name></type> <name>time</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>parsetinterval</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>i_string</name></decl></parameter>,
			   <parameter><decl><type><name>AbsoluteTime</name> <modifier>*</modifier></type><name>i_start</name></decl></parameter>,
			   <parameter><decl><type><name>AbsoluteTime</name> <modifier>*</modifier></type><name>i_end</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * GetCurrentAbsoluteTime()
 *
 * Get the current system time (relative to Unix epoch).
 *
 * NB: this will overflow in 2038; it should be gone long before that.
 */</comment>
<function><type><name>AbsoluteTime</name></type>
<name>GetCurrentAbsoluteTime</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>time_t</name></type>		<name>now</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>AbsoluteTime</name><operator>)</operator> <name>now</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>abstime2tm</name><parameter_list>(<parameter><decl><type><name>AbsoluteTime</name></type> <name>_time</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>tzp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>tzn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>time</name> <init>= <expr><operator>(</operator><name>pg_time_t</name><operator>)</operator> <name>_time</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tx</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>tzp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tx</name> <operator>=</operator> <call><name>pg_localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>time</name></expr></argument>, <argument><expr><name>session_timezone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>tx</name> <operator>=</operator> <call><name>pg_gmtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>tx</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not convert abstime to timestamp: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <name><name>tx</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>+</operator> <literal type="number">1900</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <name><name>tx</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <name><name>tx</name><operator>-&gt;</operator><name>tm_mday</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <name><name>tx</name><operator>-&gt;</operator><name>tm_hour</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <name><name>tx</name><operator>-&gt;</operator><name>tm_min</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <name><name>tx</name><operator>-&gt;</operator><name>tm_sec</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>=</operator> <name><name>tx</name><operator>-&gt;</operator><name>tm_isdst</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_gmtoff</name></name> <operator>=</operator> <name><name>tx</name><operator>-&gt;</operator><name>tm_gmtoff</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_zone</name></name> <operator>=</operator> <name><name>tx</name><operator>-&gt;</operator><name>tm_zone</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>tzp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>tzp</name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_gmtoff</name></name></expr>;</expr_stmt>	<comment type="block">/* tm_gmtoff is Sun/DEC-ism */</comment>

		<comment type="block">/*
		 * XXX FreeBSD man pages indicate that this should work - tgl 97/04/23
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>tzn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Copy no more than MAXTZLEN bytes of timezone to tzn, in case it
			 * contains an error message, which doesn't fit in the buffer
			 */</comment>
			<expr_stmt><expr><call><name>StrNCpy</name><argument_list>(<argument><expr><operator>*</operator><name>tzn</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_zone</name></name></expr></argument>, <argument><expr><name>MAXTZLEN</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_zone</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>MAXTZLEN</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid time zone name: \"%s\""</literal></expr></argument>,
								<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_zone</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* tm2abstime()
 * Convert a tm structure to abstime.
 * Note that tm has full year (not 1900-based) and 1-based month.
 */</comment>
<function><type><specifier>static</specifier> <name>AbsoluteTime</name></type>
<name>tm2abstime</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>day</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AbsoluteTime</name></type> <name>sec</name></decl>;</decl_stmt>

	<comment type="block">/* validate, before going out of range on some members */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&lt;</operator> <literal type="number">1901</literal> <operator>||</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&gt;</operator> <literal type="number">2038</literal> <operator>||</operator>
		<name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>&gt;</operator> <name>MONTHS_PER_YEAR</name> <operator>||</operator>
		<name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>&gt;</operator> <literal type="number">31</literal> <operator>||</operator>
		<name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>&gt;</operator> <name>HOURS_PER_DAY</name> <operator>||</operator>	<comment type="block">/* test for &gt; 24:00:00 */</comment>
		<operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>==</operator> <name>HOURS_PER_DAY</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator> <operator>||</operator>
		<name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>&gt;</operator> <name>MINS_PER_HOUR</name> <operator>-</operator> <literal type="number">1</literal> <operator>||</operator>
		<name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>&gt;</operator> <name>SECS_PER_MINUTE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>INVALID_ABSTIME</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>day</name> <operator>=</operator> <call><name>date2j</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>UNIX_EPOCH_JDATE</name></expr>;</expr_stmt>

	<comment type="block">/* check for time out of range */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>day</name> <argument_list type="generic">&lt; <argument><expr><name>MIN_DAYNUM</name> <operator>||</operator> <name>day</name></expr></argument> &gt;</argument_list></name> <name>MAX_DAYNUM</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>INVALID_ABSTIME</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* convert to seconds */</comment>
	<expr_stmt><expr><name>sec</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>+</operator> <name>tz</name> <operator>+</operator> <operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>+</operator> <operator>(</operator><name>day</name> <operator>*</operator> <name>HOURS_PER_DAY</name> <operator>+</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name><operator>)</operator> <operator>*</operator> <name>MINS_PER_HOUR</name><operator>)</operator> <operator>*</operator> <name>SECS_PER_MINUTE</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * check for overflow.  We need a little slop here because the H/M/S plus
	 * TZ offset could add up to more than 1 day.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>day</name> <operator>&gt;=</operator> <name>MAX_DAYNUM</name> <operator>-</operator> <literal type="number">10</literal> <operator>&amp;&amp;</operator> <name>sec</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>day</name> <operator>&lt;=</operator> <name>MIN_DAYNUM</name> <operator>+</operator> <literal type="number">10</literal> <operator>&amp;&amp;</operator> <name>sec</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>INVALID_ABSTIME</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* check for reserved values (e.g. "current" on edge of usual range */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AbsoluteTimeIsReal</name><argument_list>(<argument><expr><name>sec</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>INVALID_ABSTIME</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>sec</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* abstimein()
 * Decode date/time string and return abstime.
 */</comment>
<function><type><name>Datum</name></type>
<name>abstimein</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AbsoluteTime</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>date</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>date</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dterr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>field</name><index>[<expr><name>MAXDATEFIELDS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>workbuf</name><index>[<expr><name>MAXDATELEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nf</name></decl>,
				<decl><type ref="prev"/><name><name>ftype</name><index>[<expr><name>MAXDATEFIELDS</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>ParseDateTime</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>workbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>workbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
						  <argument><expr><name>field</name></expr></argument>, <argument><expr><name>ftype</name></expr></argument>, <argument><expr><name>MAXDATEFIELDS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dterr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeDateTime</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>ftype</name></expr></argument>, <argument><expr><name>nf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dtype</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>dterr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>DateTimeParseError</name><argument_list>(<argument><expr><name>dterr</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"abstime"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name>dtype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DTK_DATE</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>tm2abstime</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>tz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>DTK_EPOCH</name></expr>:</case>

			<comment type="block">/*
			 * Don't bother retaining this as a reserved value, but instead
			 * just set to the actual epoch time (1970-01-01)
			 */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>DTK_LATE</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NOEND_ABSTIME</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>DTK_EARLY</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NOSTART_ABSTIME</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>DTK_INVALID</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>INVALID_ABSTIME</name></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected dtype %d while parsing abstime \"%s\""</literal></expr></argument>,
				 <argument><expr><name>dtype</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>INVALID_ABSTIME</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch><empty_stmt>;</empty_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_ABSOLUTETIME</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* abstimeout()
 * Given an AbsoluteTime return the English text version of the date
 */</comment>
<function><type><name>Datum</name></type>
<name>abstimeout</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AbsoluteTime</name></type> <name>time</name> <init>= <expr><call><name>PG_GETARG_ABSOLUTETIME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>fsec</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>MAXDATELEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>zone</name><index>[<expr><name>MAXDATELEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tzn</name> <init>= <expr><name>zone</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>time</name></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/*
			 * Note that timestamp no longer supports 'invalid'. Retain
			 * 'invalid' for abstime for now, but dump it someday.
			 */</comment>
		<case>case <expr><name>INVALID_ABSTIME</name></expr>:</case>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>INVALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>NOEND_ABSTIME</name></expr>:</case>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>LATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>NOSTART_ABSTIME</name></expr>:</case>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>EARLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>abstime2tm</name><argument_list>(<argument><expr><name>time</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tzn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>EncodeDateTime</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>tz</name></expr></argument>, <argument><expr><name>tzn</name></expr></argument>, <argument><expr><name>DateStyle</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		abstimerecv			- converts external binary format to abstime
 */</comment>
<function><type><name>Datum</name></type>
<name>abstimerecv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_ABSOLUTETIME</name><argument_list>(<argument><expr><operator>(</operator><name>AbsoluteTime</name><operator>)</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AbsoluteTime</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		abstimesend			- converts abstime to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>abstimesend</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AbsoluteTime</name></type> <name>time</name> <init>= <expr><call><name>PG_GETARG_ABSOLUTETIME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* abstime_finite()
 */</comment>
<function><type><name>Datum</name></type>
<name>abstime_finite</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AbsoluteTime</name></type> <name>abstime</name> <init>= <expr><call><name>PG_GETARG_ABSOLUTETIME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>abstime</name> <operator>!=</operator> <name>INVALID_ABSTIME</name> <operator>&amp;&amp;</operator>
				   <name>abstime</name> <operator>!=</operator> <name>NOSTART_ABSTIME</name> <operator>&amp;&amp;</operator>
				   <name>abstime</name> <operator>!=</operator> <name>NOEND_ABSTIME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * abstime comparison routines
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>abstime_cmp_internal</name><parameter_list>(<parameter><decl><type><name>AbsoluteTime</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>AbsoluteTime</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We consider all INVALIDs to be equal and larger than any non-INVALID.
	 * This is somewhat arbitrary; the important thing is to have a consistent
	 * sort order.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>INVALID_ABSTIME</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>b</name> <operator>==</operator> <name>INVALID_ABSTIME</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>			<comment type="block">/* INVALID = INVALID */</comment>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>			<comment type="block">/* INVALID &gt; non-INVALID */</comment>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>b</name> <operator>==</operator> <name>INVALID_ABSTIME</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* non-INVALID &lt; INVALID */</comment>

	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>&gt;</operator> <name>b</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>a</name> <operator>==</operator> <name>b</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>abstimeeq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AbsoluteTime</name></type> <name>t1</name> <init>= <expr><call><name>PG_GETARG_ABSOLUTETIME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AbsoluteTime</name></type> <name>t2</name> <init>= <expr><call><name>PG_GETARG_ABSOLUTETIME</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>abstime_cmp_internal</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>abstimene</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AbsoluteTime</name></type> <name>t1</name> <init>= <expr><call><name>PG_GETARG_ABSOLUTETIME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AbsoluteTime</name></type> <name>t2</name> <init>= <expr><call><name>PG_GETARG_ABSOLUTETIME</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>abstime_cmp_internal</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>abstimelt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AbsoluteTime</name></type> <name>t1</name> <init>= <expr><call><name>PG_GETARG_ABSOLUTETIME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AbsoluteTime</name></type> <name>t2</name> <init>= <expr><call><name>PG_GETARG_ABSOLUTETIME</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>abstime_cmp_internal</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>abstimegt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AbsoluteTime</name></type> <name>t1</name> <init>= <expr><call><name>PG_GETARG_ABSOLUTETIME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AbsoluteTime</name></type> <name>t2</name> <init>= <expr><call><name>PG_GETARG_ABSOLUTETIME</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>abstime_cmp_internal</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>abstimele</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AbsoluteTime</name></type> <name>t1</name> <init>= <expr><call><name>PG_GETARG_ABSOLUTETIME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AbsoluteTime</name></type> <name>t2</name> <init>= <expr><call><name>PG_GETARG_ABSOLUTETIME</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>abstime_cmp_internal</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>abstimege</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AbsoluteTime</name></type> <name>t1</name> <init>= <expr><call><name>PG_GETARG_ABSOLUTETIME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AbsoluteTime</name></type> <name>t2</name> <init>= <expr><call><name>PG_GETARG_ABSOLUTETIME</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>abstime_cmp_internal</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>btabstimecmp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AbsoluteTime</name></type> <name>t1</name> <init>= <expr><call><name>PG_GETARG_ABSOLUTETIME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AbsoluteTime</name></type> <name>t2</name> <init>= <expr><call><name>PG_GETARG_ABSOLUTETIME</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>abstime_cmp_internal</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* timestamp_abstime()
 * Convert timestamp to abstime.
 */</comment>
<function><type><name>Datum</name></type>
<name>timestamp_abstime</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>timestamp</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AbsoluteTime</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_IS_NOBEGIN</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NOSTART_ABSTIME</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>TIMESTAMP_IS_NOEND</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NOEND_ABSTIME</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tz</name> <operator>=</operator> <call><name>DetermineTimeZoneOffset</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>session_timezone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>tm2abstime</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>tz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>INVALID_ABSTIME</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_ABSOLUTETIME</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* abstime_timestamp()
 * Convert abstime to timestamp.
 */</comment>
<function><type><name>Datum</name></type>
<name>abstime_timestamp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AbsoluteTime</name></type> <name>abstime</name> <init>= <expr><call><name>PG_GETARG_ABSOLUTETIME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>zone</name><index>[<expr><name>MAXDATELEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tzn</name> <init>= <expr><name>zone</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>abstime</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INVALID_ABSTIME</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot convert abstime \"invalid\" to timestamp"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>TIMESTAMP_NOBEGIN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>NOSTART_ABSTIME</name></expr>:</case>
			<expr_stmt><expr><call><name>TIMESTAMP_NOBEGIN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>NOEND_ABSTIME</name></expr>:</case>
			<expr_stmt><expr><call><name>TIMESTAMP_NOEND</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>abstime2tm</name><argument_list>(<argument><expr><name>abstime</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tzn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>tm2timestamp</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
	</block_content>}</block></switch><empty_stmt>;</empty_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* timestamptz_abstime()
 * Convert timestamp with time zone to abstime.
 */</comment>
<function><type><name>Datum</name></type>
<name>timestamptz_abstime</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>timestamp</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AbsoluteTime</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_IS_NOBEGIN</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NOSTART_ABSTIME</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>TIMESTAMP_IS_NOEND</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NOEND_ABSTIME</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>tm2abstime</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>INVALID_ABSTIME</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_ABSOLUTETIME</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* abstime_timestamptz()
 * Convert abstime to timestamp with time zone.
 */</comment>
<function><type><name>Datum</name></type>
<name>abstime_timestamptz</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AbsoluteTime</name></type> <name>abstime</name> <init>= <expr><call><name>PG_GETARG_ABSOLUTETIME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>zone</name><index>[<expr><name>MAXDATELEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tzn</name> <init>= <expr><name>zone</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>abstime</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INVALID_ABSTIME</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot convert abstime \"invalid\" to timestamp"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>TIMESTAMP_NOBEGIN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>NOSTART_ABSTIME</name></expr>:</case>
			<expr_stmt><expr><call><name>TIMESTAMP_NOBEGIN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>NOEND_ABSTIME</name></expr>:</case>
			<expr_stmt><expr><call><name>TIMESTAMP_NOEND</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>abstime2tm</name><argument_list>(<argument><expr><name>abstime</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tzn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>tm2timestamp</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
	</block_content>}</block></switch><empty_stmt>;</empty_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 *	 USER I/O ROUTINES														 *
 *****************************************************************************/</comment>

<comment type="block">/*
 *		reltimein		- converts a reltime string in an internal format
 */</comment>
<function><type><name>Datum</name></type>
<name>reltimein</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelativeTime</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dterr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>field</name><index>[<expr><name>MAXDATEFIELDS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nf</name></decl>,
				<decl><type ref="prev"/><name><name>ftype</name><index>[<expr><name>MAXDATEFIELDS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>workbuf</name><index>[<expr><name>MAXDATELEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>ParseDateTime</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>workbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>workbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
						  <argument><expr><name>field</name></expr></argument>, <argument><expr><name>ftype</name></expr></argument>, <argument><expr><name>MAXDATEFIELDS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dterr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeInterval</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>ftype</name></expr></argument>, <argument><expr><name>nf</name></expr></argument>, <argument><expr><name>INTERVAL_FULL_RANGE</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>dtype</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* if those functions think it's a bad format, try ISO8601 style */</comment>
	<if_stmt><if>if <condition>(<expr><name>dterr</name> <operator>==</operator> <name>DTERR_BAD_FORMAT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeISO8601Interval</name><argument_list>(<argument><expr><name>str</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>dtype</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>dterr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>dterr</name> <operator>==</operator> <name>DTERR_FIELD_OVERFLOW</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>dterr</name> <operator>=</operator> <name>DTERR_INTERVAL_OVERFLOW</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>DateTimeParseError</name><argument_list>(<argument><expr><name>dterr</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"reltime"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><name>dtype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DTK_DELTA</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>*</operator> <name>MINS_PER_HOUR</name> <operator>+</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name><operator>)</operator> <operator>*</operator> <name>SECS_PER_MINUTE</name><operator>)</operator> <operator>+</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>+=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>*</operator> <name>SECS_PER_YEAR</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>*</operator> <name>DAYS_PER_MONTH</name><operator>)</operator> <operator>+</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name><operator>)</operator> <operator>*</operator> <name>SECS_PER_DAY</name></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected dtype %d while parsing reltime \"%s\""</literal></expr></argument>,
				 <argument><expr><name>dtype</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>INVALID_RELTIME</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>PG_RETURN_RELATIVETIME</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		reltimeout		- converts the internal format to a reltime string
 */</comment>
<function><type><name>Datum</name></type>
<name>reltimeout</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelativeTime</name></type> <name>time</name> <init>= <expr><call><name>PG_GETARG_RELATIVETIME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>MAXDATELEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>reltime2tm</name><argument_list>(<argument><expr><name>time</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EncodeInterval</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>IntervalStyle</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		reltimerecv			- converts external binary format to reltime
 */</comment>
<function><type><name>Datum</name></type>
<name>reltimerecv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_RELATIVETIME</name><argument_list>(<argument><expr><operator>(</operator><name>RelativeTime</name><operator>)</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelativeTime</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		reltimesend			- converts reltime to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>reltimesend</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelativeTime</name></type> <name>time</name> <init>= <expr><call><name>PG_GETARG_RELATIVETIME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>reltime2tm</name><parameter_list>(<parameter><decl><type><name>RelativeTime</name></type> <name>time</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>dtime</name> <init>= <expr><name>time</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>FMODULO</name><argument_list>(<argument><expr><name>dtime</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><literal type="number">31557600</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FMODULO</name><argument_list>(<argument><expr><name>dtime</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><literal type="number">2592000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FMODULO</name><argument_list>(<argument><expr><name>dtime</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>, <argument><expr><name>SECS_PER_DAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FMODULO</name><argument_list>(<argument><expr><name>dtime</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr></argument>, <argument><expr><name>SECS_PER_HOUR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FMODULO</name><argument_list>(<argument><expr><name>dtime</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name></expr></argument>, <argument><expr><name>SECS_PER_MINUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FMODULO</name><argument_list>(<argument><expr><name>dtime</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		tintervalin		- converts a tinterval string to internal format
 */</comment>
<function><type><name>Datum</name></type>
<name>tintervalin</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tintervalstr</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeInterval</name></type> <name>tinterval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AbsoluteTime</name></type> <name>i_start</name></decl>,
				<decl><type ref="prev"/><name>i_end</name></decl>,
				<decl><type ref="prev"/><name>t1</name></decl>,
				<decl><type ref="prev"/><name>t2</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>parsetinterval</name><argument_list>(<argument><expr><name>tintervalstr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tinterval</name> <operator>=</operator> <operator>(</operator><name>TimeInterval</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TimeIntervalData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>t1</name> <operator>==</operator> <name>INVALID_ABSTIME</name> <operator>||</operator> <name>t2</name> <operator>==</operator> <name>INVALID_ABSTIME</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tinterval</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>T_INTERVAL_INVAL</name></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* undefined  */</comment>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tinterval</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>T_INTERVAL_VALID</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>i_start</name> <operator>=</operator> <call><name>ABSTIMEMIN</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_end</name> <operator>=</operator> <call><name>ABSTIMEMAX</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tinterval</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>i_start</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tinterval</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>i_end</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMEINTERVAL</name><argument_list>(<argument><expr><name>tinterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		tintervalout	- converts an internal tinterval format to a string
 */</comment>
<function><type><name>Datum</name></type>
<name>tintervalout</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeInterval</name></type> <name>tinterval</name> <init>= <expr><call><name>PG_GETARG_TIMEINTERVAL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>i_str</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>i_str</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>T_INTERVAL_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* ["..." "..."] */</comment>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>i_str</name></expr></argument>, <argument><expr><literal type="string">"[\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tinterval</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>T_INTERVAL_INVAL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>i_str</name></expr></argument>, <argument><expr><name>INVALID_INTERVAL_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>abstimeout</name></expr></argument>,
												<argument><expr><call><name>AbsoluteTimeGetDatum</name><argument_list>(<argument><expr><name><name>tinterval</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>i_str</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>i_str</name></expr></argument>, <argument><expr><literal type="string">"\" \""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>abstimeout</name></expr></argument>,
												<argument><expr><call><name>AbsoluteTimeGetDatum</name><argument_list>(<argument><expr><name><name>tinterval</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>i_str</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>i_str</name></expr></argument>, <argument><expr><literal type="string">"\"]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>i_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		tintervalrecv			- converts external binary format to tinterval
 */</comment>
<function><type><name>Datum</name></type>
<name>tintervalrecv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeInterval</name></type> <name>tinterval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>status</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tinterval</name> <operator>=</operator> <operator>(</operator><name>TimeInterval</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TimeIntervalData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tinterval</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>tinterval</name><operator>-&gt;</operator><name>status</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tinterval</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>tinterval</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tinterval</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>tinterval</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tinterval</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>INVALID_ABSTIME</name> <operator>||</operator>
		<name><name>tinterval</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>INVALID_ABSTIME</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <name>T_INTERVAL_INVAL</name></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* undefined  */</comment>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <name>T_INTERVAL_VALID</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name><name>tinterval</name><operator>-&gt;</operator><name>status</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_BINARY_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid status in external \"tinterval\" value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMEINTERVAL</name><argument_list>(<argument><expr><name>tinterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		tintervalsend			- converts tinterval to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>tintervalsend</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeInterval</name></type> <name>tinterval</name> <init>= <expr><call><name>PG_GETARG_TIMEINTERVAL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>tinterval</name><operator>-&gt;</operator><name>status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>tinterval</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>tinterval</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 *	 PUBLIC ROUTINES														 *
 *****************************************************************************/</comment>

<function><type><name>Datum</name></type>
<name>interval_reltime</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>interval</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelativeTime</name></type> <name>time</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>year</name></decl>,
				<decl><type ref="prev"/><name>month</name></decl>,
				<decl><type ref="prev"/><name>day</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeOffset</name></type>	<name>span</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>year</name> <operator>=</operator> <name><name>interval</name><operator>-&gt;</operator><name>month</name></name> <operator>/</operator> <name>MONTHS_PER_YEAR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>month</name> <operator>=</operator> <name><name>interval</name><operator>-&gt;</operator><name>month</name></name> <operator>%</operator> <name>MONTHS_PER_YEAR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>day</name> <operator>=</operator> <name><name>interval</name><operator>-&gt;</operator><name>day</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>span</name> <operator>=</operator> <operator>(</operator><operator>(</operator><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">365250000</literal></expr></argument>)</argument_list></call> <operator>*</operator> <name>year</name> <operator>+</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">30000000</literal></expr></argument>)</argument_list></call> <operator>*</operator> <name>month</name> <operator>+</operator>
			 <call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">1000000</literal></expr></argument>)</argument_list></call> <operator>*</operator> <name>day</name><operator>)</operator> <operator>*</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">86400</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>+</operator>
		<name><name>interval</name><operator>-&gt;</operator><name>time</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>span</name> <operator>/=</operator> <name>USECS_PER_SEC</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>span</name> <argument_list type="generic">&lt; <argument><expr><name>INT_MIN</name> <operator>||</operator> <name>span</name></expr></argument> &gt;</argument_list></name> <name>INT_MAX</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>time</name> <operator>=</operator> <name>INVALID_RELTIME</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>time</name> <operator>=</operator> <name>span</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_RELATIVETIME</name><argument_list>(<argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>reltime_interval</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelativeTime</name></type> <name>reltime</name> <init>= <expr><call><name>PG_GETARG_RELATIVETIME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>year</name></decl>,
				<decl><type ref="prev"/><name>month</name></decl>,
				<decl><type ref="prev"/><name>day</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Interval</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Interval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>reltime</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INVALID_RELTIME</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot convert reltime \"invalid\" to interval"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>month</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><name>year</name> <operator>=</operator> <name>reltime</name> <operator>/</operator> <name>SECS_PER_YEAR</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>reltime</name> <operator>-=</operator> <name>year</name> <operator>*</operator> <name>SECS_PER_YEAR</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>month</name> <operator>=</operator> <name>reltime</name> <operator>/</operator> <operator>(</operator><name>DAYS_PER_MONTH</name> <operator>*</operator> <name>SECS_PER_DAY</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>reltime</name> <operator>-=</operator> <name>month</name> <operator>*</operator> <operator>(</operator><name>DAYS_PER_MONTH</name> <operator>*</operator> <name>SECS_PER_DAY</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>day</name> <operator>=</operator> <name>reltime</name> <operator>/</operator> <name>SECS_PER_DAY</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>reltime</name> <operator>-=</operator> <name>day</name> <operator>*</operator> <name>SECS_PER_DAY</name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <operator>(</operator><name>reltime</name> <operator>*</operator> <name>USECS_PER_SEC</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>month</name></name> <operator>=</operator> <name>MONTHS_PER_YEAR</name> <operator>*</operator> <name>year</name> <operator>+</operator> <name>month</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>=</operator> <name>day</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>PG_RETURN_INTERVAL_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		mktinterval		- creates a time interval with endpoints t1 and t2
 */</comment>
<function><type><name>Datum</name></type>
<name>mktinterval</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AbsoluteTime</name></type> <name>t1</name> <init>= <expr><call><name>PG_GETARG_ABSOLUTETIME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AbsoluteTime</name></type> <name>t2</name> <init>= <expr><call><name>PG_GETARG_ABSOLUTETIME</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AbsoluteTime</name></type> <name>tstart</name> <init>= <expr><call><name>ABSTIMEMIN</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AbsoluteTime</name></type> <name>tend</name> <init>= <expr><call><name>ABSTIMEMAX</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeInterval</name></type> <name>tinterval</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tinterval</name> <operator>=</operator> <operator>(</operator><name>TimeInterval</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TimeIntervalData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>t1</name> <operator>==</operator> <name>INVALID_ABSTIME</name> <operator>||</operator> <name>t2</name> <operator>==</operator> <name>INVALID_ABSTIME</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tinterval</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>T_INTERVAL_INVAL</name></expr>;</expr_stmt></block_content></block></if>

	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>tinterval</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>T_INTERVAL_VALID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tinterval</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>tstart</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tinterval</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>tend</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMEINTERVAL</name><argument_list>(<argument><expr><name>tinterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		timepl, timemi and abstimemi use the formula
 *				abstime + reltime = abstime
 *		so		abstime - reltime = abstime
 *		and		abstime - abstime = reltime
 */</comment>

<comment type="block">/*
 *		timepl			- returns the value of (abstime t1 + reltime t2)
 */</comment>
<function><type><name>Datum</name></type>
<name>timepl</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AbsoluteTime</name></type> <name>t1</name> <init>= <expr><call><name>PG_GETARG_ABSOLUTETIME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelativeTime</name></type> <name>t2</name> <init>= <expr><call><name>PG_GETARG_RELATIVETIME</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>AbsoluteTimeIsReal</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>RelativeTimeIsValid</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>t2</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>t1</name> <operator>&lt;</operator> <name>NOEND_ABSTIME</name> <operator>-</operator> <name>t2</name><operator>)</operator> <operator>||</operator>
		 <operator>(</operator><name>t2</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>t1</name> <operator>&gt;</operator> <name>NOSTART_ABSTIME</name> <operator>-</operator> <name>t2</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* prevent overflow */</comment>
		<expr_stmt><expr><call><name>PG_RETURN_ABSOLUTETIME</name><argument_list>(<argument><expr><name>t1</name> <operator>+</operator> <name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_ABSOLUTETIME</name><argument_list>(<argument><expr><name>INVALID_ABSTIME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		timemi			- returns the value of (abstime t1 - reltime t2)
 */</comment>
<function><type><name>Datum</name></type>
<name>timemi</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AbsoluteTime</name></type> <name>t1</name> <init>= <expr><call><name>PG_GETARG_ABSOLUTETIME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelativeTime</name></type> <name>t2</name> <init>= <expr><call><name>PG_GETARG_RELATIVETIME</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>AbsoluteTimeIsReal</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>RelativeTimeIsValid</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>t2</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>t1</name> <operator>&gt;</operator> <name>NOSTART_ABSTIME</name> <operator>+</operator> <name>t2</name><operator>)</operator> <operator>||</operator>
		 <operator>(</operator><name>t2</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>t1</name> <operator>&lt;</operator> <name>NOEND_ABSTIME</name> <operator>+</operator> <name>t2</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* prevent overflow */</comment>
		<expr_stmt><expr><call><name>PG_RETURN_ABSOLUTETIME</name><argument_list>(<argument><expr><name>t1</name> <operator>-</operator> <name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_ABSOLUTETIME</name><argument_list>(<argument><expr><name>INVALID_ABSTIME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		intinterval		- returns true iff absolute date is in the tinterval
 */</comment>
<function><type><name>Datum</name></type>
<name>intinterval</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AbsoluteTime</name></type> <name>t</name> <init>= <expr><call><name>PG_GETARG_ABSOLUTETIME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeInterval</name></type> <name>tinterval</name> <init>= <expr><call><name>PG_GETARG_TIMEINTERVAL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tinterval</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>T_INTERVAL_VALID</name> <operator>&amp;&amp;</operator> <name>t</name> <operator>!=</operator> <name>INVALID_ABSTIME</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>abstimege</name></expr></argument>,
											 <argument><expr><call><name>AbsoluteTimeGetDatum</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><call><name>AbsoluteTimeGetDatum</name><argument_list>(<argument><expr><name><name>tinterval</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>abstimele</name></expr></argument>,
											 <argument><expr><call><name>AbsoluteTimeGetDatum</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><call><name>AbsoluteTimeGetDatum</name><argument_list>(<argument><expr><name><name>tinterval</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		tintervalrel		- returns  relative time corresponding to tinterval
 */</comment>
<function><type><name>Datum</name></type>
<name>tintervalrel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeInterval</name></type> <name>tinterval</name> <init>= <expr><call><name>PG_GETARG_TIMEINTERVAL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AbsoluteTime</name></type> <name>t1</name> <init>= <expr><name><name>tinterval</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AbsoluteTime</name></type> <name>t2</name> <init>= <expr><name><name>tinterval</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tinterval</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>T_INTERVAL_VALID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_RELATIVETIME</name><argument_list>(<argument><expr><name>INVALID_RELTIME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>AbsoluteTimeIsReal</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>AbsoluteTimeIsReal</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_RELATIVETIME</name><argument_list>(<argument><expr><name>t2</name> <operator>-</operator> <name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_RELATIVETIME</name><argument_list>(<argument><expr><name>INVALID_RELTIME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		timenow			- returns  time "now", internal format
 *
 *		Now AbsoluteTime is time since Jan 1 1970 -mer 7 Feb 1992
 */</comment>
<function><type><name>Datum</name></type>
<name>timenow</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_ABSOLUTETIME</name><argument_list>(<argument><expr><call><name>GetCurrentAbsoluteTime</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * reltime comparison routines
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>reltime_cmp_internal</name><parameter_list>(<parameter><decl><type><name>RelativeTime</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>RelativeTime</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We consider all INVALIDs to be equal and larger than any non-INVALID.
	 * This is somewhat arbitrary; the important thing is to have a consistent
	 * sort order.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>INVALID_RELTIME</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>b</name> <operator>==</operator> <name>INVALID_RELTIME</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>			<comment type="block">/* INVALID = INVALID */</comment>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>			<comment type="block">/* INVALID &gt; non-INVALID */</comment>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>b</name> <operator>==</operator> <name>INVALID_RELTIME</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* non-INVALID &lt; INVALID */</comment>

	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>&gt;</operator> <name>b</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>a</name> <operator>==</operator> <name>b</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>reltimeeq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelativeTime</name></type> <name>t1</name> <init>= <expr><call><name>PG_GETARG_RELATIVETIME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelativeTime</name></type> <name>t2</name> <init>= <expr><call><name>PG_GETARG_RELATIVETIME</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>reltime_cmp_internal</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>reltimene</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelativeTime</name></type> <name>t1</name> <init>= <expr><call><name>PG_GETARG_RELATIVETIME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelativeTime</name></type> <name>t2</name> <init>= <expr><call><name>PG_GETARG_RELATIVETIME</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>reltime_cmp_internal</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>reltimelt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelativeTime</name></type> <name>t1</name> <init>= <expr><call><name>PG_GETARG_RELATIVETIME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelativeTime</name></type> <name>t2</name> <init>= <expr><call><name>PG_GETARG_RELATIVETIME</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>reltime_cmp_internal</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>reltimegt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelativeTime</name></type> <name>t1</name> <init>= <expr><call><name>PG_GETARG_RELATIVETIME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelativeTime</name></type> <name>t2</name> <init>= <expr><call><name>PG_GETARG_RELATIVETIME</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>reltime_cmp_internal</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>reltimele</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelativeTime</name></type> <name>t1</name> <init>= <expr><call><name>PG_GETARG_RELATIVETIME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelativeTime</name></type> <name>t2</name> <init>= <expr><call><name>PG_GETARG_RELATIVETIME</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>reltime_cmp_internal</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>reltimege</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelativeTime</name></type> <name>t1</name> <init>= <expr><call><name>PG_GETARG_RELATIVETIME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelativeTime</name></type> <name>t2</name> <init>= <expr><call><name>PG_GETARG_RELATIVETIME</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>reltime_cmp_internal</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>btreltimecmp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelativeTime</name></type> <name>t1</name> <init>= <expr><call><name>PG_GETARG_RELATIVETIME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelativeTime</name></type> <name>t2</name> <init>= <expr><call><name>PG_GETARG_RELATIVETIME</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>reltime_cmp_internal</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		tintervalsame	- returns true iff tinterval i1 is same as tinterval i2
 *		Check begin and end time.
 */</comment>
<function><type><name>Datum</name></type>
<name>tintervalsame</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeInterval</name></type> <name>i1</name> <init>= <expr><call><name>PG_GETARG_TIMEINTERVAL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeInterval</name></type> <name>i2</name> <init>= <expr><call><name>PG_GETARG_TIMEINTERVAL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>i1</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>T_INTERVAL_INVAL</name> <operator>||</operator> <name><name>i2</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>T_INTERVAL_INVAL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>abstimeeq</name></expr></argument>,
										 <argument><expr><call><name>AbsoluteTimeGetDatum</name><argument_list>(<argument><expr><name><name>i1</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><call><name>AbsoluteTimeGetDatum</name><argument_list>(<argument><expr><name><name>i2</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>abstimeeq</name></expr></argument>,
										 <argument><expr><call><name>AbsoluteTimeGetDatum</name><argument_list>(<argument><expr><name><name>i1</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><call><name>AbsoluteTimeGetDatum</name><argument_list>(<argument><expr><name><name>i2</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tinterval comparison routines
 *
 * Note: comparison is based only on the lengths of the tintervals, not on
 * endpoint values (as long as they're not INVALID).  This is pretty bogus,
 * but since it's only a legacy datatype, we're not going to change it.
 *
 * Some other bogus things that won't be changed for compatibility reasons:
 * 1. The interval length computations overflow at 2^31 seconds, causing
 * intervals longer than that to sort oddly compared to those shorter.
 * 2. infinity and minus infinity (NOEND_ABSTIME and NOSTART_ABSTIME) are
 * just ordinary integers.  Since this code doesn't handle them specially,
 * it's possible for [a b] to be considered longer than [c infinity] for
 * finite abstimes a, b, c.  In combination with the previous point, the
 * interval [-infinity infinity] is treated as being shorter than many finite
 * intervals :-(
 *
 * If tinterval is ever reimplemented atop timestamp, it'd be good to give
 * some consideration to avoiding these problems.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>tinterval_cmp_internal</name><parameter_list>(<parameter><decl><type><name>TimeInterval</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>TimeInterval</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>a_invalid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>b_invalid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AbsoluteTime</name></type> <name>a_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AbsoluteTime</name></type> <name>b_len</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We consider all INVALIDs to be equal and larger than any non-INVALID.
	 * This is somewhat arbitrary; the important thing is to have a consistent
	 * sort order.
	 */</comment>
	<expr_stmt><expr><name>a_invalid</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>T_INTERVAL_INVAL</name> <operator>||</operator>
		<name><name>a</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>INVALID_ABSTIME</name> <operator>||</operator>
		<name><name>a</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>INVALID_ABSTIME</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>b_invalid</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>T_INTERVAL_INVAL</name> <operator>||</operator>
		<name><name>b</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>INVALID_ABSTIME</name> <operator>||</operator>
		<name><name>b</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>INVALID_ABSTIME</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>a_invalid</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>b_invalid</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>			<comment type="block">/* INVALID = INVALID */</comment>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>			<comment type="block">/* INVALID &gt; non-INVALID */</comment>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>b_invalid</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* non-INVALID &lt; INVALID */</comment>

	<expr_stmt><expr><name>a_len</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>a</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>b_len</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>b</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>a_len</name> <operator>&gt;</operator> <name>b_len</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>a_len</name> <operator>==</operator> <name>b_len</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>tintervaleq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeInterval</name></type> <name>i1</name> <init>= <expr><call><name>PG_GETARG_TIMEINTERVAL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeInterval</name></type> <name>i2</name> <init>= <expr><call><name>PG_GETARG_TIMEINTERVAL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>tinterval_cmp_internal</name><argument_list>(<argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>tintervalne</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeInterval</name></type> <name>i1</name> <init>= <expr><call><name>PG_GETARG_TIMEINTERVAL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeInterval</name></type> <name>i2</name> <init>= <expr><call><name>PG_GETARG_TIMEINTERVAL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>tinterval_cmp_internal</name><argument_list>(<argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>tintervallt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeInterval</name></type> <name>i1</name> <init>= <expr><call><name>PG_GETARG_TIMEINTERVAL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeInterval</name></type> <name>i2</name> <init>= <expr><call><name>PG_GETARG_TIMEINTERVAL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>tinterval_cmp_internal</name><argument_list>(<argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>tintervalle</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeInterval</name></type> <name>i1</name> <init>= <expr><call><name>PG_GETARG_TIMEINTERVAL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeInterval</name></type> <name>i2</name> <init>= <expr><call><name>PG_GETARG_TIMEINTERVAL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>tinterval_cmp_internal</name><argument_list>(<argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>tintervalgt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeInterval</name></type> <name>i1</name> <init>= <expr><call><name>PG_GETARG_TIMEINTERVAL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeInterval</name></type> <name>i2</name> <init>= <expr><call><name>PG_GETARG_TIMEINTERVAL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>tinterval_cmp_internal</name><argument_list>(<argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>tintervalge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeInterval</name></type> <name>i1</name> <init>= <expr><call><name>PG_GETARG_TIMEINTERVAL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeInterval</name></type> <name>i2</name> <init>= <expr><call><name>PG_GETARG_TIMEINTERVAL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>tinterval_cmp_internal</name><argument_list>(<argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>bttintervalcmp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeInterval</name></type> <name>i1</name> <init>= <expr><call><name>PG_GETARG_TIMEINTERVAL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeInterval</name></type> <name>i2</name> <init>= <expr><call><name>PG_GETARG_TIMEINTERVAL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>tinterval_cmp_internal</name><argument_list>(<argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		tintervalleneq	- returns true iff length of tinterval i is equal to
 *								reltime t
 *		tintervallenne	- returns true iff length of tinterval i is not equal
 *								to reltime t
 *		tintervallenlt	- returns true iff length of tinterval i is less than
 *								reltime t
 *		tintervallengt	- returns true iff length of tinterval i is greater
 *								than reltime t
 *		tintervallenle	- returns true iff length of tinterval i is less or
 *								equal than reltime t
 *		tintervallenge	- returns true iff length of tinterval i is greater or
 *								equal than reltime t
 */</comment>
<function><type><name>Datum</name></type>
<name>tintervalleneq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeInterval</name></type> <name>i</name> <init>= <expr><call><name>PG_GETARG_TIMEINTERVAL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelativeTime</name></type> <name>t</name> <init>= <expr><call><name>PG_GETARG_RELATIVETIME</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelativeTime</name></type> <name>rt</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>i</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>T_INTERVAL_INVAL</name> <operator>||</operator> <name>t</name> <operator>==</operator> <name>INVALID_RELTIME</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>rt</name> <operator>=</operator> <call><name>DatumGetRelativeTime</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>tintervalrel</name></expr></argument>,
												  <argument><expr><call><name>TimeIntervalGetDatum</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>rt</name> <operator>!=</operator> <name>INVALID_RELTIME</name> <operator>&amp;&amp;</operator> <name>rt</name> <operator>==</operator> <name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>tintervallenne</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeInterval</name></type> <name>i</name> <init>= <expr><call><name>PG_GETARG_TIMEINTERVAL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelativeTime</name></type> <name>t</name> <init>= <expr><call><name>PG_GETARG_RELATIVETIME</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelativeTime</name></type> <name>rt</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>i</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>T_INTERVAL_INVAL</name> <operator>||</operator> <name>t</name> <operator>==</operator> <name>INVALID_RELTIME</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>rt</name> <operator>=</operator> <call><name>DatumGetRelativeTime</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>tintervalrel</name></expr></argument>,
												  <argument><expr><call><name>TimeIntervalGetDatum</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>rt</name> <operator>!=</operator> <name>INVALID_RELTIME</name> <operator>&amp;&amp;</operator> <name>rt</name> <operator>!=</operator> <name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>tintervallenlt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeInterval</name></type> <name>i</name> <init>= <expr><call><name>PG_GETARG_TIMEINTERVAL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelativeTime</name></type> <name>t</name> <init>= <expr><call><name>PG_GETARG_RELATIVETIME</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelativeTime</name></type> <name>rt</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>i</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>T_INTERVAL_INVAL</name> <operator>||</operator> <name>t</name> <operator>==</operator> <name>INVALID_RELTIME</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>rt</name> <operator>=</operator> <call><name>DatumGetRelativeTime</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>tintervalrel</name></expr></argument>,
												  <argument><expr><call><name>TimeIntervalGetDatum</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>rt</name> <operator>!=</operator> <name>INVALID_RELTIME</name> <operator>&amp;&amp;</operator> <name>rt</name> <operator>&lt;</operator> <name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>tintervallengt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeInterval</name></type> <name>i</name> <init>= <expr><call><name>PG_GETARG_TIMEINTERVAL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelativeTime</name></type> <name>t</name> <init>= <expr><call><name>PG_GETARG_RELATIVETIME</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelativeTime</name></type> <name>rt</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>i</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>T_INTERVAL_INVAL</name> <operator>||</operator> <name>t</name> <operator>==</operator> <name>INVALID_RELTIME</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>rt</name> <operator>=</operator> <call><name>DatumGetRelativeTime</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>tintervalrel</name></expr></argument>,
												  <argument><expr><call><name>TimeIntervalGetDatum</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>rt</name> <operator>!=</operator> <name>INVALID_RELTIME</name> <operator>&amp;&amp;</operator> <name>rt</name> <operator>&gt;</operator> <name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>tintervallenle</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeInterval</name></type> <name>i</name> <init>= <expr><call><name>PG_GETARG_TIMEINTERVAL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelativeTime</name></type> <name>t</name> <init>= <expr><call><name>PG_GETARG_RELATIVETIME</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelativeTime</name></type> <name>rt</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>i</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>T_INTERVAL_INVAL</name> <operator>||</operator> <name>t</name> <operator>==</operator> <name>INVALID_RELTIME</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>rt</name> <operator>=</operator> <call><name>DatumGetRelativeTime</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>tintervalrel</name></expr></argument>,
												  <argument><expr><call><name>TimeIntervalGetDatum</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>rt</name> <operator>!=</operator> <name>INVALID_RELTIME</name> <operator>&amp;&amp;</operator> <name>rt</name> <operator>&lt;=</operator> <name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>tintervallenge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeInterval</name></type> <name>i</name> <init>= <expr><call><name>PG_GETARG_TIMEINTERVAL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelativeTime</name></type> <name>t</name> <init>= <expr><call><name>PG_GETARG_RELATIVETIME</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelativeTime</name></type> <name>rt</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>i</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>T_INTERVAL_INVAL</name> <operator>||</operator> <name>t</name> <operator>==</operator> <name>INVALID_RELTIME</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>rt</name> <operator>=</operator> <call><name>DatumGetRelativeTime</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>tintervalrel</name></expr></argument>,
												  <argument><expr><call><name>TimeIntervalGetDatum</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>rt</name> <operator>!=</operator> <name>INVALID_RELTIME</name> <operator>&amp;&amp;</operator> <name>rt</name> <operator>&gt;=</operator> <name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		tintervalct		- returns true iff tinterval i1 contains tinterval i2
 */</comment>
<function><type><name>Datum</name></type>
<name>tintervalct</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeInterval</name></type> <name>i1</name> <init>= <expr><call><name>PG_GETARG_TIMEINTERVAL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeInterval</name></type> <name>i2</name> <init>= <expr><call><name>PG_GETARG_TIMEINTERVAL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>i1</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>T_INTERVAL_INVAL</name> <operator>||</operator> <name><name>i2</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>T_INTERVAL_INVAL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>abstimele</name></expr></argument>,
										 <argument><expr><call><name>AbsoluteTimeGetDatum</name><argument_list>(<argument><expr><name><name>i1</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><call><name>AbsoluteTimeGetDatum</name><argument_list>(<argument><expr><name><name>i2</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>abstimege</name></expr></argument>,
										 <argument><expr><call><name>AbsoluteTimeGetDatum</name><argument_list>(<argument><expr><name><name>i1</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><call><name>AbsoluteTimeGetDatum</name><argument_list>(<argument><expr><name><name>i2</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		tintervalov		- returns true iff tinterval i1 (partially) overlaps i2
 */</comment>
<function><type><name>Datum</name></type>
<name>tintervalov</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeInterval</name></type> <name>i1</name> <init>= <expr><call><name>PG_GETARG_TIMEINTERVAL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeInterval</name></type> <name>i2</name> <init>= <expr><call><name>PG_GETARG_TIMEINTERVAL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>i1</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>T_INTERVAL_INVAL</name> <operator>||</operator> <name><name>i2</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>T_INTERVAL_INVAL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>abstimelt</name></expr></argument>,
										 <argument><expr><call><name>AbsoluteTimeGetDatum</name><argument_list>(<argument><expr><name><name>i1</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><call><name>AbsoluteTimeGetDatum</name><argument_list>(<argument><expr><name><name>i2</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>abstimegt</name></expr></argument>,
										 <argument><expr><call><name>AbsoluteTimeGetDatum</name><argument_list>(<argument><expr><name><name>i1</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><call><name>AbsoluteTimeGetDatum</name><argument_list>(<argument><expr><name><name>i2</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		tintervalstart	- returns  the start of tinterval i
 */</comment>
<function><type><name>Datum</name></type>
<name>tintervalstart</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeInterval</name></type> <name>i</name> <init>= <expr><call><name>PG_GETARG_TIMEINTERVAL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>i</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>T_INTERVAL_INVAL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_ABSOLUTETIME</name><argument_list>(<argument><expr><name>INVALID_ABSTIME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_ABSOLUTETIME</name><argument_list>(<argument><expr><name><name>i</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		tintervalend		- returns  the end of tinterval i
 */</comment>
<function><type><name>Datum</name></type>
<name>tintervalend</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeInterval</name></type> <name>i</name> <init>= <expr><call><name>PG_GETARG_TIMEINTERVAL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>i</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>T_INTERVAL_INVAL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_ABSOLUTETIME</name><argument_list>(<argument><expr><name>INVALID_ABSTIME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_ABSOLUTETIME</name><argument_list>(<argument><expr><name><name>i</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 *	 PRIVATE ROUTINES														 *
 *****************************************************************************/</comment>

<comment type="block">/*
 *		parsetinterval -- parse a tinterval string
 *
 *		output parameters:
 *				i_start, i_end: tinterval margins
 *
 *		Time interval:
 *		`[' {` '} `'' &lt;AbsTime&gt; `'' {` '} `'' &lt;AbsTime&gt; `'' {` '} `]'
 *
 *		OR	`Undefined Range'	(see also INVALID_INTERVAL_STR)
 *
 *		where &lt;AbsTime&gt; satisfies the syntax of absolute time.
 *
 *		e.g.  [  '  Jan 18 1902'   'Jan 1 00:00:00 1970']
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>parsetinterval</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>i_string</name></decl></parameter>,
			   <parameter><decl><type><name>AbsoluteTime</name> <modifier>*</modifier></type><name>i_start</name></decl></parameter>,
			   <parameter><decl><type><name>AbsoluteTime</name> <modifier>*</modifier></type><name>i_end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>p1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>c</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>p</name> <operator>=</operator> <name>i_string</name></expr>;</expr_stmt>
	<comment type="block">/* skip leading blanks up to '[' */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsSpace</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>c</name> <operator>!=</operator> <literal type="char">'['</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>bogus</name>;</goto></block_content></block></if>			<comment type="block">/* syntax error */</comment>
		<else>else<block type="pseudo"><block_content>
			<break>break;</break></block_content></block></else></if_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>bogus</name>;</goto></block_content></block></if></if_stmt>				<comment type="block">/* syntax error */</comment>
	<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
	<comment type="block">/* skip leading blanks up to '"' */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsSpace</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>c</name> <operator>!=</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>bogus</name>;</goto></block_content></block></if>			<comment type="block">/* syntax error */</comment>
		<else>else<block type="pseudo"><block_content>
			<break>break;</break></block_content></block></else></if_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>bogus</name>;</goto></block_content></block></if></if_stmt>				<comment type="block">/* syntax error */</comment>
	<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>INVALID_INTERVAL_STR</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>INVALID_INTERVAL_STR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>bogus</name>;</goto></block_content></block></if></if_stmt>				<comment type="block">/* undefined range, handled like a syntax err. */</comment>
	<comment type="block">/* search for the end of the first date and change it to a \0 */</comment>
	<expr_stmt><expr><name>p1</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>p1</name><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>p1</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>bogus</name>;</goto></block_content></block></if></if_stmt>				<comment type="block">/* syntax error */</comment>
	<expr_stmt><expr><operator>*</operator><name>p1</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<comment type="block">/* get the first date */</comment>
	<expr_stmt><expr><operator>*</operator><name>i_start</name> <operator>=</operator> <call><name>DatumGetAbsoluteTime</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>abstimein</name></expr></argument>,
														<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* undo change to \0 */</comment>
	<expr_stmt><expr><operator>*</operator><name>p1</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>++</operator><name>p1</name></expr>;</expr_stmt>
	<comment type="block">/* skip blanks up to '"', beginning of second date */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsSpace</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>c</name> <operator>!=</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>bogus</name>;</goto></block_content></block></if>			<comment type="block">/* syntax error */</comment>
		<else>else<block type="pseudo"><block_content>
			<break>break;</break></block_content></block></else></if_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>bogus</name>;</goto></block_content></block></if></if_stmt>				<comment type="block">/* syntax error */</comment>
	<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
	<comment type="block">/* search for the end of the second date and change it to a \0 */</comment>
	<expr_stmt><expr><name>p1</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>p1</name><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>p1</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>bogus</name>;</goto></block_content></block></if></if_stmt>				<comment type="block">/* syntax error */</comment>
	<expr_stmt><expr><operator>*</operator><name>p1</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<comment type="block">/* get the second date */</comment>
	<expr_stmt><expr><operator>*</operator><name>i_end</name> <operator>=</operator> <call><name>DatumGetAbsoluteTime</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>abstimein</name></expr></argument>,
													  <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* undo change to \0 */</comment>
	<expr_stmt><expr><operator>*</operator><name>p1</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>++</operator><name>p1</name></expr>;</expr_stmt>
	<comment type="block">/* skip blanks up to ']' */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsSpace</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>c</name> <operator>!=</operator> <literal type="char">']'</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>bogus</name>;</goto></block_content></block></if>			<comment type="block">/* syntax error */</comment>
		<else>else<block type="pseudo"><block_content>
			<break>break;</break></block_content></block></else></if_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>bogus</name>;</goto></block_content></block></if></if_stmt>				<comment type="block">/* syntax error */</comment>
	<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>bogus</name>;</goto></block_content></block></if></if_stmt>				<comment type="block">/* syntax error */</comment>

	<comment type="block">/* it seems to be a valid tinterval */</comment>
	<return>return;</return>

<label><name>bogus</name>:</label>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_DATETIME_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
					<argument><expr><literal type="string">"tinterval"</literal></expr></argument>, <argument><expr><name>i_string</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>i_start</name> <operator>=</operator> <operator>*</operator><name>i_end</name> <operator>=</operator> <name>INVALID_ABSTIME</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 *
 *****************************************************************************/</comment>

<comment type="block">/*
 * timeofday -
 *	   returns the current time as a text. similar to timenow() but returns
 *	   seconds with more precision (up to microsecs). (I need this to compare
 *	   the Wisconsin benchmark with Illustra whose TimeNow() shows current
 *	   time with precision up to microsecs.)			  - ay 3/95
 */</comment>
<function><type><name>Datum</name></type>
<name>timeofday</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>templ</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>tt</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tt</name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <name><name>tp</name><operator>.</operator><name>tv_sec</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_strftime</name><argument_list>(<argument><expr><name>templ</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>templ</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%a %b %d %H:%M:%S.%%06d %Y %Z"</literal></expr></argument>,
				<argument><expr><call><name>pg_localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tt</name></expr></argument>, <argument><expr><name>session_timezone</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>templ</name></expr></argument>, <argument><expr><name><name>tp</name><operator>.</operator><name>tv_usec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
