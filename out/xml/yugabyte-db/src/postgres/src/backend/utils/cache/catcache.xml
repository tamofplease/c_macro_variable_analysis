<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/utils/cache/catcache.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * catcache.c
 *	  System catalog cache for tuples matching a key.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/utils/cache/catcache.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tuptoaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/valid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/yb_scan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_yb_tablegroup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CATCACHE_STATS</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>		<comment type="block">/* for on_proc_exit */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hashutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resowner_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_yb_utils.h"</cpp:file></cpp:include>

 <comment type="block">/* #define CACHEDEBUG */</comment>	<comment type="block">/* turns DEBUG elogs on */</comment>

<comment type="block">/*
 * Given a hash value and the size of the hash table, find the bucket
 * in which the hash value belongs. Since the hash table must contain
 * a power-of-2 number of elements, this is a simple bitmask.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_INDEX</name><parameter_list>(<parameter><type><name>h</name></type></parameter>, <parameter><type><name>sz</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((Index) ((h) &amp; ((sz) - 1)))</cpp:value></cpp:define>


<comment type="block">/*
 *		variables, macros and other stuff
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CACHEDEBUG</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CACHE1_elog</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>				<cpp:value>elog(a,b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CACHE2_elog</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro>				<cpp:value>elog(a,b,c)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CACHE3_elog</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro>			<cpp:value>elog(a,b,c,d)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CACHE4_elog</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro>			<cpp:value>elog(a,b,c,d,e)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CACHE5_elog</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>elog(a,b,c,d,e,f)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CACHE6_elog</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>g</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>elog(a,b,c,d,e,f,g)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CACHE1_elog</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CACHE2_elog</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CACHE3_elog</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CACHE4_elog</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CACHE5_elog</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CACHE6_elog</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>g</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Cache management header --- pointer is NULL until created */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>CatCacheHeader</name> <modifier>*</modifier></type><name>CacheHdr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>NumCatalogCacheMisses</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>HeapTuple</name></type> <name>SearchCatCacheInternal</name><parameter_list>(<parameter><decl><type><name>CatCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>,
					   <parameter><decl><type><name>Datum</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>v2</name></decl></parameter>,
					   <parameter><decl><type><name>Datum</name></type> <name>v3</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>v4</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>pg_noinline</name> <name>HeapTuple</name></type> <name>SearchCatCacheMiss</name><parameter_list>(<parameter><decl><type><name>CatCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>,
				   <parameter><decl><type><name>uint32</name></type> <name>hashValue</name></decl></parameter>,
				   <parameter><decl><type><name>Index</name></type> <name>hashIndex</name></decl></parameter>,
				   <parameter><decl><type><name>Datum</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>v2</name></decl></parameter>,
				   <parameter><decl><type><name>Datum</name></type> <name>v3</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>v4</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>CatalogCacheComputeHashValue</name><parameter_list>(<parameter><decl><type><name>CatCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>,
							 <parameter><decl><type><name>Datum</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>v2</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>v3</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>v4</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>CatalogCacheComputeTupleHashValue</name><parameter_list>(<parameter><decl><type><name>CatCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>,
								  <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>CatalogCacheCompareTuple</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CatCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name>Datum</name> <modifier>*</modifier></type><name>cachekeys</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name>Datum</name> <modifier>*</modifier></type><name>searchkeys</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CATCACHE_STATS</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CatCachePrintStats</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CatCacheRemoveCTup</name><parameter_list>(<parameter><decl><type><name>CatCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>, <parameter><decl><type><name>CatCTup</name> <modifier>*</modifier></type><name>ct</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CatCacheRemoveCList</name><parameter_list>(<parameter><decl><type><name>CatCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>, <parameter><decl><type><name>CatCList</name> <modifier>*</modifier></type><name>cl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CatalogCacheInitializeCache</name><parameter_list>(<parameter><decl><type><name>CatCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CatCTup</name> <modifier>*</modifier></type><name>CatalogCacheCreateEntry</name><parameter_list>(<parameter><decl><type><name>CatCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>ntp</name></decl></parameter>,
						<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>arguments</name></decl></parameter>,
						<parameter><decl><type><name>uint32</name></type> <name>hashValue</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>hashIndex</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>negative</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CatCacheFreeKeys</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>attnos</name></decl></parameter>,
				 <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>keys</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CatCacheCopyKeys</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>attnos</name></decl></parameter>,
				 <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>srckeys</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>dstkeys</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 *					internal support functions
 */</comment>

<comment type="block">/*
 * Hash and equality functions for system types that are used as cache key
 * fields.  In some cases, we just call the regular SQL-callable functions for
 * the appropriate data type, but that tends to be a little slow, and the
 * speed of these functions is performance-critical.  Therefore, for data
 * types that frequently occur as catcache keys, we hard-code the logic here.
 * Avoiding the overhead of DirectFunctionCallN(...) is a substantial win, and
 * in certain cases (like int4) we can adopt a faster hash algorithm as well.
 */</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>chareqfast</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>DatumGetChar</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>DatumGetChar</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>charhashfast</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>murmurhash32</name><argument_list>(<argument><expr><operator>(</operator><name>int32</name><operator>)</operator> <call><name>DatumGetChar</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>nameeqfast</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ca</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><call><name>DatumGetName</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cb</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><call><name>DatumGetName</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>ca</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>namehashfast</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><call><name>DatumGetName</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>hash_any</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>key</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>int2eqfast</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>DatumGetInt16</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>DatumGetInt16</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>int2hashfast</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>murmurhash32</name><argument_list>(<argument><expr><operator>(</operator><name>int32</name><operator>)</operator> <call><name>DatumGetInt16</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>int4eqfast</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>int4hashfast</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>murmurhash32</name><argument_list>(<argument><expr><operator>(</operator><name>int32</name><operator>)</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>texteqfast</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>texteq</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>texthashfast</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>hashtext</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>oidvectoreqfast</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>oidvectoreq</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>oidvectorhashfast</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>hashoidvector</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Lookup support functions for a type. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>GetCCHashEqFuncs</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>keytype</name></decl></parameter>, <parameter><decl><type><name>CCHashFN</name> <modifier>*</modifier></type><name>hashfunc</name></decl></parameter>, <parameter><decl><type><name>RegProcedure</name> <modifier>*</modifier></type><name>eqfunc</name></decl></parameter>, <parameter><decl><type><name>CCFastEqualFN</name> <modifier>*</modifier></type><name>fasteqfunc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>keytype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>BOOLOID</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>hashfunc</name> <operator>=</operator> <name>charhashfast</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>fasteqfunc</name> <operator>=</operator> <name>chareqfast</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>eqfunc</name> <operator>=</operator> <name>F_BOOLEQ</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CHAROID</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>hashfunc</name> <operator>=</operator> <name>charhashfast</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>fasteqfunc</name> <operator>=</operator> <name>chareqfast</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>eqfunc</name> <operator>=</operator> <name>F_CHAREQ</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>NAMEOID</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>hashfunc</name> <operator>=</operator> <name>namehashfast</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>fasteqfunc</name> <operator>=</operator> <name>nameeqfast</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>eqfunc</name> <operator>=</operator> <name>F_NAMEEQ</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>INT2OID</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>hashfunc</name> <operator>=</operator> <name>int2hashfast</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>fasteqfunc</name> <operator>=</operator> <name>int2eqfast</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>eqfunc</name> <operator>=</operator> <name>F_INT2EQ</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>INT4OID</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>hashfunc</name> <operator>=</operator> <name>int4hashfast</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>fasteqfunc</name> <operator>=</operator> <name>int4eqfast</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>eqfunc</name> <operator>=</operator> <name>F_INT4EQ</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>TEXTOID</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>hashfunc</name> <operator>=</operator> <name>texthashfast</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>fasteqfunc</name> <operator>=</operator> <name>texteqfast</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>eqfunc</name> <operator>=</operator> <name>F_TEXTEQ</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OIDOID</name></expr>:</case>
		<case>case <expr><name>REGPROCOID</name></expr>:</case>
		<case>case <expr><name>REGPROCEDUREOID</name></expr>:</case>
		<case>case <expr><name>REGOPEROID</name></expr>:</case>
		<case>case <expr><name>REGOPERATOROID</name></expr>:</case>
		<case>case <expr><name>REGCLASSOID</name></expr>:</case>
		<case>case <expr><name>REGTYPEOID</name></expr>:</case>
		<case>case <expr><name>REGCONFIGOID</name></expr>:</case>
		<case>case <expr><name>REGDICTIONARYOID</name></expr>:</case>
		<case>case <expr><name>REGROLEOID</name></expr>:</case>
		<case>case <expr><name>REGNAMESPACEOID</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>hashfunc</name> <operator>=</operator> <name>int4hashfast</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>fasteqfunc</name> <operator>=</operator> <name>int4eqfast</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>eqfunc</name> <operator>=</operator> <name>F_OIDEQ</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OIDVECTOROID</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>hashfunc</name> <operator>=</operator> <name>oidvectorhashfast</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>fasteqfunc</name> <operator>=</operator> <name>oidvectoreqfast</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>eqfunc</name> <operator>=</operator> <name>F_OIDVECTOREQ</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"type %u not supported as catcache key"</literal></expr></argument>, <argument><expr><name>keytype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>hashfunc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>

			<expr_stmt><expr><operator>*</operator><name>eqfunc</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 *		CatalogCacheComputeHashValue
 *
 * Compute the hash value associated with a given set of lookup keys
 */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>CatalogCacheComputeHashValue</name><parameter_list>(<parameter><decl><type><name>CatCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>,
							 <parameter><decl><type><name>Datum</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>v2</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>v3</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>v4</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>hashValue</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>oneHash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CCHashFN</name>   <modifier>*</modifier></type><name>cc_hashfunc</name> <init>= <expr><name><name>cache</name><operator>-&gt;</operator><name>cc_hashfunc</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CACHE4_elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"CatalogCacheComputeHashValue %s %d %p"</literal></expr></argument>,
				<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_relname</name></name></expr></argument>,
				<argument><expr><name>nkeys</name></expr></argument>,
				<argument><expr><name>cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>nkeys</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">4</literal></expr>:</case>
			<expr_stmt><expr><name>oneHash</name> <operator>=</operator> <operator>(</operator><name><name>cc_hashfunc</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>)</operator> <operator>(</operator><name>v4</name><operator>)</operator></expr>;</expr_stmt>

			<expr_stmt><expr><name>hashValue</name> <operator>^=</operator> <name>oneHash</name> <operator>&lt;&lt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>hashValue</name> <operator>^=</operator> <name>oneHash</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<case>case <expr><literal type="number">3</literal></expr>:</case>
			<expr_stmt><expr><name>oneHash</name> <operator>=</operator> <operator>(</operator><name><name>cc_hashfunc</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator> <operator>(</operator><name>v3</name><operator>)</operator></expr>;</expr_stmt>

			<expr_stmt><expr><name>hashValue</name> <operator>^=</operator> <name>oneHash</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>hashValue</name> <operator>^=</operator> <name>oneHash</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<case>case <expr><literal type="number">2</literal></expr>:</case>
			<expr_stmt><expr><name>oneHash</name> <operator>=</operator> <operator>(</operator><name><name>cc_hashfunc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>(</operator><name>v2</name><operator>)</operator></expr>;</expr_stmt>

			<expr_stmt><expr><name>hashValue</name> <operator>^=</operator> <name>oneHash</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>hashValue</name> <operator>^=</operator> <name>oneHash</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<case>case <expr><literal type="number">1</literal></expr>:</case>
			<expr_stmt><expr><name>oneHash</name> <operator>=</operator> <operator>(</operator><name><name>cc_hashfunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>(</operator><name>v1</name><operator>)</operator></expr>;</expr_stmt>

			<expr_stmt><expr><name>hashValue</name> <operator>^=</operator> <name>oneHash</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"wrong number of hash keys: %d"</literal></expr></argument>, <argument><expr><name>nkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>hashValue</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		CatalogCacheComputeTupleHashValue
 *
 * Compute the hash value associated with a given tuple to be cached
 */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>CatalogCacheComputeTupleHashValue</name><parameter_list>(<parameter><decl><type><name>CatCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>v1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>v2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>v3</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>v4</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>cc_keyno</name> <init>= <expr><name><name>cache</name><operator>-&gt;</operator><name>cc_keyno</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>cc_tupdesc</name> <init>= <expr><name><name>cache</name><operator>-&gt;</operator><name>cc_tupdesc</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Now extract key fields from tuple, insert into scankey */</comment>
	<switch>switch <condition>(<expr><name>nkeys</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">4</literal></expr>:</case>
			<expr_stmt><expr><name>v4</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>cc_keyno</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <name>ObjectIdAttributeNumber</name><operator>)</operator></expr>
				?</condition><then> <expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>
				</then><else>: <expr><call><name>fastgetattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
							  <argument><expr><name><name>cc_keyno</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>,
							  <argument><expr><name>cc_tupdesc</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<case>case <expr><literal type="number">3</literal></expr>:</case>
			<expr_stmt><expr><name>v3</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>cc_keyno</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <name>ObjectIdAttributeNumber</name><operator>)</operator></expr>
				?</condition><then> <expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>
				</then><else>: <expr><call><name>fastgetattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
							  <argument><expr><name><name>cc_keyno</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
							  <argument><expr><name>cc_tupdesc</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<case>case <expr><literal type="number">2</literal></expr>:</case>
			<expr_stmt><expr><name>v2</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>cc_keyno</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>ObjectIdAttributeNumber</name><operator>)</operator></expr>
				?</condition><then> <expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>
				</then><else>: <expr><call><name>fastgetattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
							  <argument><expr><name><name>cc_keyno</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
							  <argument><expr><name>cc_tupdesc</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<case>case <expr><literal type="number">1</literal></expr>:</case>
			<expr_stmt><expr><name>v1</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>cc_keyno</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>ObjectIdAttributeNumber</name><operator>)</operator></expr>
				?</condition><then> <expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>
				</then><else>: <expr><call><name>fastgetattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
							  <argument><expr><name><name>cc_keyno</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
							  <argument><expr><name>cc_tupdesc</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"wrong number of hash keys: %d"</literal></expr></argument>, <argument><expr><name>nkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><call><name>CatalogCacheComputeHashValue</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>nkeys</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>v3</name></expr></argument>, <argument><expr><name>v4</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		CatalogCacheCompareTuple
 *
 * Compare a tuple to the passed arguments.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>CatalogCacheCompareTuple</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CatCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name>Datum</name> <modifier>*</modifier></type><name>cachekeys</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name>Datum</name> <modifier>*</modifier></type><name>searchkeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>CCFastEqualFN</name> <modifier>*</modifier></type><name>cc_fastequal</name> <init>= <expr><name><name>cache</name><operator>-&gt;</operator><name>cc_fastequal</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nkeys</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>cc_fastequal</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>(</operator><name><name>cachekeys</name><index>[<expr><name>i</name></expr>]</index></name><operator>,</operator> <name><name>searchkeys</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CATCACHE_STATS</name></cpp:ifdef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>CatCachePrintStats</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>slist_iter</name></type>	<name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>cc_searches</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>cc_hits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>cc_neg_hits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>cc_newloads</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>cc_invals</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>cc_lsearches</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>cc_lhits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<macro><name>slist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;CacheHdr-&gt;ch_caches</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CatCache</name>   <modifier>*</modifier></type><name>cache</name> <init>= <expr><call><name>slist_container</name><argument_list>(<argument><expr><name>CatCache</name></expr></argument>, <argument><expr><name>cc_next</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cache</name><operator>-&gt;</operator><name>cc_ntup</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>cache</name><operator>-&gt;</operator><name>cc_searches</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* don't print unused caches */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"catcache %s/%u: %d tup, %ld srch, %ld+%ld=%ld hits, %ld+%ld=%ld loads, %ld invals, %ld lsrch, %ld lhits"</literal></expr></argument>,
			 <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_relname</name></name></expr></argument>,
			 <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_indexoid</name></name></expr></argument>,
			 <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_ntup</name></name></expr></argument>,
			 <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_searches</name></name></expr></argument>,
			 <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_hits</name></name></expr></argument>,
			 <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_neg_hits</name></name></expr></argument>,
			 <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_hits</name></name> <operator>+</operator> <name><name>cache</name><operator>-&gt;</operator><name>cc_neg_hits</name></name></expr></argument>,
			 <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_newloads</name></name></expr></argument>,
			 <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_searches</name></name> <operator>-</operator> <name><name>cache</name><operator>-&gt;</operator><name>cc_hits</name></name> <operator>-</operator> <name><name>cache</name><operator>-&gt;</operator><name>cc_neg_hits</name></name> <operator>-</operator> <name><name>cache</name><operator>-&gt;</operator><name>cc_newloads</name></name></expr></argument>,
			 <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_searches</name></name> <operator>-</operator> <name><name>cache</name><operator>-&gt;</operator><name>cc_hits</name></name> <operator>-</operator> <name><name>cache</name><operator>-&gt;</operator><name>cc_neg_hits</name></name></expr></argument>,
			 <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_invals</name></name></expr></argument>,
			 <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_lsearches</name></name></expr></argument>,
			 <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_lhits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cc_searches</name> <operator>+=</operator> <name><name>cache</name><operator>-&gt;</operator><name>cc_searches</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cc_hits</name> <operator>+=</operator> <name><name>cache</name><operator>-&gt;</operator><name>cc_hits</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cc_neg_hits</name> <operator>+=</operator> <name><name>cache</name><operator>-&gt;</operator><name>cc_neg_hits</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cc_newloads</name> <operator>+=</operator> <name><name>cache</name><operator>-&gt;</operator><name>cc_newloads</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cc_invals</name> <operator>+=</operator> <name><name>cache</name><operator>-&gt;</operator><name>cc_invals</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cc_lsearches</name> <operator>+=</operator> <name><name>cache</name><operator>-&gt;</operator><name>cc_lsearches</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cc_lhits</name> <operator>+=</operator> <name><name>cache</name><operator>-&gt;</operator><name>cc_lhits</name></name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"catcache totals: %d tup, %ld srch, %ld+%ld=%ld hits, %ld+%ld=%ld loads, %ld invals, %ld lsrch, %ld lhits"</literal></expr></argument>,
		 <argument><expr><name><name>CacheHdr</name><operator>-&gt;</operator><name>ch_ntup</name></name></expr></argument>,
		 <argument><expr><name>cc_searches</name></expr></argument>,
		 <argument><expr><name>cc_hits</name></expr></argument>,
		 <argument><expr><name>cc_neg_hits</name></expr></argument>,
		 <argument><expr><name>cc_hits</name> <operator>+</operator> <name>cc_neg_hits</name></expr></argument>,
		 <argument><expr><name>cc_newloads</name></expr></argument>,
		 <argument><expr><name>cc_searches</name> <operator>-</operator> <name>cc_hits</name> <operator>-</operator> <name>cc_neg_hits</name> <operator>-</operator> <name>cc_newloads</name></expr></argument>,
		 <argument><expr><name>cc_searches</name> <operator>-</operator> <name>cc_hits</name> <operator>-</operator> <name>cc_neg_hits</name></expr></argument>,
		 <argument><expr><name>cc_invals</name></expr></argument>,
		 <argument><expr><name>cc_lsearches</name></expr></argument>,
		 <argument><expr><name>cc_lhits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* CATCACHE_STATS */</comment>


<comment type="block">/*
 *		CatCacheRemoveCTup
 *
 * Unlink and delete the given cache entry
 *
 * NB: if it is a member of a CatCList, the CatCList is deleted too.
 * Both the cache entry and the list had better have zero refcount.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CatCacheRemoveCTup</name><parameter_list>(<parameter><decl><type><name>CatCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>, <parameter><decl><type><name>CatCTup</name> <modifier>*</modifier></type><name>ct</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>refcount</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>my_cache</name></name> <operator>==</operator> <name>cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ct</name><operator>-&gt;</operator><name>c_list</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The cleanest way to handle this is to call CatCacheRemoveCList,
		 * which will recurse back to me, and the recursive call will do the
		 * work.  Set the "dead" flag to make sure it does recurse.
		 */</comment>
		<expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>dead</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CatCacheRemoveCList</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name><name>ct</name><operator>-&gt;</operator><name>c_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>					<comment type="block">/* nothing left to do */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* delink from linked list */</comment>
	<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ct</name><operator>-&gt;</operator><name>cache_elem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Free keys when we're dealing with a negative entry, normal entries just
	 * point into tuple, allocated together with the CatCTup.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ct</name><operator>-&gt;</operator><name>negative</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CatCacheFreeKeys</name><argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_tupdesc</name></name></expr></argument>, <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_nkeys</name></name></expr></argument>,
						 <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_keyno</name></name></expr></argument>, <argument><expr><name><name>ct</name><operator>-&gt;</operator><name>keys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>--</operator><name><name>cache</name><operator>-&gt;</operator><name>cc_ntup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>--</operator><name><name>CacheHdr</name><operator>-&gt;</operator><name>ch_ntup</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		CatCacheRemoveCList
 *
 * Unlink and delete the given cache list entry
 *
 * NB: any dead member entries that become unreferenced are deleted too.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CatCacheRemoveCList</name><parameter_list>(<parameter><decl><type><name>CatCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>, <parameter><decl><type><name>CatCList</name> <modifier>*</modifier></type><name>cl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cl</name><operator>-&gt;</operator><name>refcount</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cl</name><operator>-&gt;</operator><name>my_cache</name></name> <operator>==</operator> <name>cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* delink from member tuples */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>cl</name><operator>-&gt;</operator><name>n_members</name></name></expr>;</init> <condition><expr><operator>--</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CatCTup</name>    <modifier>*</modifier></type><name>ct</name> <init>= <expr><name><name>cl</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>c_list</name></name> <operator>==</operator> <name>cl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>c_list</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<comment type="block">/* if the member is dead and now has no references, remove it */</comment>
		<if_stmt><if>if <condition>(
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>CATCACHE_FORCE_RELEASE</name></cpp:ifndef>
			<expr><name><name>ct</name><operator>-&gt;</operator><name>dead</name></name> <operator>&amp;&amp;</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<name><name>ct</name><operator>-&gt;</operator><name>refcount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CatCacheRemoveCTup</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* delink from linked list */</comment>
	<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cl</name><operator>-&gt;</operator><name>cache_elem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* free associated column data */</comment>
	<expr_stmt><expr><call><name>CatCacheFreeKeys</name><argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_tupdesc</name></name></expr></argument>, <argument><expr><name><name>cl</name><operator>-&gt;</operator><name>nkeys</name></name></expr></argument>,
					 <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_keyno</name></name></expr></argument>, <argument><expr><name><name>cl</name><operator>-&gt;</operator><name>keys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *	CatCacheInvalidate
 *
 *	Invalidate entries in the specified cache, given a hash value.
 *
 *	We delete cache entries that match the hash value, whether positive
 *	or negative.  We don't care whether the invalidation is the result
 *	of a tuple insertion or a deletion.
 *
 *	We used to try to match positive cache entries by TID, but that is
 *	unsafe after a VACUUM FULL on a system catalog: an inval event could
 *	be queued before VACUUM FULL, and then processed afterwards, when the
 *	target tuple that has to be invalidated has a different TID than it
 *	did when the event was created.  So now we just compare hash values and
 *	accept the small risk of unnecessary invalidations due to false matches.
 *
 *	This routine is only quasi-public: it should only be used by inval.c.
 */</comment>
<function><type><name>void</name></type>
<name>CatCacheInvalidate</name><parameter_list>(<parameter><decl><type><name>CatCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashValue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Index</name></type>		<name>hashIndex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_mutable_iter</name></type> <name>iter</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CACHE1_elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"CatCacheInvalidate: called"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We don't bother to check whether the cache has finished initialization
	 * yet; if not, there will be no entries in it so no problem.
	 */</comment>

	<comment type="block">/*
	 * Invalidate *all* CatCLists in this cache; it's too hard to tell which
	 * searches might still be correct, so just zap 'em all.
	 */</comment>
	<macro><name>dlist_foreach_modify</name><argument_list>(<argument>iter</argument>, <argument>&amp;cache-&gt;cc_lists</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CatCList</name>   <modifier>*</modifier></type><name>cl</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>CatCList</name></expr></argument>, <argument><expr><name>cache_elem</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cl</name><operator>-&gt;</operator><name>refcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>cl</name><operator>-&gt;</operator><name>dead</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CatCacheRemoveCList</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>cl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * inspect the proper hash bucket for tuple matches
	 */</comment>
	<expr_stmt><expr><name>hashIndex</name> <operator>=</operator> <call><name>HASH_INDEX</name><argument_list>(<argument><expr><name>hashValue</name></expr></argument>, <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_nbuckets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>dlist_foreach_modify</name><argument_list>(<argument>iter</argument>, <argument>&amp;cache-&gt;cc_bucket[hashIndex]</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CatCTup</name>    <modifier>*</modifier></type><name>ct</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>CatCTup</name></expr></argument>, <argument><expr><name>cache_elem</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>hashValue</name> <operator>==</operator> <name><name>ct</name><operator>-&gt;</operator><name>hash_value</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>ct</name><operator>-&gt;</operator><name>refcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
				<operator>(</operator><name><name>ct</name><operator>-&gt;</operator><name>c_list</name></name> <operator>&amp;&amp;</operator> <name><name>ct</name><operator>-&gt;</operator><name>c_list</name><operator>-&gt;</operator><name>refcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>dead</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<comment type="block">/* list, if any, was marked dead above */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>c_list</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>ct</name><operator>-&gt;</operator><name>c_list</name><operator>-&gt;</operator><name>dead</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>CatCacheRemoveCTup</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>CACHE1_elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"CatCacheInvalidate: invalidated"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CATCACHE_STATS</name></cpp:ifdef>
			<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_invals</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<comment type="block">/* could be multiple matches, so keep looking! */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *					   public functions
 * ----------------------------------------------------------------
 */</comment>


<comment type="block">/*
 * Standard routine for creating cache context if it doesn't exist yet
 *
 * There are a lot of places (probably far more than necessary) that check
 * whether CacheMemoryContext exists yet and want to create it if not.
 * We centralize knowledge of exactly how to create it here.
 */</comment>
<function><type><name>void</name></type>
<name>CreateCacheMemoryContext</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Purely for paranoia, check that context doesn't exist; caller probably
	 * did so already.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>CacheMemoryContext</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>CacheMemoryContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
												   <argument><expr><literal type="string">"CacheMemoryContext"</literal></expr></argument>,
												   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		ResetCatalogCache
 *
 * Reset one catalog cache to empty.
 *
 * This is not very efficient if the target cache is nearly empty.
 * However, it shouldn't need to be efficient; we don't invoke it often.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ResetCatalogCache</name><parameter_list>(<parameter><decl><type><name>CatCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_mutable_iter</name></type> <name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Remove each list in this cache, or at least mark it dead */</comment>
	<macro><name>dlist_foreach_modify</name><argument_list>(<argument>iter</argument>, <argument>&amp;cache-&gt;cc_lists</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CatCList</name>   <modifier>*</modifier></type><name>cl</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>CatCList</name></expr></argument>, <argument><expr><name>cache_elem</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cl</name><operator>-&gt;</operator><name>refcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>cl</name><operator>-&gt;</operator><name>dead</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CatCacheRemoveCList</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>cl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Remove each tuple in this cache, or at least mark it dead */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cache</name><operator>-&gt;</operator><name>cc_nbuckets</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>dlist_head</name> <modifier>*</modifier></type><name>bucket</name> <init>= <expr><operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>cc_bucket</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<macro><name>dlist_foreach_modify</name><argument_list>(<argument>iter</argument>, <argument>bucket</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CatCTup</name>    <modifier>*</modifier></type><name>ct</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>CatCTup</name></expr></argument>, <argument><expr><name>cache_elem</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>ct</name><operator>-&gt;</operator><name>refcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
				<operator>(</operator><name><name>ct</name><operator>-&gt;</operator><name>c_list</name></name> <operator>&amp;&amp;</operator> <name><name>ct</name><operator>-&gt;</operator><name>c_list</name><operator>-&gt;</operator><name>refcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>dead</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<comment type="block">/* list, if any, was marked dead above */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>c_list</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>ct</name><operator>-&gt;</operator><name>c_list</name><operator>-&gt;</operator><name>dead</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>CatCacheRemoveCTup</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CATCACHE_STATS</name></cpp:ifdef>
			<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_invals</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 *		ResetCatalogCaches
 *
 * Reset all caches when a shared cache inval event forces it
 */</comment>
<function><type><name>void</name></type>
<name>ResetCatalogCaches</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>slist_iter</name></type>	<name>iter</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CACHE1_elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"ResetCatalogCaches called"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>slist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;CacheHdr-&gt;ch_caches</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CatCache</name>   <modifier>*</modifier></type><name>cache</name> <init>= <expr><call><name>slist_container</name><argument_list>(<argument><expr><name>CatCache</name></expr></argument>, <argument><expr><name>cc_next</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ResetCatalogCache</name><argument_list>(<argument><expr><name>cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>CACHE1_elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"end of ResetCatalogCaches call"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		CatalogCacheFlushCatalog
 *
 *	Flush all catcache entries that came from the specified system catalog.
 *	This is needed after VACUUM FULL/CLUSTER on the catalog, since the
 *	tuples very likely now have different TIDs than before.  (At one point
 *	we also tried to force re-execution of CatalogCacheInitializeCache for
 *	the cache(s) on that catalog.  This is a bad idea since it leads to all
 *	kinds of trouble if a cache flush occurs while loading cache entries.
 *	We now avoid the need to do it by copying cc_tupdesc out of the relcache,
 *	rather than relying on the relcache to keep a tupdesc for us.  Of course
 *	this assumes the tupdesc of a cachable system table will not change...)
 */</comment>
<function><type><name>void</name></type>
<name>CatalogCacheFlushCatalog</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>catId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>slist_iter</name></type>	<name>iter</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CACHE2_elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"CatalogCacheFlushCatalog called for %u"</literal></expr></argument>, <argument><expr><name>catId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>slist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;CacheHdr-&gt;ch_caches</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CatCache</name>   <modifier>*</modifier></type><name>cache</name> <init>= <expr><call><name>slist_container</name><argument_list>(<argument><expr><name>CatCache</name></expr></argument>, <argument><expr><name>cc_next</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Does this cache store tuples of the target catalog? */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cache</name><operator>-&gt;</operator><name>cc_reloid</name></name> <operator>==</operator> <name>catId</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Yes, so flush all its contents */</comment>
			<expr_stmt><expr><call><name>ResetCatalogCache</name><argument_list>(<argument><expr><name>cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Tell inval.c to call syscache callbacks for this cache */</comment>
			<expr_stmt><expr><call><name>CallSyscacheCallbacks</name><argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>CACHE1_elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"end of CatalogCacheFlushCatalog call"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		InitCatCache
 *
 *	This allocates and initializes a cache for a system catalog relation.
 *	Actually, the cache is only partially initialized to avoid opening the
 *	relation.  The relation will be opened and the rest of the cache
 *	structure initialized on the first access.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CACHEDEBUG</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>InitCatCache_DEBUG2</name></cpp:macro> \
<cpp:value>do { \
	elog(DEBUG2, "InitCatCache: rel=%u ind=%u id=%d nkeys=%d size=%d", \
		 cp-&gt;cc_reloid, cp-&gt;cc_indexoid, cp-&gt;id, \
		 cp-&gt;cc_nkeys, cp-&gt;cc_nbuckets); \
} while(0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>InitCatCache_DEBUG2</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>CatCache</name> <modifier>*</modifier></type>
<name>InitCatCache</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>,
			 <parameter><decl><type><name>Oid</name></type> <name>reloid</name></decl></parameter>,
			 <parameter><decl><type><name>Oid</name></type> <name>indexoid</name></decl></parameter>,
			 <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>,
			 <parameter><decl><type><specifier>const</specifier> <name>int</name> <modifier>*</modifier></type><name>key</name></decl></parameter>,
			 <parameter><decl><type><name>int</name></type> <name>nbuckets</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CatCache</name>   <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>sz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * nbuckets is the initial number of hash buckets to use in this catcache.
	 * It will be enlarged later if it becomes too full.
	 *
	 * nbuckets must be a power of two.  We check this via Assert rather than
	 * a full runtime check because the values will be coming from constant
	 * tables.
	 *
	 * If you're confused by the power-of-two check, see comments in
	 * bitmapset.c for an explanation.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nbuckets</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>nbuckets</name> <operator>&amp;</operator> <operator>-</operator><name>nbuckets</name><operator>)</operator> <operator>==</operator> <name>nbuckets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * first switch to the cache context so our allocations do not vanish at
	 * the end of a transaction
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>CacheMemoryContext</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CreateCacheMemoryContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * if first time through, initialize the cache group header
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>CacheHdr</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>CacheHdr</name> <operator>=</operator> <operator>(</operator><name>CatCacheHeader</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CatCacheHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>slist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>CacheHdr</name><operator>-&gt;</operator><name>ch_caches</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>CacheHdr</name><operator>-&gt;</operator><name>ch_ntup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CATCACHE_STATS</name></cpp:ifdef>
		<comment type="block">/* set up to dump stats at backend exit */</comment>
		<expr_stmt><expr><call><name>on_proc_exit</name><argument_list>(<argument><expr><name>CatCachePrintStats</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Allocate a new cache structure, aligning to a cacheline boundary
	 *
	 * Note: we rely on zeroing to initialize all the dlist headers correctly
	 */</comment>
	<expr_stmt><expr><name>sz</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CatCache</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>PG_CACHE_LINE_SIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cp</name> <operator>=</operator> <operator>(</operator><name>CatCache</name> <operator>*</operator><operator>)</operator> <call><name>CACHELINEALIGN</name><argument_list>(<argument><expr><call><name>palloc0</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>cc_bucket</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nbuckets</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>dlist_head</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * initialize the cache's relation information for the relation
	 * corresponding to this cache, and initialize some of the new cache's
	 * other internal fields.  But don't open the relation yet.
	 */</comment>
	<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>cc_relname</name></name> <operator>=</operator> <literal type="string">"(not known yet)"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>cc_reloid</name></name> <operator>=</operator> <name>reloid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>cc_indexoid</name></name> <operator>=</operator> <name>indexoid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>cc_relisshared</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* temporary */</comment>
	<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>cc_tupdesc</name></name> <operator>=</operator> <operator>(</operator><name>TupleDesc</name><operator>)</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>cc_ntup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>cc_nbuckets</name></name> <operator>=</operator> <name>nbuckets</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>cc_nkeys</name></name> <operator>=</operator> <name>nkeys</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nkeys</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>cc_keyno</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>key</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/*
	 * new cache is initialized as far as we can go for now. print some
	 * debugging information, if appropriate.
	 */</comment>
	<expr_stmt><expr><name>InitCatCache_DEBUG2</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * add completed cache to top of group header's list
	 */</comment>
	<expr_stmt><expr><call><name>slist_push_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>CacheHdr</name><operator>-&gt;</operator><name>ch_caches</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cp</name><operator>-&gt;</operator><name>cc_next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * back to the old context before we return...
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>cp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Enlarge a catcache, doubling the number of buckets.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RehashCatCache</name><parameter_list>(<parameter><decl><type><name>CatCache</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_head</name> <modifier>*</modifier></type><name>newbucket</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>newnbuckets</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"rehashing catalog cache id %d for %s; %d tups, %d buckets"</literal></expr></argument>,
		 <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cc_relname</name></name></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cc_ntup</name></name></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cc_nbuckets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allocate a new, larger, hash table. */</comment>
	<expr_stmt><expr><name>newnbuckets</name> <operator>=</operator> <name><name>cp</name><operator>-&gt;</operator><name>cc_nbuckets</name></name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>newbucket</name> <operator>=</operator> <operator>(</operator><name>dlist_head</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>, <argument><expr><name>newnbuckets</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>dlist_head</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Move all entries from old hash table to new. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cp</name><operator>-&gt;</operator><name>cc_nbuckets</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>dlist_mutable_iter</name></type> <name>iter</name></decl>;</decl_stmt>

		<macro><name>dlist_foreach_modify</name><argument_list>(<argument>iter</argument>, <argument>&amp;cp-&gt;cc_bucket[i]</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CatCTup</name>    <modifier>*</modifier></type><name>ct</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>CatCTup</name></expr></argument>, <argument><expr><name>cache_elem</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>hashIndex</name> <init>= <expr><call><name>HASH_INDEX</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>hash_value</name></name></expr></argument>, <argument><expr><name>newnbuckets</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>dlist_push_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>newbucket</name><index>[<expr><name>hashIndex</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ct</name><operator>-&gt;</operator><name>cache_elem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></for>

	<comment type="block">/* Switch to the new array. */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cc_bucket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>cc_nbuckets</name></name> <operator>=</operator> <name>newnbuckets</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>cc_bucket</name></name> <operator>=</operator> <name>newbucket</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		CatalogCacheInitializeCache
 *
 * This function does final initialization of a catcache: obtain the tuple
 * descriptor and set up the hash and equality function links.  We assume
 * that the relcache entry can be opened at this point!
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CACHEDEBUG</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CatalogCacheInitializeCache_DEBUG1</name></cpp:macro> \
	<cpp:value>elog(DEBUG2, "CatalogCacheInitializeCache: cache @%p rel=%u", cache, \
		 cache-&gt;cc_reloid)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CatalogCacheInitializeCache_DEBUG2</name></cpp:macro> \
<cpp:value>do { \
		if (cache-&gt;cc_keyno[i] &gt; 0) { \
			elog(DEBUG2, "CatalogCacheInitializeCache: load %d/%d w/%d, %u", \
				i+1, cache-&gt;cc_nkeys, cache-&gt;cc_keyno[i], \
				 TupleDescAttr(tupdesc, cache-&gt;cc_keyno[i] - 1)-&gt;atttypid); \
		} else { \
			elog(DEBUG2, "CatalogCacheInitializeCache: load %d/%d w/%d", \
				i+1, cache-&gt;cc_nkeys, cache-&gt;cc_keyno[i]); \
		} \
} while(0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CatalogCacheInitializeCache_DEBUG1</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CatalogCacheInitializeCache_DEBUG2</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>CatalogCacheInitializeCache</name><parameter_list>(<parameter><decl><type><name>CatCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>CatalogCacheInitializeCache_DEBUG1</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Skip for YbTablegroupRelationId if not in snapshot
	 * (possible if using an older non-upgraded cluster state)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cache</name><operator>-&gt;</operator><name>cc_reloid</name></name> <operator>==</operator> <name>YbTablegroupRelationId</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>YbTablegroupCatalogExists</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* double check that the Tablegroup catalog doesn't exist */</comment>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>YbTablegroupRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>YbTablegroupCatalogExists</name> <operator>=</operator> <call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>YbTablegroupCatalogExists</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_reloid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * switch to the cache context so our allocations do not vanish at the end
	 * of a transaction
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CacheMemoryContext</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * copy the relcache's tuple descriptor to permanent cache storage
	 */</comment>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTupleDescCopyConstr</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * save the relation's name and relisshared flag, too (cc_relname is used
	 * only for debugging purposes)
	 */</comment>
	<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_relname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_relisshared</name></name> <operator>=</operator> <call><name>RelationGetForm</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>relisshared</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * return to the caller's memory context and close the rel
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CACHE3_elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"CatalogCacheInitializeCache: %s, %d keys"</literal></expr></argument>,
				<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_relname</name></name></expr></argument>, <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_nkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * initialize cache's key information
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cache</name><operator>-&gt;</operator><name>cc_nkeys</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>keytype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RegProcedure</name></type> <name>eqfunc</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>CatalogCacheInitializeCache_DEBUG2</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cache</name><operator>-&gt;</operator><name>cc_keyno</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>,
												   <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_keyno</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>keytype</name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
			<comment type="block">/* cache key columns should always be NOT NULL */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attnotnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>cache</name><operator>-&gt;</operator><name>cc_keyno</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>ObjectIdAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"only sys attr supported in caches is OID"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>keytype</name> <operator>=</operator> <name>OIDOID</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>GetCCHashEqFuncs</name><argument_list>(<argument><expr><name>keytype</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>cc_hashfunc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>eqfunc</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>cc_fastequal</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Do equality-function lookup (we assume this won't need a catalog
		 * lookup for any supported type)
		 */</comment>
		<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name>eqfunc</name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>cc_skey</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_func</name></expr></argument>,
					  <argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Initialize sk_attno suitably for HeapKeyTest() and heap scans */</comment>
		<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_skey</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_attno</name> <operator>=</operator> <name><name>cache</name><operator>-&gt;</operator><name>cc_keyno</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/* Fill in sk_strategy as well --- always standard equality */</comment>
		<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_skey</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_strategy</name> <operator>=</operator> <name>BTEqualStrategyNumber</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_skey</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_subtype</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<comment type="block">/* Currently, there are no catcaches on collation-aware data types */</comment>
		<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_skey</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_collation</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CACHE4_elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"CatalogCacheInitializeCache %s %d %p"</literal></expr></argument>,
					<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_relname</name></name></expr></argument>,
					<argument><expr><name>i</name></expr></argument>,
					<argument><expr><name>cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * mark this cache fully initialized
	 */</comment>
	<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_tupdesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * YugaByte utility method to set the data for a cache list entry.
 * Used during InitCatCachePhase2 (specifically for the procedure name list
 * and for rewrite rules).
 * Code basically takes the second part of SearchCatCacheList (which sets the
 * data if no entry is found).
 */</comment>
<function><type><name>void</name></type>
<name>SetCatCacheList</name><parameter_list>(<parameter><decl><type><name>CatCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>,
                <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>,
                <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>current_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>cur_skey</name><index>[<expr><name>CATCACHE_MAXKEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>arguments</name><index>[<expr><name>CATCACHE_MAXKEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>lHashValue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_iter</name></type>  <name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatCList</name>    <modifier>*</modifier></type><name>cl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatCTup</name>     <modifier>*</modifier></type><name>ct</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier><specifier>volatile</specifier></type> <name>ctlist</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>      <modifier>*</modifier></type><name>ctlist_item</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>           <name>nmembers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>     <name>ntp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>           <name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * one-time startup overhead for each cache
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cache</name><operator>-&gt;</operator><name>cc_tupdesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CatalogCacheInitializeCache</name><argument_list>(<argument><expr><name>cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nkeys</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nkeys</name> <operator>&lt;</operator> <name><name>cache</name><operator>-&gt;</operator><name>cc_nkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>cur_skey</name></expr></argument>, <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_skey</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cur_skey</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tup</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>current_list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nkeys</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>cur_skey</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_attno</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>is_null</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Not needed as this is checked before */</comment>
		<expr_stmt><expr><name><name>cur_skey</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_argument</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tup</name></expr></argument>,
		                                       <argument><expr><name><name>cur_skey</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_attno</name></expr></argument>,
		                                       <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_tupdesc</name></name></expr></argument>,
		                                       <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name>lHashValue</name> <operator>=</operator> <call><name>CatalogCacheComputeHashValue</name><argument_list>(<argument><expr><name>cache</name></expr></argument>,
											  <argument><expr><name>nkeys</name></expr></argument>,
											  <argument><expr><name><name>cur_skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name></expr></argument>,
											  <argument><expr><name><name>cur_skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name></expr></argument>,
											  <argument><expr><name><name>cur_skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name></expr></argument>,
											  <argument><expr><name><name>cur_skey</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CATCACHE_STATS</name></cpp:ifdef>
	<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_lsearches</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


	<comment type="block">/* Initialize local parameter array */</comment>
	<expr_stmt><expr><name><name>arguments</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>cur_skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>arguments</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>cur_skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>arguments</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>cur_skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>arguments</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>cur_skey</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * List was not found in cache, so we have to build it by reading the
	 * relation.  For each matching tuple found in the relation, use an
	 * existing cache entry if possible, else build a new one.
	 *
	 * We have to bump the member refcounts temporarily to ensure they won't
	 * get dropped from the cache while loading other members. We use a PG_TRY
	 * block to ensure we can undo those refcounts if we get an error before
	 * we finish constructing the CatCList.
	 */</comment>
	<expr_stmt><expr><call><name>ResourceOwnerEnlargeCatCacheListRefs</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ctlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_reloid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>current_list</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint32</name></type>     <name>hashValue</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Index</name></type>      <name>hashIndex</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>       <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>dlist_head</name> <modifier>*</modifier></type><name>bucket</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>ntp</name> <operator>=</operator> <operator>(</operator><name>HeapTuple</name><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * See if there's an entry for this tuple already.
			 */</comment>
			<expr_stmt><expr><name>ct</name>        <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>hashValue</name> <operator>=</operator> <call><name>CatalogCacheComputeTupleHashValue</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_nkeys</name></name></expr></argument>, <argument><expr><name>ntp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>hashIndex</name> <operator>=</operator> <call><name>HASH_INDEX</name><argument_list>(<argument><expr><name>hashValue</name></expr></argument>, <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_nbuckets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>bucket</name> <operator>=</operator> <operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>cc_bucket</name><index>[<expr><name>hashIndex</name></expr>]</index></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
			<comment type="block">/* Cannot rely on ctid comparison in YB mode */</comment>
			<block>{<block_content>
				<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>bucket</argument>)</argument_list></macro>
				<block>{<block_content>
					<expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>CatCTup</name></expr></argument>, <argument><expr><name>cache_elem</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>ct</name><operator>-&gt;</operator><name>dead</name></name> <operator>||</operator> <name><name>ct</name><operator>-&gt;</operator><name>negative</name></name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>    <comment type="block">/* ignore dead and negative entries */</comment>

					<if_stmt><if>if <condition>(<expr><name><name>ct</name><operator>-&gt;</operator><name>hash_value</name></name> <operator>!=</operator> <name>hashValue</name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>    <comment type="block">/* quickly skip entry if wrong hash val */</comment>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ItemPointerEquals</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>ct</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>,
										   <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>ntp</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>    <comment type="block">/* not same tuple */</comment>

					<comment type="block">/*
					 * Found a match, but can't use it if it belongs to another
					 * list already
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>ct</name><operator>-&gt;</operator><name>c_list</name></name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>            <comment type="block">/* A-OK */</comment>
				</block_content>}</block>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* We didn't find a usable entry, so make a new one */</comment>
				<expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>CatalogCacheCreateEntry</name><argument_list>(<argument><expr><name>cache</name></expr></argument>,
											 <argument><expr><name>ntp</name></expr></argument>,
											 <argument><expr><name>arguments</name></expr></argument>,
											 <argument><expr><name>hashValue</name></expr></argument>,
											 <argument><expr><name>hashIndex</name></expr></argument>,
											 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Careful here: add entry to ctlist, then bump its refcount */</comment>
			<comment type="block">/* This way leaves state correct if lappend runs out of memory */</comment>
			<expr_stmt><expr><name>ctlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>ctlist</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>refcount</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now we can build the CatCList entry.  First we need a dummy tuple
		 * containing the key values...
		 */</comment>
		<expr_stmt><expr><name>oldcxt</name>   <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nmembers</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>ctlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cl</name>       <operator>=</operator> <operator>(</operator><name>CatCList</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>CatCList</name></expr></argument>, <argument><expr><name>members</name></expr></argument>)</argument_list></call> <operator>+</operator>
									   <name>nmembers</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CatCTup</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Extract key values */</comment>
		<expr_stmt><expr><call><name>CatCacheCopyKeys</name><argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_tupdesc</name></name></expr></argument>, <argument><expr><name>nkeys</name></expr></argument>, <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_keyno</name></name></expr></argument>,
						 <argument><expr><name>arguments</name></expr></argument>, <argument><expr><name><name>cl</name><operator>-&gt;</operator><name>keys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We are now past the last thing that could trigger an elog before we
		 * have finished building the CatCList and remembering it in the
		 * resource owner.  So it's OK to fall out of the PG_TRY, and indeed
		 * we'd better do so before we start marking the members as belonging
		 * to the list.
		 */</comment>

	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>ctlist_item</argument>, <argument>ctlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>ct</name> <operator>=</operator> <operator>(</operator><name>CatCTup</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ctlist_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>c_list</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>refcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>refcount</name></name><operator>--</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>CATCACHE_FORCE_RELEASE</name></cpp:ifndef>
					<expr><name><name>ct</name><operator>-&gt;</operator><name>dead</name></name> <operator>&amp;&amp;</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<name><name>ct</name><operator>-&gt;</operator><name>refcount</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
					<operator>(</operator><name><name>ct</name><operator>-&gt;</operator><name>c_list</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>ct</name><operator>-&gt;</operator><name>c_list</name><operator>-&gt;</operator><name>refcount</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>CatCacheRemoveCTup</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>cl</name><operator>-&gt;</operator><name>cl_magic</name></name>   <operator>=</operator> <name>CL_MAGIC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cl</name><operator>-&gt;</operator><name>my_cache</name></name>   <operator>=</operator> <name>cache</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cl</name><operator>-&gt;</operator><name>refcount</name></name>   <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>            <comment type="block">/* for the moment */</comment>
	<expr_stmt><expr><name><name>cl</name><operator>-&gt;</operator><name>dead</name></name>       <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cl</name><operator>-&gt;</operator><name>ordered</name></name>    <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cl</name><operator>-&gt;</operator><name>nkeys</name></name>      <operator>=</operator> <name>nkeys</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cl</name><operator>-&gt;</operator><name>hash_value</name></name> <operator>=</operator> <name>lHashValue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cl</name><operator>-&gt;</operator><name>n_members</name></name>  <operator>=</operator> <name>nmembers</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>ctlist_item</argument>, <argument>ctlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name><name>cl</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>ct</name> <operator>=</operator> <operator>(</operator><name>CatCTup</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ctlist_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>c_list</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>c_list</name></name> <operator>=</operator> <name>cl</name></expr>;</expr_stmt>
		<comment type="block">/* release the temporary refcount on the member */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>refcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>refcount</name></name><operator>--</operator></expr>;</expr_stmt>
		<comment type="block">/* mark list dead if any members already dead */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ct</name><operator>-&gt;</operator><name>dead</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>cl</name><operator>-&gt;</operator><name>dead</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <name>nmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>dlist_push_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>cc_lists</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cl</name><operator>-&gt;</operator><name>cache_elem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * InitCatCachePhase2 -- external interface for CatalogCacheInitializeCache
 *
 * One reason to call this routine is to ensure that the relcache has
 * created entries for all the catalogs and indexes referenced by catcaches.
 * Therefore, provide an option to open the index as well as fixing the
 * cache itself.  An exception is the indexes on pg_am, which we don't use
 * (cf. IndexScanOK).
 */</comment>
<function><type><name>void</name></type>
<name>InitCatCachePhase2</name><parameter_list>(<parameter><decl><type><name>CatCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>touch_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>cache</name><operator>-&gt;</operator><name>cc_tupdesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CatalogCacheInitializeCache</name><argument_list>(<argument><expr><name>cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * TODO(mihnea/robert) This could be enabled if we handle
	 * "primary key as index" so that PG can open the primary indexes by id.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>touch_index</name> <operator>&amp;&amp;</operator>
		<name><name>cache</name><operator>-&gt;</operator><name>id</name></name> <operator>!=</operator> <name>AMOID</name> <operator>&amp;&amp;</operator>
		<name><name>cache</name><operator>-&gt;</operator><name>id</name></name> <operator>!=</operator> <name>AMNAME</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>idesc</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We must lock the underlying catalog before opening the index to
		 * avoid deadlock, since index_open could possibly result in reading
		 * this same catalog, and if anyone else is exclusive-locking this
		 * catalog and index they'll be doing it in that order.
		 */</comment>
		<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_reloid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>idesc</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_indexoid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * While we've got the index open, let's check that it's unique (and
		 * not just deferrable-unique, thank you very much).  This is just to
		 * catch thinkos in definitions of new catcaches, so we don't worry
		 * about the pg_am indexes not getting tested.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>idesc</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisunique</name></name> <operator>&amp;&amp;</operator>
			   <name><name>idesc</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indimmediate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>idesc</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_reloid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		IndexScanOK
 *
 *		This function checks for tuples that will be fetched by
 *		IndexSupportInitialize() during relcache initialization for
 *		certain system indexes that support critical syscaches.
 *		We can't use an indexscan to fetch these, else we'll get into
 *		infinite recursion.  A plain heap scan will work, however.
 *		Once we have completed relcache initialization (signaled by
 *		criticalRelcachesBuilt), we don't have to worry anymore.
 *
 *		Similarly, during backend startup we have to be able to use the
 *		pg_authid and pg_auth_members syscaches for authentication even if
 *		we don't yet have relcache entries for those catalogs' indexes.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IndexScanOK</name><parameter_list>(<parameter><decl><type><name>CatCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>cur_skey</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>cache</name><operator>-&gt;</operator><name>id</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INDEXRELID</name></expr>:</case>

			<comment type="block">/*
			 * Rather than tracking exactly which indexes have to be loaded
			 * before we can use indexscans (which changes from time to time),
			 * just force all pg_index searches to be heap scans until we've
			 * built the critical relcaches.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>criticalRelcachesBuilt</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>AMOID</name></expr>:</case>
		<case>case <expr><name>AMNAME</name></expr>:</case>

			<comment type="block">/*
			 * Always do heap scans in pg_am, because it's so small there's
			 * not much point in an indexscan anyway.  We *must* do this when
			 * initially building critical relcache entries, but we might as
			 * well just always do it.
			 */</comment>
			<return>return <expr><name>false</name></expr>;</return>

		<case>case <expr><name>AUTHNAME</name></expr>:</case>
		<case>case <expr><name>AUTHOID</name></expr>:</case>
		<case>case <expr><name>AUTHMEMMEMROLE</name></expr>:</case>

			<comment type="block">/*
			 * Protect authentication lookups occurring before relcache has
			 * collected entries for shared indexes.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>criticalSharedRelcachesBuilt</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Normal case, allow index scan */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Utility to add a Tuple entry to the cache only if it's negative or does not exist.
 * Used only when IsYugaByteEnabled() is true.
 * Currently used in two cases:
 *  1. When initializing the caches (i.e. on backend start).
 *  2. When inserting a new entry to the sys catalog (i.e. on DDL create).
 */</comment>
<function><type><name>void</name></type>
<name>SetCatCacheTuple</name><parameter_list>(<parameter><decl><type><name>CatCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><name>CATCACHE_MAXKEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>arguments</name><index>[<expr><name>CATCACHE_MAXKEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>hashValue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>       <name>hashIndex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_iter</name></type>  <name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_head</name>  <modifier>*</modifier></type><name>bucket</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatCTup</name>     <modifier>*</modifier></type><name>ct</name></decl>;</decl_stmt>

	<comment type="block">/* Make sure we're in an xact, even if this ends up being a cache hit */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize cache if needed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cache</name><operator>-&gt;</operator><name>cc_tupdesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CatalogCacheInitializeCache</name><argument_list>(<argument><expr><name>cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * initialize the search key information
	 */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_skey</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>CATCACHE_MAXKEYS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>key</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_attno</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>key</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_argument</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>is_null</name></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>key</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_argument</name>     <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tup</name></expr></argument>,
		                                      <argument><expr><name><name>key</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_attno</name></expr></argument>,
		                                      <argument><expr><name>desc</name></expr></argument>,
		                                      <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>key</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_argument</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * find the hash bucket in which to look for the tuple
	 */</comment>
	<expr_stmt><expr><name>hashValue</name> <operator>=</operator> <call><name>CatalogCacheComputeHashValue</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_nkeys</name></name></expr></argument>,
											 <argument><expr><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name></expr></argument>,
											 <argument><expr><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name></expr></argument>,
											 <argument><expr><name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name></expr></argument>,
											 <argument><expr><name><name>key</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hashIndex</name> <operator>=</operator> <call><name>HASH_INDEX</name><argument_list>(<argument><expr><name>hashValue</name></expr></argument>, <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_nbuckets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize local parameter array */</comment>
	<expr_stmt><expr><name><name>arguments</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>arguments</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>arguments</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>arguments</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>key</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * scan the hash bucket until we find a match or exhaust our tuples
	 *
	 * Note: it's okay to use dlist_foreach here, even though we modify the
	 * dlist within the loop, because we don't continue the loop afterwards.
	 */</comment>
	<expr_stmt><expr><name>bucket</name> <operator>=</operator> <operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>cc_bucket</name><index>[<expr><name>hashIndex</name></expr>]</index></name></expr>;</expr_stmt>
	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>bucket</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>CatCTup</name></expr></argument>, <argument><expr><name>cache_elem</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ct</name><operator>-&gt;</operator><name>dead</name></name> <operator>||</operator> <name><name>ct</name><operator>-&gt;</operator><name>negative</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>            <comment type="block">/* ignore dead and negative entries */</comment>

		<if_stmt><if>if <condition>(<expr><name><name>ct</name><operator>-&gt;</operator><name>hash_value</name></name> <operator>!=</operator> <name>hashValue</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>            <comment type="block">/* quickly skip entry if wrong hash val */</comment>

		<comment type="block">/*
		 * see if the cached tuple matches our key.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CatalogCacheCompareTuple</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_nkeys</name></name></expr></argument>, <argument><expr><name><name>ct</name><operator>-&gt;</operator><name>keys</name></name></expr></argument>, <argument><expr><name>arguments</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We found a match in the cache -- nothing to do.
		 */</comment>
		<return>return;</return>
	</block_content>}</block>

	<comment type="block">/*
	 * Tuple was not found in cache, so we should add it.
	 */</comment>
	<expr_stmt><expr><call><name>CatalogCacheCreateEntry</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>arguments</name></expr></argument>, <argument><expr><name>hashValue</name></expr></argument>, <argument><expr><name>hashIndex</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	SearchCatCacheInternal
 *
 *		This call searches a system cache for a tuple, opening the relation
 *		if necessary (on the first access to a particular cache).
 *
 *		The result is NULL if not found, or a pointer to a HeapTuple in
 *		the cache.  The caller must not modify the tuple, and must call
 *		ReleaseCatCache() when done with it.
 *
 * The search key values should be expressed as Datums of the key columns'
 * datatype(s).  (Pass zeroes for any unused parameters.)  As a special
 * exception, the passed-in key for a NAME column can be just a C string;
 * the caller need not go to the trouble of converting it to a fully
 * null-padded NAME.
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>SearchCatCache</name><parameter_list>(<parameter><decl><type><name>CatCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>,
			   <parameter><decl><type><name>Datum</name></type> <name>v1</name></decl></parameter>,
			   <parameter><decl><type><name>Datum</name></type> <name>v2</name></decl></parameter>,
			   <parameter><decl><type><name>Datum</name></type> <name>v3</name></decl></parameter>,
			   <parameter><decl><type><name>Datum</name></type> <name>v4</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>SearchCatCacheInternal</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_nkeys</name></name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>v3</name></expr></argument>, <argument><expr><name>v4</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SearchCatCacheN() are SearchCatCache() versions for a specific number of
 * arguments. The compiler can inline the body and unroll loops, making them a
 * bit faster than SearchCatCache().
 */</comment>

<function><type><name>HeapTuple</name></type>
<name>SearchCatCache1</name><parameter_list>(<parameter><decl><type><name>CatCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>,
				<parameter><decl><type><name>Datum</name></type> <name>v1</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>SearchCatCacheInternal</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>HeapTuple</name></type>
<name>SearchCatCache2</name><parameter_list>(<parameter><decl><type><name>CatCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>,
				<parameter><decl><type><name>Datum</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>v2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>SearchCatCacheInternal</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>HeapTuple</name></type>
<name>SearchCatCache3</name><parameter_list>(<parameter><decl><type><name>CatCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>,
				<parameter><decl><type><name>Datum</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>v2</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>v3</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>SearchCatCacheInternal</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>v3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>HeapTuple</name></type>
<name>SearchCatCache4</name><parameter_list>(<parameter><decl><type><name>CatCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>,
				<parameter><decl><type><name>Datum</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>v2</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>v3</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>v4</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>SearchCatCacheInternal</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>v3</name></expr></argument>, <argument><expr><name>v4</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Work-horse for SearchCatCache/SearchCatCacheN.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>HeapTuple</name></type>
<name>SearchCatCacheInternal</name><parameter_list>(<parameter><decl><type><name>CatCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>,
					   <parameter><decl><type><name>Datum</name></type> <name>v1</name></decl></parameter>,
					   <parameter><decl><type><name>Datum</name></type> <name>v2</name></decl></parameter>,
					   <parameter><decl><type><name>Datum</name></type> <name>v3</name></decl></parameter>,
					   <parameter><decl><type><name>Datum</name></type> <name>v4</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>arguments</name><index>[<expr><name>CATCACHE_MAXKEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>hashValue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>hashIndex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_iter</name></type>	<name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_head</name> <modifier>*</modifier></type><name>bucket</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatCTup</name>    <modifier>*</modifier></type><name>ct</name></decl>;</decl_stmt>

	<comment type="block">/* Make sure we're in an xact, even if this ends up being a cache hit */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_nkeys</name></name> <operator>==</operator> <name>nkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * one-time startup overhead for each cache
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_tupdesc</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CatalogCacheInitializeCache</name><argument_list>(<argument><expr><name>cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CATCACHE_STATS</name></cpp:ifdef>
	<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_searches</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Initialize local parameter array */</comment>
	<expr_stmt><expr><name><name>arguments</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>v1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>arguments</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>v2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>arguments</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>v3</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>arguments</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>v4</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * find the hash bucket in which to look for the tuple
	 */</comment>
	<expr_stmt><expr><name>hashValue</name> <operator>=</operator> <call><name>CatalogCacheComputeHashValue</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>nkeys</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>v3</name></expr></argument>, <argument><expr><name>v4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hashIndex</name> <operator>=</operator> <call><name>HASH_INDEX</name><argument_list>(<argument><expr><name>hashValue</name></expr></argument>, <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_nbuckets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * scan the hash bucket until we find a match or exhaust our tuples
	 *
	 * Note: it's okay to use dlist_foreach here, even though we modify the
	 * dlist within the loop, because we don't continue the loop afterwards.
	 */</comment>
	<expr_stmt><expr><name>bucket</name> <operator>=</operator> <operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>cc_bucket</name><index>[<expr><name>hashIndex</name></expr>]</index></name></expr>;</expr_stmt>
	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>bucket</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>CatCTup</name></expr></argument>, <argument><expr><name>cache_elem</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ct</name><operator>-&gt;</operator><name>dead</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* ignore dead entries */</comment>

		<if_stmt><if>if <condition>(<expr><name><name>ct</name><operator>-&gt;</operator><name>hash_value</name></name> <operator>!=</operator> <name>hashValue</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* quickly skip entry if wrong hash val */</comment>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CatalogCacheCompareTuple</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>nkeys</name></expr></argument>, <argument><expr><name><name>ct</name><operator>-&gt;</operator><name>keys</name></name></expr></argument>, <argument><expr><name>arguments</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We found a match in the cache.  Move it to the front of the list
		 * for its hashbucket, in order to speed subsequent searches.  (The
		 * most frequently accessed elements in any hashbucket will tend to be
		 * near the front of the hashbucket's list.)
		 */</comment>
		<expr_stmt><expr><call><name>dlist_move_head</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ct</name><operator>-&gt;</operator><name>cache_elem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If it's a positive entry, bump its refcount and return it. If it's
		 * negative, we can report failure to the caller.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ct</name><operator>-&gt;</operator><name>negative</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ResourceOwnerEnlargeCatCacheRefs</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>refcount</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ResourceOwnerRememberCatCacheRef</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ct</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>CACHE3_elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"SearchCatCache(%s): found in bucket %d"</literal></expr></argument>,
						<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_relname</name></name></expr></argument>, <argument><expr><name>hashIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CATCACHE_STATS</name></cpp:ifdef>
			<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_hits</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<return>return <expr><operator>&amp;</operator><name><name>ct</name><operator>-&gt;</operator><name>tuple</name></name></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>CACHE3_elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"SearchCatCache(%s): found neg entry in bucket %d"</literal></expr></argument>,
						<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_relname</name></name></expr></argument>, <argument><expr><name>hashIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CATCACHE_STATS</name></cpp:ifdef>
			<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_neg_hits</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<return>return <expr><call><name>SearchCatCacheMiss</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>nkeys</name></expr></argument>, <argument><expr><name>hashValue</name></expr></argument>, <argument><expr><name>hashIndex</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>v3</name></expr></argument>, <argument><expr><name>v4</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
* Function returns true in some special cases where we allow negative caches:
* 1. pg_cast (CASTSOURCETARGET) to avoid master lookups during parsing.
*    TODO: reconsider this now that we support CREATE CAST.
* 2. pg_statistic (STATRELATTINH) and pg_statistic_ext
*    (STATEXTNAMENSP and STATEXTOID) since we do not support
*    statistics in DocDB/YSQL yet.
* 3. pg_class (RELNAMENSP), pg_type (TYPENAMENSP)
*    but only for system tables since users cannot create system tables in YSQL.
*    This is violated in YSQL upgrade, but doing so will force cache refresh.
* 4. Caches within temporary namespaces as data in this namespaces can be
*    changed by current session only.
* 5. pg_attribute as `ALTER TABLE` is used to add new columns and it increments
*    catalog version.
* 6. pg_type (TYPEOID and TYPENAMENSP) to avoid redundant master lookups while
*    parsing functions that are checked to be possible type coercions.
* 7. pg_namespace (NAMESPACEOID and NAMESPACENAME) to avoid lookups while
*    recomputeNamespacePath. The CREATE SCHEMA stmt increments catalog version.
*/</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>YbAllowNegativeCacheEntries</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>cache_id</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>namespace_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch<condition>(<expr><name>cache_id</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CASTSOURCETARGET</name></expr>:</case> <expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<case>case <expr><name>STATRELATTINH</name></expr>:</case> <expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<case>case <expr><name>STATEXTNAMENSP</name></expr>:</case> <expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<case>case <expr><name>STATEXTOID</name></expr>:</case> <expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<case>case <expr><name>ATTNUM</name></expr>:</case> <expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<case>case <expr><name>TYPEOID</name></expr>:</case> <expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<case>case <expr><name>TYPENAMENSP</name></expr>:</case> <expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<case>case <expr><name>NAMESPACEOID</name></expr>:</case> <expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<case>case <expr><name>NAMESPACENAME</name></expr>:</case>
			<return>return <expr><name>true</name></expr>;</return>
		<case>case <expr><name>RELNAMENSP</name></expr>:</case>
			<return>return <expr><name>namespace_id</name> <operator>==</operator> <name>PG_CATALOG_NAMESPACE</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>YBCIsInitDbModeEnvVarSet</name><argument_list>()</argument_list></call></expr>;</return>
	</block_content>}</block></switch>
	<return>return <expr><call><name>isTempOrTempToastNamespace</name><argument_list>(<argument><expr><name>namespace_id</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Search the actual catalogs, rather than the cache.
 *
 * This is kept separate from SearchCatCacheInternal() to keep the fast-path
 * as small as possible.  To avoid that effort being undone by a helpful
 * compiler, try to explicitly forbid inlining.
 */</comment>
<function><type><specifier>static</specifier> <name>pg_noinline</name> <name>HeapTuple</name></type>
<name>SearchCatCacheMiss</name><parameter_list>(<parameter><decl><type><name>CatCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>,
				   <parameter><decl><type><name>uint32</name></type> <name>hashValue</name></decl></parameter>,
				   <parameter><decl><type><name>Index</name></type> <name>hashIndex</name></decl></parameter>,
				   <parameter><decl><type><name>Datum</name></type> <name>v1</name></decl></parameter>,
				   <parameter><decl><type><name>Datum</name></type> <name>v2</name></decl></parameter>,
				   <parameter><decl><type><name>Datum</name></type> <name>v3</name></decl></parameter>,
				   <parameter><decl><type><name>Datum</name></type> <name>v4</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>cur_skey</name><index>[<expr><name>CATCACHE_MAXKEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scandesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ntp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatCTup</name>    <modifier>*</modifier></type><name>ct</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>arguments</name><index>[<expr><name>CATCACHE_MAXKEYS</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* Initialize local parameter array */</comment>
	<expr_stmt><expr><name><name>arguments</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>v1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>arguments</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>v2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>arguments</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>v3</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>arguments</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>v4</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Ok, need to make a lookup in the relation, copy the scankey and fill
	 * out any per-call fields.
	 */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>cur_skey</name></expr></argument>, <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_skey</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cur_skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name> <operator>=</operator> <name>v1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cur_skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name> <operator>=</operator> <name>v2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cur_skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name> <operator>=</operator> <name>v3</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cur_skey</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name> <operator>=</operator> <name>v4</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Tuple was not found in cache, so we have to try to retrieve it directly
	 * from the relation.  If found, we will add it to the cache; if not
	 * found, we will add a negative cache entry instead.
	 *
	 * NOTE: it is possible for recursive cache lookups to occur while reading
	 * the relation --- for example, due to shared-cache-inval messages being
	 * processed during heap_open().  This is OK.  It's even possible for one
	 * of those lookups to find and enter the very same tuple we are trying to
	 * fetch here.  If that happens, we will enter a second copy of the tuple
	 * into the cache.  The first copy will never be referenced again, and
	 * will eventually age out of the cache, so there's no functional problem.
	 * This case is rare enough that it's not worth expending extra cycles to
	 * detect.
	 */</comment>
	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_reloid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>NumCatalogCacheMisses</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>yb_debug_log_catcache_events</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * For safety, disable catcache logging within the scope of this
		 * function as YBDatumToString below may trigger additional cache
		 * lookups (to get the attribute type info).
		 */</comment>
		<expr_stmt><expr><name>yb_debug_log_catcache_events</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nkeys</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<decl_stmt><decl><type><name>int</name></type> <name>attnum</name> <init>= <expr><name><name>cache</name><operator>-&gt;</operator><name>cc_keyno</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>typid</name> <init>= <expr><name>OIDOID</name></expr></init></decl>;</decl_stmt> <comment type="line">// default.</comment>
			<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>typid</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_tupdesc</name></name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>YBDatumToString</name><argument_list>(<argument><expr><name><name>cur_skey</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_argument</name></expr></argument>, <argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
		        <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Catalog cache miss on cache with id %d:\n"</literal>
		                <literal type="string">"Target rel: %s (oid : %d), index oid %d\n"</literal>
		                <literal type="string">"Search keys: %s"</literal></expr></argument>,
		                <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>id</name></name></expr></argument>,
		                <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_relname</name></name></expr></argument>,
		                <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_reloid</name></name></expr></argument>,
		                <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_indexoid</name></name></expr></argument>,
		                <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Done, reset catcache logging. */</comment>
		<expr_stmt><expr><name>yb_debug_log_catcache_events</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>scandesc</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>relation</name></expr></argument>,
								  <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_indexoid</name></name></expr></argument>,
								  <argument><expr><call><name>IndexScanOK</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>cur_skey</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><name>nkeys</name></expr></argument>,
								  <argument><expr><name>cur_skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ct</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>ntp</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>CatalogCacheCreateEntry</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>ntp</name></expr></argument>, <argument><expr><name>arguments</name></expr></argument>,
									 <argument><expr><name>hashValue</name></expr></argument>, <argument><expr><name>hashIndex</name></expr></argument>,
									 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* immediately set the refcount to 1 */</comment>
		<expr_stmt><expr><call><name>ResourceOwnerEnlargeCatCacheRefs</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>refcount</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ResourceOwnerRememberCatCacheRef</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ct</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>					<comment type="block">/* assume only one match */</comment>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If tuple was not found, we need to build a negative cache entry
	 * containing a fake tuple.  The fake tuple has the correct key columns,
	 * but nulls everywhere else.
	 *
	 * In bootstrap mode, we don't build negative entries, because the cache
	 * invalidation mechanism isn't alive and can't clear them if the tuple
	 * gets created later.  (Bootstrap doesn't do UPDATEs, so it doesn't need
	 * cache inval for that.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ct</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Disable negative entries for YugaByte to handle case where the entry
		 * was added by (running a command on) another node.
		 * We also don't support tuple update as of 14/12/2018.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
		    <operator>!</operator><call><name>YbAllowNegativeCacheEntries</name><argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>id</name></name></expr></argument>,
		                                 <argument><expr><call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name><name>cur_skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>CatalogCacheCreateEntry</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>arguments</name></expr></argument>,
									 <argument><expr><name>hashValue</name></expr></argument>, <argument><expr><name>hashIndex</name></expr></argument>,
									 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CACHE4_elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"SearchCatCache(%s): Contains %d/%d tuples"</literal></expr></argument>,
					<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_relname</name></name></expr></argument>, <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_ntup</name></name></expr></argument>, <argument><expr><name><name>CacheHdr</name><operator>-&gt;</operator><name>ch_ntup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CACHE3_elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"SearchCatCache(%s): put neg entry in bucket %d"</literal></expr></argument>,
					<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_relname</name></name></expr></argument>, <argument><expr><name>hashIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We are not returning the negative entry to the caller, so leave its
		 * refcount zero.
		 */</comment>

		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>CACHE4_elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"SearchCatCache(%s): Contains %d/%d tuples"</literal></expr></argument>,
				<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_relname</name></name></expr></argument>, <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_ntup</name></name></expr></argument>, <argument><expr><name><name>CacheHdr</name><operator>-&gt;</operator><name>ch_ntup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CACHE3_elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"SearchCatCache(%s): put in bucket %d"</literal></expr></argument>,
				<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_relname</name></name></expr></argument>, <argument><expr><name>hashIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CATCACHE_STATS</name></cpp:ifdef>
	<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_newloads</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><operator>&amp;</operator><name><name>ct</name><operator>-&gt;</operator><name>tuple</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	ReleaseCatCache
 *
 *	Decrement the reference count of a catcache entry (releasing the
 *	hold grabbed by a successful SearchCatCache).
 *
 *	NOTE: if compiled with -DCATCACHE_FORCE_RELEASE then catcache entries
 *	will be freed as soon as their refcount goes to zero.  In combination
 *	with aset.c's CLOBBER_FREED_MEMORY option, this provides a good test
 *	to catch references to already-released catcache entries.
 */</comment>
<function><type><name>void</name></type>
<name>ReleaseCatCache</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CatCTup</name>    <modifier>*</modifier></type><name>ct</name> <init>= <expr><operator>(</operator><name>CatCTup</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tuple</name><operator>)</operator> <operator>-</operator>
								  <call><name>offsetof</name><argument_list>(<argument><expr><name>CatCTup</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Safety checks to ensure we were handed a cache entry */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>ct_magic</name></name> <operator>==</operator> <name>CT_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>refcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>refcount</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ResourceOwnerForgetCatCacheRef</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ct</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>CATCACHE_FORCE_RELEASE</name></cpp:ifndef>
		<expr><name><name>ct</name><operator>-&gt;</operator><name>dead</name></name> <operator>&amp;&amp;</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<name><name>ct</name><operator>-&gt;</operator><name>refcount</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>ct</name><operator>-&gt;</operator><name>c_list</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>ct</name><operator>-&gt;</operator><name>c_list</name><operator>-&gt;</operator><name>refcount</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CatCacheRemoveCTup</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>my_cache</name></name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *	GetCatCacheHashValue
 *
 *		Compute the hash value for a given set of search keys.
 *
 * The reason for exposing this as part of the API is that the hash value is
 * exposed in cache invalidation operations, so there are places outside the
 * catcache code that need to be able to compute the hash values.
 */</comment>
<function><type><name>uint32</name></type>
<name>GetCatCacheHashValue</name><parameter_list>(<parameter><decl><type><name>CatCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>,
					 <parameter><decl><type><name>Datum</name></type> <name>v1</name></decl></parameter>,
					 <parameter><decl><type><name>Datum</name></type> <name>v2</name></decl></parameter>,
					 <parameter><decl><type><name>Datum</name></type> <name>v3</name></decl></parameter>,
					 <parameter><decl><type><name>Datum</name></type> <name>v4</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * one-time startup overhead for each cache
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cache</name><operator>-&gt;</operator><name>cc_tupdesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CatalogCacheInitializeCache</name><argument_list>(<argument><expr><name>cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * calculate the hash value
	 */</comment>
	<return>return <expr><call><name>CatalogCacheComputeHashValue</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_nkeys</name></name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>v3</name></expr></argument>, <argument><expr><name>v4</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *	SearchCatCacheList
 *
 *		Generate a list of all tuples matching a partial key (that is,
 *		a key specifying just the first K of the cache's N key columns).
 *
 *		It doesn't make any sense to specify all of the cache's key columns
 *		here: since the key is unique, there could be at most one match, so
 *		you ought to use SearchCatCache() instead.  Hence this function takes
 *		one less Datum argument than SearchCatCache() does.
 *
 *		The caller must not modify the list object or the pointed-to tuples,
 *		and must call ReleaseCatCacheList() when done with the list.
 */</comment>
<function><type><name>CatCList</name> <modifier>*</modifier></type>
<name>SearchCatCacheList</name><parameter_list>(<parameter><decl><type><name>CatCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>,
				   <parameter><decl><type><name>Datum</name></type> <name>v1</name></decl></parameter>,
				   <parameter><decl><type><name>Datum</name></type> <name>v2</name></decl></parameter>,
				   <parameter><decl><type><name>Datum</name></type> <name>v3</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>v4</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>			<comment type="block">/* dummy last-column value */</comment>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>arguments</name><index>[<expr><name>CATCACHE_MAXKEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>lHashValue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_iter</name></type>	<name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatCList</name>   <modifier>*</modifier></type><name>cl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatCTup</name>    <modifier>*</modifier></type><name>ct</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier><specifier>volatile</specifier></type> <name>ctlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ctlist_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nmembers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ordered</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ntp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * one-time startup overhead for each cache
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cache</name><operator>-&gt;</operator><name>cc_tupdesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CatalogCacheInitializeCache</name><argument_list>(<argument><expr><name>cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nkeys</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nkeys</name> <operator>&lt;</operator> <name><name>cache</name><operator>-&gt;</operator><name>cc_nkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CATCACHE_STATS</name></cpp:ifdef>
	<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_lsearches</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Initialize local parameter array */</comment>
	<expr_stmt><expr><name><name>arguments</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>v1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>arguments</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>v2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>arguments</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>v3</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>arguments</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>v4</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * compute a hash value of the given keys for faster search.  We don't
	 * presently divide the CatCList items into buckets, but this still lets
	 * us skip non-matching items quickly most of the time.
	 */</comment>
	<expr_stmt><expr><name>lHashValue</name> <operator>=</operator> <call><name>CatalogCacheComputeHashValue</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>nkeys</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>v3</name></expr></argument>, <argument><expr><name>v4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * scan the items until we find a match or exhaust our list
	 *
	 * Note: it's okay to use dlist_foreach here, even though we modify the
	 * dlist within the loop, because we don't continue the loop afterwards.
	 */</comment>
	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;cache-&gt;cc_lists</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>cl</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>CatCList</name></expr></argument>, <argument><expr><name>cache_elem</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cl</name><operator>-&gt;</operator><name>dead</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* ignore dead entries */</comment>

		<if_stmt><if>if <condition>(<expr><name><name>cl</name><operator>-&gt;</operator><name>hash_value</name></name> <operator>!=</operator> <name>lHashValue</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* quickly skip entry if wrong hash val */</comment>

		<comment type="block">/*
		 * see if the cached list matches our key.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cl</name><operator>-&gt;</operator><name>nkeys</name></name> <operator>!=</operator> <name>nkeys</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CatalogCacheCompareTuple</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>nkeys</name></expr></argument>, <argument><expr><name><name>cl</name><operator>-&gt;</operator><name>keys</name></name></expr></argument>, <argument><expr><name>arguments</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We found a matching list.  Move the list to the front of the
		 * cache's list-of-lists, to speed subsequent searches.  (We do not
		 * move the members to the fronts of their hashbucket lists, however,
		 * since there's no point in that unless they are searched for
		 * individually.)
		 */</comment>
		<expr_stmt><expr><call><name>dlist_move_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>cc_lists</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cl</name><operator>-&gt;</operator><name>cache_elem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Bump the list's refcount and return it */</comment>
		<expr_stmt><expr><call><name>ResourceOwnerEnlargeCatCacheListRefs</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cl</name><operator>-&gt;</operator><name>refcount</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ResourceOwnerRememberCatCacheListRef</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>, <argument><expr><name>cl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CACHE2_elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"SearchCatCacheList(%s): found list"</literal></expr></argument>,
					<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CATCACHE_STATS</name></cpp:ifdef>
		<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_lhits</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<return>return <expr><name>cl</name></expr>;</return>
	</block_content>}</block>

	<comment type="block">/*
	 * List was not found in cache, so we have to build it by reading the
	 * relation.  For each matching tuple found in the relation, use an
	 * existing cache entry if possible, else build a new one.
	 *
	 * We have to bump the member refcounts temporarily to ensure they won't
	 * get dropped from the cache while loading other members. We use a PG_TRY
	 * block to ensure we can undo those refcounts if we get an error before
	 * we finish constructing the CatCList.
	 */</comment>
	<expr_stmt><expr><call><name>ResourceOwnerEnlargeCatCacheListRefs</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ctlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>cur_skey</name><index>[<expr><name>CATCACHE_MAXKEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scandesc</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Ok, need to make a lookup in the relation, copy the scankey and
		 * fill out any per-call fields.
		 */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>cur_skey</name></expr></argument>, <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_skey</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>cache</name><operator>-&gt;</operator><name>cc_nkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cur_skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name> <operator>=</operator> <name>v1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cur_skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name> <operator>=</operator> <name>v2</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cur_skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name> <operator>=</operator> <name>v3</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cur_skey</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name> <operator>=</operator> <name>v4</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_reloid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>scandesc</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>relation</name></expr></argument>,
									  <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_indexoid</name></name></expr></argument>,
									  <argument><expr><call><name>IndexScanOK</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>cur_skey</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument>,
									  <argument><expr><name>nkeys</name></expr></argument>,
									  <argument><expr><name>cur_skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* The list will be ordered iff we are doing an index scan */</comment>
		<expr_stmt><expr><name>ordered</name> <operator>=</operator> <operator>(</operator><name><name>scandesc</name><operator>-&gt;</operator><name>irel</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>

		<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>ntp</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint32</name></type>		<name>hashValue</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Index</name></type>		<name>hashIndex</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>dlist_head</name> <modifier>*</modifier></type><name>bucket</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * See if there's an entry for this tuple already.
			 */</comment>
			<expr_stmt><expr><name>ct</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>hashValue</name> <operator>=</operator> <call><name>CatalogCacheComputeTupleHashValue</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_nkeys</name></name></expr></argument>, <argument><expr><name>ntp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>hashIndex</name> <operator>=</operator> <call><name>HASH_INDEX</name><argument_list>(<argument><expr><name>hashValue</name></expr></argument>, <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_nbuckets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>bucket</name> <operator>=</operator> <operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>cc_bucket</name><index>[<expr><name>hashIndex</name></expr>]</index></name></expr>;</expr_stmt>
			<comment type="block">/* Cannot rely on ctid comparison in YB mode */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>bucket</argument>)</argument_list></macro>
				<block>{<block_content>
					<expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>CatCTup</name></expr></argument>, <argument><expr><name>cache_elem</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>ct</name><operator>-&gt;</operator><name>dead</name></name> <operator>||</operator> <name><name>ct</name><operator>-&gt;</operator><name>negative</name></name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>	<comment type="block">/* ignore dead and negative entries */</comment>

					<if_stmt><if>if <condition>(<expr><name><name>ct</name><operator>-&gt;</operator><name>hash_value</name></name> <operator>!=</operator> <name>hashValue</name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>	<comment type="block">/* quickly skip entry if wrong hash val */</comment>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ItemPointerEquals</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>ct</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>ntp</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>	<comment type="block">/* not same tuple */</comment>

					<comment type="block">/*
					 * Found a match, but can't use it if it belongs to another
					 * list already
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>ct</name><operator>-&gt;</operator><name>c_list</name></name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>			<comment type="block">/* A-OK */</comment>
				</block_content>}</block>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* We didn't find a usable entry, so make a new one */</comment>
				<expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>CatalogCacheCreateEntry</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>ntp</name></expr></argument>, <argument><expr><name>arguments</name></expr></argument>,
											 <argument><expr><name>hashValue</name></expr></argument>, <argument><expr><name>hashIndex</name></expr></argument>,
											 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Careful here: add entry to ctlist, then bump its refcount */</comment>
			<comment type="block">/* This way leaves state correct if lappend runs out of memory */</comment>
			<expr_stmt><expr><name>ctlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>ctlist</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>refcount</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Now we can build the CatCList entry. */</comment>
		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nmembers</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>ctlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cl</name> <operator>=</operator> <operator>(</operator><name>CatCList</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>CatCList</name></expr></argument>, <argument><expr><name>members</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>nmembers</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CatCTup</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Extract key values */</comment>
		<expr_stmt><expr><call><name>CatCacheCopyKeys</name><argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_tupdesc</name></name></expr></argument>, <argument><expr><name>nkeys</name></expr></argument>, <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_keyno</name></name></expr></argument>,
						 <argument><expr><name>arguments</name></expr></argument>, <argument><expr><name><name>cl</name><operator>-&gt;</operator><name>keys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We are now past the last thing that could trigger an elog before we
		 * have finished building the CatCList and remembering it in the
		 * resource owner.  So it's OK to fall out of the PG_TRY, and indeed
		 * we'd better do so before we start marking the members as belonging
		 * to the list.
		 */</comment>

	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>ctlist_item</argument>, <argument>ctlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>ct</name> <operator>=</operator> <operator>(</operator><name>CatCTup</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ctlist_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>c_list</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>refcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>refcount</name></name><operator>--</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>CATCACHE_FORCE_RELEASE</name></cpp:ifndef>
				<expr><name><name>ct</name><operator>-&gt;</operator><name>dead</name></name> <operator>&amp;&amp;</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<name><name>ct</name><operator>-&gt;</operator><name>refcount</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<operator>(</operator><name><name>ct</name><operator>-&gt;</operator><name>c_list</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>ct</name><operator>-&gt;</operator><name>c_list</name><operator>-&gt;</operator><name>refcount</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>CatCacheRemoveCTup</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>cl</name><operator>-&gt;</operator><name>cl_magic</name></name> <operator>=</operator> <name>CL_MAGIC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cl</name><operator>-&gt;</operator><name>my_cache</name></name> <operator>=</operator> <name>cache</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cl</name><operator>-&gt;</operator><name>refcount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* for the moment */</comment>
	<expr_stmt><expr><name><name>cl</name><operator>-&gt;</operator><name>dead</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cl</name><operator>-&gt;</operator><name>ordered</name></name> <operator>=</operator> <name>ordered</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cl</name><operator>-&gt;</operator><name>nkeys</name></name> <operator>=</operator> <name>nkeys</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cl</name><operator>-&gt;</operator><name>hash_value</name></name> <operator>=</operator> <name>lHashValue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cl</name><operator>-&gt;</operator><name>n_members</name></name> <operator>=</operator> <name>nmembers</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>ctlist_item</argument>, <argument>ctlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name><name>cl</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>ct</name> <operator>=</operator> <operator>(</operator><name>CatCTup</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ctlist_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>c_list</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>c_list</name></name> <operator>=</operator> <name>cl</name></expr>;</expr_stmt>
		<comment type="block">/* release the temporary refcount on the member */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>refcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>refcount</name></name><operator>--</operator></expr>;</expr_stmt>
		<comment type="block">/* mark list dead if any members already dead */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ct</name><operator>-&gt;</operator><name>dead</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>cl</name><operator>-&gt;</operator><name>dead</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <name>nmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>dlist_push_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>cc_lists</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cl</name><operator>-&gt;</operator><name>cache_elem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Finally, bump the list's refcount and return it */</comment>
	<expr_stmt><expr><name><name>cl</name><operator>-&gt;</operator><name>refcount</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ResourceOwnerRememberCatCacheListRef</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>, <argument><expr><name>cl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CACHE3_elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"SearchCatCacheList(%s): made list of %d members"</literal></expr></argument>,
				<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_relname</name></name></expr></argument>, <argument><expr><name>nmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>cl</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	ReleaseCatCacheList
 *
 *	Decrement the reference count of a catcache list.
 */</comment>
<function><type><name>void</name></type>
<name>ReleaseCatCacheList</name><parameter_list>(<parameter><decl><type><name>CatCList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Safety checks to ensure we were handed a cache entry */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>cl_magic</name></name> <operator>==</operator> <name>CL_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>refcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>refcount</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ResourceOwnerForgetCatCacheListRef</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>CATCACHE_FORCE_RELEASE</name></cpp:ifndef>
		<expr><name><name>list</name><operator>-&gt;</operator><name>dead</name></name> <operator>&amp;&amp;</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<name><name>list</name><operator>-&gt;</operator><name>refcount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CatCacheRemoveCList</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>my_cache</name></name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CatalogCacheCreateEntry
 *		Create a new CatCTup entry, copying the given HeapTuple and other
 *		supplied data into it.  The new entry initially has refcount 0.
 */</comment>
<function><type><specifier>static</specifier> <name>CatCTup</name> <modifier>*</modifier></type>
<name>CatalogCacheCreateEntry</name><parameter_list>(<parameter><decl><type><name>CatCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>ntp</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>arguments</name></decl></parameter>,
						<parameter><decl><type><name>uint32</name></type> <name>hashValue</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>hashIndex</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>negative</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CatCTup</name>    <modifier>*</modifier></type><name>ct</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>dtp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

	<comment type="block">/* negative entries have no tuple associated */</comment>
	<if_stmt><if>if <condition>(<expr><name>ntp</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>negative</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If there are any out-of-line toasted fields in the tuple, expand
		 * them in-line.  This saves cycles during later use of the catcache
		 * entry, and also protects us against the possibility of the toast
		 * tuples being freed before we attempt to fetch them, in case of
		 * something using a slightly stale catcache entry.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleHasExternal</name><argument_list>(<argument><expr><name>ntp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>dtp</name> <operator>=</operator> <call><name>toast_flatten_tuple</name><argument_list>(<argument><expr><name>ntp</name></expr></argument>, <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>dtp</name> <operator>=</operator> <name>ntp</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Allocate memory for CatCTup and the cached tuple in one go */</comment>
		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ct</name> <operator>=</operator> <operator>(</operator><name>CatCTup</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CatCTup</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
								<name>MAXIMUM_ALIGNOF</name> <operator>+</operator> <name><name>dtp</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <name><name>dtp</name><operator>-&gt;</operator><name>t_len</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_self</name></name> <operator>=</operator> <name><name>dtp</name><operator>-&gt;</operator><name>t_self</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <name><name>dtp</name><operator>-&gt;</operator><name>t_tableOid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator>
			<call><name>MAXALIGN</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>ct</name><operator>)</operator> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CatCTup</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* copy tuple contents */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>ct</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_data</name></name></expr></argument>,
			   <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name><name>dtp</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>,
			   <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HEAPTUPLE_COPY_YBCTID</name><argument_list>(<argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>t_ybctid</name></name></expr></argument>, <argument><expr><name><name>ct</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_ybctid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>dtp</name> <operator>!=</operator> <name>ntp</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* extract keys - they'll point into the tuple if not by-value */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cache</name><operator>-&gt;</operator><name>cc_nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>atp</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>atp</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ct</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>,
							   <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_keyno</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
							   <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_tupdesc</name></name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>keys</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>atp</name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>negative</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ct</name> <operator>=</operator> <operator>(</operator><name>CatCTup</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CatCTup</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Store keys - they'll point into separately allocated memory if not
		 * by-value.
		 */</comment>
		<expr_stmt><expr><call><name>CatCacheCopyKeys</name><argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_tupdesc</name></name></expr></argument>, <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_nkeys</name></name></expr></argument>, <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_keyno</name></name></expr></argument>,
						 <argument><expr><name>arguments</name></expr></argument>, <argument><expr><name><name>ct</name><operator>-&gt;</operator><name>keys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Finish initializing the CatCTup header, and add it to the cache's
	 * linked list and counts.
	 */</comment>
	<expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>ct_magic</name></name> <operator>=</operator> <name>CT_MAGIC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>my_cache</name></name> <operator>=</operator> <name>cache</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>c_list</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>refcount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* for the moment */</comment>
	<expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>dead</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>negative</name></name> <operator>=</operator> <name>negative</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>hash_value</name></name> <operator>=</operator> <name>hashValue</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>dlist_push_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>cc_bucket</name><index>[<expr><name>hashIndex</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ct</name><operator>-&gt;</operator><name>cache_elem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>cc_ntup</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>CacheHdr</name><operator>-&gt;</operator><name>ch_ntup</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the hash table has become too full, enlarge the buckets array. Quite
	 * arbitrarily, we enlarge when fill factor &gt; 2.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cache</name><operator>-&gt;</operator><name>cc_ntup</name></name> <operator>&gt;</operator> <name><name>cache</name><operator>-&gt;</operator><name>cc_nbuckets</name></name> <operator>*</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RehashCatCache</name><argument_list>(<argument><expr><name>cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>ct</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper routine that frees keys stored in the keys array.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CatCacheFreeKeys</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>attnos</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>keys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nkeys</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><name><name>attnos</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name></decl>;</decl_stmt>

		<comment type="block">/* only valid system attribute is the oid, which is by value */</comment>
		<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <name>ObjectIdAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>att</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>att</name><operator>-&gt;</operator><name>attbyval</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>keys</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Helper routine that copies the keys in the srckeys array into the dstkeys
 * one, guaranteeing that the datums are fully allocated in the current memory
 * context.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CatCacheCopyKeys</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>attnos</name></decl></parameter>,
				 <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>srckeys</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>dstkeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * XXX: memory and lookup performance could possibly be improved by
	 * storing all keys in one allocation.
	 */</comment>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nkeys</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><name><name>attnos</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <name>ObjectIdAttributeNumber</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>dstkeys</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>srckeys</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>src</name> <init>= <expr><name><name>srckeys</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>NameData</name></type>	<name>srcname</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Must be careful in case the caller passed a C string where a
			 * NAME is wanted: convert the given argument to a correctly
			 * padded NAME.  Otherwise the memcpy() done by datumCopy() could
			 * fall off the end of memory.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>==</operator> <name>NAMEOID</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>srcname</name></expr></argument>, <argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>src</name> <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>srcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>dstkeys</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name>src</name></expr></argument>,
								   <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attbyval</name></name></expr></argument>,
								   <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

</block_content>}</block></function>

<comment type="block">/*
 *	PrepareToInvalidateCacheTuple()
 *
 *	This is part of a rather subtle chain of events, so pay attention:
 *
 *	When a tuple is inserted or deleted, it cannot be flushed from the
 *	catcaches immediately, for reasons explained at the top of cache/inval.c.
 *	Instead we have to add entry(s) for the tuple to a list of pending tuple
 *	invalidations that will be done at the end of the command or transaction.
 *
 *	The lists of tuples that need to be flushed are kept by inval.c.  This
 *	routine is a helper routine for inval.c.  Given a tuple belonging to
 *	the specified relation, find all catcaches it could be in, compute the
 *	correct hash value for each such catcache, and call the specified
 *	function to record the cache id and hash value in inval.c's lists.
 *	SysCacheInvalidate will be called later, if appropriate,
 *	using the recorded information.
 *
 *	For an insert or delete, tuple is the target tuple and newtuple is NULL.
 *	For an update, we are called just once, with tuple being the old tuple
 *	version and newtuple the new version.  We should make two list entries
 *	if the tuple's hash value changed, but only one if it didn't.
 *
 *	Note that it is irrelevant whether the given tuple is actually loaded
 *	into the catcache at the moment.  Even if it's not there now, it might
 *	be by the end of the command, or there might be a matching negative entry
 *	to flush --- or other backends' caches might have such entries --- so
 *	we have to make list entries to flush it later.
 *
 *	Also note that it's not an error if there are no catcaches for the
 *	specified relation.  inval.c doesn't know exactly which rels have
 *	catcaches --- it will call this routine for any tuple that's in a
 *	system relation.
 */</comment>
<function><type><name>void</name></type>
<name>PrepareToInvalidateCacheTuple</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
							  <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
							  <parameter><decl><type><name>HeapTuple</name></type> <name>newtuple</name></decl></parameter>,
							  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>function</name>) <parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>uint32</name></type></decl></parameter>, <parameter><decl><type><name>Oid</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>slist_iter</name></type>	<name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>reloid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CACHE1_elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"PrepareToInvalidateCacheTuple: called"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * sanity checks
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationIsValid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>function</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CacheHdr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>reloid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* ----------------
	 *	for each cache
	 *	   if the cache contains tuples from the specified relation
	 *		   compute the tuple's hash value(s) in this cache,
	 *		   and call the passed function to register the information.
	 * ----------------
	 */</comment>

	<macro><name>slist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;CacheHdr-&gt;ch_caches</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CatCache</name>   <modifier>*</modifier></type><name>ccp</name> <init>= <expr><call><name>slist_container</name><argument_list>(<argument><expr><name>CatCache</name></expr></argument>, <argument><expr><name>cc_next</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>hashvalue</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>dbid</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ccp</name><operator>-&gt;</operator><name>cc_reloid</name></name> <operator>!=</operator> <name>reloid</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Just in case cache hasn't finished initialization yet... */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ccp</name><operator>-&gt;</operator><name>cc_tupdesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CatalogCacheInitializeCache</name><argument_list>(<argument><expr><name>ccp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>hashvalue</name> <operator>=</operator> <call><name>CatalogCacheComputeTupleHashValue</name><argument_list>(<argument><expr><name>ccp</name></expr></argument>, <argument><expr><name><name>ccp</name><operator>-&gt;</operator><name>cc_nkeys</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dbid</name> <operator>=</operator> <ternary><condition><expr><name><name>ccp</name><operator>-&gt;</operator><name>cc_relisshared</name></name></expr> ?</condition><then> <expr><operator>(</operator><name>Oid</name><operator>)</operator> <literal type="number">0</literal></expr> </then><else>: <expr><name>MyDatabaseId</name></expr></else></ternary></expr>;</expr_stmt>

		<expr_stmt><expr><call>(<modifier>*</modifier><name>function</name>) <argument_list>(<argument><expr><name><name>ccp</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>, <argument><expr><name>dbid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>newtuple</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint32</name></type>		<name>newhashvalue</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>newhashvalue</name> <operator>=</operator> <call><name>CatalogCacheComputeTupleHashValue</name><argument_list>(<argument><expr><name>ccp</name></expr></argument>, <argument><expr><name><name>ccp</name><operator>-&gt;</operator><name>cc_nkeys</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>newhashvalue</name> <operator>!=</operator> <name>hashvalue</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call>(<modifier>*</modifier><name>function</name>) <argument_list>(<argument><expr><name><name>ccp</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name>newhashvalue</name></expr></argument>, <argument><expr><name>dbid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 *	RelationHasCachedLists
 *
 *	Returns true if there is a catalog cache associated with this
 * 	relation which is currently caching at least one list.
 */</comment>
<function><type><name>bool</name></type>
<name>RelationHasCachedLists</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>slist_iter</name></type> <name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>reloid</name></decl>;</decl_stmt>

	<comment type="block">/* sanity checks */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationIsValid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CacheHdr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>reloid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>slist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;CacheHdr-&gt;ch_caches</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CatCache</name> <modifier>*</modifier></type><name>ccp</name> <init>= <expr><call><name>slist_container</name><argument_list>(<argument><expr><name>CatCache</name></expr></argument>, <argument><expr><name>cc_next</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>ccp</name><operator>-&gt;</operator><name>cc_reloid</name></name> <operator>==</operator> <name>reloid</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ccp</name><operator>-&gt;</operator><name>cc_lists</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutines for warning about reference leaks.  These are exported so
 * that resowner.c can call them.
 */</comment>
<function><type><name>void</name></type>
<name>PrintCatCacheLeakWarning</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CatCTup</name>    <modifier>*</modifier></type><name>ct</name> <init>= <expr><operator>(</operator><name>CatCTup</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tuple</name><operator>)</operator> <operator>-</operator>
								  <call><name>offsetof</name><argument_list>(<argument><expr><name>CatCTup</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Safety check to ensure we were handed a cache entry */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>ct_magic</name></name> <operator>==</operator> <name>CT_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"cache reference leak: cache %s (%d), tuple %u/%u has count %d"</literal></expr></argument>,
		 <argument><expr><name><name>ct</name><operator>-&gt;</operator><name>my_cache</name><operator>-&gt;</operator><name>cc_relname</name></name></expr></argument>, <argument><expr><name><name>ct</name><operator>-&gt;</operator><name>my_cache</name><operator>-&gt;</operator><name>id</name></name></expr></argument>,
		 <argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>,
		 <argument><expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>,
		 <argument><expr><name><name>ct</name><operator>-&gt;</operator><name>refcount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>PrintCatCacheListLeakWarning</name><parameter_list>(<parameter><decl><type><name>CatCList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"cache reference leak: cache %s (%d), list %p has count %d"</literal></expr></argument>,
		 <argument><expr><name><name>list</name><operator>-&gt;</operator><name>my_cache</name><operator>-&gt;</operator><name>cc_relname</name></name></expr></argument>, <argument><expr><name><name>list</name><operator>-&gt;</operator><name>my_cache</name><operator>-&gt;</operator><name>id</name></name></expr></argument>,
		 <argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>list</name><operator>-&gt;</operator><name>refcount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>long</name></type>
<name>GetCatCacheMisses</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<return>return <expr><name>NumCatalogCacheMisses</name></expr>;</return>
</block_content>}</block></function>
</unit>
