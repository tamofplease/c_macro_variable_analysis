<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/utils/adt/network_gist.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * network_gist.c
 *	  GiST support for network types.
 *
 * The key thing to understand about this code is the definition of the
 * "union" of a set of INET/CIDR values.  It works like this:
 * 1. If the values are not all of the same IP address family, the "union"
 * is a dummy value with family number zero, minbits zero, commonbits zero,
 * address all zeroes.  Otherwise:
 * 2. The union has the common IP address family number.
 * 3. The union's minbits value is the smallest netmask length ("ip_bits")
 * of all the input values.
 * 4. Let C be the number of leading address bits that are in common among
 * all the input values (C ranges from 0 to ip_maxbits for the family).
 * 5. The union's commonbits value is C.
 * 6. The union's address value is the same as the common prefix for its
 * first C bits, and is zeroes to the right of that.  The physical width
 * of the address value is ip_maxbits for the address family.
 *
 * In a leaf index entry (representing a single key), commonbits is equal to
 * ip_maxbits for the address family, minbits is the same as the represented
 * value's ip_bits, and the address is equal to the represented address.
 * Although it may appear that we're wasting a byte by storing the union
 * format and not just the represented INET/CIDR value in leaf keys, the
 * extra byte is actually "free" because of alignment considerations.
 *
 * Note that this design tracks minbits and commonbits independently; in any
 * given union value, either might be smaller than the other.  This does not
 * help us much when descending the tree, because of the way inet comparison
 * is defined: at non-leaf nodes we can't compare more than minbits bits
 * even if we know them.  However, it greatly improves the quality of split
 * decisions.  Preliminary testing suggests that searches are as much as
 * twice as fast as for a simpler design in which a single field doubles as
 * the common prefix length and the minimum ip_bits value.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/utils/adt/network_gist.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/stratnum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inet.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Operator strategy numbers used in the GiST inet_ops opclass
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INETSTRAT_OVERLAPS</name></cpp:macro>		<cpp:value>RTOverlapStrategyNumber</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INETSTRAT_EQ</name></cpp:macro>			<cpp:value>RTEqualStrategyNumber</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INETSTRAT_NE</name></cpp:macro>			<cpp:value>RTNotEqualStrategyNumber</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INETSTRAT_LT</name></cpp:macro>			<cpp:value>RTLessStrategyNumber</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INETSTRAT_LE</name></cpp:macro>			<cpp:value>RTLessEqualStrategyNumber</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INETSTRAT_GT</name></cpp:macro>			<cpp:value>RTGreaterStrategyNumber</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INETSTRAT_GE</name></cpp:macro>			<cpp:value>RTGreaterEqualStrategyNumber</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INETSTRAT_SUB</name></cpp:macro>			<cpp:value>RTSubStrategyNumber</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INETSTRAT_SUBEQ</name></cpp:macro>			<cpp:value>RTSubEqualStrategyNumber</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INETSTRAT_SUP</name></cpp:macro>			<cpp:value>RTSuperStrategyNumber</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INETSTRAT_SUPEQ</name></cpp:macro>			<cpp:value>RTSuperEqualStrategyNumber</cpp:value></cpp:define>


<comment type="block">/*
 * Representation of a GiST INET/CIDR index key.  This is not identical to
 * INET/CIDR because we need to keep track of the length of the common address
 * prefix as well as the minimum netmask length.  However, as long as it
 * follows varlena header rules, the core GiST code won't know the difference.
 * For simplicity we always use 1-byte-header varlena format.
 */</comment>
<typedef>typedef <type><struct>struct <name>GistInetKey</name>
<block>{
	<decl_stmt><decl><type><name>uint8</name></type>		<name>va_header</name></decl>;</decl_stmt>		<comment type="block">/* varlena header --- don't touch directly */</comment>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>family</name></decl>;</decl_stmt>		<comment type="block">/* PGSQL_AF_INET, PGSQL_AF_INET6, or zero */</comment>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>minbits</name></decl>;</decl_stmt>		<comment type="block">/* minimum number of bits in netmask */</comment>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>commonbits</name></decl>;</decl_stmt>	<comment type="block">/* number of common prefix bits in addresses */</comment>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>ipaddr</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* up to 128 bits of common address */</comment>
}</block></struct></type> <name>GistInetKey</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DatumGetInetKeyP</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((GistInetKey *) DatumGetPointer(X))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>InetKeyPGetDatum</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>PointerGetDatum(X)</cpp:value></cpp:define>

<comment type="block">/*
 * Access macros; not really exciting, but we use these for notational
 * consistency with access to INET/CIDR values.  Note that family-zero values
 * are stored with 4 bytes of address, not 16.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gk_ip_family</name><parameter_list>(<parameter><type><name>gkptr</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((gkptr)-&gt;family)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gk_ip_minbits</name><parameter_list>(<parameter><type><name>gkptr</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((gkptr)-&gt;minbits)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gk_ip_commonbits</name><parameter_list>(<parameter><type><name>gkptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((gkptr)-&gt;commonbits)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gk_ip_addr</name><parameter_list>(<parameter><type><name>gkptr</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((gkptr)-&gt;ipaddr)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ip_family_maxbits</name><parameter_list>(<parameter><type><name>fam</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((fam) == PGSQL_AF_INET6 ? 128 : 32)</cpp:value></cpp:define>

<comment type="block">/* These require that the family field has been set: */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gk_ip_addrsize</name><parameter_list>(<parameter><type><name>gkptr</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(gk_ip_family(gkptr) == PGSQL_AF_INET6 ? 16 : 4)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gk_ip_maxbits</name><parameter_list>(<parameter><type><name>gkptr</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>ip_family_maxbits(gk_ip_family(gkptr))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_GK_VARSIZE</name><parameter_list>(<parameter><type><name>dst</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>SET_VARSIZE_SHORT(dst, offsetof(GistInetKey, ipaddr) + gk_ip_addrsize(dst))</cpp:value></cpp:define>


<comment type="block">/*
 * The GiST query consistency check
 */</comment>
<function><type><name>Datum</name></type>
<name>inet_gist_consistent</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>ent</name> <init>= <expr><operator>(</operator><name>GISTENTRY</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>inet</name>	   <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>PG_GETARG_INET_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StrategyNumber</name></type> <name>strategy</name> <init>= <expr><operator>(</operator><name>StrategyNumber</name><operator>)</operator> <call><name>PG_GETARG_UINT16</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Oid		subtype = PG_GETARG_OID(3); */</comment>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>recheck</name> <init>= <expr><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GistInetKey</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>DatumGetInetKeyP</name><argument_list>(<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>minbits</name></decl>,
				<decl><type ref="prev"/><name>order</name></decl>;</decl_stmt>

	<comment type="block">/* All operators served by this function are exact. */</comment>
	<expr_stmt><expr><operator>*</operator><name>recheck</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check 0: different families
	 *
	 * If key represents multiple address families, its children could match
	 * anything.  This can only happen on an inner index page.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>gk_ip_family</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>GIST_LEAF</name><argument_list>(<argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check 1: different families
	 *
	 * Matching families do not help any of the strategies.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>gk_ip_family</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>ip_family</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>strategy</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>INETSTRAT_LT</name></expr>:</case>
			<case>case <expr><name>INETSTRAT_LE</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>gk_ip_family</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>ip_family</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><name>INETSTRAT_GE</name></expr>:</case>
			<case>case <expr><name>INETSTRAT_GT</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>gk_ip_family</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>ip_family</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><name>INETSTRAT_NE</name></expr>:</case>
				<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
		<comment type="block">/* For all other cases, we can be sure there is no match */</comment>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check 2: network bit count
	 *
	 * Network bit count (ip_bits) helps to check leaves for sub network and
	 * sup network operators.  At non-leaf nodes, we know every child value
	 * has ip_bits &gt;= gk_ip_minbits(key), so we can avoid descending in some
	 * cases too.
	 */</comment>
	<switch>switch <condition>(<expr><name>strategy</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INETSTRAT_SUB</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>GIST_LEAF</name><argument_list>(<argument><expr><name>ent</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>gk_ip_minbits</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <call><name>ip_bits</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>INETSTRAT_SUBEQ</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>GIST_LEAF</name><argument_list>(<argument><expr><name>ent</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>gk_ip_minbits</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>ip_bits</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>INETSTRAT_SUPEQ</name></expr>:</case>
		<case>case <expr><name>INETSTRAT_EQ</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>gk_ip_minbits</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>ip_bits</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>INETSTRAT_SUP</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>gk_ip_minbits</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <call><name>ip_bits</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Check 3: common network bits
	 *
	 * Compare available common prefix bits to the query, but not beyond
	 * either the query's netmask or the minimum netmask among the represented
	 * values.  If these bits don't match the query, we have our answer (and
	 * may or may not need to descend, depending on the operator).  If they do
	 * match, and we are not at a leaf, we descend in all cases.
	 *
	 * Note this is the final check for operators that only consider the
	 * network part of the address.
	 */</comment>
	<expr_stmt><expr><name>minbits</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><call><name>gk_ip_commonbits</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>gk_ip_minbits</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>minbits</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>minbits</name></expr></argument>, <argument><expr><call><name>ip_bits</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>order</name> <operator>=</operator> <call><name>bitncmp</name><argument_list>(<argument><expr><call><name>gk_ip_addr</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ip_addr</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>minbits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>strategy</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INETSTRAT_SUB</name></expr>:</case>
		<case>case <expr><name>INETSTRAT_SUBEQ</name></expr>:</case>
		<case>case <expr><name>INETSTRAT_OVERLAPS</name></expr>:</case>
		<case>case <expr><name>INETSTRAT_SUPEQ</name></expr>:</case>
		<case>case <expr><name>INETSTRAT_SUP</name></expr>:</case>
			<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>order</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<case>case <expr><name>INETSTRAT_LT</name></expr>:</case>
		<case>case <expr><name>INETSTRAT_LE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>order</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>order</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>GIST_LEAF</name><argument_list>(<argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>INETSTRAT_EQ</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>order</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GIST_LEAF</name><argument_list>(<argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>INETSTRAT_GE</name></expr>:</case>
		<case>case <expr><name>INETSTRAT_GT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>order</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>order</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>GIST_LEAF</name><argument_list>(<argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>INETSTRAT_NE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>order</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>GIST_LEAF</name><argument_list>(<argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Remaining checks are only for leaves and basic comparison strategies.
	 * See network_cmp_internal() in network.c for the implementation we need
	 * to match.  Note that in a leaf key, commonbits should equal the address
	 * length, so we compared the whole network parts above.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GIST_LEAF</name><argument_list>(<argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check 4: network bit count
	 *
	 * Next step is to compare netmask widths.
	 */</comment>
	<switch>switch <condition>(<expr><name>strategy</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INETSTRAT_LT</name></expr>:</case>
		<case>case <expr><name>INETSTRAT_LE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>gk_ip_minbits</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>ip_bits</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>gk_ip_minbits</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>ip_bits</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>INETSTRAT_EQ</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>gk_ip_minbits</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>ip_bits</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>INETSTRAT_GE</name></expr>:</case>
		<case>case <expr><name>INETSTRAT_GT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>gk_ip_minbits</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>ip_bits</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>gk_ip_minbits</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>ip_bits</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>INETSTRAT_NE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>gk_ip_minbits</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>ip_bits</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Check 5: whole address
	 *
	 * Netmask bit counts are the same, so check all the address bits.
	 */</comment>
	<expr_stmt><expr><name>order</name> <operator>=</operator> <call><name>bitncmp</name><argument_list>(<argument><expr><call><name>gk_ip_addr</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ip_addr</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>gk_ip_maxbits</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>strategy</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INETSTRAT_LT</name></expr>:</case>
			<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>order</name> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<case>case <expr><name>INETSTRAT_LE</name></expr>:</case>
			<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>order</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<case>case <expr><name>INETSTRAT_EQ</name></expr>:</case>
			<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>order</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<case>case <expr><name>INETSTRAT_GE</name></expr>:</case>
			<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>order</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<case>case <expr><name>INETSTRAT_GT</name></expr>:</case>
			<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>order</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<case>case <expr><name>INETSTRAT_NE</name></expr>:</case>
			<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>order</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown strategy for inet GiST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Calculate parameters of the union of some GistInetKeys.
 *
 * Examine the keys in elements m..n inclusive of the GISTENTRY array,
 * and compute these output parameters:
 * *minfamily_p = minimum IP address family number
 * *maxfamily_p = maximum IP address family number
 * *minbits_p = minimum netmask width
 * *commonbits_p = number of leading bits in common among the addresses
 *
 * minbits and commonbits are forced to zero if there's more than one
 * address family.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>calc_inet_union_params</name><parameter_list>(<parameter><decl><type><name>GISTENTRY</name> <modifier>*</modifier></type><name>ent</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>,
					   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>minfamily_p</name></decl></parameter>,
					   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>maxfamily_p</name></decl></parameter>,
					   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>minbits_p</name></decl></parameter>,
					   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>commonbits_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>minfamily</name></decl>,
				<decl><type ref="prev"/><name>maxfamily</name></decl>,
				<decl><type ref="prev"/><name>minbits</name></decl>,
				<decl><type ref="prev"/><name>commonbits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>addr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GistInetKey</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Must be at least one key. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>m</name> <operator>&lt;=</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize variables using the first key. */</comment>
	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>DatumGetInetKeyP</name><argument_list>(<argument><expr><name><name>ent</name><index>[<expr><name>m</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>minfamily</name> <operator>=</operator> <name>maxfamily</name> <operator>=</operator> <call><name>gk_ip_family</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>minbits</name> <operator>=</operator> <call><name>gk_ip_minbits</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>commonbits</name> <operator>=</operator> <call><name>gk_ip_commonbits</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>gk_ip_addr</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Scan remaining keys. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>m</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>DatumGetInetKeyP</name><argument_list>(<argument><expr><name><name>ent</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Determine range of family numbers */</comment>
		<if_stmt><if>if <condition>(<expr><name>minfamily</name> <operator>&gt;</operator> <call><name>gk_ip_family</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>minfamily</name> <operator>=</operator> <call><name>gk_ip_family</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>maxfamily</name> <operator>&lt;</operator> <call><name>gk_ip_family</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>maxfamily</name> <operator>=</operator> <call><name>gk_ip_family</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Find minimum minbits */</comment>
		<if_stmt><if>if <condition>(<expr><name>minbits</name> <operator>&gt;</operator> <call><name>gk_ip_minbits</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>minbits</name> <operator>=</operator> <call><name>gk_ip_minbits</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Find minimum number of bits in common */</comment>
		<if_stmt><if>if <condition>(<expr><name>commonbits</name> <operator>&gt;</operator> <call><name>gk_ip_commonbits</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>commonbits</name> <operator>=</operator> <call><name>gk_ip_commonbits</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>commonbits</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>commonbits</name> <operator>=</operator> <call><name>bitncommon</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><call><name>gk_ip_addr</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>commonbits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Force minbits/commonbits to zero if more than one family. */</comment>
	<if_stmt><if>if <condition>(<expr><name>minfamily</name> <operator>!=</operator> <name>maxfamily</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>minbits</name> <operator>=</operator> <name>commonbits</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>minfamily_p</name> <operator>=</operator> <name>minfamily</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>maxfamily_p</name> <operator>=</operator> <name>maxfamily</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>minbits_p</name> <operator>=</operator> <name>minbits</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>commonbits_p</name> <operator>=</operator> <name>commonbits</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Same as above, but the GISTENTRY elements to examine are those with
 * indices listed in the offsets[] array.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>calc_inet_union_params_indexed</name><parameter_list>(<parameter><decl><type><name>GISTENTRY</name> <modifier>*</modifier></type><name>ent</name></decl></parameter>,
							   <parameter><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>offsets</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>noffsets</name></decl></parameter>,
							   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>minfamily_p</name></decl></parameter>,
							   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>maxfamily_p</name></decl></parameter>,
							   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>minbits_p</name></decl></parameter>,
							   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>commonbits_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>minfamily</name></decl>,
				<decl><type ref="prev"/><name>maxfamily</name></decl>,
				<decl><type ref="prev"/><name>minbits</name></decl>,
				<decl><type ref="prev"/><name>commonbits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>addr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GistInetKey</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Must be at least one key. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>noffsets</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize variables using the first key. */</comment>
	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>DatumGetInetKeyP</name><argument_list>(<argument><expr><name><name>ent</name><index>[<expr><name><name>offsets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>minfamily</name> <operator>=</operator> <name>maxfamily</name> <operator>=</operator> <call><name>gk_ip_family</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>minbits</name> <operator>=</operator> <call><name>gk_ip_minbits</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>commonbits</name> <operator>=</operator> <call><name>gk_ip_commonbits</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>gk_ip_addr</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Scan remaining keys. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>noffsets</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>DatumGetInetKeyP</name><argument_list>(<argument><expr><name><name>ent</name><index>[<expr><name><name>offsets</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Determine range of family numbers */</comment>
		<if_stmt><if>if <condition>(<expr><name>minfamily</name> <operator>&gt;</operator> <call><name>gk_ip_family</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>minfamily</name> <operator>=</operator> <call><name>gk_ip_family</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>maxfamily</name> <operator>&lt;</operator> <call><name>gk_ip_family</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>maxfamily</name> <operator>=</operator> <call><name>gk_ip_family</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Find minimum minbits */</comment>
		<if_stmt><if>if <condition>(<expr><name>minbits</name> <operator>&gt;</operator> <call><name>gk_ip_minbits</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>minbits</name> <operator>=</operator> <call><name>gk_ip_minbits</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Find minimum number of bits in common */</comment>
		<if_stmt><if>if <condition>(<expr><name>commonbits</name> <operator>&gt;</operator> <call><name>gk_ip_commonbits</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>commonbits</name> <operator>=</operator> <call><name>gk_ip_commonbits</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>commonbits</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>commonbits</name> <operator>=</operator> <call><name>bitncommon</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><call><name>gk_ip_addr</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>commonbits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Force minbits/commonbits to zero if more than one family. */</comment>
	<if_stmt><if>if <condition>(<expr><name>minfamily</name> <operator>!=</operator> <name>maxfamily</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>minbits</name> <operator>=</operator> <name>commonbits</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>minfamily_p</name> <operator>=</operator> <name>minfamily</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>maxfamily_p</name> <operator>=</operator> <name>maxfamily</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>minbits_p</name> <operator>=</operator> <name>minbits</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>commonbits_p</name> <operator>=</operator> <name>commonbits</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Construct a GistInetKey representing a union value.
 *
 * Inputs are the family/minbits/commonbits values to use, plus a pointer to
 * the address field of one of the union inputs.  (Since we're going to copy
 * just the bits-in-common, it doesn't matter which one.)
 */</comment>
<function><type><specifier>static</specifier> <name>GistInetKey</name> <modifier>*</modifier></type>
<name>build_inet_union_key</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>family</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>minbits</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>commonbits</name></decl></parameter>,
					 <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GistInetKey</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Make sure any unused bits are zeroed. */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>GistInetKey</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GistInetKey</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>gk_ip_family</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>family</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>gk_ip_minbits</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>minbits</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>gk_ip_commonbits</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>commonbits</name></expr>;</expr_stmt>

	<comment type="block">/* Clone appropriate bytes of the address. */</comment>
	<if_stmt><if>if <condition>(<expr><name>commonbits</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>gk_ip_addr</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><operator>(</operator><name>commonbits</name> <operator>+</operator> <literal type="number">7</literal><operator>)</operator> <operator>/</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Clean any unwanted bits in the last partial byte. */</comment>
	<if_stmt><if>if <condition>(<expr><name>commonbits</name> <operator>%</operator> <literal type="number">8</literal> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>gk_ip_addr</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call><index>[<expr><name>commonbits</name> <operator>/</operator> <literal type="number">8</literal></expr>]</index> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><literal type="number">0xFF</literal> <operator>&gt;&gt;</operator> <operator>(</operator><name>commonbits</name> <operator>%</operator> <literal type="number">8</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Set varlena header correctly. */</comment>
	<expr_stmt><expr><call><name>SET_GK_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * The GiST union function
 *
 * See comments at head of file for the definition of the union.
 */</comment>
<function><type><name>Datum</name></type>
<name>inet_gist_union</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GistEntryVector</name> <modifier>*</modifier></type><name>entryvec</name> <init>= <expr><operator>(</operator><name>GistEntryVector</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>ent</name> <init>= <expr><name><name>entryvec</name><operator>-&gt;</operator><name>vector</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>minfamily</name></decl>,
				<decl><type ref="prev"/><name>maxfamily</name></decl>,
				<decl><type ref="prev"/><name>minbits</name></decl>,
				<decl><type ref="prev"/><name>commonbits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>addr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GistInetKey</name> <modifier>*</modifier></type><name>tmp</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Determine parameters of the union. */</comment>
	<expr_stmt><expr><call><name>calc_inet_union_params</name><argument_list>(<argument><expr><name>ent</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>entryvec</name><operator>-&gt;</operator><name>n</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name>minfamily</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>maxfamily</name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name>minbits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>commonbits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If more than one family, emit family number zero. */</comment>
	<if_stmt><if>if <condition>(<expr><name>minfamily</name> <operator>!=</operator> <name>maxfamily</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>minfamily</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Initialize address using the first key. */</comment>
	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>DatumGetInetKeyP</name><argument_list>(<argument><expr><name><name>ent</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>gk_ip_addr</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Construct the union value. */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>build_inet_union_key</name><argument_list>(<argument><expr><name>minfamily</name></expr></argument>, <argument><expr><name>minbits</name></expr></argument>, <argument><expr><name>commonbits</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * The GiST compress function
 *
 * Convert an inet value to GistInetKey.
 */</comment>
<function><type><name>Datum</name></type>
<name>inet_gist_compress</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>GISTENTRY</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>retval</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>leafkey</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GISTENTRY</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>inet</name>	   <modifier>*</modifier></type><name>in</name> <init>= <expr><call><name>DatumGetInetPP</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>GistInetKey</name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>r</name> <operator>=</operator> <operator>(</operator><name>GistInetKey</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GistInetKey</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>gk_ip_family</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>ip_family</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>gk_ip_minbits</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>ip_bits</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>gk_ip_commonbits</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>gk_ip_maxbits</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>gk_ip_addr</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ip_addr</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>gk_ip_addrsize</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_GK_VARSIZE</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>gistentryinit</name><argument_list>(<argument><expr><operator>*</operator><name>retval</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>page</name></name></expr></argument>,
						  <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>gistentryinit</name><argument_list>(<argument><expr><operator>*</operator><name>retval</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
						  <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>page</name></name></expr></argument>,
						  <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * We do not need a decompress function, because the other GiST inet
 * support functions work with the GistInetKey representation.
 */</comment>

<comment type="block">/*
 * The GiST fetch function
 *
 * Reconstruct the original inet datum from a GistInetKey.
 */</comment>
<function><type><name>Datum</name></type>
<name>inet_gist_fetch</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>GISTENTRY</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GistInetKey</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>DatumGetInetKeyP</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>retval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>inet</name>	   <modifier>*</modifier></type><name>dst</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dst</name> <operator>=</operator> <operator>(</operator><name>inet</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>inet</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ip_family</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>gk_ip_family</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ip_bits</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>gk_ip_minbits</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>ip_addr</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>gk_ip_addr</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ip_addrsize</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_INET_VARSIZE</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GISTENTRY</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>gistentryinit</name><argument_list>(<argument><expr><operator>*</operator><name>retval</name></expr></argument>, <argument><expr><call><name>InetPGetDatum</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>page</name></name></expr></argument>,
				  <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * The GiST page split penalty function
 *
 * Charge a large penalty if address family doesn't match, or a somewhat
 * smaller one if the new value would degrade the union's minbits
 * (minimum netmask width).  Otherwise, penalty is inverse of the
 * new number of common address bits.
 */</comment>
<function><type><name>Datum</name></type>
<name>inet_gist_penalty</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>origent</name> <init>= <expr><operator>(</operator><name>GISTENTRY</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>newent</name> <init>= <expr><operator>(</operator><name>GISTENTRY</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float</name>	   <modifier>*</modifier></type><name>penalty</name> <init>= <expr><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GistInetKey</name> <modifier>*</modifier></type><name>orig</name> <init>= <expr><call><name>DatumGetInetKeyP</name><argument_list>(<argument><expr><name><name>origent</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></init></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>new</name> <init>= <expr><call><name>DatumGetInetKeyP</name><argument_list>(<argument><expr><name><name>newent</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>commonbits</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>gk_ip_family</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>gk_ip_family</name><argument_list>(<argument><expr><name>new</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>gk_ip_minbits</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <call><name>gk_ip_minbits</name><argument_list>(<argument><expr><name>new</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>commonbits</name> <operator>=</operator> <call><name>bitncommon</name><argument_list>(<argument><expr><call><name>gk_ip_addr</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>gk_ip_addr</name><argument_list>(<argument><expr><name>new</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>Min</name><argument_list>(<argument><expr><call><name>gk_ip_commonbits</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>gk_ip_commonbits</name><argument_list>(<argument><expr><name>new</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>commonbits</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>penalty</name> <operator>=</operator> <literal type="number">1.0f</literal> <operator>/</operator> <name>commonbits</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>penalty</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>penalty</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>penalty</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>penalty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * The GiST PickSplit method
 *
 * There are two ways to split. First one is to split by address families,
 * if there are multiple families appearing in the input.
 *
 * The second and more common way is to split by addresses. To achieve this,
 * determine the number of leading bits shared by all the keys, then split on
 * the next bit.  (We don't currently consider the netmask widths while doing
 * this; should we?)  If we fail to get a nontrivial split that way, split
 * 50-50.
 */</comment>
<function><type><name>Datum</name></type>
<name>inet_gist_picksplit</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GistEntryVector</name> <modifier>*</modifier></type><name>entryvec</name> <init>= <expr><operator>(</operator><name>GistEntryVector</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GIST_SPLITVEC</name> <modifier>*</modifier></type><name>splitvec</name> <init>= <expr><operator>(</operator><name>GIST_SPLITVEC</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>ent</name> <init>= <expr><name><name>entryvec</name><operator>-&gt;</operator><name>vector</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>minfamily</name></decl>,
				<decl><type ref="prev"/><name>maxfamily</name></decl>,
				<decl><type ref="prev"/><name>minbits</name></decl>,
				<decl><type ref="prev"/><name>commonbits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>addr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GistInetKey</name> <modifier>*</modifier></type><name>tmp</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>left_union</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>right_union</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxoff</name></decl>,
				<decl><type ref="prev"/><name>nbytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>i</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>left</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>right</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <name><name>entryvec</name><operator>-&gt;</operator><name>n</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <operator>(</operator><name>maxoff</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><name>left</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>right</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>splitvec</name><operator>-&gt;</operator><name>spl_left</name></name> <operator>=</operator> <name>left</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>splitvec</name><operator>-&gt;</operator><name>spl_right</name></name> <operator>=</operator> <name>right</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>splitvec</name><operator>-&gt;</operator><name>spl_nleft</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>splitvec</name><operator>-&gt;</operator><name>spl_nright</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Determine parameters of the union of all the inputs. */</comment>
	<expr_stmt><expr><call><name>calc_inet_union_params</name><argument_list>(<argument><expr><name>ent</name></expr></argument>, <argument><expr><name>FirstOffsetNumber</name></expr></argument>, <argument><expr><name>maxoff</name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name>minfamily</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>maxfamily</name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name>minbits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>commonbits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>minfamily</name> <operator>!=</operator> <name>maxfamily</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Multiple families, so split by family. */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>i</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/*
			 * If there's more than 2 families, all but maxfamily go into the
			 * left union.  This could only happen if the inputs include some
			 * IPv4, some IPv6, and some already-multiple-family unions.
			 */</comment>
			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>DatumGetInetKeyP</name><argument_list>(<argument><expr><name><name>ent</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>gk_ip_family</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>maxfamily</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>left</name><index>[<expr><name><name>splitvec</name><operator>-&gt;</operator><name>spl_nleft</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>right</name><index>[<expr><name><name>splitvec</name><operator>-&gt;</operator><name>spl_nright</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Split on the next bit after the common bits.  If that yields a
		 * trivial split, try the next bit position to the right.  Repeat till
		 * success; or if we run out of bits, do an arbitrary 50-50 split.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>maxbits</name> <init>= <expr><call><name>ip_family_maxbits</name><argument_list>(<argument><expr><name>minfamily</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><name>commonbits</name> <operator>&lt;</operator> <name>maxbits</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Split using the commonbits'th bit position. */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>bitbyte</name> <init>= <expr><name>commonbits</name> <operator>/</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>bitmask</name> <init>= <expr><literal type="number">0x80</literal> <operator>&gt;&gt;</operator> <operator>(</operator><name>commonbits</name> <operator>%</operator> <literal type="number">8</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>splitvec</name><operator>-&gt;</operator><name>spl_nleft</name></name> <operator>=</operator> <name><name>splitvec</name><operator>-&gt;</operator><name>spl_nright</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>i</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>DatumGetInetKeyP</name><argument_list>(<argument><expr><name><name>ent</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>gk_ip_addr</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>addr</name><index>[<expr><name>bitbyte</name></expr>]</index></name> <operator>&amp;</operator> <name>bitmask</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>left</name><index>[<expr><name><name>splitvec</name><operator>-&gt;</operator><name>spl_nleft</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>right</name><index>[<expr><name><name>splitvec</name><operator>-&gt;</operator><name>spl_nright</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></for>

			<if_stmt><if>if <condition>(<expr><name><name>splitvec</name><operator>-&gt;</operator><name>spl_nleft</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>splitvec</name><operator>-&gt;</operator><name>spl_nright</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* success */</comment>
			<expr_stmt><expr><name>commonbits</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>

		<if_stmt><if>if <condition>(<expr><name>commonbits</name> <operator>&gt;=</operator> <name>maxbits</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Failed ... do a 50-50 split. */</comment>
			<expr_stmt><expr><name><name>splitvec</name><operator>-&gt;</operator><name>spl_nleft</name></name> <operator>=</operator> <name><name>splitvec</name><operator>-&gt;</operator><name>spl_nright</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>maxoff</name> <operator>/</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name><name>left</name><index>[<expr><name><name>splitvec</name><operator>-&gt;</operator><name>spl_nleft</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			</block_content>}</block></for>
			<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>i</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name><name>right</name><index>[<expr><name><name>splitvec</name><operator>-&gt;</operator><name>spl_nright</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Compute the union value for each side from scratch.  In most cases we
	 * could approximate the union values with what we already know, but this
	 * ensures that each side has minbits and commonbits set as high as
	 * possible.
	 */</comment>
	<expr_stmt><expr><call><name>calc_inet_union_params_indexed</name><argument_list>(<argument><expr><name>ent</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name><name>splitvec</name><operator>-&gt;</operator><name>spl_nleft</name></name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>minfamily</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>maxfamily</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>minbits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>commonbits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>minfamily</name> <operator>!=</operator> <name>maxfamily</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>minfamily</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>DatumGetInetKeyP</name><argument_list>(<argument><expr><name><name>ent</name><index>[<expr><name><name>left</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>gk_ip_addr</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>left_union</name> <operator>=</operator> <call><name>build_inet_union_key</name><argument_list>(<argument><expr><name>minfamily</name></expr></argument>, <argument><expr><name>minbits</name></expr></argument>, <argument><expr><name>commonbits</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>splitvec</name><operator>-&gt;</operator><name>spl_ldatum</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>left_union</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>calc_inet_union_params_indexed</name><argument_list>(<argument><expr><name>ent</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name><name>splitvec</name><operator>-&gt;</operator><name>spl_nright</name></name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>minfamily</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>maxfamily</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>minbits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>commonbits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>minfamily</name> <operator>!=</operator> <name>maxfamily</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>minfamily</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>DatumGetInetKeyP</name><argument_list>(<argument><expr><name><name>ent</name><index>[<expr><name><name>right</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>gk_ip_addr</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>right_union</name> <operator>=</operator> <call><name>build_inet_union_key</name><argument_list>(<argument><expr><name>minfamily</name></expr></argument>, <argument><expr><name>minbits</name></expr></argument>, <argument><expr><name>commonbits</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>splitvec</name><operator>-&gt;</operator><name>spl_rdatum</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>right_union</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>splitvec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * The GiST equality function
 */</comment>
<function><type><name>Datum</name></type>
<name>inet_gist_same</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GistInetKey</name> <modifier>*</modifier></type><name>left</name> <init>= <expr><call><name>DatumGetInetKeyP</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GistInetKey</name> <modifier>*</modifier></type><name>right</name> <init>= <expr><call><name>DatumGetInetKeyP</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <operator>(</operator><call><name>gk_ip_family</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>gk_ip_family</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			   <call><name>gk_ip_minbits</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>gk_ip_minbits</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			   <call><name>gk_ip_commonbits</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>gk_ip_commonbits</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			   <call><name>memcmp</name><argument_list>(<argument><expr><call><name>gk_ip_addr</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>gk_ip_addr</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gk_ip_addrsize</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
