<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/utils/adt/regproc.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * regproc.c
 *	  Functions for the built-in types regproc, regclass, regtype, etc.
 *
 * These types are all binary-compatible with type Oid, and rely on Oid
 * for comparison and so forth.  Their only interesting behavior is in
 * special I/O conversion routines.
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/utils/adt/regproc.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_ts_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_ts_dict.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/scansup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/regproc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/varlena.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>format_operator_internal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>operator_oid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force_qualify</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>format_procedure_internal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>procedure_oid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force_qualify</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>parseNameAndArgTypes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allowNone</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>names</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nargs</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>argtypes</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block" format="doxygen">/*****************************************************************************
 *	 USER I/O ROUTINES														 *
 *****************************************************************************/</comment>

<comment type="block">/*
 * regprocin		- converts "proname" to proc OID
 *
 * We also accept a numeric OID, for symmetry with the output routine.
 *
 * '-' signifies unknown (OID 0).  In all other cases, the input must
 * match an existing pg_proc entry.
 */</comment>
<function><type><name>Datum</name></type>
<name>regprocin</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pro_name_or_oid</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RegProcedure</name></type> <name>result</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>names</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>clist</name></decl>;</decl_stmt>

	<comment type="block">/* '-' ? */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>pro_name_or_oid</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Numeric OID? */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pro_name_or_oid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator>
		<name><name>pro_name_or_oid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'9'</literal> <operator>&amp;&amp;</operator>
		<call><name>strspn</name><argument_list>(<argument><expr><name>pro_name_or_oid</name></expr></argument>, <argument><expr><literal type="string">"0123456789"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>pro_name_or_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>oidin</name></expr></argument>,
													  <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>pro_name_or_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Else it's a name, possibly schema-qualified */</comment>

	<comment type="block">/*
	 * We should never get here in bootstrap mode, as all references should
	 * have been resolved by genbki.pl.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"regproc values must be OIDs in bootstrap mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Normal case: parse the name into components and see if it matches any
	 * pg_proc entries in the current search path.
	 */</comment>
	<expr_stmt><expr><name>names</name> <operator>=</operator> <call><name>stringToQualifiedNameList</name><argument_list>(<argument><expr><name>pro_name_or_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>clist</name> <operator>=</operator> <call><name>FuncnameGetCandidates</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>clist</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>pro_name_or_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>clist</name><operator>-&gt;</operator><name>next</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_AMBIGUOUS_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"more than one function named \"%s\""</literal></expr></argument>,
						<argument><expr><name>pro_name_or_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>clist</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * to_regproc	- converts "proname" to proc OID
 *
 * If the name is not found, we return NULL.
 */</comment>
<function><type><name>Datum</name></type>
<name>to_regproc</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pro_name</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>names</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>clist</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Parse the name into components and see if it matches any pg_proc
	 * entries in the current search path.
	 */</comment>
	<expr_stmt><expr><name>names</name> <operator>=</operator> <call><name>stringToQualifiedNameList</name><argument_list>(<argument><expr><name>pro_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>clist</name> <operator>=</operator> <call><name>FuncnameGetCandidates</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>clist</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>clist</name><operator>-&gt;</operator><name>next</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name><name>clist</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * regprocout		- converts proc OID to "pro_name"
 */</comment>
<function><type><name>Datum</name></type>
<name>regprocout</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RegProcedure</name></type> <name>proid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>proctup</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>proid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>proctup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>proid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procform</name> <init>= <expr><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>proname</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>procform</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * In bootstrap mode, skip the fancy namespace stuff and just return
		 * the proc name.  (This path is only needed for debugging output
		 * anyway.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>proname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>clist</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Would this proc be found (uniquely!) by regprocin? If not,
			 * qualify it.
			 */</comment>
			<expr_stmt><expr><name>clist</name> <operator>=</operator> <call><name>FuncnameGetCandidates</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>proname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>clist</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>clist</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				<name><name>clist</name><operator>-&gt;</operator><name>oid</name></name> <operator>==</operator> <name>proid</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>nspname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>procform</name><operator>-&gt;</operator><name>pronamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>proname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* If OID doesn't match any pg_proc entry, return it numerically */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name>proid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		regprocrecv			- converts external binary format to regproc
 */</comment>
<function><type><name>Datum</name></type>
<name>regprocrecv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Exactly the same as oidrecv, so share code */</comment>
	<return>return <expr><call><name>oidrecv</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		regprocsend			- converts regproc to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>regprocsend</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Exactly the same as oidsend, so share code */</comment>
	<return>return <expr><call><name>oidsend</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * regprocedurein		- converts "proname(args)" to proc OID
 *
 * We also accept a numeric OID, for symmetry with the output routine.
 *
 * '-' signifies unknown (OID 0).  In all other cases, the input must
 * match an existing pg_proc entry.
 */</comment>
<function><type><name>Datum</name></type>
<name>regprocedurein</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pro_name_or_oid</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RegProcedure</name></type> <name>result</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>names</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>argtypes</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>clist</name></decl>;</decl_stmt>

	<comment type="block">/* '-' ? */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>pro_name_or_oid</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Numeric OID? */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pro_name_or_oid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator>
		<name><name>pro_name_or_oid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'9'</literal> <operator>&amp;&amp;</operator>
		<call><name>strspn</name><argument_list>(<argument><expr><name>pro_name_or_oid</name></expr></argument>, <argument><expr><literal type="string">"0123456789"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>pro_name_or_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>oidin</name></expr></argument>,
													  <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>pro_name_or_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* The rest of this wouldn't work in bootstrap mode */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"regprocedure values must be OIDs in bootstrap mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Else it's a name and arguments.  Parse the name and arguments, look up
	 * potential matches in the current namespace search list, and scan to see
	 * which one exactly matches the given argument types.  (There will not be
	 * more than one match.)
	 */</comment>
	<expr_stmt><expr><call><name>parseNameAndArgTypes</name><argument_list>(<argument><expr><name>pro_name_or_oid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>names</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nargs</name></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>clist</name> <operator>=</operator> <call><name>FuncnameGetCandidates</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init>;</init> <condition><expr><name>clist</name></expr>;</condition> <incr><expr><name>clist</name> <operator>=</operator> <name><name>clist</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>clist</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>, <argument><expr><name>nargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>clist</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>pro_name_or_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>clist</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * to_regprocedure	- converts "proname(args)" to proc OID
 *
 * If the name is not found, we return NULL.
 */</comment>
<function><type><name>Datum</name></type>
<name>to_regprocedure</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pro_name</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>names</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>argtypes</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>clist</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Parse the name and arguments, look up potential matches in the current
	 * namespace search list, and scan to see which one exactly matches the
	 * given argument types.    (There will not be more than one match.)
	 */</comment>
	<expr_stmt><expr><call><name>parseNameAndArgTypes</name><argument_list>(<argument><expr><name>pro_name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>names</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nargs</name></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>clist</name> <operator>=</operator> <call><name>FuncnameGetCandidates</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init>;</init> <condition><expr><name>clist</name></expr>;</condition> <incr><expr><name>clist</name> <operator>=</operator> <name><name>clist</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>clist</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>, <argument><expr><name>nargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name><name>clist</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * format_procedure		- converts proc OID to "pro_name(args)"
 *
 * This exports the useful functionality of regprocedureout for use
 * in other backend modules.  The result is a palloc'd string.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>format_procedure</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>procedure_oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>format_procedure_internal</name><argument_list>(<argument><expr><name>procedure_oid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>format_procedure_qualified</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>procedure_oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>format_procedure_internal</name><argument_list>(<argument><expr><name>procedure_oid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Routine to produce regprocedure names; see format_procedure above.
 *
 * force_qualify says whether to schema-qualify; if true, the name is always
 * qualified regardless of search_path visibility.  Otherwise the name is only
 * qualified if the function is not in path.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>format_procedure_internal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>procedure_oid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force_qualify</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>proctup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>proctup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>procedure_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procform</name> <init>= <expr><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>proname</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>procform</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name> <init>= <expr><name><name>procform</name><operator>-&gt;</operator><name>pronargs</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

		<comment type="block">/* XXX no support here for bootstrap mode */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Would this proc be found (given the right args) by regprocedurein?
		 * If not, or if caller requests it, we need to qualify it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>force_qualify</name> <operator>&amp;&amp;</operator> <call><name>FunctionIsVisible</name><argument_list>(<argument><expr><name>procedure_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nspname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>procform</name><operator>-&gt;</operator><name>pronamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s("</literal></expr></argument>,
						 <argument><expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>proname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>thisargtype</name> <init>= <expr><name><name>procform</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
								   <argument><expr><ternary><condition><expr><name>force_qualify</name></expr> ?</condition><then>
								   <expr><call><name>format_type_be_qualified</name><argument_list>(<argument><expr><name>thisargtype</name></expr></argument>)</argument_list></call></expr> </then><else>:
								   <expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>thisargtype</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* If OID doesn't match any pg_proc entry, return it numerically */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name>procedure_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Output an objname/objargs representation for the procedure with the
 * given OID.  If it doesn't exist, an error is thrown.
 *
 * This can be used to feed get_object_address.
 */</comment>
<function><type><name>void</name></type>
<name>format_procedure_parts</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>procedure_oid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>objnames</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>objargs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>proctup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>proctup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>procedure_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for procedure with OID %u"</literal></expr></argument>, <argument><expr><name>procedure_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>procform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nargs</name> <operator>=</operator> <name><name>procform</name><operator>-&gt;</operator><name>pronargs</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>objnames</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><call><name>get_namespace_name_or_temp</name><argument_list>(<argument><expr><name><name>procform</name><operator>-&gt;</operator><name>pronamespace</name></name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>procform</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>objargs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>thisargtype</name> <init>= <expr><name><name>procform</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><operator>*</operator><name>objargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>objargs</name></expr></argument>, <argument><expr><call><name>format_type_be_qualified</name><argument_list>(<argument><expr><name>thisargtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * regprocedureout		- converts proc OID to "pro_name(args)"
 */</comment>
<function><type><name>Datum</name></type>
<name>regprocedureout</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RegProcedure</name></type> <name>proid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>proid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>format_procedure</name><argument_list>(<argument><expr><name>proid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		regprocedurerecv			- converts external binary format to regprocedure
 */</comment>
<function><type><name>Datum</name></type>
<name>regprocedurerecv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Exactly the same as oidrecv, so share code */</comment>
	<return>return <expr><call><name>oidrecv</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		regproceduresend			- converts regprocedure to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>regproceduresend</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Exactly the same as oidsend, so share code */</comment>
	<return>return <expr><call><name>oidsend</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * regoperin		- converts "oprname" to operator OID
 *
 * We also accept a numeric OID, for symmetry with the output routine.
 *
 * '0' signifies unknown (OID 0).  In all other cases, the input must
 * match an existing pg_operator entry.
 */</comment>
<function><type><name>Datum</name></type>
<name>regoperin</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>opr_name_or_oid</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>names</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>clist</name></decl>;</decl_stmt>

	<comment type="block">/* '0' ? */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>opr_name_or_oid</name></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Numeric OID? */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>opr_name_or_oid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator>
		<name><name>opr_name_or_oid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'9'</literal> <operator>&amp;&amp;</operator>
		<call><name>strspn</name><argument_list>(<argument><expr><name>opr_name_or_oid</name></expr></argument>, <argument><expr><literal type="string">"0123456789"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>opr_name_or_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>oidin</name></expr></argument>,
													  <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>opr_name_or_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Else it's a name, possibly schema-qualified */</comment>

	<comment type="block">/* The rest of this wouldn't work in bootstrap mode */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"regoper values must be OIDs in bootstrap mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Normal case: parse the name into components and see if it matches any
	 * pg_operator entries in the current search path.
	 */</comment>
	<expr_stmt><expr><name>names</name> <operator>=</operator> <call><name>stringToQualifiedNameList</name><argument_list>(<argument><expr><name>opr_name_or_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>clist</name> <operator>=</operator> <call><name>OpernameGetCandidates</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>clist</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operator does not exist: %s"</literal></expr></argument>, <argument><expr><name>opr_name_or_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>clist</name><operator>-&gt;</operator><name>next</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_AMBIGUOUS_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"more than one operator named %s"</literal></expr></argument>,
						<argument><expr><name>opr_name_or_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>clist</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * to_regoper		- converts "oprname" to operator OID
 *
 * If the name is not found, we return NULL.
 */</comment>
<function><type><name>Datum</name></type>
<name>to_regoper</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>opr_name</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>names</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>clist</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Parse the name into components and see if it matches any pg_operator
	 * entries in the current search path.
	 */</comment>
	<expr_stmt><expr><name>names</name> <operator>=</operator> <call><name>stringToQualifiedNameList</name><argument_list>(<argument><expr><name>opr_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>clist</name> <operator>=</operator> <call><name>OpernameGetCandidates</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>clist</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>clist</name><operator>-&gt;</operator><name>next</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name><name>clist</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * regoperout		- converts operator OID to "opr_name"
 */</comment>
<function><type><name>Datum</name></type>
<name>regoperout</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oprid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>opertup</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>oprid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>opertup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oprid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>operform</name> <init>= <expr><operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oprname</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>operform</name><operator>-&gt;</operator><name>oprname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * In bootstrap mode, skip the fancy namespace stuff and just return
		 * the oper name.  (This path is only needed for debugging output
		 * anyway.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>oprname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>clist</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Would this oper be found (uniquely!) by regoperin? If not,
			 * qualify it.
			 */</comment>
			<expr_stmt><expr><name>clist</name> <operator>=</operator> <call><name>OpernameGetCandidates</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>oprname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>clist</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>clist</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				<name><name>clist</name><operator>-&gt;</operator><name>oid</name></name> <operator>==</operator> <name>oprid</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>oprname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>operform</name><operator>-&gt;</operator><name>oprnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>quote_identifier</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>oprname</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"%s.%s"</literal></expr></argument>, <argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>oprname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If OID doesn't match any pg_operator entry, return it numerically
		 */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name>oprid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		regoperrecv			- converts external binary format to regoper
 */</comment>
<function><type><name>Datum</name></type>
<name>regoperrecv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Exactly the same as oidrecv, so share code */</comment>
	<return>return <expr><call><name>oidrecv</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		regopersend			- converts regoper to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>regopersend</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Exactly the same as oidsend, so share code */</comment>
	<return>return <expr><call><name>oidsend</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * regoperatorin		- converts "oprname(args)" to operator OID
 *
 * We also accept a numeric OID, for symmetry with the output routine.
 *
 * '0' signifies unknown (OID 0).  In all other cases, the input must
 * match an existing pg_operator entry.
 */</comment>
<function><type><name>Datum</name></type>
<name>regoperatorin</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>opr_name_or_oid</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>names</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>argtypes</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* '0' ? */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>opr_name_or_oid</name></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Numeric OID? */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>opr_name_or_oid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator>
		<name><name>opr_name_or_oid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'9'</literal> <operator>&amp;&amp;</operator>
		<call><name>strspn</name><argument_list>(<argument><expr><name>opr_name_or_oid</name></expr></argument>, <argument><expr><literal type="string">"0123456789"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>opr_name_or_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>oidin</name></expr></argument>,
													  <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>opr_name_or_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* The rest of this wouldn't work in bootstrap mode */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"regoperator values must be OIDs in bootstrap mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Else it's a name and arguments.  Parse the name and arguments, look up
	 * potential matches in the current namespace search list, and scan to see
	 * which one exactly matches the given argument types.  (There will not be
	 * more than one match.)
	 */</comment>
	<expr_stmt><expr><call><name>parseNameAndArgTypes</name><argument_list>(<argument><expr><name>opr_name_or_oid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>names</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nargs</name></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_PARAMETER</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"missing argument"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use NONE to denote the missing argument of a unary operator."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_ARGUMENTS</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too many arguments"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Provide two argument types for operator."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>OpernameGetOprid</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><name><name>argtypes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argtypes</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operator does not exist: %s"</literal></expr></argument>, <argument><expr><name>opr_name_or_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * to_regoperator	- converts "oprname(args)" to operator OID
 *
 * If the name is not found, we return NULL.
 */</comment>
<function><type><name>Datum</name></type>
<name>to_regoperator</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>opr_name_or_oid</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>names</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>argtypes</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Parse the name and arguments, look up potential matches in the current
	 * namespace search list, and scan to see which one exactly matches the
	 * given argument types.    (There will not be more than one match.)
	 */</comment>
	<expr_stmt><expr><call><name>parseNameAndArgTypes</name><argument_list>(<argument><expr><name>opr_name_or_oid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>names</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nargs</name></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_PARAMETER</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"missing argument"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use NONE to denote the missing argument of a unary operator."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_ARGUMENTS</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too many arguments"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Provide two argument types for operator."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>OpernameGetOprid</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><name><name>argtypes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argtypes</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * format_operator		- converts operator OID to "opr_name(args)"
 *
 * This exports the useful functionality of regoperatorout for use
 * in other backend modules.  The result is a palloc'd string.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>format_operator_internal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>operator_oid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force_qualify</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>opertup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>opertup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>operator_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>operform</name> <init>= <expr><operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oprname</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>operform</name><operator>-&gt;</operator><name>oprname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

		<comment type="block">/* XXX no support here for bootstrap mode */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Would this oper be found (given the right args) by regoperatorin?
		 * If not, or if caller explicitly requests it, we need to qualify it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>force_qualify</name> <operator>||</operator> <operator>!</operator><call><name>OperatorIsVisible</name><argument_list>(<argument><expr><name>operator_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>operform</name><operator>-&gt;</operator><name>oprnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s."</literal></expr></argument>,
							 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s("</literal></expr></argument>, <argument><expr><name>oprname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>operform</name><operator>-&gt;</operator><name>oprleft</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s,"</literal></expr></argument>,
							 <argument><expr><ternary><condition><expr><name>force_qualify</name></expr> ?</condition><then>
							 <expr><call><name>format_type_be_qualified</name><argument_list>(<argument><expr><name><name>operform</name><operator>-&gt;</operator><name>oprleft</name></name></expr></argument>)</argument_list></call></expr> </then><else>:
							 <expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>operform</name><operator>-&gt;</operator><name>oprleft</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NONE,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>operform</name><operator>-&gt;</operator><name>oprright</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s)"</literal></expr></argument>,
							 <argument><expr><ternary><condition><expr><name>force_qualify</name></expr> ?</condition><then>
							 <expr><call><name>format_type_be_qualified</name><argument_list>(<argument><expr><name><name>operform</name><operator>-&gt;</operator><name>oprright</name></name></expr></argument>)</argument_list></call></expr> </then><else>:
							 <expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>operform</name><operator>-&gt;</operator><name>oprright</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NONE)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If OID doesn't match any pg_operator entry, return it numerically
		 */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name>operator_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>format_operator</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>operator_oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>format_operator_internal</name><argument_list>(<argument><expr><name>operator_oid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>format_operator_qualified</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>operator_oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>format_operator_internal</name><argument_list>(<argument><expr><name>operator_oid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>format_operator_parts</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>operator_oid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>objnames</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>objargs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>opertup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>oprForm</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>opertup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>operator_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for operator with OID %u"</literal></expr></argument>,
			 <argument><expr><name>operator_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oprForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>objnames</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><call><name>get_namespace_name_or_temp</name><argument_list>(<argument><expr><name><name>oprForm</name><operator>-&gt;</operator><name>oprnamespace</name></name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>oprForm</name><operator>-&gt;</operator><name>oprname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>objargs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>oprForm</name><operator>-&gt;</operator><name>oprleft</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>objargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>objargs</name></expr></argument>,
						   <argument><expr><call><name>format_type_be_qualified</name><argument_list>(<argument><expr><name><name>oprForm</name><operator>-&gt;</operator><name>oprleft</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>oprForm</name><operator>-&gt;</operator><name>oprright</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>objargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>objargs</name></expr></argument>,
						   <argument><expr><call><name>format_type_be_qualified</name><argument_list>(<argument><expr><name><name>oprForm</name><operator>-&gt;</operator><name>oprright</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * regoperatorout		- converts operator OID to "opr_name(args)"
 */</comment>
<function><type><name>Datum</name></type>
<name>regoperatorout</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oprid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>oprid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>format_operator</name><argument_list>(<argument><expr><name>oprid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		regoperatorrecv			- converts external binary format to regoperator
 */</comment>
<function><type><name>Datum</name></type>
<name>regoperatorrecv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Exactly the same as oidrecv, so share code */</comment>
	<return>return <expr><call><name>oidrecv</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		regoperatorsend			- converts regoperator to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>regoperatorsend</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Exactly the same as oidsend, so share code */</comment>
	<return>return <expr><call><name>oidsend</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * regclassin		- converts "classname" to class OID
 *
 * We also accept a numeric OID, for symmetry with the output routine.
 *
 * '-' signifies unknown (OID 0).  In all other cases, the input must
 * match an existing pg_class entry.
 */</comment>
<function><type><name>Datum</name></type>
<name>regclassin</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>class_name_or_oid</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>names</name></decl>;</decl_stmt>

	<comment type="block">/* '-' ? */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>class_name_or_oid</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Numeric OID? */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>class_name_or_oid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator>
		<name><name>class_name_or_oid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'9'</literal> <operator>&amp;&amp;</operator>
		<call><name>strspn</name><argument_list>(<argument><expr><name>class_name_or_oid</name></expr></argument>, <argument><expr><literal type="string">"0123456789"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>class_name_or_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>oidin</name></expr></argument>,
													  <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>class_name_or_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Else it's a name, possibly schema-qualified */</comment>

	<comment type="block">/* The rest of this wouldn't work in bootstrap mode */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"regclass values must be OIDs in bootstrap mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Normal case: parse the name into components and see if it matches any
	 * pg_class entries in the current search path.
	 */</comment>
	<expr_stmt><expr><name>names</name> <operator>=</operator> <call><name>stringToQualifiedNameList</name><argument_list>(<argument><expr><name>class_name_or_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We might not even have permissions on this relation; don't lock it. */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * to_regclass		- converts "classname" to class OID
 *
 * If the name is not found, we return NULL.
 */</comment>
<function><type><name>Datum</name></type>
<name>to_regclass</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>class_name</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>names</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Parse the name into components and see if it matches any pg_class
	 * entries in the current search path.
	 */</comment>
	<expr_stmt><expr><name>names</name> <operator>=</operator> <call><name>stringToQualifiedNameList</name><argument_list>(<argument><expr><name>class_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We might not even have permissions on this relation; don't lock it. */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * regclassout		- converts class OID to "class_name"
 */</comment>
<function><type><name>Datum</name></type>
<name>regclassout</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>classid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>classtup</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>classid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>classtup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>classid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>classtup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classform</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>classtup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>classname</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>classform</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * In bootstrap mode, skip the fancy namespace stuff and just return
		 * the class name.  (This path is only needed for debugging output
		 * anyway.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>classname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Would this class be found by regclassin? If not, qualify it.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>RelationIsVisible</name><argument_list>(<argument><expr><name>classid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>nspname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>classform</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>classname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>classtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* If OID doesn't match any pg_class entry, return it numerically */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name>classid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		regclassrecv			- converts external binary format to regclass
 */</comment>
<function><type><name>Datum</name></type>
<name>regclassrecv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Exactly the same as oidrecv, so share code */</comment>
	<return>return <expr><call><name>oidrecv</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		regclasssend			- converts regclass to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>regclasssend</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Exactly the same as oidsend, so share code */</comment>
	<return>return <expr><call><name>oidsend</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * regtypein		- converts "typename" to type OID
 *
 * The type name can be specified using the full type syntax recognized by
 * the parser; for example, DOUBLE PRECISION and INTEGER[] will work and be
 * translated to the correct type names.  (We ignore any typmod info
 * generated by the parser, however.)
 *
 * We also accept a numeric OID, for symmetry with the output routine,
 * and for possible use in bootstrap mode.
 *
 * '-' signifies unknown (OID 0).  In all other cases, the input must
 * match an existing pg_type entry.
 */</comment>
<function><type><name>Datum</name></type>
<name>regtypein</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typ_name_or_oid</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name></decl>;</decl_stmt>

	<comment type="block">/* '-' ? */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typ_name_or_oid</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Numeric OID? */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>typ_name_or_oid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator>
		<name><name>typ_name_or_oid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'9'</literal> <operator>&amp;&amp;</operator>
		<call><name>strspn</name><argument_list>(<argument><expr><name>typ_name_or_oid</name></expr></argument>, <argument><expr><literal type="string">"0123456789"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>typ_name_or_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>oidin</name></expr></argument>,
													  <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>typ_name_or_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Else it's a type name, possibly schema-qualified or decorated */</comment>

	<comment type="block">/* The rest of this wouldn't work in bootstrap mode */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"regtype values must be OIDs in bootstrap mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Normal case: invoke the full parser to deal with special cases such as
	 * array syntax.
	 */</comment>
	<expr_stmt><expr><call><name>parseTypeString</name><argument_list>(<argument><expr><name>typ_name_or_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typmod</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * to_regtype		- converts "typename" to type OID
 *
 * If the name is not found, we return NULL.
 */</comment>
<function><type><name>Datum</name></type>
<name>to_regtype</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typ_name</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Invoke the full parser to deal with special cases such as array syntax.
	 */</comment>
	<expr_stmt><expr><call><name>parseTypeString</name><argument_list>(<argument><expr><name>typ_name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typmod</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * regtypeout		- converts type OID to "typ_name"
 */</comment>
<function><type><name>Datum</name></type>
<name>regtypeout</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>typetup</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>typid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>typetup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>typetup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typeform</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typetup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * In bootstrap mode, skip the fancy namespace stuff and just return
		 * the type name.  (This path is only needed for debugging output
		 * anyway.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typname</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>typeform</name><operator>-&gt;</operator><name>typname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>typname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>format_type_be</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typetup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* If OID doesn't match any pg_type entry, return it numerically */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		regtyperecv			- converts external binary format to regtype
 */</comment>
<function><type><name>Datum</name></type>
<name>regtyperecv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Exactly the same as oidrecv, so share code */</comment>
	<return>return <expr><call><name>oidrecv</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		regtypesend			- converts regtype to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>regtypesend</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Exactly the same as oidsend, so share code */</comment>
	<return>return <expr><call><name>oidsend</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * regconfigin		- converts "tsconfigname" to tsconfig OID
 *
 * We also accept a numeric OID, for symmetry with the output routine.
 *
 * '-' signifies unknown (OID 0).  In all other cases, the input must
 * match an existing pg_ts_config entry.
 */</comment>
<function><type><name>Datum</name></type>
<name>regconfigin</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cfg_name_or_oid</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>names</name></decl>;</decl_stmt>

	<comment type="block">/* '-' ? */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>cfg_name_or_oid</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Numeric OID? */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cfg_name_or_oid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator>
		<name><name>cfg_name_or_oid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'9'</literal> <operator>&amp;&amp;</operator>
		<call><name>strspn</name><argument_list>(<argument><expr><name>cfg_name_or_oid</name></expr></argument>, <argument><expr><literal type="string">"0123456789"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>cfg_name_or_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>oidin</name></expr></argument>,
													  <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>cfg_name_or_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* The rest of this wouldn't work in bootstrap mode */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"regconfig values must be OIDs in bootstrap mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Normal case: parse the name into components and see if it matches any
	 * pg_ts_config entries in the current search path.
	 */</comment>
	<expr_stmt><expr><name>names</name> <operator>=</operator> <call><name>stringToQualifiedNameList</name><argument_list>(<argument><expr><name>cfg_name_or_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_ts_config_oid</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * regconfigout		- converts tsconfig OID to "tsconfigname"
 */</comment>
<function><type><name>Datum</name></type>
<name>regconfigout</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>cfgid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>cfgtup</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>cfgid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>cfgtup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TSCONFIGOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>cfgid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>cfgtup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_ts_config</name></type> <name>cfgform</name> <init>= <expr><operator>(</operator><name>Form_pg_ts_config</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>cfgtup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cfgname</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>cfgform</name><operator>-&gt;</operator><name>cfgname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Would this config be found by regconfigin? If not, qualify it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TSConfigIsVisible</name><argument_list>(<argument><expr><name>cfgid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nspname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>cfgform</name><operator>-&gt;</operator><name>cfgnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>cfgname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>cfgtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* If OID doesn't match any pg_ts_config row, return it numerically */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name>cfgid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		regconfigrecv			- converts external binary format to regconfig
 */</comment>
<function><type><name>Datum</name></type>
<name>regconfigrecv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Exactly the same as oidrecv, so share code */</comment>
	<return>return <expr><call><name>oidrecv</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		regconfigsend			- converts regconfig to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>regconfigsend</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Exactly the same as oidsend, so share code */</comment>
	<return>return <expr><call><name>oidsend</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * regdictionaryin		- converts "tsdictionaryname" to tsdictionary OID
 *
 * We also accept a numeric OID, for symmetry with the output routine.
 *
 * '-' signifies unknown (OID 0).  In all other cases, the input must
 * match an existing pg_ts_dict entry.
 */</comment>
<function><type><name>Datum</name></type>
<name>regdictionaryin</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dict_name_or_oid</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>names</name></decl>;</decl_stmt>

	<comment type="block">/* '-' ? */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>dict_name_or_oid</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Numeric OID? */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dict_name_or_oid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator>
		<name><name>dict_name_or_oid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'9'</literal> <operator>&amp;&amp;</operator>
		<call><name>strspn</name><argument_list>(<argument><expr><name>dict_name_or_oid</name></expr></argument>, <argument><expr><literal type="string">"0123456789"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>dict_name_or_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>oidin</name></expr></argument>,
													  <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>dict_name_or_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* The rest of this wouldn't work in bootstrap mode */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"regdictionary values must be OIDs in bootstrap mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Normal case: parse the name into components and see if it matches any
	 * pg_ts_dict entries in the current search path.
	 */</comment>
	<expr_stmt><expr><name>names</name> <operator>=</operator> <call><name>stringToQualifiedNameList</name><argument_list>(<argument><expr><name>dict_name_or_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_ts_dict_oid</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * regdictionaryout		- converts tsdictionary OID to "tsdictionaryname"
 */</comment>
<function><type><name>Datum</name></type>
<name>regdictionaryout</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>dictid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>dicttup</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>dictid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>dicttup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TSDICTOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>dictid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>dicttup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_ts_dict</name></type> <name>dictform</name> <init>= <expr><operator>(</operator><name>Form_pg_ts_dict</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>dicttup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dictname</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>dictform</name><operator>-&gt;</operator><name>dictname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Would this dictionary be found by regdictionaryin? If not, qualify
		 * it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TSDictionaryIsVisible</name><argument_list>(<argument><expr><name>dictid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nspname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>dictform</name><operator>-&gt;</operator><name>dictnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>dictname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>dicttup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* If OID doesn't match any pg_ts_dict row, return it numerically */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name>dictid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		regdictionaryrecv	- converts external binary format to regdictionary
 */</comment>
<function><type><name>Datum</name></type>
<name>regdictionaryrecv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Exactly the same as oidrecv, so share code */</comment>
	<return>return <expr><call><name>oidrecv</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		regdictionarysend	- converts regdictionary to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>regdictionarysend</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Exactly the same as oidsend, so share code */</comment>
	<return>return <expr><call><name>oidsend</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * regrolein	- converts "rolename" to role OID
 *
 * We also accept a numeric OID, for symmetry with the output routine.
 *
 * '-' signifies unknown (OID 0).  In all other cases, the input must
 * match an existing pg_authid entry.
 */</comment>
<function><type><name>Datum</name></type>
<name>regrolein</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>role_name_or_oid</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>names</name></decl>;</decl_stmt>

	<comment type="block">/* '-' ? */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>role_name_or_oid</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Numeric OID? */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>role_name_or_oid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator>
		<name><name>role_name_or_oid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'9'</literal> <operator>&amp;&amp;</operator>
		<call><name>strspn</name><argument_list>(<argument><expr><name>role_name_or_oid</name></expr></argument>, <argument><expr><literal type="string">"0123456789"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>role_name_or_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>oidin</name></expr></argument>,
													  <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>role_name_or_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* The rest of this wouldn't work in bootstrap mode */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"regrole values must be OIDs in bootstrap mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Normal case: see if the name matches any pg_authid entry. */</comment>
	<expr_stmt><expr><name>names</name> <operator>=</operator> <call><name>stringToQualifiedNameList</name><argument_list>(<argument><expr><name>role_name_or_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_NAME</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid name syntax"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_role_oid</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * to_regrole		- converts "rolename" to role OID
 *
 * If the name is not found, we return NULL.
 */</comment>
<function><type><name>Datum</name></type>
<name>to_regrole</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>role_name</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>names</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>names</name> <operator>=</operator> <call><name>stringToQualifiedNameList</name><argument_list>(<argument><expr><name>role_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_NAME</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid name syntax"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_role_oid</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * regroleout		- converts role OID to "role_name"
 */</comment>
<function><type><name>Datum</name></type>
<name>regroleout</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>roleoid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>roleoid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>GetUserNameFromId</name><argument_list>(<argument><expr><name>roleoid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* pstrdup is not really necessary, but it avoids a compiler warning */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* If OID doesn't match any role, return it numerically */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name>roleoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		regrolerecv - converts external binary format to regrole
 */</comment>
<function><type><name>Datum</name></type>
<name>regrolerecv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Exactly the same as oidrecv, so share code */</comment>
	<return>return <expr><call><name>oidrecv</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		regrolesend - converts regrole to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>regrolesend</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Exactly the same as oidsend, so share code */</comment>
	<return>return <expr><call><name>oidsend</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * regnamespacein		- converts "nspname" to namespace OID
 *
 * We also accept a numeric OID, for symmetry with the output routine.
 *
 * '-' signifies unknown (OID 0).  In all other cases, the input must
 * match an existing pg_namespace entry.
 */</comment>
<function><type><name>Datum</name></type>
<name>regnamespacein</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nsp_name_or_oid</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>names</name></decl>;</decl_stmt>

	<comment type="block">/* '-' ? */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>nsp_name_or_oid</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Numeric OID? */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>nsp_name_or_oid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator>
		<name><name>nsp_name_or_oid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'9'</literal> <operator>&amp;&amp;</operator>
		<call><name>strspn</name><argument_list>(<argument><expr><name>nsp_name_or_oid</name></expr></argument>, <argument><expr><literal type="string">"0123456789"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>nsp_name_or_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>oidin</name></expr></argument>,
													  <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>nsp_name_or_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* The rest of this wouldn't work in bootstrap mode */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"regnamespace values must be OIDs in bootstrap mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Normal case: see if the name matches any pg_namespace entry. */</comment>
	<expr_stmt><expr><name>names</name> <operator>=</operator> <call><name>stringToQualifiedNameList</name><argument_list>(<argument><expr><name>nsp_name_or_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_NAME</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid name syntax"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * to_regnamespace		- converts "nspname" to namespace OID
 *
 * If the name is not found, we return NULL.
 */</comment>
<function><type><name>Datum</name></type>
<name>to_regnamespace</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nsp_name</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>names</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>names</name> <operator>=</operator> <call><name>stringToQualifiedNameList</name><argument_list>(<argument><expr><name>nsp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_NAME</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid name syntax"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * regnamespaceout		- converts namespace OID to "nsp_name"
 */</comment>
<function><type><name>Datum</name></type>
<name>regnamespaceout</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>nspid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>nspid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name>nspid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* pstrdup is not really necessary, but it avoids a compiler warning */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* If OID doesn't match any namespace, return it numerically */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name>nspid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		regnamespacerecv	- converts external binary format to regnamespace
 */</comment>
<function><type><name>Datum</name></type>
<name>regnamespacerecv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Exactly the same as oidrecv, so share code */</comment>
	<return>return <expr><call><name>oidrecv</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		regnamespacesend		- converts regnamespace to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>regnamespacesend</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Exactly the same as oidsend, so share code */</comment>
	<return>return <expr><call><name>oidsend</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * text_regclass: convert text to regclass
 *
 * This could be replaced by CoerceViaIO, except that we need to treat
 * text-to-regclass as an implicit cast to support legacy forms of nextval()
 * and related functions.
 */</comment>
<function><type><name>Datum</name></type>
<name>text_regclass</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>relname</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>rv</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><call><name>textToQualifiedNameList</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We might not even have permissions on this relation; don't lock it. */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Given a C string, parse it into a qualified-name list.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>stringToQualifiedNameList</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rawname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>namelist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/* We need a modifiable copy of the input string. */</comment>
	<expr_stmt><expr><name>rawname</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SplitIdentifierString</name><argument_list>(<argument><expr><name>rawname</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>namelist</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_NAME</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid name syntax"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>namelist</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_NAME</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid name syntax"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>namelist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>curname</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>curname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>namelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************************************************
 *	 SUPPORT ROUTINES														 *
 *****************************************************************************/</comment>

<comment type="block">/*
 * Given a C string, parse it into a qualified function or operator name
 * followed by a parenthesized list of type names.  Reduce the
 * type names to an array of OIDs (returned into *nargs and *argtypes;
 * the argtypes array should be of size FUNC_MAX_ARGS).  The function or
 * operator name is returned to *names as a List of Strings.
 *
 * If allowNone is true, accept "NONE" and return it as InvalidOid (this is
 * for unary operators).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>parseNameAndArgTypes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allowNone</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>names</name></decl></parameter>,
					 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nargs</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>argtypes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rawname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>in_quote</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>had_comma</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>paren_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typeid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name></decl>;</decl_stmt>

	<comment type="block">/* We need a modifiable copy of the input string. */</comment>
	<expr_stmt><expr><name>rawname</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Scan to find the expected left paren; mustn't be quoted */</comment>
	<expr_stmt><expr><name>in_quote</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>ptr</name> <operator>=</operator> <name>rawname</name></expr>;</init> <condition><expr><operator>*</operator><name>ptr</name></expr>;</condition> <incr><expr><name>ptr</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>in_quote</name> <operator>=</operator> <operator>!</operator><name>in_quote</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'('</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>in_quote</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"expected a left parenthesis"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Separate the name and parse it into a list */</comment>
	<expr_stmt><expr><operator>*</operator><name>ptr</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>names</name> <operator>=</operator> <call><name>stringToQualifiedNameList</name><argument_list>(<argument><expr><name>rawname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for the trailing right parenthesis and remove it */</comment>
	<expr_stmt><expr><name>ptr2</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>--</operator><name>ptr2</name> <operator>&gt;</operator> <name>ptr</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>scanner_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>ptr2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr2</name> <operator>!=</operator> <literal type="char">')'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"expected a right parenthesis"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>ptr2</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<comment type="block">/* Separate the remaining string into comma-separated type names */</comment>
	<expr_stmt><expr><operator>*</operator><name>nargs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>had_comma</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/* allow leading whitespace */</comment>
		<while>while <condition>(<expr><call><name>scanner_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* End of string.  Okay unless we had a comma before. */</comment>
			<if_stmt><if>if <condition>(<expr><name>had_comma</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"expected a type name"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>typename</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
		<comment type="block">/* Find end of type name --- end of string or comma */</comment>
		<comment type="block">/* ... but not a quoted or parenthesized comma */</comment>
		<expr_stmt><expr><name>in_quote</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>paren_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>ptr</name></expr>;</condition> <incr><expr><name>ptr</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>in_quote</name> <operator>=</operator> <operator>!</operator><name>in_quote</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">','</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>in_quote</name> <operator>&amp;&amp;</operator> <name>paren_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><name>in_quote</name></expr>)</condition>
			<block>{<block_content>
				<switch>switch <condition>(<expr><operator>*</operator><name>ptr</name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><literal type="char">'('</literal></expr>:</case>
					<case>case <expr><literal type="char">'['</literal></expr>:</case>
						<expr_stmt><expr><name>paren_count</name><operator>++</operator></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><literal type="char">')'</literal></expr>:</case>
					<case>case <expr><literal type="char">']'</literal></expr>:</case>
						<expr_stmt><expr><name>paren_count</name><operator>--</operator></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>in_quote</name> <operator>||</operator> <name>paren_count</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"improper type name"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>ptr2</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>had_comma</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>ptr</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>had_comma</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<comment type="block">/* Lop off trailing whitespace */</comment>
		<while>while <condition>(<expr><operator>--</operator><name>ptr2</name> <operator>&gt;=</operator> <name>typename</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>scanner_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>ptr2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><operator>*</operator><name>ptr2</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		</block_content>}</block></while>

		<if_stmt><if>if <condition>(<expr><name>allowNone</name> <operator>&amp;&amp;</operator> <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>typename</name></expr></argument>, <argument><expr><literal type="string">"none"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Special case for NONE */</comment>
			<expr_stmt><expr><name>typeid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>typmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Use full parser to resolve the type name */</comment>
			<expr_stmt><expr><call><name>parseTypeString</name><argument_list>(<argument><expr><name>typename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typmod</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>nargs</name> <operator>&gt;=</operator> <name>FUNC_MAX_ARGS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_ARGUMENTS</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too many arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>argtypes</name><index>[<expr><operator>*</operator><name>nargs</name></expr>]</index></name> <operator>=</operator> <name>typeid</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>nargs</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
