<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/utils/adt/arrayfuncs.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * arrayfuncs.c
 *	  Support functions for arrays.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/utils/adt/arrayfuncs.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;float.h&gt;</cpp:file></cpp:include>				<comment type="block">/* for _isnan */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/arrayaccess.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>


<comment type="block">/*
 * GUC parameter
 */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>Array_nulls</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Local definitions
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSGN</name></cpp:macro>	 <cpp:value>"="</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AARR_FREE_IF_COPY</name><parameter_list>(<parameter><type><name>array</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		if (!VARATT_IS_EXPANDED_HEADER(array)) \
			PG_FREE_IF_COPY(array, n); \
	} while (0)</cpp:value></cpp:define>

<typedef>typedef <type><enum>enum
<block>{
	<decl><name>ARRAY_NO_LEVEL</name></decl>,
	<decl><name>ARRAY_LEVEL_STARTED</name></decl>,
	<decl><name>ARRAY_ELEM_STARTED</name></decl>,
	<decl><name>ARRAY_ELEM_COMPLETED</name></decl>,
	<decl><name>ARRAY_QUOTED_ELEM_STARTED</name></decl>,
	<decl><name>ARRAY_QUOTED_ELEM_COMPLETED</name></decl>,
	<decl><name>ARRAY_ELEM_DELIMITED</name></decl>,
	<decl><name>ARRAY_LEVEL_COMPLETED</name></decl>,
	<decl><name>ARRAY_LEVEL_DELIMITED</name></decl>
}</block></enum></type> <name>ArrayParseState</name>;</typedef>

<comment type="block">/* Working state for array_iterate() */</comment>
<typedef>typedef <type><struct>struct <name>ArrayIteratorData</name>
<block>{
	<comment type="block">/* basic info about the array, set up during array_create_iterator() */</comment>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arr</name></decl>;</decl_stmt>			<comment type="block">/* array we're iterating through */</comment>
	<decl_stmt><decl><type><name>bits8</name>	   <modifier>*</modifier></type><name>nullbitmap</name></decl>;</decl_stmt>		<comment type="block">/* its null bitmap, if any */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nitems</name></decl>;</decl_stmt>			<comment type="block">/* total number of elements in array */</comment>
	<decl_stmt><decl><type><name>int16</name></type>		<name>typlen</name></decl>;</decl_stmt>			<comment type="block">/* element type's length */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typbyval</name></decl>;</decl_stmt>		<comment type="block">/* element type's byval property */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name>typalign</name></decl>;</decl_stmt>		<comment type="block">/* element type's align property */</comment>

	<comment type="block">/* information about the requested slice size */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>slice_ndim</name></decl>;</decl_stmt>		<comment type="block">/* slice dimension, or 0 if not slicing */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>slice_len</name></decl>;</decl_stmt>		<comment type="block">/* number of elements per slice */</comment>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>slice_dims</name></decl>;</decl_stmt>		<comment type="block">/* slice dims array */</comment>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>slice_lbound</name></decl>;</decl_stmt>	<comment type="block">/* slice lbound array */</comment>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>slice_values</name></decl>;</decl_stmt>	<comment type="block">/* workspace of length slice_len */</comment>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>slice_nulls</name></decl>;</decl_stmt>	<comment type="block">/* workspace of length slice_len */</comment>

	<comment type="block">/* current position information, updated on each iteration */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>data_ptr</name></decl>;</decl_stmt>		<comment type="block">/* our current position in the array */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>current_item</name></decl>;</decl_stmt>	<comment type="block">/* the item # we're at in the array */</comment>
}</block></struct></type>			<name>ArrayIteratorData</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>array_isspace</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>ArrayCount</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dim</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>typdelim</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReadArrayStr</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>arrayStr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>origStr</name></decl></parameter>,
			 <parameter><decl><type><name>int</name></type> <name>nitems</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ndim</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dim</name></decl></parameter>,
			 <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>inputproc</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typioparam</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>,
			 <parameter><decl><type><name>char</name></type> <name>typdelim</name></decl></parameter>,
			 <parameter><decl><type><name>int</name></type> <name>typlen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>typbyval</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>typalign</name></decl></parameter>,
			 <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>,
			 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasnulls</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>nbytes</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReadArrayBinary</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nitems</name></decl></parameter>,
				<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>receiveproc</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typioparam</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>typlen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>typbyval</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>typalign</name></decl></parameter>,
				<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>,
				<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasnulls</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>nbytes</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>array_get_element_expanded</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arraydatum</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>nSubscripts</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>indx</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>arraytyplen</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>elmlen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>elmbyval</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>elmalign</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>array_set_element_expanded</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arraydatum</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>nSubscripts</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>indx</name></decl></parameter>,
						   <parameter><decl><type><name>Datum</name></type> <name>dataValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isNull</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>arraytyplen</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>elmlen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>elmbyval</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>elmalign</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>array_get_isnull</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>bits8</name> <modifier>*</modifier></type><name>nullbitmap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>array_set_isnull</name><parameter_list>(<parameter><decl><type><name>bits8</name> <modifier>*</modifier></type><name>nullbitmap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isNull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>ArrayCast</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>byval</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ArrayCastAndSet</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>src</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>typlen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>typbyval</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>typalign</name></decl></parameter>,
				<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>array_seek</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>bits8</name> <modifier>*</modifier></type><name>nullbitmap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nitems</name></decl></parameter>,
		   <parameter><decl><type><name>int</name></type> <name>typlen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>typbyval</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>typalign</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>array_nelems_size</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>bits8</name> <modifier>*</modifier></type><name>nullbitmap</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>nitems</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>typlen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>typbyval</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>typalign</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>array_copy</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>destptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nitems</name></decl></parameter>,
		   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>srcptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>bits8</name> <modifier>*</modifier></type><name>nullbitmap</name></decl></parameter>,
		   <parameter><decl><type><name>int</name></type> <name>typlen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>typbyval</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>typalign</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>array_slice_size</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>arraydataptr</name></decl></parameter>, <parameter><decl><type><name>bits8</name> <modifier>*</modifier></type><name>arraynullsptr</name></decl></parameter>,
				 <parameter><decl><type><name>int</name></type> <name>ndim</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dim</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>lb</name></decl></parameter>,
				 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>endp</name></decl></parameter>,
				 <parameter><decl><type><name>int</name></type> <name>typlen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>typbyval</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>typalign</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>array_extract_slice</name><parameter_list>(<parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>newarray</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>ndim</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dim</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>lb</name></decl></parameter>,
					<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>arraydataptr</name></decl></parameter>, <parameter><decl><type><name>bits8</name> <modifier>*</modifier></type><name>arraynullsptr</name></decl></parameter>,
					<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>endp</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>typlen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>typbyval</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>typalign</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>array_insert_slice</name><parameter_list>(<parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>destArray</name></decl></parameter>, <parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>origArray</name></decl></parameter>,
				   <parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>srcArray</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>ndim</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dim</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>lb</name></decl></parameter>,
				   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>endp</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>typlen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>typbyval</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>typalign</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>array_cmp</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ArrayType</name> <modifier>*</modifier></type><name>create_array_envelope</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>ndims</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dimv</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>lbv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nbytes</name></decl></parameter>,
					  <parameter><decl><type><name>Oid</name></type> <name>elmtype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dataoffset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ArrayType</name> <modifier>*</modifier></type><name>array_fill_internal</name><parameter_list>(<parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>dims</name></decl></parameter>, <parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>lbs</name></decl></parameter>,
					<parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>elmtype</name></decl></parameter>,
					<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ArrayType</name> <modifier>*</modifier></type><name>array_replace_internal</name><parameter_list>(<parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>array</name></decl></parameter>,
					   <parameter><decl><type><name>Datum</name></type> <name>search</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>search_isnull</name></decl></parameter>,
					   <parameter><decl><type><name>Datum</name></type> <name>replace</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>replace_isnull</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>remove</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>,
					   <parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>width_bucket_array_float8</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>operand</name></decl></parameter>, <parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>thresholds</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>width_bucket_array_fixed</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>operand</name></decl></parameter>,
						 <parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>thresholds</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>,
						 <parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>width_bucket_array_variable</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>operand</name></decl></parameter>,
							<parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>thresholds</name></decl></parameter>,
							<parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>,
							<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * array_in :
 *		  converts an array from the external format in "string" to
 *		  its internal format.
 *
 * return value :
 *		  the internal representation of the input array
 */</comment>
<function><type><name>Datum</name></type>
<name>array_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>string</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>	<comment type="block">/* external form */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>element_type</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>	<comment type="block">/* type of an array
													 * element */</comment>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>	<comment type="block">/* typmod for array elements */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>typlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typbyval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>typalign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>typdelim</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typioparam</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>string_save</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>nitems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>dataPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nullsPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasnulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>nbytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>dataoffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>retval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndim</name></decl>,
				<decl><type ref="prev"/><name><name>dim</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name><name>lBound</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayMetaState</name> <modifier>*</modifier></type><name>my_extra</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We arrange to look up info about element type, including its input
	 * conversion proc, only once per series of calls, assuming the element
	 * type doesn't change underneath us.
	 */</comment>
	<expr_stmt><expr><name>my_extra</name> <operator>=</operator> <operator>(</operator><name>ArrayMetaState</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>my_extra</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>,
													  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ArrayMetaState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>my_extra</name> <operator>=</operator> <operator>(</operator><name>ArrayMetaState</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>my_extra</name><operator>-&gt;</operator><name>element_type</name></name> <operator>=</operator> <operator>~</operator><name>element_type</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>my_extra</name><operator>-&gt;</operator><name>element_type</name></name> <operator>!=</operator> <name>element_type</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Get info about element type, including its input conversion proc
		 */</comment>
		<expr_stmt><expr><call><name>get_type_io_data</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>, <argument><expr><name>IOFunc_input</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>typalign</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>typdelim</name></name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>typioparam</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>typiofunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>typiofunc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>,
					  <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>my_extra</name><operator>-&gt;</operator><name>element_type</name></name> <operator>=</operator> <name>element_type</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>typlen</name> <operator>=</operator> <name><name>my_extra</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>typbyval</name> <operator>=</operator> <name><name>my_extra</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>typalign</name> <operator>=</operator> <name><name>my_extra</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>typdelim</name> <operator>=</operator> <name><name>my_extra</name><operator>-&gt;</operator><name>typdelim</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>typioparam</name> <operator>=</operator> <name><name>my_extra</name><operator>-&gt;</operator><name>typioparam</name></name></expr>;</expr_stmt>

	<comment type="block">/* Make a modifiable copy of the input */</comment>
	<expr_stmt><expr><name>string_save</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the input string starts with dimension info, read and use that.
	 * Otherwise, we require the input to be in curly-brace style, and we
	 * prescan the input to determine dimensions.
	 *
	 * Dimension info takes the form of one or more [n] or [m:n] items. The
	 * outer loop iterates once per dimension item.
	 */</comment>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <name>string_save</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ndim</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ub</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Note: we currently allow whitespace between, but not within,
		 * dimension items.
		 */</comment>
		<while>while <condition>(<expr><call><name>array_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'['</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* no more dimension items */</comment>
		<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ndim</name> <operator>&gt;=</operator> <name>MAXDIM</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of array dimensions (%d) exceeds the maximum allowed (%d)"</literal></expr></argument>,
							<argument><expr><name>ndim</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>MAXDIM</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<for>for <control>(<init><expr><name>q</name> <operator>=</operator> <name>p</name></expr>;</init> <condition><expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>q</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><operator>*</operator><name>q</name> <operator>==</operator> <literal type="char">'-'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>*</operator><name>q</name> <operator>==</operator> <literal type="char">'+'</literal><operator>)</operator></expr>;</condition> <incr><expr><name>q</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			 <comment type="block">/* skip */</comment> <empty_stmt>;</empty_stmt></block_content></block></for>
		<if_stmt><if>if <condition>(<expr><name>q</name> <operator>==</operator> <name>p</name></expr>)</condition><block type="pseudo"><block_content>				<comment type="block">/* no digits? */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed array literal: \"%s\""</literal></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"\"[\" must introduce explicitly-specified array dimensions."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>q</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* [m:n] format */</comment>
			<expr_stmt><expr><operator>*</operator><name>q</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>lBound</name><index>[<expr><name>ndim</name></expr>]</index></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>p</name> <operator>=</operator> <name>q</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>q</name> <operator>=</operator> <name>p</name></expr>;</init> <condition><expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>q</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><operator>*</operator><name>q</name> <operator>==</operator> <literal type="char">'-'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>*</operator><name>q</name> <operator>==</operator> <literal type="char">'+'</literal><operator>)</operator></expr>;</condition> <incr><expr><name>q</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				 <comment type="block">/* skip */</comment> <empty_stmt>;</empty_stmt></block_content></block></for>
			<if_stmt><if>if <condition>(<expr><name>q</name> <operator>==</operator> <name>p</name></expr>)</condition><block type="pseudo"><block_content>			<comment type="block">/* no digits? */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed array literal: \"%s\""</literal></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Missing array dimension value."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* [n] format */</comment>
			<expr_stmt><expr><name><name>lBound</name><index>[<expr><name>ndim</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>q</name> <operator>!=</operator> <literal type="char">']'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed array literal: \"%s\""</literal></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Missing \"%s\" after array dimensions."</literal></expr></argument>,
							   <argument><expr><literal type="string">"]"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>q</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>ub</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <name>q</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ub</name> <operator>&lt;</operator> <name><name>lBound</name><index>[<expr><name>ndim</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"upper bound cannot be less than lower bound"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>dim</name><index>[<expr><name>ndim</name></expr>]</index></name> <operator>=</operator> <name>ub</name> <operator>-</operator> <name><name>lBound</name><index>[<expr><name>ndim</name></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>ndim</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>ndim</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No array dimensions, so intuit dimensions from brace structure */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'{'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed array literal: \"%s\""</literal></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Array value must start with \"{\" or dimension information."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>ndim</name> <operator>=</operator> <call><name>ArrayCount</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>typdelim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndim</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>lBound</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>ndim_braces</name></decl>,
					<decl><type ref="prev"/><name><name>dim_braces</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>;</decl_stmt>

		<comment type="block">/* If array dimensions are given, expect '=' operator */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ASSGN</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>ASSGN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed array literal: \"%s\""</literal></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Missing \"%s\" after array dimensions."</literal></expr></argument>,
							   <argument><expr><name>ASSGN</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>ASSGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><call><name>array_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

		<comment type="block">/*
		 * intuit dimensions from brace structure -- it better match what we
		 * were given
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'{'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed array literal: \"%s\""</literal></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Array contents must start with \"{\"."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>ndim_braces</name> <operator>=</operator> <call><name>ArrayCount</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>dim_braces</name></expr></argument>, <argument><expr><name>typdelim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ndim_braces</name> <operator>!=</operator> <name>ndim</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed array literal: \"%s\""</literal></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Specified array dimensions do not match array contents."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndim</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>dim</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>dim_braces</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed array literal: \"%s\""</literal></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Specified array dimensions do not match array contents."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ARRAYDEBUG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"array_in- ndim %d ("</literal></expr></argument>, <argument><expr><name>ndim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndim</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><name><name>dim</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for><empty_stmt>;</empty_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">") for %s\n"</literal></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* This checks for overflow of the array dimensions */</comment>
	<expr_stmt><expr><name>nitems</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ArrayCheckBounds</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>lBound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Empty array? */</comment>
	<if_stmt><if>if <condition>(<expr><name>nitems</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><call><name>construct_empty_array</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>dataPtr</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nitems</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nullsPtr</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nitems</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReadArrayStr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>string</name></expr></argument>,
				 <argument><expr><name>nitems</name></expr></argument>, <argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>,
				 <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>, <argument><expr><name>typioparam</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>,
				 <argument><expr><name>typdelim</name></expr></argument>,
				 <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>,
				 <argument><expr><name>dataPtr</name></expr></argument>, <argument><expr><name>nullsPtr</name></expr></argument>,
				 <argument><expr><operator>&amp;</operator><name>hasnulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>hasnulls</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>dataoffset</name> <operator>=</operator> <call><name>ARR_OVERHEAD_WITHNULLS</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nbytes</name> <operator>+=</operator> <name>dataoffset</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>dataoffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* marker for no null bitmap */</comment>
		<expr_stmt><expr><name>nbytes</name> <operator>+=</operator> <call><name>ARR_OVERHEAD_NONULLS</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>(</operator><name>ArrayType</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>ndim</name></name> <operator>=</operator> <name>ndim</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>dataoffset</name></name> <operator>=</operator> <name>dataoffset</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * This comes from the array's pg_type.typelem (which points to the base
	 * data type's pg_type.oid) and stores system oids in user tables. This
	 * oid must be preserved by binary upgrades.
	 */</comment>
	<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>elemtype</name></name> <operator>=</operator> <name>element_type</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>ndim</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>ARR_LBOUND</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lBound</name></expr></argument>, <argument><expr><name>ndim</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CopyArrayEls</name><argument_list>(<argument><expr><name>retval</name></expr></argument>,
				 <argument><expr><name>dataPtr</name></expr></argument>, <argument><expr><name>nullsPtr</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>,
				 <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>,
				 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>dataPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nullsPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>string_save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * array_isspace() --- a non-locale-dependent isspace()
 *
 * We used to use isspace() for parsing array values, but that has
 * undesirable results: an array value might be silently interpreted
 * differently depending on the locale setting.  Now we just hard-wire
 * the traditional ASCII definition of isspace().
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>array_isspace</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator>
		<name>ch</name> <operator>==</operator> <literal type="char">'\t'</literal> <operator>||</operator>
		<name>ch</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator>
		<name>ch</name> <operator>==</operator> <literal type="char">'\r'</literal> <operator>||</operator>
		<name>ch</name> <operator>==</operator> <literal type="char">'\v'</literal> <operator>||</operator>
		<name>ch</name> <operator>==</operator> <literal type="char">'\f'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ArrayCount
 *	 Determines the dimensions for an array string.
 *
 * Returns number of dimensions as function result.  The axis lengths are
 * returned in dim[], which must be of size MAXDIM.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ArrayCount</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dim</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>typdelim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nest_level</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndim</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
				<decl><type ref="prev"/><name><name>temp</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name><name>nelems</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name><name>nelems_last</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>in_quotes</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>eoArray</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>empty_array</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayParseState</name></type> <name>parse_state</name> <init>= <expr><name>ARRAY_NO_LEVEL</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAXDIM</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>temp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>dim</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>nelems_last</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nelems</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>!</operator><name>eoArray</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>itemdone</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><operator>!</operator><name>itemdone</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>parse_state</name> <operator>==</operator> <name>ARRAY_ELEM_STARTED</name> <operator>||</operator>
				<name>parse_state</name> <operator>==</operator> <name>ARRAY_QUOTED_ELEM_STARTED</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>empty_array</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<switch>switch <condition>(<expr><operator>*</operator><name>ptr</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><literal type="char">'\0'</literal></expr>:</case>
					<comment type="block">/* Signal a premature end of the string */</comment>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed array literal: \"%s\""</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Unexpected end of input."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'\\'</literal></expr>:</case>

					<comment type="block">/*
					 * An escape must be after a level start, after an element
					 * start, or after an element delimiter. In any case we
					 * now must be past an element start.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>parse_state</name> <operator>!=</operator> <name>ARRAY_LEVEL_STARTED</name> <operator>&amp;&amp;</operator>
						<name>parse_state</name> <operator>!=</operator> <name>ARRAY_ELEM_STARTED</name> <operator>&amp;&amp;</operator>
						<name>parse_state</name> <operator>!=</operator> <name>ARRAY_QUOTED_ELEM_STARTED</name> <operator>&amp;&amp;</operator>
						<name>parse_state</name> <operator>!=</operator> <name>ARRAY_ELEM_DELIMITED</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed array literal: \"%s\""</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Unexpected \"%c\" character."</literal></expr></argument>,
										   <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>parse_state</name> <operator>!=</operator> <name>ARRAY_QUOTED_ELEM_STARTED</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>parse_state</name> <operator>=</operator> <name>ARRAY_ELEM_STARTED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<comment type="block">/* skip the escaped character */</comment>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><name>ptr</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed array literal: \"%s\""</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Unexpected end of input."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'"'</literal></expr>:</case>

					<comment type="block">/*
					 * A quote must be after a level start, after a quoted
					 * element start, or after an element delimiter. In any
					 * case we now must be past an element start.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>parse_state</name> <operator>!=</operator> <name>ARRAY_LEVEL_STARTED</name> <operator>&amp;&amp;</operator>
						<name>parse_state</name> <operator>!=</operator> <name>ARRAY_QUOTED_ELEM_STARTED</name> <operator>&amp;&amp;</operator>
						<name>parse_state</name> <operator>!=</operator> <name>ARRAY_ELEM_DELIMITED</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed array literal: \"%s\""</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Unexpected array element."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>in_quotes</name> <operator>=</operator> <operator>!</operator><name>in_quotes</name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>in_quotes</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>parse_state</name> <operator>=</operator> <name>ARRAY_QUOTED_ELEM_STARTED</name></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>parse_state</name> <operator>=</operator> <name>ARRAY_QUOTED_ELEM_COMPLETED</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'{'</literal></expr>:</case>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>in_quotes</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * A left brace can occur if no nesting has occurred
						 * yet, after a level start, or after a level
						 * delimiter.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name>parse_state</name> <operator>!=</operator> <name>ARRAY_NO_LEVEL</name> <operator>&amp;&amp;</operator>
							<name>parse_state</name> <operator>!=</operator> <name>ARRAY_LEVEL_STARTED</name> <operator>&amp;&amp;</operator>
							<name>parse_state</name> <operator>!=</operator> <name>ARRAY_LEVEL_DELIMITED</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed array literal: \"%s\""</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Unexpected \"%c\" character."</literal></expr></argument>,
											   <argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>parse_state</name> <operator>=</operator> <name>ARRAY_LEVEL_STARTED</name></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>nest_level</name> <operator>&gt;=</operator> <name>MAXDIM</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of array dimensions (%d) exceeds the maximum allowed (%d)"</literal></expr></argument>,
											<argument><expr><name>nest_level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>MAXDIM</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name><name>temp</name><index>[<expr><name>nest_level</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
						<expr_stmt><expr><name>nest_level</name><operator>++</operator></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>ndim</name> <operator>&lt;</operator> <name>nest_level</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>ndim</name> <operator>=</operator> <name>nest_level</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'}'</literal></expr>:</case>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>in_quotes</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * A right brace can occur after an element start, an
						 * element completion, a quoted element completion, or
						 * a level completion.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name>parse_state</name> <operator>!=</operator> <name>ARRAY_ELEM_STARTED</name> <operator>&amp;&amp;</operator>
							<name>parse_state</name> <operator>!=</operator> <name>ARRAY_ELEM_COMPLETED</name> <operator>&amp;&amp;</operator>
							<name>parse_state</name> <operator>!=</operator> <name>ARRAY_QUOTED_ELEM_COMPLETED</name> <operator>&amp;&amp;</operator>
							<name>parse_state</name> <operator>!=</operator> <name>ARRAY_LEVEL_COMPLETED</name> <operator>&amp;&amp;</operator>
							<operator>!</operator><operator>(</operator><name>nest_level</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>parse_state</name> <operator>==</operator> <name>ARRAY_LEVEL_STARTED</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed array literal: \"%s\""</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Unexpected \"%c\" character."</literal></expr></argument>,
											   <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>parse_state</name> <operator>=</operator> <name>ARRAY_LEVEL_COMPLETED</name></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>nest_level</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed array literal: \"%s\""</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Unmatched \"%c\" character."</literal></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>nest_level</name><operator>--</operator></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><name><name>nelems_last</name><index>[<expr><name>nest_level</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
							<name><name>nelems</name><index>[<expr><name>nest_level</name></expr>]</index></name> <operator>!=</operator> <name><name>nelems_last</name><index>[<expr><name>nest_level</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed array literal: \"%s\""</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Multidimensional arrays must have "</literal>
											   <literal type="string">"sub-arrays with matching "</literal>
											   <literal type="string">"dimensions."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name><name>nelems_last</name><index>[<expr><name>nest_level</name></expr>]</index></name> <operator>=</operator> <name><name>nelems</name><index>[<expr><name>nest_level</name></expr>]</index></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>nelems</name><index>[<expr><name>nest_level</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>nest_level</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>eoArray</name> <operator>=</operator> <name>itemdone</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
						<else>else
						<block>{<block_content>
							<comment type="block">/*
							 * We don't set itemdone here; see comments in
							 * ReadArrayStr
							 */</comment>
							<expr_stmt><expr><name><name>temp</name><index>[<expr><name>nest_level</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
						</block_content>}</block></else></if_stmt>
					</block_content>}</block></if></if_stmt>
					<break>break;</break>
				<default>default:</default>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>in_quotes</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <name>typdelim</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/*
							 * Delimiters can occur after an element start, an
							 * element completion, a quoted element
							 * completion, or a level completion.
							 */</comment>
							<if_stmt><if>if <condition>(<expr><name>parse_state</name> <operator>!=</operator> <name>ARRAY_ELEM_STARTED</name> <operator>&amp;&amp;</operator>
								<name>parse_state</name> <operator>!=</operator> <name>ARRAY_ELEM_COMPLETED</name> <operator>&amp;&amp;</operator>
								<name>parse_state</name> <operator>!=</operator> <name>ARRAY_QUOTED_ELEM_COMPLETED</name> <operator>&amp;&amp;</operator>
								<name>parse_state</name> <operator>!=</operator> <name>ARRAY_LEVEL_COMPLETED</name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
										<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
										 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed array literal: \"%s\""</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>,</operator>
										 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Unexpected \"%c\" character."</literal></expr></argument>,
												   <argument><expr><name>typdelim</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<if_stmt><if>if <condition>(<expr><name>parse_state</name> <operator>==</operator> <name>ARRAY_LEVEL_COMPLETED</name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name>parse_state</name> <operator>=</operator> <name>ARRAY_LEVEL_DELIMITED</name></expr>;</expr_stmt></block_content></block></if>
							<else>else<block type="pseudo"><block_content>
								<expr_stmt><expr><name>parse_state</name> <operator>=</operator> <name>ARRAY_ELEM_DELIMITED</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
							<expr_stmt><expr><name>itemdone</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>nelems</name><index>[<expr><name>nest_level</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
						</block_content>}</block></if>
						<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>array_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/*
							 * Other non-space characters must be after a
							 * level start, after an element start, or after
							 * an element delimiter. In any case we now must
							 * be past an element start.
							 */</comment>
							<if_stmt><if>if <condition>(<expr><name>parse_state</name> <operator>!=</operator> <name>ARRAY_LEVEL_STARTED</name> <operator>&amp;&amp;</operator>
								<name>parse_state</name> <operator>!=</operator> <name>ARRAY_ELEM_STARTED</name> <operator>&amp;&amp;</operator>
								<name>parse_state</name> <operator>!=</operator> <name>ARRAY_ELEM_DELIMITED</name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
										<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
										 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed array literal: \"%s\""</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>,</operator>
										 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Unexpected array element."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<expr_stmt><expr><name>parse_state</name> <operator>=</operator> <name>ARRAY_ELEM_STARTED</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>itemdone</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><name><name>temp</name><index>[<expr><name>ndim</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* only whitespace is allowed after the closing brace */</comment>
	<while>while <condition>(<expr><operator>*</operator><name>ptr</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>array_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name><operator>++</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed array literal: \"%s\""</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Junk after closing right brace."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* special case for an empty array */</comment>
	<if_stmt><if>if <condition>(<expr><name>empty_array</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndim</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dim</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>temp</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

	<return>return <expr><name>ndim</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ReadArrayStr :
 *	 parses the array string pointed to by "arrayStr" and converts the values
 *	 to internal format.  Unspecified elements are initialized to nulls.
 *	 The array dimensions must already have been determined.
 *
 * Inputs:
 *	arrayStr: the string to parse.
 *			  CAUTION: the contents of "arrayStr" will be modified!
 *	origStr: the unmodified input string, used only in error messages.
 *	nitems: total number of array elements, as already determined.
 *	ndim: number of array dimensions
 *	dim[]: array axis lengths
 *	inputproc: type-specific input procedure for element datatype.
 *	typioparam, typmod: auxiliary values to pass to inputproc.
 *	typdelim: the value delimiter (type-specific).
 *	typlen, typbyval, typalign: storage parameters of element datatype.
 *
 * Outputs:
 *	values[]: filled with converted data values.
 *	nulls[]: filled with is-null markers.
 *	*hasnulls: set true iff there are any null elements.
 *	*nbytes: set to total size of data area needed (including alignment
 *		padding but not including array header overhead).
 *
 * Note that values[] and nulls[] are allocated by the caller, and must have
 * nitems elements.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReadArrayStr</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>arrayStr</name></decl></parameter>,
			 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>origStr</name></decl></parameter>,
			 <parameter><decl><type><name>int</name></type> <name>nitems</name></decl></parameter>,
			 <parameter><decl><type><name>int</name></type> <name>ndim</name></decl></parameter>,
			 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dim</name></decl></parameter>,
			 <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>inputproc</name></decl></parameter>,
			 <parameter><decl><type><name>Oid</name></type> <name>typioparam</name></decl></parameter>,
			 <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>,
			 <parameter><decl><type><name>char</name></type> <name>typdelim</name></decl></parameter>,
			 <parameter><decl><type><name>int</name></type> <name>typlen</name></decl></parameter>,
			 <parameter><decl><type><name>bool</name></type> <name>typbyval</name></decl></parameter>,
			 <parameter><decl><type><name>char</name></type> <name>typalign</name></decl></parameter>,
			 <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
			 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>,
			 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasnulls</name></decl></parameter>,
			 <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>nbytes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>nest_level</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>srcptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>in_quotes</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>eoArray</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>totbytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>indx</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name><name>prod</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>mda_get_prod</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>prod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>indx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>indx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize is-null markers to true */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>nitems</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We have to remove " and \ characters to create a clean item value to
	 * pass to the datatype input routine.  We overwrite each item value
	 * in-place within arrayStr to do this.  srcptr is the current scan point,
	 * and dstptr is where we are copying to.
	 *
	 * We also want to suppress leading and trailing unquoted whitespace. We
	 * use the leadingspace flag to suppress leading space.  Trailing space is
	 * tracked by using dstendptr to point to the last significant output
	 * character.
	 *
	 * The error checking in this routine is mostly pro-forma, since we expect
	 * that ArrayCount() already validated the string.  So we don't bother
	 * with errdetail messages.
	 */</comment>
	<expr_stmt><expr><name>srcptr</name> <operator>=</operator> <name>arrayStr</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>!</operator><name>eoArray</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>itemdone</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>leadingspace</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>hasquoting</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>itemstart</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dstptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dstendptr</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>itemstart</name> <operator>=</operator> <name>dstptr</name> <operator>=</operator> <name>dstendptr</name> <operator>=</operator> <name>srcptr</name></expr>;</expr_stmt>

		<while>while <condition>(<expr><operator>!</operator><name>itemdone</name></expr>)</condition>
		<block>{<block_content>
			<switch>switch <condition>(<expr><operator>*</operator><name>srcptr</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><literal type="char">'\0'</literal></expr>:</case>
					<comment type="block">/* Signal a premature end of the string */</comment>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed array literal: \"%s\""</literal></expr></argument>,
									<argument><expr><name>origStr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'\\'</literal></expr>:</case>
					<comment type="block">/* Skip backslash, copy next character as-is. */</comment>
					<expr_stmt><expr><name>srcptr</name><operator>++</operator></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name>srcptr</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed array literal: \"%s\""</literal></expr></argument>,
										<argument><expr><name>origStr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><operator>*</operator><name>dstptr</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>srcptr</name><operator>++</operator></expr>;</expr_stmt>
					<comment type="block">/* Treat the escaped character as non-whitespace */</comment>
					<expr_stmt><expr><name>leadingspace</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>dstendptr</name> <operator>=</operator> <name>dstptr</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>hasquoting</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* can't be a NULL marker */</comment>
					<break>break;</break>
				<case>case <expr><literal type="char">'"'</literal></expr>:</case>
					<expr_stmt><expr><name>in_quotes</name> <operator>=</operator> <operator>!</operator><name>in_quotes</name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>in_quotes</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>leadingspace</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/*
						 * Advance dstendptr when we exit in_quotes; this
						 * saves having to do it in all the other in_quotes
						 * cases.
						 */</comment>
						<expr_stmt><expr><name>dstendptr</name> <operator>=</operator> <name>dstptr</name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<expr_stmt><expr><name>hasquoting</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* can't be a NULL marker */</comment>
					<expr_stmt><expr><name>srcptr</name><operator>++</operator></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'{'</literal></expr>:</case>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>in_quotes</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>nest_level</name> <operator>&gt;=</operator> <name>ndim</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed array literal: \"%s\""</literal></expr></argument>,
											<argument><expr><name>origStr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>nest_level</name><operator>++</operator></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>indx</name><index>[<expr><name>nest_level</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
						<expr_stmt><expr><name>srcptr</name><operator>++</operator></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>dstptr</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>srcptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'}'</literal></expr>:</case>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>in_quotes</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>nest_level</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed array literal: \"%s\""</literal></expr></argument>,
											<argument><expr><name>origStr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>ArrayGetOffset0</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>indx</name></expr></argument>, <argument><expr><name>prod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name><name>indx</name><index>[<expr><name>nest_level</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
						<expr_stmt><expr><name>nest_level</name><operator>--</operator></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>nest_level</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>eoArray</name> <operator>=</operator> <name>itemdone</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>indx</name><index>[<expr><name>nest_level</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
						<expr_stmt><expr><name>srcptr</name><operator>++</operator></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>dstptr</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>srcptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<break>break;</break>
				<default>default:</default>
					<if_stmt><if>if <condition>(<expr><name>in_quotes</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>dstptr</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>srcptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><operator>*</operator><name>srcptr</name> <operator>==</operator> <name>typdelim</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>ArrayGetOffset0</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>indx</name></expr></argument>, <argument><expr><name>prod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>itemdone</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>indx</name><index>[<expr><name>ndim</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
						<expr_stmt><expr><name>srcptr</name><operator>++</operator></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><call><name>array_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>srcptr</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * If leading space, drop it immediately.  Else, copy
						 * but don't advance dstendptr.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name>leadingspace</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>srcptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><operator>*</operator><name>dstptr</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>srcptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><operator>*</operator><name>dstptr</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>srcptr</name><operator>++</operator></expr>;</expr_stmt>
						<expr_stmt><expr><name>leadingspace</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>dstendptr</name> <operator>=</operator> <name>dstptr</name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>dstptr</name> <operator>&lt;</operator> <name>srcptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>dstendptr</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>i</name> <operator>&gt;=</operator> <name>nitems</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed array literal: \"%s\""</literal></expr></argument>,
							<argument><expr><name>origStr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>Array_nulls</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>hasquoting</name> <operator>&amp;&amp;</operator>
			<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>itemstart</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* it's a NULL item */</comment>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>InputFunctionCall</name><argument_list>(<argument><expr><name>inputproc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
										  <argument><expr><name>typioparam</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>InputFunctionCall</name><argument_list>(<argument><expr><name>inputproc</name></expr></argument>, <argument><expr><name>itemstart</name></expr></argument>,
										  <argument><expr><name>typioparam</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Check for nulls, compute total data space needed
	 */</comment>
	<expr_stmt><expr><name>hasnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>totbytes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>hasnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* let's just make sure data is not toasted */</comment>
			<if_stmt><if>if <condition>(<expr><name>typlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>totbytes</name> <operator>=</operator> <call><name>att_addlength_datum</name><argument_list>(<argument><expr><name>totbytes</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>totbytes</name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>totbytes</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* check for overflow of total request */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AllocSizeIsValid</name><argument_list>(<argument><expr><name>totbytes</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"array size exceeds the maximum allowed (%d)"</literal></expr></argument>,
								<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>MaxAllocSize</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><operator>*</operator><name>hasnulls</name> <operator>=</operator> <name>hasnull</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>nbytes</name> <operator>=</operator> <name>totbytes</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Copy data into an array object from a temporary array of Datums.
 *
 * array: array object (with header fields already filled in)
 * values: array of Datums to be copied
 * nulls: array of is-null flags (can be NULL if no nulls)
 * nitems: number of Datums to be copied
 * typbyval, typlen, typalign: info about element datatype
 * freedata: if true and element type is pass-by-ref, pfree data values
 * referenced by Datums after copying them.
 *
 * If the input data is of varlena type, the caller must have ensured that
 * the values are not toasted.  (Doing it here doesn't work since the
 * caller has already allocated space for the array...)
 */</comment>
<function><type><name>void</name></type>
<name>CopyArrayEls</name><parameter_list>(<parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>array</name></decl></parameter>,
			 <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
			 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>,
			 <parameter><decl><type><name>int</name></type> <name>nitems</name></decl></parameter>,
			 <parameter><decl><type><name>int</name></type> <name>typlen</name></decl></parameter>,
			 <parameter><decl><type><name>bool</name></type> <name>typbyval</name></decl></parameter>,
			 <parameter><decl><type><name>char</name></type> <name>typalign</name></decl></parameter>,
			 <parameter><decl><type><name>bool</name></type> <name>freedata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bits8</name>	   <modifier>*</modifier></type><name>bitmap</name> <init>= <expr><call><name>ARR_NULLBITMAP</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bitval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bitmask</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>typbyval</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>freedata</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>nulls</name> <operator>&amp;&amp;</operator> <name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bitmap</name></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* shouldn't happen */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null array element where not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* bitmap bit stays 0 */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>bitval</name> <operator>|=</operator> <name>bitmask</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>ArrayCastAndSet</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>freedata</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>bitmap</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>bitmask</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>bitmask</name> <operator>==</operator> <literal type="number">0x100</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>bitmap</name><operator>++</operator> <operator>=</operator> <name>bitval</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>bitval</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>bitmask</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>bitmap</name> <operator>&amp;&amp;</operator> <name>bitmask</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>bitmap</name> <operator>=</operator> <name>bitval</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * array_out :
 *		   takes the internal representation of an array and returns a string
 *		  containing the array in its external format.
 */</comment>
<function><type><name>Datum</name></type>
<name>array_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AnyArrayType</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>PG_GETARG_ANY_ARRAY_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DatumDecodeOptions</name> <modifier>*</modifier></type><name>decode_options</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>element_type</name> <init>= <expr><call><name>AARR_ELEMTYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>typlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typbyval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>typalign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>typdelim</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tmp</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>retval</name></decl>,
			  <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>values</name></decl>,
				<decl><type ref="prev"/><name><name>dims_str</name><index>[<expr><operator>(</operator><name>MAXDIM</name> <operator>*</operator> <literal type="number">33</literal><operator>)</operator> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * 33 per dim since we assume 15 digits per number + ':' +'[]'
	 *
	 * +2 allows for assignment operator + trailing null
	 */</comment>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>needquotes</name></decl>,
				<decl><type ref="prev"/><name>needdims</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>overall_length</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nitems</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>,
				<decl><type ref="prev"/><name>k</name></decl>,
				<decl><type ref="prev"/><name><name>indx</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndim</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>dims</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>lb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>array_iter</name></type>	<name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayMetaState</name> <modifier>*</modifier></type><name>my_extra</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>decode_options</name> <operator>=</operator> <operator>(</operator><name>DatumDecodeOptions</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>typlen</name> <operator>=</operator> <name><name>decode_options</name><operator>-&gt;</operator><name>elem_len</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>typbyval</name> <operator>=</operator> <name><name>decode_options</name><operator>-&gt;</operator><name>elem_by_val</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>typalign</name> <operator>=</operator> <name><name>decode_options</name><operator>-&gt;</operator><name>elem_align</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>typdelim</name> <operator>=</operator> <name><name>decode_options</name><operator>-&gt;</operator><name>elem_delim</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We arrange to look up info about element type, including its output
		 * conversion proc, only once per series of calls, assuming the element
		 * type doesn't change underneath us.
		 */</comment>
		<expr_stmt><expr><name>my_extra</name> <operator>=</operator> <operator>(</operator><name>ArrayMetaState</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>my_extra</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>,
													  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ArrayMetaState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>my_extra</name> <operator>=</operator> <operator>(</operator><name>ArrayMetaState</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>my_extra</name><operator>-&gt;</operator><name>element_type</name></name> <operator>=</operator> <operator>~</operator><name>element_type</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>my_extra</name><operator>-&gt;</operator><name>element_type</name></name> <operator>!=</operator> <name>element_type</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Get info about element type, including its output conversion proc
			 */</comment>
			<expr_stmt><expr><call><name>get_type_io_data</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>, <argument><expr><name>IOFunc_output</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>typalign</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>typdelim</name></name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>typioparam</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>typiofunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>typiofunc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>,
					<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>my_extra</name><operator>-&gt;</operator><name>element_type</name></name> <operator>=</operator> <name>element_type</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>typlen</name> <operator>=</operator> <name><name>my_extra</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>typbyval</name> <operator>=</operator> <name><name>my_extra</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>typalign</name> <operator>=</operator> <name><name>my_extra</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>typdelim</name> <operator>=</operator> <name><name>my_extra</name><operator>-&gt;</operator><name>typdelim</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>ndim</name> <operator>=</operator> <call><name>AARR_NDIM</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dims</name> <operator>=</operator> <call><name>AARR_DIMS</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lb</name> <operator>=</operator> <call><name>AARR_LBOUND</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nitems</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>dims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nitems</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"{}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * we will need to add explicit dimensions if any dimension has a lower
	 * bound other than one
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndim</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>lb</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>needdims</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Convert all values to string form, count total space needed (including
	 * any overhead such as escaping backslashes), and detect whether each
	 * item needs double quotes.
	 */</comment>
	<expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nitems</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>needquotes</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nitems</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>overall_length</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>array_iter_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>itemvalue</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>needquote</name></decl>;</decl_stmt>

		<comment type="block">/* Get source element, checking for NULL */</comment>
		<expr_stmt><expr><name>itemvalue</name> <operator>=</operator> <call><name>array_iter_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
									<argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>overall_length</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>needquote</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>decode_options</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>decode_options</name><operator>-&gt;</operator><name>from_YB</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>decode_options</name><operator>-&gt;</operator><name>option</name></name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>DatumDecodeOptions</name></type> <name>tz_datum_decodeOptions</name></decl>;</decl_stmt>
					<expr_stmt><expr><name><name>tz_datum_decodeOptions</name><operator>.</operator><name>timezone</name></name> <operator>=</operator> <name><name>decode_options</name><operator>-&gt;</operator><name>timezone</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tz_datum_decodeOptions</name><operator>.</operator><name>from_YB</name></name> <operator>=</operator> <name><name>decode_options</name><operator>-&gt;</operator><name>from_YB</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>FunctionCall2</name><argument_list>(<argument><expr><name><name>decode_options</name><operator>-&gt;</operator><name>elem_finfo</name></name></expr></argument>, <argument><expr><name>itemvalue</name></expr></argument>,
								<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tz_datum_decodeOptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>decode_options</name><operator>-&gt;</operator><name>option</name></name> <operator>==</operator> <literal type="char">'r'</literal> <operator>&amp;&amp;</operator>
						<name><name>decode_options</name><operator>-&gt;</operator><name>range_datum_decode_options</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>DatumDecodeOptions</name><modifier>*</modifier></type> <name>range_decodeOptions</name> <init>= <expr><name><name>decode_options</name><operator>-&gt;</operator><name>range_datum_decode_options</name></name></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>FunctionCall2</name><argument_list>(<argument><expr><name><name>decode_options</name><operator>-&gt;</operator><name>elem_finfo</name></name></expr></argument>, <argument><expr><name>itemvalue</name></expr></argument>,
								<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>range_decodeOptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>OutputFunctionCall</name><argument_list>(<argument><expr><name><name>decode_options</name><operator>-&gt;</operator><name>elem_finfo</name></name></expr></argument>, <argument><expr><name>itemvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>OutputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>, <argument><expr><name>itemvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/* count data plus backslashes; detect chars needing quotes */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>needquote</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* force quotes for empty string */</comment>
			<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>needquote</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* force quotes for literal NULL */</comment>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>needquote</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<for>for <control>(<init><expr><name>tmp</name> <operator>=</operator> <name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><operator>*</operator><name>tmp</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>tmp</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type>		<name>ch</name> <init>= <expr><operator>*</operator><name>tmp</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>overall_length</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'"'</literal> <operator>||</operator> <name>ch</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>needquote</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>overall_length</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'{'</literal> <operator>||</operator> <name>ch</name> <operator>==</operator> <literal type="char">'}'</literal> <operator>||</operator> <name>ch</name> <operator>==</operator> <name>typdelim</name> <operator>||</operator>
						 <call><name>array_isspace</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>needquote</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>needquotes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>needquote</name></expr>;</expr_stmt>

		<comment type="block">/* Count the pair of double quotes, if needed */</comment>
		<if_stmt><if>if <condition>(<expr><name>needquote</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>overall_length</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* and the comma (or other typdelim delimiter) */</comment>
		<expr_stmt><expr><name>overall_length</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * The very last array element doesn't have a typdelim delimiter after it,
	 * but that's OK; that space is needed for the trailing '\0'.
	 *
	 * Now count total number of curly brace pairs in output string.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>j</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>k</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndim</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>j</name> <operator>+=</operator> <name>k</name></expr><operator>,</operator> <expr><name>k</name> <operator>*=</operator> <name><name>dims</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name>overall_length</name> <operator>+=</operator> <literal type="number">2</literal> <operator>*</operator> <name>j</name></expr>;</expr_stmt>

	<comment type="block">/* Format explicit dimensions if required */</comment>
	<expr_stmt><expr><name><name>dims_str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>needdims</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>dims_str</name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndim</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="string">"[%d:%d]"</literal></expr></argument>, <argument><expr><name><name>lb</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>lb</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name><name>dims</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><operator>*</operator><name>ptr</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>ASSGN</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>overall_length</name> <operator>+=</operator> <name>ptr</name> <operator>-</operator> <name>dims_str</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Now construct the output string */</comment>
	<expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>overall_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <name>retval</name></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APPENDSTR</name><parameter_list>(<parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(strcpy(p, (str)), p += strlen(p))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APPENDCHAR</name><parameter_list>(<parameter><type><name>ch</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(*p++ = (ch), *p = '\0')</cpp:value></cpp:define>

	<if_stmt><if>if <condition>(<expr><name>needdims</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>APPENDSTR</name><argument_list>(<argument><expr><name>dims_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>APPENDCHAR</name><argument_list>(<argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndim</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>indx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<do>do
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>j</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndim</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>APPENDCHAR</name><argument_list>(<argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

		<if_stmt><if>if <condition>(<expr><name><name>needquotes</name><index>[<expr><name>k</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>APPENDCHAR</name><argument_list>(<argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>tmp</name> <operator>=</operator> <name><name>values</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</init> <condition><expr><operator>*</operator><name>tmp</name></expr>;</condition> <incr><expr><name>tmp</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type>		<name>ch</name> <init>= <expr><operator>*</operator><name>tmp</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'"'</literal> <operator>||</operator> <name>ch</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>ch</name></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>APPENDCHAR</name><argument_list>(<argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>APPENDSTR</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>k</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>ndim</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>++</operator><operator>(</operator><name><name>indx</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>&lt;</operator> <name><name>dims</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>APPENDCHAR</name><argument_list>(<argument><expr><name>typdelim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>indx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APPENDCHAR</name><argument_list>(<argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name>j</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>j</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>;</do>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>APPENDSTR</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>APPENDCHAR</name></cpp:undef>

	<comment type="block">/* Assert that we calculated the string length accurately */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>overall_length</name> <operator>==</operator> <operator>(</operator><name>p</name> <operator>-</operator> <name>retval</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>needquotes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * array_recv :
 *		  converts an array from the external binary format to
 *		  its internal format.
 *
 * return value :
 *		  the internal representation of the input array
 */</comment>
<function><type><name>Datum</name></type>
<name>array_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>spec_element_type</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>	<comment type="block">/* type of an array
														 * element */</comment>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>	<comment type="block">/* typmod for array elements */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>element_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>typlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typbyval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>typalign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typioparam</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>nitems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>dataPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nullsPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasnulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>nbytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>dataoffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>retval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndim</name></decl>,
				<decl><type ref="prev"/><name>flags</name></decl>,
				<decl><type ref="prev"/><name><name>dim</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name><name>lBound</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayMetaState</name> <modifier>*</modifier></type><name>my_extra</name></decl>;</decl_stmt>

	<comment type="block">/* Get the array header information */</comment>
	<expr_stmt><expr><name>ndim</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ndim</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>				<comment type="block">/* we do allow zero-dimension arrays */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_BINARY_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid number of dimensions: %d"</literal></expr></argument>, <argument><expr><name>ndim</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>ndim</name> <operator>&gt;</operator> <name>MAXDIM</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of array dimensions (%d) exceeds the maximum allowed (%d)"</literal></expr></argument>,
						<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>MAXDIM</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>flags</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_BINARY_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid array flags"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>element_type</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>element_type</name> <operator>!=</operator> <name>spec_element_type</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* XXX Can we allow taking the input element type in any cases? */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"wrong element type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndim</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>dim</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lBound</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* This checks for overflow of array dimensions */</comment>
	<expr_stmt><expr><name>nitems</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ArrayCheckBounds</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>lBound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We arrange to look up info about element type, including its receive
	 * conversion proc, only once per series of calls, assuming the element
	 * type doesn't change underneath us.
	 */</comment>
	<expr_stmt><expr><name>my_extra</name> <operator>=</operator> <operator>(</operator><name>ArrayMetaState</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>my_extra</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>,
													  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ArrayMetaState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>my_extra</name> <operator>=</operator> <operator>(</operator><name>ArrayMetaState</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>my_extra</name><operator>-&gt;</operator><name>element_type</name></name> <operator>=</operator> <operator>~</operator><name>element_type</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>my_extra</name><operator>-&gt;</operator><name>element_type</name></name> <operator>!=</operator> <name>element_type</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Get info about element type, including its receive proc */</comment>
		<expr_stmt><expr><call><name>get_type_io_data</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>, <argument><expr><name>IOFunc_receive</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>typalign</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>typdelim</name></name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>typioparam</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>typiofunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>typiofunc</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no binary input function available for type %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>typiofunc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>,
					  <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>my_extra</name><operator>-&gt;</operator><name>element_type</name></name> <operator>=</operator> <name>element_type</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>nitems</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Return empty array ... but not till we've validated element_type */</comment>
		<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><call><name>construct_empty_array</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>typlen</name> <operator>=</operator> <name><name>my_extra</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>typbyval</name> <operator>=</operator> <name><name>my_extra</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>typalign</name> <operator>=</operator> <name><name>my_extra</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>typioparam</name> <operator>=</operator> <name><name>my_extra</name><operator>-&gt;</operator><name>typioparam</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>dataPtr</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nitems</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nullsPtr</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nitems</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReadArrayBinary</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>, <argument><expr><name>typioparam</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>,
					<argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>,
					<argument><expr><name>dataPtr</name></expr></argument>, <argument><expr><name>nullsPtr</name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name>hasnulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>hasnulls</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>dataoffset</name> <operator>=</operator> <call><name>ARR_OVERHEAD_WITHNULLS</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nbytes</name> <operator>+=</operator> <name>dataoffset</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>dataoffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* marker for no null bitmap */</comment>
		<expr_stmt><expr><name>nbytes</name> <operator>+=</operator> <call><name>ARR_OVERHEAD_NONULLS</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>(</operator><name>ArrayType</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>ndim</name></name> <operator>=</operator> <name>ndim</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>dataoffset</name></name> <operator>=</operator> <name>dataoffset</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>elemtype</name></name> <operator>=</operator> <name>element_type</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>ndim</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>ARR_LBOUND</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lBound</name></expr></argument>, <argument><expr><name>ndim</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CopyArrayEls</name><argument_list>(<argument><expr><name>retval</name></expr></argument>,
				 <argument><expr><name>dataPtr</name></expr></argument>, <argument><expr><name>nullsPtr</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>,
				 <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>,
				 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>dataPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nullsPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ReadArrayBinary:
 *	 collect the data elements of an array being read in binary style.
 *
 * Inputs:
 *	buf: the data buffer to read from.
 *	nitems: total number of array elements (already read).
 *	receiveproc: type-specific receive procedure for element datatype.
 *	typioparam, typmod: auxiliary values to pass to receiveproc.
 *	typlen, typbyval, typalign: storage parameters of element datatype.
 *
 * Outputs:
 *	values[]: filled with converted data values.
 *	nulls[]: filled with is-null markers.
 *	*hasnulls: set true iff there are any null elements.
 *	*nbytes: set to total size of data area needed (including alignment
 *		padding but not including array header overhead).
 *
 * Note that values[] and nulls[] are allocated by the caller, and must have
 * nitems elements.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReadArrayBinary</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>nitems</name></decl></parameter>,
				<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>receiveproc</name></decl></parameter>,
				<parameter><decl><type><name>Oid</name></type> <name>typioparam</name></decl></parameter>,
				<parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>typlen</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>typbyval</name></decl></parameter>,
				<parameter><decl><type><name>char</name></type> <name>typalign</name></decl></parameter>,
				<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
				<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>,
				<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasnulls</name></decl></parameter>,
				<parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>nbytes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>totbytes</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>itemlen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>elem_buf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>csave</name></decl>;</decl_stmt>

		<comment type="block">/* Get and check the item length */</comment>
		<expr_stmt><expr><name>itemlen</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name><name>itemlen</name> <argument_list type="generic">&lt; <argument><expr><operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>itemlen</name></expr></argument> &gt;</argument_list></name> <argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name><name>buf</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_BINARY_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"insufficient data left in message"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>itemlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* -1 length means NULL */</comment>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>ReceiveFunctionCall</name><argument_list>(<argument><expr><name>receiveproc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
											<argument><expr><name>typioparam</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Rather than copying data around, we just set up a phony StringInfo
		 * pointing to the correct portion of the input buffer. We assume we
		 * can scribble on the input buffer so as to maintain the convention
		 * that StringInfos have a trailing null.
		 */</comment>
		<expr_stmt><expr><name><name>elem_buf</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>buf</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>buf</name><operator>-&gt;</operator><name>cursor</name></name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>elem_buf</name><operator>.</operator><name>maxlen</name></name> <operator>=</operator> <name>itemlen</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>elem_buf</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>itemlen</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>elem_buf</name><operator>.</operator><name>cursor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>cursor</name></name> <operator>+=</operator> <name>itemlen</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>csave</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>buf</name><operator>-&gt;</operator><name>cursor</name></name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>buf</name><operator>-&gt;</operator><name>cursor</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

		<comment type="block">/* Now call the element's receiveproc */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>ReceiveFunctionCall</name><argument_list>(<argument><expr><name>receiveproc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elem_buf</name></expr></argument>,
										<argument><expr><name>typioparam</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* Trouble if it didn't eat the whole buffer */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>elem_buf</name><operator>.</operator><name>cursor</name></name> <operator>!=</operator> <name>itemlen</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_BINARY_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"improper binary format in array element %d"</literal></expr></argument>,
							<argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>buf</name><operator>-&gt;</operator><name>cursor</name></name></expr>]</index></name> <operator>=</operator> <name>csave</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Check for nulls, compute total data space needed
	 */</comment>
	<expr_stmt><expr><name>hasnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>totbytes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>hasnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* let's just make sure data is not toasted */</comment>
			<if_stmt><if>if <condition>(<expr><name>typlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>totbytes</name> <operator>=</operator> <call><name>att_addlength_datum</name><argument_list>(<argument><expr><name>totbytes</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>totbytes</name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>totbytes</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* check for overflow of total request */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AllocSizeIsValid</name><argument_list>(<argument><expr><name>totbytes</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"array size exceeds the maximum allowed (%d)"</literal></expr></argument>,
								<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>MaxAllocSize</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><operator>*</operator><name>hasnulls</name> <operator>=</operator> <name>hasnull</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>nbytes</name> <operator>=</operator> <name>totbytes</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * array_send :
 *		  takes the internal representation of an array and returns a bytea
 *		  containing the array in its external binary format.
 */</comment>
<function><type><name>Datum</name></type>
<name>array_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AnyArrayType</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>PG_GETARG_ANY_ARRAY_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>element_type</name> <init>= <expr><call><name>AARR_ELEMTYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>typlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typbyval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>typalign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nitems</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndim</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>dim</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>lb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>array_iter</name></type>	<name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayMetaState</name> <modifier>*</modifier></type><name>my_extra</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We arrange to look up info about element type, including its send
	 * conversion proc, only once per series of calls, assuming the element
	 * type doesn't change underneath us.
	 */</comment>
	<expr_stmt><expr><name>my_extra</name> <operator>=</operator> <operator>(</operator><name>ArrayMetaState</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>my_extra</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>,
													  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ArrayMetaState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>my_extra</name> <operator>=</operator> <operator>(</operator><name>ArrayMetaState</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>my_extra</name><operator>-&gt;</operator><name>element_type</name></name> <operator>=</operator> <operator>~</operator><name>element_type</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>my_extra</name><operator>-&gt;</operator><name>element_type</name></name> <operator>!=</operator> <name>element_type</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Get info about element type, including its send proc */</comment>
		<expr_stmt><expr><call><name>get_type_io_data</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>, <argument><expr><name>IOFunc_send</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>typalign</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>typdelim</name></name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>typioparam</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>typiofunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>typiofunc</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no binary output function available for type %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>typiofunc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>,
					  <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>my_extra</name><operator>-&gt;</operator><name>element_type</name></name> <operator>=</operator> <name>element_type</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>typlen</name> <operator>=</operator> <name><name>my_extra</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>typbyval</name> <operator>=</operator> <name><name>my_extra</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>typalign</name> <operator>=</operator> <name><name>my_extra</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>ndim</name> <operator>=</operator> <call><name>AARR_NDIM</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dim</name> <operator>=</operator> <call><name>AARR_DIMS</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lb</name> <operator>=</operator> <call><name>AARR_LBOUND</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nitems</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Send the array header information */</comment>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>ndim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><ternary><condition><expr><call><name>AARR_HASNULL</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>element_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndim</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>dim</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>lb</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Send the array elements using the element's own sendproc */</comment>
	<expr_stmt><expr><call><name>array_iter_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>itemvalue</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

		<comment type="block">/* Get source element, checking for NULL */</comment>
		<expr_stmt><expr><name>itemvalue</name> <operator>=</operator> <call><name>array_iter_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
									<argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* -1 length means a NULL */</comment>
			<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>outputbytes</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>outputbytes</name> <operator>=</operator> <call><name>SendFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>, <argument><expr><name>itemvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>outputbytes</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>outputbytes</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>outputbytes</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>outputbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * array_ndims :
 *		  returns the number of dimensions of the array pointed to by "v"
 */</comment>
<function><type><name>Datum</name></type>
<name>array_ndims</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AnyArrayType</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>PG_GETARG_ANY_ARRAY_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Sanity check: does it look like an array at all? */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>AARR_NDIM</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>AARR_NDIM</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>MAXDIM</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>AARR_NDIM</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * array_dims :
 *		  returns the dimensions of the array pointed to by "v", as a "text"
 */</comment>
<function><type><name>Datum</name></type>
<name>array_dims</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AnyArrayType</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>PG_GETARG_ANY_ARRAY_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>dimv</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>lb</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * 33 since we assume 15 digits per number + ':' +'[]'
	 *
	 * +1 for trailing null
	 */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>MAXDIM</name> <operator>*</operator> <literal type="number">33</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* Sanity check: does it look like an array at all? */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>AARR_NDIM</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>AARR_NDIM</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>MAXDIM</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>dimv</name> <operator>=</operator> <call><name>AARR_DIMS</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lb</name> <operator>=</operator> <call><name>AARR_LBOUND</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>p</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>AARR_NDIM</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"[%d:%d]"</literal></expr></argument>, <argument><expr><name><name>lb</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>dimv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name><name>lb</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * array_lower :
 *		returns the lower dimension, of the DIM requested, for
 *		the array pointed to by "v", as an int4
 */</comment>
<function><type><name>Datum</name></type>
<name>array_lower</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AnyArrayType</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>PG_GETARG_ANY_ARRAY_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>reqdim</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>lb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Sanity check: does it look like an array at all? */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>AARR_NDIM</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>AARR_NDIM</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>MAXDIM</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Sanity check: was the requested dim valid */</comment>
	<if_stmt><if>if <condition>(<expr><name>reqdim</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>reqdim</name> <operator>&gt;</operator> <call><name>AARR_NDIM</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>lb</name> <operator>=</operator> <call><name>AARR_LBOUND</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>lb</name><index>[<expr><name>reqdim</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * array_upper :
 *		returns the upper dimension, of the DIM requested, for
 *		the array pointed to by "v", as an int4
 */</comment>
<function><type><name>Datum</name></type>
<name>array_upper</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AnyArrayType</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>PG_GETARG_ANY_ARRAY_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>reqdim</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>dimv</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>lb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Sanity check: does it look like an array at all? */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>AARR_NDIM</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>AARR_NDIM</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>MAXDIM</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Sanity check: was the requested dim valid */</comment>
	<if_stmt><if>if <condition>(<expr><name>reqdim</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>reqdim</name> <operator>&gt;</operator> <call><name>AARR_NDIM</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>lb</name> <operator>=</operator> <call><name>AARR_LBOUND</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dimv</name> <operator>=</operator> <call><name>AARR_DIMS</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>dimv</name><index>[<expr><name>reqdim</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>lb</name><index>[<expr><name>reqdim</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * array_length :
 *		returns the length, of the dimension requested, for
 *		the array pointed to by "v", as an int4
 */</comment>
<function><type><name>Datum</name></type>
<name>array_length</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AnyArrayType</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>PG_GETARG_ANY_ARRAY_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>reqdim</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>dimv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Sanity check: does it look like an array at all? */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>AARR_NDIM</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>AARR_NDIM</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>MAXDIM</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Sanity check: was the requested dim valid */</comment>
	<if_stmt><if>if <condition>(<expr><name>reqdim</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>reqdim</name> <operator>&gt;</operator> <call><name>AARR_NDIM</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>dimv</name> <operator>=</operator> <call><name>AARR_DIMS</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>dimv</name><index>[<expr><name>reqdim</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * array_cardinality:
 *		returns the total number of elements in an array
 */</comment>
<function><type><name>Datum</name></type>
<name>array_cardinality</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AnyArrayType</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>PG_GETARG_ANY_ARRAY_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>ArrayGetNItems</name><argument_list>(<argument><expr><call><name>AARR_NDIM</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>AARR_DIMS</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * array_get_element :
 *	  This routine takes an array datum and a subscript array and returns
 *	  the referenced item as a Datum.  Note that for a pass-by-reference
 *	  datatype, the returned Datum is a pointer into the array object.
 *
 * This handles both ordinary varlena arrays and fixed-length arrays.
 *
 * Inputs:
 *	arraydatum: the array object (mustn't be NULL)
 *	nSubscripts: number of subscripts supplied
 *	indx[]: the subscript values
 *	arraytyplen: pg_type.typlen for the array type
 *	elmlen: pg_type.typlen for the array's element type
 *	elmbyval: pg_type.typbyval for the array's element type
 *	elmalign: pg_type.typalign for the array's element type
 *
 * Outputs:
 *	The return value is the element Datum.
 *	*isNull is set to indicate whether the element is NULL.
 */</comment>
<function><type><name>Datum</name></type>
<name>array_get_element</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arraydatum</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>nSubscripts</name></decl></parameter>,
				  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>indx</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>arraytyplen</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>elmlen</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>elmbyval</name></decl></parameter>,
				  <parameter><decl><type><name>char</name></type> <name>elmalign</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>ndim</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>dim</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>lb</name></decl>,
				<decl><type ref="prev"/><name>offset</name></decl>,
				<decl><type ref="prev"/><name><name>fixedDim</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name><name>fixedLb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>arraydataptr</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>retptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bits8</name>	   <modifier>*</modifier></type><name>arraynullsptr</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>arraytyplen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * fixed-length arrays -- these are assumed to be 1-d, 0-based
		 */</comment>
		<expr_stmt><expr><name>ndim</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fixedDim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>arraytyplen</name> <operator>/</operator> <name>elmlen</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fixedLb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>dim</name> <operator>=</operator> <name>fixedDim</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>lb</name> <operator>=</operator> <name>fixedLb</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>arraydataptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>arraydatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>arraynullsptr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_EXPANDED</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>arraydatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* expanded array: let's do this in a separate function */</comment>
		<return>return <expr><call><name>array_get_element_expanded</name><argument_list>(<argument><expr><name>arraydatum</name></expr></argument>,
										  <argument><expr><name>nSubscripts</name></expr></argument>,
										  <argument><expr><name>indx</name></expr></argument>,
										  <argument><expr><name>arraytyplen</name></expr></argument>,
										  <argument><expr><name>elmlen</name></expr></argument>,
										  <argument><expr><name>elmbyval</name></expr></argument>,
										  <argument><expr><name>elmalign</name></expr></argument>,
										  <argument><expr><name>isNull</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* detoast array if necessary, producing normal varlena input */</comment>
		<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>array</name> <init>= <expr><call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>arraydatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>ndim</name> <operator>=</operator> <call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dim</name> <operator>=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lb</name> <operator>=</operator> <call><name>ARR_LBOUND</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>arraydataptr</name> <operator>=</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>arraynullsptr</name> <operator>=</operator> <call><name>ARR_NULLBITMAP</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Return NULL for invalid subscript
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ndim</name> <operator>!=</operator> <name>nSubscripts</name> <operator>||</operator> <name>ndim</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>ndim</name> <operator>&gt;</operator> <name>MAXDIM</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndim</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>indx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name><name>lb</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator> <name><name>indx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <operator>(</operator><name><name>dim</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name><name>lb</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Calculate the element number
	 */</comment>
	<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>ArrayGetOffset</name><argument_list>(<argument><expr><name>nSubscripts</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>lb</name></expr></argument>, <argument><expr><name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check for NULL array element
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>array_get_isnull</name><argument_list>(<argument><expr><name>arraynullsptr</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * OK, get the element
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>retptr</name> <operator>=</operator> <call><name>array_seek</name><argument_list>(<argument><expr><name>arraydataptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>arraynullsptr</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>,
						<argument><expr><name>elmlen</name></expr></argument>, <argument><expr><name>elmbyval</name></expr></argument>, <argument><expr><name>elmalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>ArrayCast</name><argument_list>(<argument><expr><name>retptr</name></expr></argument>, <argument><expr><name>elmbyval</name></expr></argument>, <argument><expr><name>elmlen</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Implementation of array_get_element() for an expanded array
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>array_get_element_expanded</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arraydatum</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>nSubscripts</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>indx</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>arraytyplen</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>elmlen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>elmbyval</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>elmalign</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExpandedArrayHeader</name> <modifier>*</modifier></type><name>eah</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>ndim</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>dim</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>lb</name></decl>,
				<decl><type ref="prev"/><name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>dvalues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>dnulls</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>eah</name> <operator>=</operator> <operator>(</operator><name>ExpandedArrayHeader</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetEOHP</name><argument_list>(<argument><expr><name>arraydatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>eah</name><operator>-&gt;</operator><name>ea_magic</name></name> <operator>==</operator> <name>EA_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* sanity-check caller's info against object */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>arraytyplen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>elmlen</name> <operator>==</operator> <name><name>eah</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>elmbyval</name> <operator>==</operator> <name><name>eah</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>elmalign</name> <operator>==</operator> <name><name>eah</name><operator>-&gt;</operator><name>typalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ndim</name> <operator>=</operator> <name><name>eah</name><operator>-&gt;</operator><name>ndims</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>dim</name> <operator>=</operator> <name><name>eah</name><operator>-&gt;</operator><name>dims</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lb</name> <operator>=</operator> <name><name>eah</name><operator>-&gt;</operator><name>lbound</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Return NULL for invalid subscript
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ndim</name> <operator>!=</operator> <name>nSubscripts</name> <operator>||</operator> <name>ndim</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>ndim</name> <operator>&gt;</operator> <name>MAXDIM</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndim</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>indx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name><name>lb</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator> <name><name>indx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <operator>(</operator><name><name>dim</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name><name>lb</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Calculate the element number
	 */</comment>
	<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>ArrayGetOffset</name><argument_list>(<argument><expr><name>nSubscripts</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>lb</name></expr></argument>, <argument><expr><name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Deconstruct array if we didn't already.  Note that we apply this even
	 * if the input is nominally read-only: it should be safe enough.
	 */</comment>
	<expr_stmt><expr><call><name>deconstruct_expanded_array</name><argument_list>(<argument><expr><name>eah</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>dvalues</name> <operator>=</operator> <name><name>eah</name><operator>-&gt;</operator><name>dvalues</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>dnulls</name> <operator>=</operator> <name><name>eah</name><operator>-&gt;</operator><name>dnulls</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check for NULL array element
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>dnulls</name> <operator>&amp;&amp;</operator> <name><name>dnulls</name><index>[<expr><name>offset</name></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * OK, get the element.  It's OK to return a pass-by-ref value as a
	 * pointer into the expanded array, for the same reason that regular
	 * array_get_element can return a pointer into flat arrays: the value is
	 * assumed not to change for as long as the Datum reference can exist.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<return>return <expr><name><name>dvalues</name><index>[<expr><name>offset</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * array_get_slice :
 *		   This routine takes an array and a range of indices (upperIndex and
 *		   lowerIndx), creates a new array structure for the referred elements
 *		   and returns a pointer to it.
 *
 * This handles both ordinary varlena arrays and fixed-length arrays.
 *
 * Inputs:
 *	arraydatum: the array object (mustn't be NULL)
 *	nSubscripts: number of subscripts supplied (must be same for upper/lower)
 *	upperIndx[]: the upper subscript values
 *	lowerIndx[]: the lower subscript values
 *	upperProvided[]: true for provided upper subscript values
 *	lowerProvided[]: true for provided lower subscript values
 *	arraytyplen: pg_type.typlen for the array type
 *	elmlen: pg_type.typlen for the array's element type
 *	elmbyval: pg_type.typbyval for the array's element type
 *	elmalign: pg_type.typalign for the array's element type
 *
 * Outputs:
 *	The return value is the new array Datum (it's never NULL)
 *
 * Omitted upper and lower subscript values are replaced by the corresponding
 * array bound.
 *
 * NOTE: we assume it is OK to scribble on the provided subscript arrays
 * lowerIndx[] and upperIndx[].  These are generally just temporaries.
 */</comment>
<function><type><name>Datum</name></type>
<name>array_get_slice</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arraydatum</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>nSubscripts</name></decl></parameter>,
				<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>upperIndx</name></decl></parameter>,
				<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>lowerIndx</name></decl></parameter>,
				<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>upperProvided</name></decl></parameter>,
				<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>lowerProvided</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>arraytyplen</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>elmlen</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>elmbyval</name></decl></parameter>,
				<parameter><decl><type><name>char</name></type> <name>elmalign</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>array</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>newarray</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>ndim</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>dim</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>lb</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>newlb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>fixedDim</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name><name>fixedLb</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>elemtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>arraydataptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bits8</name>	   <modifier>*</modifier></type><name>arraynullsptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>dataoffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bytes</name></decl>,
				<decl><type ref="prev"/><name><name>span</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>arraytyplen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * fixed-length arrays -- currently, cannot slice these because parser
		 * labels output as being of the fixed-length array type! Code below
		 * shows how we could support it if the parser were changed to label
		 * output as a suitable varlena array type.
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"slices of fixed-length arrays not implemented"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * fixed-length arrays -- these are assumed to be 1-d, 0-based
		 *
		 * XXX where would we get the correct ELEMTYPE from?
		 */</comment>
		<expr_stmt><expr><name>ndim</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fixedDim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>arraytyplen</name> <operator>/</operator> <name>elmlen</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fixedLb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>dim</name> <operator>=</operator> <name>fixedDim</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>lb</name> <operator>=</operator> <name>fixedLb</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>elemtype</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>	<comment type="block">/* XXX */</comment>
		<expr_stmt><expr><name>arraydataptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>arraydatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>arraynullsptr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* detoast input array if necessary */</comment>
		<expr_stmt><expr><name>array</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>arraydatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ndim</name> <operator>=</operator> <call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dim</name> <operator>=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lb</name> <operator>=</operator> <call><name>ARR_LBOUND</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>elemtype</name> <operator>=</operator> <call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>arraydataptr</name> <operator>=</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>arraynullsptr</name> <operator>=</operator> <call><name>ARR_NULLBITMAP</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Check provided subscripts.  A slice exceeding the current array limits
	 * is silently truncated to the array limits.  If we end up with an empty
	 * slice, return an empty array.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ndim</name> <argument_list type="generic">&lt; <argument><expr><name>nSubscripts</name> <operator>||</operator> <name>ndim</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>ndim</name></expr></argument> &gt;</argument_list></name> <name>MAXDIM</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>construct_empty_array</name><argument_list>(<argument><expr><name>elemtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nSubscripts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lowerProvided</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator> <name><name>lowerIndx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name><name>lb</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>lowerIndx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>lb</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>upperProvided</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator> <name><name>upperIndx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <operator>(</operator><name><name>dim</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name><name>lb</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>upperIndx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>dim</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name><name>lb</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>lowerIndx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name><name>upperIndx</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>construct_empty_array</name><argument_list>(<argument><expr><name>elemtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<comment type="block">/* fill any missing subscript positions with full array range */</comment>
	<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndim</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>lowerIndx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>lb</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>upperIndx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>dim</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name><name>lb</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>lowerIndx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name><name>upperIndx</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>construct_empty_array</name><argument_list>(<argument><expr><name>elemtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>mda_get_range</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>span</name></expr></argument>, <argument><expr><name>lowerIndx</name></expr></argument>, <argument><expr><name>upperIndx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>bytes</name> <operator>=</operator> <call><name>array_slice_size</name><argument_list>(<argument><expr><name>arraydataptr</name></expr></argument>, <argument><expr><name>arraynullsptr</name></expr></argument>,
							 <argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>lb</name></expr></argument>,
							 <argument><expr><name>lowerIndx</name></expr></argument>, <argument><expr><name>upperIndx</name></expr></argument>,
							 <argument><expr><name>elmlen</name></expr></argument>, <argument><expr><name>elmbyval</name></expr></argument>, <argument><expr><name>elmalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Currently, we put a null bitmap in the result if the source has one;
	 * could be smarter ...
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>arraynullsptr</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>dataoffset</name> <operator>=</operator> <call><name>ARR_OVERHEAD_WITHNULLS</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><call><name>ArrayGetNItems</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>span</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bytes</name> <operator>+=</operator> <name>dataoffset</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>dataoffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* marker for no null bitmap */</comment>
		<expr_stmt><expr><name>bytes</name> <operator>+=</operator> <call><name>ARR_OVERHEAD_NONULLS</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>newarray</name> <operator>=</operator> <operator>(</operator><name>ArrayType</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>newarray</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newarray</name><operator>-&gt;</operator><name>ndim</name></name> <operator>=</operator> <name>ndim</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newarray</name><operator>-&gt;</operator><name>dataoffset</name></name> <operator>=</operator> <name>dataoffset</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newarray</name><operator>-&gt;</operator><name>elemtype</name></name> <operator>=</operator> <name>elemtype</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>newarray</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>span</name></expr></argument>, <argument><expr><name>ndim</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Lower bounds of the new array are set to 1.  Formerly (before 7.3) we
	 * copied the given lowerIndx values ... but that seems confusing.
	 */</comment>
	<expr_stmt><expr><name>newlb</name> <operator>=</operator> <call><name>ARR_LBOUND</name><argument_list>(<argument><expr><name>newarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndim</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newlb</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>array_extract_slice</name><argument_list>(<argument><expr><name>newarray</name></expr></argument>,
						<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>lb</name></expr></argument>,
						<argument><expr><name>arraydataptr</name></expr></argument>, <argument><expr><name>arraynullsptr</name></expr></argument>,
						<argument><expr><name>lowerIndx</name></expr></argument>, <argument><expr><name>upperIndx</name></expr></argument>,
						<argument><expr><name>elmlen</name></expr></argument>, <argument><expr><name>elmbyval</name></expr></argument>, <argument><expr><name>elmalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>newarray</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * array_set_element :
 *		  This routine sets the value of one array element (specified by
 *		  a subscript array) to a new value specified by "dataValue".
 *
 * This handles both ordinary varlena arrays and fixed-length arrays.
 *
 * Inputs:
 *	arraydatum: the initial array object (mustn't be NULL)
 *	nSubscripts: number of subscripts supplied
 *	indx[]: the subscript values
 *	dataValue: the datum to be inserted at the given position
 *	isNull: whether dataValue is NULL
 *	arraytyplen: pg_type.typlen for the array type
 *	elmlen: pg_type.typlen for the array's element type
 *	elmbyval: pg_type.typbyval for the array's element type
 *	elmalign: pg_type.typalign for the array's element type
 *
 * Result:
 *		  A new array is returned, just like the old except for the one
 *		  modified entry.  The original array object is not changed,
 *		  unless what is passed is a read-write reference to an expanded
 *		  array object; in that case the expanded array is updated in-place.
 *
 * For one-dimensional arrays only, we allow the array to be extended
 * by assigning to a position outside the existing subscript range; any
 * positions between the existing elements and the new one are set to NULLs.
 * (XXX TODO: allow a corresponding behavior for multidimensional arrays)
 *
 * NOTE: For assignments, we throw an error for invalid subscripts etc,
 * rather than returning a NULL as the fetch operations do.
 */</comment>
<function><type><name>Datum</name></type>
<name>array_set_element</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arraydatum</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>nSubscripts</name></decl></parameter>,
				  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>indx</name></decl></parameter>,
				  <parameter><decl><type><name>Datum</name></type> <name>dataValue</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>isNull</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>arraytyplen</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>elmlen</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>elmbyval</name></decl></parameter>,
				  <parameter><decl><type><name>char</name></type> <name>elmalign</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>array</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>newarray</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>ndim</name></decl>,
				<decl><type ref="prev"/><name><name>dim</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name><name>lb</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>elt_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>newhasnulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bits8</name>	   <modifier>*</modifier></type><name>oldnullbitmap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>oldnitems</name></decl>,
				<decl><type ref="prev"/><name>newnitems</name></decl>,
				<decl><type ref="prev"/><name>olddatasize</name></decl>,
				<decl><type ref="prev"/><name>newsize</name></decl>,
				<decl><type ref="prev"/><name>olditemlen</name></decl>,
				<decl><type ref="prev"/><name>newitemlen</name></decl>,
				<decl><type ref="prev"/><name>overheadlen</name></decl>,
				<decl><type ref="prev"/><name>oldoverheadlen</name></decl>,
				<decl><type ref="prev"/><name>addedbefore</name></decl>,
				<decl><type ref="prev"/><name>addedafter</name></decl>,
				<decl><type ref="prev"/><name>lenbefore</name></decl>,
				<decl><type ref="prev"/><name>lenafter</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>arraytyplen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * fixed-length arrays -- these are assumed to be 1-d, 0-based. We
		 * cannot extend them, either.
		 */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>resultarray</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>nSubscripts</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"wrong number of array subscripts"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>indx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>indx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <name>arraytyplen</name> <operator>/</operator> <name>elmlen</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"array subscript out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot assign null value to an element of a fixed-length array"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>resultarray</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>arraytyplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>resultarray</name></expr></argument>, <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>arraydatum</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arraytyplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>elt_ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>resultarray</name> <operator>+</operator> <name><name>indx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name>elmlen</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ArrayCastAndSet</name><argument_list>(<argument><expr><name>dataValue</name></expr></argument>, <argument><expr><name>elmlen</name></expr></argument>, <argument><expr><name>elmbyval</name></expr></argument>, <argument><expr><name>elmalign</name></expr></argument>, <argument><expr><name>elt_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>resultarray</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>nSubscripts</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>nSubscripts</name> <operator>&gt;</operator> <name>MAXDIM</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"wrong number of array subscripts"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* make sure item to be inserted is not toasted */</comment>
	<if_stmt><if>if <condition>(<expr><name>elmlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dataValue</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name>dataValue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_EXPANDED</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>arraydatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* expanded array: let's do this in a separate function */</comment>
		<return>return <expr><call><name>array_set_element_expanded</name><argument_list>(<argument><expr><name>arraydatum</name></expr></argument>,
										  <argument><expr><name>nSubscripts</name></expr></argument>,
										  <argument><expr><name>indx</name></expr></argument>,
										  <argument><expr><name>dataValue</name></expr></argument>,
										  <argument><expr><name>isNull</name></expr></argument>,
										  <argument><expr><name>arraytyplen</name></expr></argument>,
										  <argument><expr><name>elmlen</name></expr></argument>,
										  <argument><expr><name>elmbyval</name></expr></argument>,
										  <argument><expr><name>elmalign</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* detoast input array if necessary */</comment>
	<expr_stmt><expr><name>array</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>arraydatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ndim</name> <operator>=</operator> <call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * if number of dims is zero, i.e. an empty array, create an array with
	 * nSubscripts dimensions, and set the lower bounds to the supplied
	 * subscripts
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ndim</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>elmtype</name> <init>= <expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nSubscripts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>dim</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>lb</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>indx</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>construct_md_array</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dataValue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>,
												  <argument><expr><name>nSubscripts</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>lb</name></expr></argument>,
												  <argument><expr><name>elmtype</name></expr></argument>,
												  <argument><expr><name>elmlen</name></expr></argument>, <argument><expr><name>elmbyval</name></expr></argument>, <argument><expr><name>elmalign</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ndim</name> <operator>!=</operator> <name>nSubscripts</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"wrong number of array subscripts"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* copy dim/lb since we may modify them */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dim</name></expr></argument>, <argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ndim</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>lb</name></expr></argument>, <argument><expr><call><name>ARR_LBOUND</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ndim</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>newhasnulls</name> <operator>=</operator> <operator>(</operator><call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>isNull</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>addedbefore</name> <operator>=</operator> <name>addedafter</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check subscripts
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ndim</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>indx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <name><name>lb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>addedbefore</name> <operator>=</operator> <name><name>lb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name><name>indx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <name>addedbefore</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>lb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>indx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>addedbefore</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>newhasnulls</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* will insert nulls */</comment>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>indx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <operator>(</operator><name><name>dim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>lb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>addedafter</name> <operator>=</operator> <name><name>indx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <operator>(</operator><name><name>dim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>lb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <name>addedafter</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>addedafter</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>newhasnulls</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* will insert nulls */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * XXX currently we do not support extending multi-dimensional arrays
		 * during assignment
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndim</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>indx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name><name>lb</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator>
				<name><name>indx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <operator>(</operator><name><name>dim</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name><name>lb</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"array subscript out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* This checks for overflow of the array dimensions */</comment>
	<expr_stmt><expr><name>newnitems</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ArrayCheckBounds</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>lb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute sizes of items and areas to copy
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>newhasnulls</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>overheadlen</name> <operator>=</operator> <call><name>ARR_OVERHEAD_WITHNULLS</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>newnitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>overheadlen</name> <operator>=</operator> <call><name>ARR_OVERHEAD_NONULLS</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>oldnitems</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldnullbitmap</name> <operator>=</operator> <call><name>ARR_NULLBITMAP</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldoverheadlen</name> <operator>=</operator> <call><name>ARR_DATA_OFFSET</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>olddatasize</name> <operator>=</operator> <call><name>ARR_SIZE</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>oldoverheadlen</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>addedbefore</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>lenbefore</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>olditemlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>lenafter</name> <operator>=</operator> <name>olddatasize</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>addedafter</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>offset</name> <operator>=</operator> <name>oldnitems</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>lenbefore</name> <operator>=</operator> <name>olddatasize</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>olditemlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>lenafter</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>ArrayGetOffset</name><argument_list>(<argument><expr><name>nSubscripts</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>lb</name></expr></argument>, <argument><expr><name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>elt_ptr</name> <operator>=</operator> <call><name>array_seek</name><argument_list>(<argument><expr><call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>oldnullbitmap</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>,
							 <argument><expr><name>elmlen</name></expr></argument>, <argument><expr><name>elmbyval</name></expr></argument>, <argument><expr><name>elmalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lenbefore</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>elt_ptr</name> <operator>-</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>array_get_isnull</name><argument_list>(<argument><expr><name>oldnullbitmap</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>olditemlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>olditemlen</name> <operator>=</operator> <call><name>att_addlength_pointer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>elmlen</name></expr></argument>, <argument><expr><name>elt_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>olditemlen</name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>olditemlen</name></expr></argument>, <argument><expr><name>elmalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>lenafter</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>olddatasize</name> <operator>-</operator> <name>lenbefore</name> <operator>-</operator> <name>olditemlen</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>newitemlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>newitemlen</name> <operator>=</operator> <call><name>att_addlength_datum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>elmlen</name></expr></argument>, <argument><expr><name>dataValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newitemlen</name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>newitemlen</name></expr></argument>, <argument><expr><name>elmalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>newsize</name> <operator>=</operator> <name>overheadlen</name> <operator>+</operator> <name>lenbefore</name> <operator>+</operator> <name>newitemlen</name> <operator>+</operator> <name>lenafter</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * OK, create the new array and fill in header/dimensions
	 */</comment>
	<expr_stmt><expr><name>newarray</name> <operator>=</operator> <operator>(</operator><name>ArrayType</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>newarray</name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newarray</name><operator>-&gt;</operator><name>ndim</name></name> <operator>=</operator> <name>ndim</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newarray</name><operator>-&gt;</operator><name>dataoffset</name></name> <operator>=</operator> <ternary><condition><expr><name>newhasnulls</name></expr> ?</condition><then> <expr><name>overheadlen</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newarray</name><operator>-&gt;</operator><name>elemtype</name></name> <operator>=</operator> <call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>newarray</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>ndim</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>ARR_LBOUND</name><argument_list>(<argument><expr><name>newarray</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lb</name></expr></argument>, <argument><expr><name>ndim</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fill in data
	 */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>newarray</name> <operator>+</operator> <name>overheadlen</name></expr></argument>,
		   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>array</name> <operator>+</operator> <name>oldoverheadlen</name></expr></argument>,
		   <argument><expr><name>lenbefore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArrayCastAndSet</name><argument_list>(<argument><expr><name>dataValue</name></expr></argument>, <argument><expr><name>elmlen</name></expr></argument>, <argument><expr><name>elmbyval</name></expr></argument>, <argument><expr><name>elmalign</name></expr></argument>,
						<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>newarray</name> <operator>+</operator> <name>overheadlen</name> <operator>+</operator> <name>lenbefore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>newarray</name> <operator>+</operator> <name>overheadlen</name> <operator>+</operator> <name>lenbefore</name> <operator>+</operator> <name>newitemlen</name></expr></argument>,
		   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>array</name> <operator>+</operator> <name>oldoverheadlen</name> <operator>+</operator> <name>lenbefore</name> <operator>+</operator> <name>olditemlen</name></expr></argument>,
		   <argument><expr><name>lenafter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fill in nulls bitmap if needed
	 *
	 * Note: it's possible we just replaced the last NULL with a non-NULL, and
	 * could get rid of the bitmap.  Seems not worth testing for though.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>newhasnulls</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bits8</name>	   <modifier>*</modifier></type><name>newnullbitmap</name> <init>= <expr><call><name>ARR_NULLBITMAP</name><argument_list>(<argument><expr><name>newarray</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Zero the bitmap to take care of marking inserted positions null */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>newnullbitmap</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>newnitems</name> <operator>+</operator> <literal type="number">7</literal><operator>)</operator> <operator>/</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Fix the inserted value */</comment>
		<if_stmt><if>if <condition>(<expr><name>addedafter</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>array_set_isnull</name><argument_list>(<argument><expr><name>newnullbitmap</name></expr></argument>, <argument><expr><name>newnitems</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>array_set_isnull</name><argument_list>(<argument><expr><name>newnullbitmap</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<comment type="block">/* Fix the copied range(s) */</comment>
		<if_stmt><if>if <condition>(<expr><name>addedbefore</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>array_bitmap_copy</name><argument_list>(<argument><expr><name>newnullbitmap</name></expr></argument>, <argument><expr><name>addedbefore</name></expr></argument>,
							  <argument><expr><name>oldnullbitmap</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							  <argument><expr><name>oldnitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>array_bitmap_copy</name><argument_list>(<argument><expr><name>newnullbitmap</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							  <argument><expr><name>oldnullbitmap</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							  <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>addedafter</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>array_bitmap_copy</name><argument_list>(<argument><expr><name>newnullbitmap</name></expr></argument>, <argument><expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
								  <argument><expr><name>oldnullbitmap</name></expr></argument>, <argument><expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
								  <argument><expr><name>oldnitems</name> <operator>-</operator> <name>offset</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>newarray</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Implementation of array_set_element() for an expanded array
 *
 * Note: as with any operation on a read/write expanded object, we must
 * take pains not to leave the object in a corrupt state if we fail partway
 * through.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>array_set_element_expanded</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arraydatum</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>nSubscripts</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>indx</name></decl></parameter>,
						   <parameter><decl><type><name>Datum</name></type> <name>dataValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isNull</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>arraytyplen</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>elmlen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>elmbyval</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>elmalign</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExpandedArrayHeader</name> <modifier>*</modifier></type><name>eah</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>dvalues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>dnulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>ndim</name></decl>,
				<decl><type ref="prev"/><name><name>dim</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name><name>lb</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>dimschanged</name></decl>,
				<decl><type ref="prev"/><name>newhasnulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>addedbefore</name></decl>,
				<decl><type ref="prev"/><name>addedafter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oldValue</name></decl>;</decl_stmt>

	<comment type="block">/* Convert to R/W object if not so already */</comment>
	<expr_stmt><expr><name>eah</name> <operator>=</operator> <call><name>DatumGetExpandedArray</name><argument_list>(<argument><expr><name>arraydatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Sanity-check caller's info against object; we don't use it otherwise */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>arraytyplen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>elmlen</name> <operator>==</operator> <name><name>eah</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>elmbyval</name> <operator>==</operator> <name><name>eah</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>elmalign</name> <operator>==</operator> <name><name>eah</name><operator>-&gt;</operator><name>typalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy dimension info into local storage.  This allows us to modify the
	 * dimensions if needed, while not messing up the expanded value if we
	 * fail partway through.
	 */</comment>
	<expr_stmt><expr><name>ndim</name> <operator>=</operator> <name><name>eah</name><operator>-&gt;</operator><name>ndims</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ndim</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ndim</name> <operator>&lt;=</operator> <name>MAXDIM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dim</name></expr></argument>, <argument><expr><name><name>eah</name><operator>-&gt;</operator><name>dims</name></name></expr></argument>, <argument><expr><name>ndim</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>lb</name></expr></argument>, <argument><expr><name><name>eah</name><operator>-&gt;</operator><name>lbound</name></name></expr></argument>, <argument><expr><name>ndim</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dimschanged</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * if number of dims is zero, i.e. an empty array, create an array with
	 * nSubscripts dimensions, and set the lower bounds to the supplied
	 * subscripts.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ndim</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Allocate adequate space for new dimension info.  This is harmless
		 * if we fail later.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nSubscripts</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nSubscripts</name> <operator>&lt;=</operator> <name>MAXDIM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>dims</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name><name>eah</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>eoh_context</name></name></expr></argument>,
												   <argument><expr><name>nSubscripts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>lbound</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name><name>eah</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>eoh_context</name></name></expr></argument>,
													 <argument><expr><name>nSubscripts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Update local copies of dimension info */</comment>
		<expr_stmt><expr><name>ndim</name> <operator>=</operator> <name>nSubscripts</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nSubscripts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>dim</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>lb</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>indx</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name>dimschanged</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>ndim</name> <operator>!=</operator> <name>nSubscripts</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"wrong number of array subscripts"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Deconstruct array if we didn't already.  (Someday maybe add a special
	 * case path for fixed-length, no-nulls cases, where we can overwrite an
	 * element in place without ever deconstructing.  But today is not that
	 * day.)
	 */</comment>
	<expr_stmt><expr><call><name>deconstruct_expanded_array</name><argument_list>(<argument><expr><name>eah</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy new element into array's context, if needed (we assume it's
	 * already detoasted, so no junk should be created).  If we fail further
	 * down, this memory is leaked, but that's reasonably harmless.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>eah</name><operator>-&gt;</operator><name>typbyval</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isNull</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>eah</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>eoh_context</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>dataValue</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name>dataValue</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>eah</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>dvalues</name> <operator>=</operator> <name><name>eah</name><operator>-&gt;</operator><name>dvalues</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>dnulls</name> <operator>=</operator> <name><name>eah</name><operator>-&gt;</operator><name>dnulls</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>newhasnulls</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>dnulls</name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <name>isNull</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>addedbefore</name> <operator>=</operator> <name>addedafter</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check subscripts (this logic matches original array_set_element)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ndim</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>indx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <name><name>lb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>addedbefore</name> <operator>=</operator> <name><name>lb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name><name>indx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <name>addedbefore</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>lb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>indx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>dimschanged</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>addedbefore</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>newhasnulls</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* will insert nulls */</comment>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>indx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <operator>(</operator><name><name>dim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>lb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>addedafter</name> <operator>=</operator> <name><name>indx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <operator>(</operator><name><name>dim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>lb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <name>addedafter</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>dimschanged</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>addedafter</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>newhasnulls</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* will insert nulls */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * XXX currently we do not support extending multi-dimensional arrays
		 * during assignment
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndim</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>indx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name><name>lb</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator>
				<name><name>indx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <operator>(</operator><name><name>dim</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name><name>lb</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"array subscript out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Check for overflow of the array dimensions */</comment>
	<if_stmt><if>if <condition>(<expr><name>dimschanged</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ArrayCheckBounds</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>lb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Now we can calculate linear offset of target item in array */</comment>
	<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>ArrayGetOffset</name><argument_list>(<argument><expr><name>nSubscripts</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>lb</name></expr></argument>, <argument><expr><name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Physically enlarge existing dvalues/dnulls arrays if needed */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;</operator> <name><name>eah</name><operator>-&gt;</operator><name>dvalueslen</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We want some extra space if we're enlarging */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>newlen</name> <init>= <expr><name><name>dim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>dim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>/</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>newlen</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>newlen</name></expr></argument>, <argument><expr><name><name>dim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* integer overflow guard */</comment>
		<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>dvalues</name></name> <operator>=</operator> <name>dvalues</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator>
			<call><name>repalloc</name><argument_list>(<argument><expr><name>dvalues</name></expr></argument>, <argument><expr><name>newlen</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>dnulls</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>dnulls</name></name> <operator>=</operator> <name>dnulls</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator>
				<call><name>repalloc</name><argument_list>(<argument><expr><name>dnulls</name></expr></argument>, <argument><expr><name>newlen</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>dvalueslen</name></name> <operator>=</operator> <name>newlen</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we need a nulls bitmap and don't already have one, create it, being
	 * sure to mark all existing entries as not null.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>newhasnulls</name> <operator>&amp;&amp;</operator> <name>dnulls</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>dnulls</name></name> <operator>=</operator> <name>dnulls</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator>
			<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name><name>eah</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>eoh_context</name></name></expr></argument>,
								   <argument><expr><name><name>eah</name><operator>-&gt;</operator><name>dvalueslen</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We now have all the needed space allocated, so we're ready to make
	 * irreversible changes.  Be very wary of allowing failure below here.
	 */</comment>

	<comment type="block">/* Flattened value will no longer represent array accurately */</comment>
	<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>fvalue</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<comment type="block">/* And we don't know the flattened size either */</comment>
	<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>flat_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Update dimensionality info if needed */</comment>
	<if_stmt><if>if <condition>(<expr><name>dimschanged</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>ndims</name></name> <operator>=</operator> <name>ndim</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>eah</name><operator>-&gt;</operator><name>dims</name></name></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>ndim</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>eah</name><operator>-&gt;</operator><name>lbound</name></name></expr></argument>, <argument><expr><name>lb</name></expr></argument>, <argument><expr><name>ndim</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Reposition items if needed, and fill addedbefore items with nulls */</comment>
	<if_stmt><if>if <condition>(<expr><name>addedbefore</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>dvalues</name> <operator>+</operator> <name>addedbefore</name></expr></argument>, <argument><expr><name>dvalues</name></expr></argument>, <argument><expr><name><name>eah</name><operator>-&gt;</operator><name>nelems</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>addedbefore</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>dvalues</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
		<if_stmt><if>if <condition>(<expr><name>dnulls</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>dnulls</name> <operator>+</operator> <name>addedbefore</name></expr></argument>, <argument><expr><name>dnulls</name></expr></argument>, <argument><expr><name><name>eah</name><operator>-&gt;</operator><name>nelems</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>addedbefore</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>dnulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></for>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>nelems</name></name> <operator>+=</operator> <name>addedbefore</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* fill addedafter items with nulls */</comment>
	<if_stmt><if>if <condition>(<expr><name>addedafter</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>addedafter</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>dvalues</name><index>[<expr><name><name>eah</name><operator>-&gt;</operator><name>nelems</name></name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
		<if_stmt><if>if <condition>(<expr><name>dnulls</name></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>addedafter</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>dnulls</name><index>[<expr><name><name>eah</name><operator>-&gt;</operator><name>nelems</name></name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></for>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>nelems</name></name> <operator>+=</operator> <name>addedafter</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Grab old element value for pfree'ing, if needed. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>eah</name><operator>-&gt;</operator><name>typbyval</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>dnulls</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><name><name>dnulls</name><index>[<expr><name>offset</name></expr>]</index></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>oldValue</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>dvalues</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>oldValue</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* And finally we can insert the new element. */</comment>
	<expr_stmt><expr><name><name>dvalues</name><index>[<expr><name>offset</name></expr>]</index></name> <operator>=</operator> <name>dataValue</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dnulls</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dnulls</name><index>[<expr><name>offset</name></expr>]</index></name> <operator>=</operator> <name>isNull</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Free old element if needed; this keeps repeated element replacements
	 * from bloating the array's storage.  If the pfree somehow fails, it
	 * won't corrupt the array.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>oldValue</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Don't try to pfree a part of the original flat array */</comment>
		<if_stmt><if>if <condition>(<expr><name>oldValue</name> <operator>&lt;</operator> <name><name>eah</name><operator>-&gt;</operator><name>fstartptr</name></name> <operator>||</operator> <name>oldValue</name> <operator>&gt;=</operator> <name><name>eah</name><operator>-&gt;</operator><name>fendptr</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>oldValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Done, return standard TOAST pointer for object */</comment>
	<return>return <expr><call><name>EOHPGetRWDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>eah</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * array_set_slice :
 *		  This routine sets the value of a range of array locations (specified
 *		  by upper and lower subscript values) to new values passed as
 *		  another array.
 *
 * This handles both ordinary varlena arrays and fixed-length arrays.
 *
 * Inputs:
 *	arraydatum: the initial array object (mustn't be NULL)
 *	nSubscripts: number of subscripts supplied (must be same for upper/lower)
 *	upperIndx[]: the upper subscript values
 *	lowerIndx[]: the lower subscript values
 *	upperProvided[]: true for provided upper subscript values
 *	lowerProvided[]: true for provided lower subscript values
 *	srcArrayDatum: the source for the inserted values
 *	isNull: indicates whether srcArrayDatum is NULL
 *	arraytyplen: pg_type.typlen for the array type
 *	elmlen: pg_type.typlen for the array's element type
 *	elmbyval: pg_type.typbyval for the array's element type
 *	elmalign: pg_type.typalign for the array's element type
 *
 * Result:
 *		  A new array is returned, just like the old except for the
 *		  modified range.  The original array object is not changed.
 *
 * Omitted upper and lower subscript values are replaced by the corresponding
 * array bound.
 *
 * For one-dimensional arrays only, we allow the array to be extended
 * by assigning to positions outside the existing subscript range; any
 * positions between the existing elements and the new ones are set to NULLs.
 * (XXX TODO: allow a corresponding behavior for multidimensional arrays)
 *
 * NOTE: we assume it is OK to scribble on the provided index arrays
 * lowerIndx[] and upperIndx[].  These are generally just temporaries.
 *
 * NOTE: For assignments, we throw an error for silly subscripts etc,
 * rather than returning a NULL or empty array as the fetch operations do.
 */</comment>
<function><type><name>Datum</name></type>
<name>array_set_slice</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arraydatum</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>nSubscripts</name></decl></parameter>,
				<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>upperIndx</name></decl></parameter>,
				<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>lowerIndx</name></decl></parameter>,
				<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>upperProvided</name></decl></parameter>,
				<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>lowerProvided</name></decl></parameter>,
				<parameter><decl><type><name>Datum</name></type> <name>srcArrayDatum</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>isNull</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>arraytyplen</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>elmlen</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>elmbyval</name></decl></parameter>,
				<parameter><decl><type><name>char</name></type> <name>elmalign</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>array</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>srcArray</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>newarray</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>ndim</name></decl>,
				<decl><type ref="prev"/><name><name>dim</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name><name>lb</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name><name>span</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>newhasnulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nitems</name></decl>,
				<decl><type ref="prev"/><name>nsrcitems</name></decl>,
				<decl><type ref="prev"/><name>olddatasize</name></decl>,
				<decl><type ref="prev"/><name>newsize</name></decl>,
				<decl><type ref="prev"/><name>olditemsize</name></decl>,
				<decl><type ref="prev"/><name>newitemsize</name></decl>,
				<decl><type ref="prev"/><name>overheadlen</name></decl>,
				<decl><type ref="prev"/><name>oldoverheadlen</name></decl>,
				<decl><type ref="prev"/><name>addedbefore</name></decl>,
				<decl><type ref="prev"/><name>addedafter</name></decl>,
				<decl><type ref="prev"/><name>lenbefore</name></decl>,
				<decl><type ref="prev"/><name>lenafter</name></decl>,
				<decl><type ref="prev"/><name>itemsbefore</name></decl>,
				<decl><type ref="prev"/><name>itemsafter</name></decl>,
				<decl><type ref="prev"/><name>nolditems</name></decl>;</decl_stmt>

	<comment type="block">/* Currently, assignment from a NULL source array is a no-op */</comment>
	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>arraydatum</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>arraytyplen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * fixed-length arrays -- not got round to doing this...
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"updates on slices of fixed-length arrays not implemented"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* detoast arrays if necessary */</comment>
	<expr_stmt><expr><name>array</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>arraydatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>srcArray</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>srcArrayDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* note: we assume srcArray contains no toasted elements */</comment>

	<expr_stmt><expr><name>ndim</name> <operator>=</operator> <call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * if number of dims is zero, i.e. an empty array, create an array with
	 * nSubscripts dimensions, and set the upper and lower bounds to the
	 * supplied subscripts
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ndim</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>dvalues</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>dnulls</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nelems</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>elmtype</name> <init>= <expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>srcArray</name></expr></argument>, <argument><expr><name>elmtype</name></expr></argument>, <argument><expr><name>elmlen</name></expr></argument>, <argument><expr><name>elmbyval</name></expr></argument>, <argument><expr><name>elmalign</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>dvalues</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dnulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nelems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nSubscripts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>upperProvided</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator> <operator>!</operator><name><name>lowerProvided</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"array slice subscript must provide both boundaries"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"When assigning to a slice of an empty array value,"</literal>
								   <literal type="string">" slice boundaries must be fully specified."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>dim</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <name><name>upperIndx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <name><name>lowerIndx</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>lb</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>lowerIndx</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* complain if too few source items; we ignore extras, however */</comment>
		<if_stmt><if>if <condition>(<expr><name>nelems</name> <operator>&lt;</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><name>nSubscripts</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"source array too small"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>construct_md_array</name><argument_list>(<argument><expr><name>dvalues</name></expr></argument>, <argument><expr><name>dnulls</name></expr></argument>, <argument><expr><name>nSubscripts</name></expr></argument>,
												  <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>lb</name></expr></argument>, <argument><expr><name>elmtype</name></expr></argument>,
												  <argument><expr><name>elmlen</name></expr></argument>, <argument><expr><name>elmbyval</name></expr></argument>, <argument><expr><name>elmalign</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ndim</name> <argument_list type="generic">&lt; <argument><expr><name>nSubscripts</name> <operator>||</operator> <name>ndim</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>ndim</name></expr></argument> &gt;</argument_list></name> <name>MAXDIM</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"wrong number of array subscripts"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* copy dim/lb since we may modify them */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dim</name></expr></argument>, <argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ndim</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>lb</name></expr></argument>, <argument><expr><call><name>ARR_LBOUND</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ndim</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>newhasnulls</name> <operator>=</operator> <operator>(</operator><call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>srcArray</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>addedbefore</name> <operator>=</operator> <name>addedafter</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check subscripts
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ndim</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nSubscripts</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lowerProvided</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>lowerIndx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>lb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>upperProvided</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>upperIndx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>dim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>lb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>lowerIndx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;</operator> <name><name>upperIndx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"upper bound cannot be less than lower bound"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>lowerIndx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <name><name>lb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>upperIndx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <name><name>lb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>newhasnulls</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* will insert nulls */</comment>
			<expr_stmt><expr><name>addedbefore</name> <operator>=</operator> <name><name>lb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name><name>lowerIndx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <name>addedbefore</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>lb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>lowerIndx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>upperIndx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <operator>(</operator><name><name>dim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>lb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>lowerIndx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;</operator> <operator>(</operator><name><name>dim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>lb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>newhasnulls</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* will insert nulls */</comment>
			<expr_stmt><expr><name>addedafter</name> <operator>=</operator> <name><name>upperIndx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <operator>(</operator><name><name>dim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>lb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <name>addedafter</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * XXX currently we do not support extending multi-dimensional arrays
		 * during assignment
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nSubscripts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lowerProvided</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>lowerIndx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>lb</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>upperProvided</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>upperIndx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>dim</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name><name>lb</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>lowerIndx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name><name>upperIndx</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"upper bound cannot be less than lower bound"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>lowerIndx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name><name>lb</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator>
				<name><name>upperIndx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <operator>(</operator><name><name>dim</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name><name>lb</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"array subscript out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<comment type="block">/* fill any missing subscript positions with full array range */</comment>
		<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndim</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>lowerIndx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>lb</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>upperIndx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>dim</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name><name>lb</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>lowerIndx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name><name>upperIndx</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"upper bound cannot be less than lower bound"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Do this mainly to check for overflow */</comment>
	<expr_stmt><expr><name>nitems</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ArrayCheckBounds</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>lb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure source array has enough entries.  Note we ignore the shape of
	 * the source array and just read entries serially.
	 */</comment>
	<expr_stmt><expr><call><name>mda_get_range</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>span</name></expr></argument>, <argument><expr><name>lowerIndx</name></expr></argument>, <argument><expr><name>upperIndx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nsrcitems</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>span</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nsrcitems</name> <operator>&gt;</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>srcArray</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>srcArray</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"source array too small"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Compute space occupied by new entries, space occupied by replaced
	 * entries, and required space for new array.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>newhasnulls</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>overheadlen</name> <operator>=</operator> <call><name>ARR_OVERHEAD_WITHNULLS</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>overheadlen</name> <operator>=</operator> <call><name>ARR_OVERHEAD_NONULLS</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>newitemsize</name> <operator>=</operator> <call><name>array_nelems_size</name><argument_list>(<argument><expr><call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>srcArray</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
									<argument><expr><call><name>ARR_NULLBITMAP</name><argument_list>(<argument><expr><name>srcArray</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nsrcitems</name></expr></argument>,
									<argument><expr><name>elmlen</name></expr></argument>, <argument><expr><name>elmbyval</name></expr></argument>, <argument><expr><name>elmalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldoverheadlen</name> <operator>=</operator> <call><name>ARR_DATA_OFFSET</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>olddatasize</name> <operator>=</operator> <call><name>ARR_SIZE</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>oldoverheadlen</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ndim</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * here we do not need to cope with extension of the array; it would
		 * be a lot more complicated if we had to do so...
		 */</comment>
		<expr_stmt><expr><name>olditemsize</name> <operator>=</operator> <call><name>array_slice_size</name><argument_list>(<argument><expr><call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>ARR_NULLBITMAP</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>lb</name></expr></argument>,
									   <argument><expr><name>lowerIndx</name></expr></argument>, <argument><expr><name>upperIndx</name></expr></argument>,
									   <argument><expr><name>elmlen</name></expr></argument>, <argument><expr><name>elmbyval</name></expr></argument>, <argument><expr><name>elmalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lenbefore</name> <operator>=</operator> <name>lenafter</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
		<expr_stmt><expr><name>itemsbefore</name> <operator>=</operator> <name>itemsafter</name> <operator>=</operator> <name>nolditems</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * here we must allow for possibility of slice larger than orig array
		 * and/or not adjacent to orig array subscripts
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>oldlb</name> <init>= <expr><call><name>ARR_LBOUND</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>oldub</name> <init>= <expr><name>oldlb</name> <operator>+</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>slicelb</name> <init>= <expr><call><name>Max</name><argument_list>(<argument><expr><name>oldlb</name></expr></argument>, <argument><expr><name><name>lowerIndx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>sliceub</name> <init>= <expr><call><name>Min</name><argument_list>(<argument><expr><name>oldub</name></expr></argument>, <argument><expr><name><name>upperIndx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oldarraydata</name> <init>= <expr><call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bits8</name>	   <modifier>*</modifier></type><name>oldarraybitmap</name> <init>= <expr><call><name>ARR_NULLBITMAP</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* count/size of old array entries that will go before the slice */</comment>
		<expr_stmt><expr><name>itemsbefore</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>slicelb</name></expr></argument>, <argument><expr><name>oldub</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>-</operator> <name>oldlb</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>lenbefore</name> <operator>=</operator> <call><name>array_nelems_size</name><argument_list>(<argument><expr><name>oldarraydata</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>oldarraybitmap</name></expr></argument>,
									  <argument><expr><name>itemsbefore</name></expr></argument>,
									  <argument><expr><name>elmlen</name></expr></argument>, <argument><expr><name>elmbyval</name></expr></argument>, <argument><expr><name>elmalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* count/size of old array entries that will be replaced by slice */</comment>
		<if_stmt><if>if <condition>(<expr><name>slicelb</name> <operator>&gt;</operator> <name>sliceub</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>nolditems</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>olditemsize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>nolditems</name> <operator>=</operator> <name>sliceub</name> <operator>-</operator> <name>slicelb</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>olditemsize</name> <operator>=</operator> <call><name>array_nelems_size</name><argument_list>(<argument><expr><name>oldarraydata</name> <operator>+</operator> <name>lenbefore</name></expr></argument>,
											<argument><expr><name>itemsbefore</name></expr></argument>, <argument><expr><name>oldarraybitmap</name></expr></argument>,
											<argument><expr><name>nolditems</name></expr></argument>,
											<argument><expr><name>elmlen</name></expr></argument>, <argument><expr><name>elmbyval</name></expr></argument>, <argument><expr><name>elmalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<comment type="block">/* count/size of old array entries that will go after the slice */</comment>
		<expr_stmt><expr><name>itemsafter</name> <operator>=</operator> <name>oldub</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <call><name>Max</name><argument_list>(<argument><expr><name>sliceub</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>oldlb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lenafter</name> <operator>=</operator> <name>olddatasize</name> <operator>-</operator> <name>lenbefore</name> <operator>-</operator> <name>olditemsize</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>newsize</name> <operator>=</operator> <name>overheadlen</name> <operator>+</operator> <name>olddatasize</name> <operator>-</operator> <name>olditemsize</name> <operator>+</operator> <name>newitemsize</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>newarray</name> <operator>=</operator> <operator>(</operator><name>ArrayType</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>newarray</name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newarray</name><operator>-&gt;</operator><name>ndim</name></name> <operator>=</operator> <name>ndim</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newarray</name><operator>-&gt;</operator><name>dataoffset</name></name> <operator>=</operator> <ternary><condition><expr><name>newhasnulls</name></expr> ?</condition><then> <expr><name>overheadlen</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newarray</name><operator>-&gt;</operator><name>elemtype</name></name> <operator>=</operator> <call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>newarray</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>ndim</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>ARR_LBOUND</name><argument_list>(<argument><expr><name>newarray</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lb</name></expr></argument>, <argument><expr><name>ndim</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ndim</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * here we do not need to cope with extension of the array; it would
		 * be a lot more complicated if we had to do so...
		 */</comment>
		<expr_stmt><expr><call><name>array_insert_slice</name><argument_list>(<argument><expr><name>newarray</name></expr></argument>, <argument><expr><name>array</name></expr></argument>, <argument><expr><name>srcArray</name></expr></argument>,
						   <argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>lb</name></expr></argument>,
						   <argument><expr><name>lowerIndx</name></expr></argument>, <argument><expr><name>upperIndx</name></expr></argument>,
						   <argument><expr><name>elmlen</name></expr></argument>, <argument><expr><name>elmbyval</name></expr></argument>, <argument><expr><name>elmalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* fill in data */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>newarray</name> <operator>+</operator> <name>overheadlen</name></expr></argument>,
			   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>array</name> <operator>+</operator> <name>oldoverheadlen</name></expr></argument>,
			   <argument><expr><name>lenbefore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>newarray</name> <operator>+</operator> <name>overheadlen</name> <operator>+</operator> <name>lenbefore</name></expr></argument>,
			   <argument><expr><call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>srcArray</name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name>newitemsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>newarray</name> <operator>+</operator> <name>overheadlen</name> <operator>+</operator> <name>lenbefore</name> <operator>+</operator> <name>newitemsize</name></expr></argument>,
			   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>array</name> <operator>+</operator> <name>oldoverheadlen</name> <operator>+</operator> <name>lenbefore</name> <operator>+</operator> <name>olditemsize</name></expr></argument>,
			   <argument><expr><name>lenafter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* fill in nulls bitmap if needed */</comment>
		<if_stmt><if>if <condition>(<expr><name>newhasnulls</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bits8</name>	   <modifier>*</modifier></type><name>newnullbitmap</name> <init>= <expr><call><name>ARR_NULLBITMAP</name><argument_list>(<argument><expr><name>newarray</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bits8</name>	   <modifier>*</modifier></type><name>oldnullbitmap</name> <init>= <expr><call><name>ARR_NULLBITMAP</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Zero the bitmap to handle marking inserted positions null */</comment>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>newnullbitmap</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>nitems</name> <operator>+</operator> <literal type="number">7</literal><operator>)</operator> <operator>/</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>array_bitmap_copy</name><argument_list>(<argument><expr><name>newnullbitmap</name></expr></argument>, <argument><expr><name>addedbefore</name></expr></argument>,
							  <argument><expr><name>oldnullbitmap</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							  <argument><expr><name>itemsbefore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>array_bitmap_copy</name><argument_list>(<argument><expr><name>newnullbitmap</name></expr></argument>, <argument><expr><name><name>lowerIndx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name><name>lb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
							  <argument><expr><call><name>ARR_NULLBITMAP</name><argument_list>(<argument><expr><name>srcArray</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							  <argument><expr><name>nsrcitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>array_bitmap_copy</name><argument_list>(<argument><expr><name>newnullbitmap</name></expr></argument>, <argument><expr><name>addedbefore</name> <operator>+</operator> <name>itemsbefore</name> <operator>+</operator> <name>nolditems</name></expr></argument>,
							  <argument><expr><name>oldnullbitmap</name></expr></argument>, <argument><expr><name>itemsbefore</name> <operator>+</operator> <name>nolditems</name></expr></argument>,
							  <argument><expr><name>itemsafter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>newarray</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * array_ref : backwards compatibility wrapper for array_get_element
 *
 * This only works for detoasted/flattened varlena arrays, since the array
 * argument is declared as "ArrayType *".  However there's enough code like
 * that to justify preserving this API.
 */</comment>
<function><type><name>Datum</name></type>
<name>array_ref</name><parameter_list>(<parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>array</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nSubscripts</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>indx</name></decl></parameter>,
		  <parameter><decl><type><name>int</name></type> <name>arraytyplen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elmlen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>elmbyval</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>elmalign</name></decl></parameter>,
		  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>array_get_element</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nSubscripts</name></expr></argument>, <argument><expr><name>indx</name></expr></argument>,
							 <argument><expr><name>arraytyplen</name></expr></argument>, <argument><expr><name>elmlen</name></expr></argument>, <argument><expr><name>elmbyval</name></expr></argument>, <argument><expr><name>elmalign</name></expr></argument>,
							 <argument><expr><name>isNull</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * array_set : backwards compatibility wrapper for array_set_element
 *
 * This only works for detoasted/flattened varlena arrays, since the array
 * argument and result are declared as "ArrayType *".  However there's enough
 * code like that to justify preserving this API.
 */</comment>
<function><type><name>ArrayType</name> <modifier>*</modifier></type>
<name>array_set</name><parameter_list>(<parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>array</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nSubscripts</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>indx</name></decl></parameter>,
		  <parameter><decl><type><name>Datum</name></type> <name>dataValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isNull</name></decl></parameter>,
		  <parameter><decl><type><name>int</name></type> <name>arraytyplen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elmlen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>elmbyval</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>elmalign</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><call><name>array_set_element</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><name>nSubscripts</name></expr></argument>, <argument><expr><name>indx</name></expr></argument>,
												<argument><expr><name>dataValue</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>,
												<argument><expr><name>arraytyplen</name></expr></argument>,
												<argument><expr><name>elmlen</name></expr></argument>, <argument><expr><name>elmbyval</name></expr></argument>, <argument><expr><name>elmalign</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * array_map()
 *
 * Map an array through an arbitrary expression.  Return a new array with
 * the same dimensions and each source element transformed by the given,
 * already-compiled expression.  Each source element is placed in the
 * innermost_caseval/innermost_casenull fields of the ExprState.
 *
 * Parameters are:
 * * arrayd: Datum representing array argument.
 * * exprstate: ExprState representing the per-element transformation.
 * * econtext: context for expression evaluation.
 * * retType: OID of element type of output array.  This must be the same as,
 *	 or binary-compatible with, the result type of the expression.  It might
 *	 be different from the input array's element type.
 * * amstate: workspace for array_map.  Must be zeroed by caller before
 *	 first call, and not touched after that.
 *
 * It is legitimate to pass a freshly-zeroed ArrayMapState on each call,
 * but better performance can be had if the state can be preserved across
 * a series of calls.
 *
 * NB: caller must assure that input array is not NULL.  NULL elements in
 * the array are OK however.
 * NB: caller should be running in econtext's per-tuple memory context.
 */</comment>
<function><type><name>Datum</name></type>
<name>array_map</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arrayd</name></decl></parameter>,
		  <parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>exprstate</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>,
		  <parameter><decl><type><name>Oid</name></type> <name>retType</name></decl></parameter>, <parameter><decl><type><name>ArrayMapState</name> <modifier>*</modifier></type><name>amstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AnyArrayType</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>DatumGetAnyArrayP</name><argument_list>(<argument><expr><name>arrayd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>dim</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndim</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nitems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>nbytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>dataoffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasnulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>inpType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>inp_typlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>inp_typbyval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>inp_typalign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>typlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typbyval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>typalign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>array_iter</name></type>	<name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayMetaState</name> <modifier>*</modifier></type><name>inp_extra</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayMetaState</name> <modifier>*</modifier></type><name>ret_extra</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>transform_source</name> <init>= <expr><name><name>exprstate</name><operator>-&gt;</operator><name>innermost_caseval</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>transform_source_isnull</name> <init>= <expr><name><name>exprstate</name><operator>-&gt;</operator><name>innermost_casenull</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>inpType</name> <operator>=</operator> <call><name>AARR_ELEMTYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ndim</name> <operator>=</operator> <call><name>AARR_NDIM</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dim</name> <operator>=</operator> <call><name>AARR_DIMS</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nitems</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for empty array */</comment>
	<if_stmt><if>if <condition>(<expr><name>nitems</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Return empty array */</comment>
		<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>construct_empty_array</name><argument_list>(<argument><expr><name>retType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We arrange to look up info about input and return element types only
	 * once per series of calls, assuming the element type doesn't change
	 * underneath us.
	 */</comment>
	<expr_stmt><expr><name>inp_extra</name> <operator>=</operator> <operator>&amp;</operator><name><name>amstate</name><operator>-&gt;</operator><name>inp_extra</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_extra</name> <operator>=</operator> <operator>&amp;</operator><name><name>amstate</name><operator>-&gt;</operator><name>ret_extra</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>inp_extra</name><operator>-&gt;</operator><name>element_type</name></name> <operator>!=</operator> <name>inpType</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><name>inpType</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>inp_extra</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>inp_extra</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>inp_extra</name><operator>-&gt;</operator><name>typalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>inp_extra</name><operator>-&gt;</operator><name>element_type</name></name> <operator>=</operator> <name>inpType</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>inp_typlen</name> <operator>=</operator> <name><name>inp_extra</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>inp_typbyval</name> <operator>=</operator> <name><name>inp_extra</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>inp_typalign</name> <operator>=</operator> <name><name>inp_extra</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ret_extra</name><operator>-&gt;</operator><name>element_type</name></name> <operator>!=</operator> <name>retType</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><name>retType</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>ret_extra</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>ret_extra</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>ret_extra</name><operator>-&gt;</operator><name>typalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ret_extra</name><operator>-&gt;</operator><name>element_type</name></name> <operator>=</operator> <name>retType</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>typlen</name> <operator>=</operator> <name><name>ret_extra</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>typbyval</name> <operator>=</operator> <name><name>ret_extra</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>typalign</name> <operator>=</operator> <name><name>ret_extra</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>

	<comment type="block">/* Allocate temporary arrays for new values */</comment>
	<expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nitems</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nulls</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nitems</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Loop over source data */</comment>
	<expr_stmt><expr><call><name>array_iter_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hasnulls</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* Get source element, checking for NULL */</comment>
		<expr_stmt><expr><operator>*</operator><name>transform_source</name> <operator>=</operator>
			<call><name>array_iter_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>, <argument><expr><name>transform_source_isnull</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
							<argument><expr><name>inp_typlen</name></expr></argument>, <argument><expr><name>inp_typbyval</name></expr></argument>, <argument><expr><name>inp_typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Apply the given expression to source element */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name>exprstate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>hasnulls</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Ensure data is not toasted */</comment>
			<if_stmt><if>if <condition>(<expr><name>typlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* Update total result size */</comment>
			<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>att_addlength_datum</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* check for overflow of total request */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AllocSizeIsValid</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"array size exceeds the maximum allowed (%d)"</literal></expr></argument>,
								<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>MaxAllocSize</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Allocate and fill the result array */</comment>
	<if_stmt><if>if <condition>(<expr><name>hasnulls</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>dataoffset</name> <operator>=</operator> <call><name>ARR_OVERHEAD_WITHNULLS</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nbytes</name> <operator>+=</operator> <name>dataoffset</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>dataoffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* marker for no null bitmap */</comment>
		<expr_stmt><expr><name>nbytes</name> <operator>+=</operator> <call><name>ARR_OVERHEAD_NONULLS</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>ArrayType</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>ndim</name></name> <operator>=</operator> <name>ndim</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dataoffset</name></name> <operator>=</operator> <name>dataoffset</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>elemtype</name></name> <operator>=</operator> <name>retType</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>AARR_DIMS</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ndim</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>ARR_LBOUND</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>AARR_LBOUND</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ndim</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CopyArrayEls</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
				 <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>,
				 <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>,
				 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note: do not risk trying to pfree the results of the called expression
	 */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * construct_array	--- simple method for constructing an array object
 *
 * elems: array of Datum items to become the array contents
 *		  (NULL element values are not supported).
 * nelems: number of items
 * elmtype, elmlen, elmbyval, elmalign: info for the datatype of the items
 *
 * A palloc'd 1-D array object is constructed and returned.  Note that
 * elem values will be copied into the object even if pass-by-ref type.
 * Also note the result will be 0-D not 1-D if nelems = 0.
 *
 * NOTE: it would be cleaner to look up the elmlen/elmbval/elmalign info
 * from the system catalogs, given the elmtype.  However, the caller is
 * in a better position to cache this info across multiple uses, or even
 * to hard-wire values if the element type is hard-wired.
 */</comment>
<function><type><name>ArrayType</name> <modifier>*</modifier></type>
<name>construct_array</name><parameter_list>(<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>elems</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nelems</name></decl></parameter>,
				<parameter><decl><type><name>Oid</name></type> <name>elmtype</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>elmlen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>elmbyval</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>elmalign</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>dims</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>lbs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>dims</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>nelems</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lbs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<return>return <expr><call><name>construct_md_array</name><argument_list>(<argument><expr><name>elems</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>dims</name></expr></argument>, <argument><expr><name>lbs</name></expr></argument>,
							  <argument><expr><name>elmtype</name></expr></argument>, <argument><expr><name>elmlen</name></expr></argument>, <argument><expr><name>elmbyval</name></expr></argument>, <argument><expr><name>elmalign</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * construct_md_array	--- simple method for constructing an array object
 *							with arbitrary dimensions and possible NULLs
 *
 * elems: array of Datum items to become the array contents
 * nulls: array of is-null flags (can be NULL if no nulls)
 * ndims: number of dimensions
 * dims: integer array with size of each dimension
 * lbs: integer array with lower bound of each dimension
 * elmtype, elmlen, elmbyval, elmalign: info for the datatype of the items
 *
 * A palloc'd ndims-D array object is constructed and returned.  Note that
 * elem values will be copied into the object even if pass-by-ref type.
 * Also note the result will be 0-D not ndims-D if any dims[i] = 0.
 *
 * NOTE: it would be cleaner to look up the elmlen/elmbval/elmalign info
 * from the system catalogs, given the elmtype.  However, the caller is
 * in a better position to cache this info across multiple uses, or even
 * to hard-wire values if the element type is hard-wired.
 */</comment>
<function><type><name>ArrayType</name> <modifier>*</modifier></type>
<name>construct_md_array</name><parameter_list>(<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>elems</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>ndims</name></decl></parameter>,
				   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dims</name></decl></parameter>,
				   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>lbs</name></decl></parameter>,
				   <parameter><decl><type><name>Oid</name></type> <name>elmtype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elmlen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>elmbyval</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>elmalign</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasnulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>nbytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>dataoffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nelems</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>ndims</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>				<comment type="block">/* we do allow zero-dimension arrays */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid number of dimensions: %d"</literal></expr></argument>, <argument><expr><name>ndims</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>ndims</name> <operator>&gt;</operator> <name>MAXDIM</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of array dimensions (%d) exceeds the maximum allowed (%d)"</literal></expr></argument>,
						<argument><expr><name>ndims</name></expr></argument>, <argument><expr><name>MAXDIM</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* This checks for overflow of the array dimensions */</comment>
	<expr_stmt><expr><name>nelems</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><name>ndims</name></expr></argument>, <argument><expr><name>dims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ArrayCheckBounds</name><argument_list>(<argument><expr><name>ndims</name></expr></argument>, <argument><expr><name>dims</name></expr></argument>, <argument><expr><name>lbs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if ndims &lt;= 0 or any dims[i] == 0, return empty array */</comment>
	<if_stmt><if>if <condition>(<expr><name>nelems</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>construct_empty_array</name><argument_list>(<argument><expr><name>elmtype</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* compute required space */</comment>
	<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>hasnulls</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>nulls</name> <operator>&amp;&amp;</operator> <name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>hasnulls</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* make sure data is not toasted */</comment>
		<if_stmt><if>if <condition>(<expr><name>elmlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>elems</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name><name>elems</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>att_addlength_datum</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>elmlen</name></expr></argument>, <argument><expr><name><name>elems</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>elmalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* check for overflow of total request */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AllocSizeIsValid</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"array size exceeds the maximum allowed (%d)"</literal></expr></argument>,
							<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>MaxAllocSize</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Allocate and initialize result array */</comment>
	<if_stmt><if>if <condition>(<expr><name>hasnulls</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>dataoffset</name> <operator>=</operator> <call><name>ARR_OVERHEAD_WITHNULLS</name><argument_list>(<argument><expr><name>ndims</name></expr></argument>, <argument><expr><name>nelems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nbytes</name> <operator>+=</operator> <name>dataoffset</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>dataoffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* marker for no null bitmap */</comment>
		<expr_stmt><expr><name>nbytes</name> <operator>+=</operator> <call><name>ARR_OVERHEAD_NONULLS</name><argument_list>(<argument><expr><name>ndims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>ArrayType</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>ndim</name></name> <operator>=</operator> <name>ndims</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dataoffset</name></name> <operator>=</operator> <name>dataoffset</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>elemtype</name></name> <operator>=</operator> <name>elmtype</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dims</name></expr></argument>, <argument><expr><name>ndims</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>ARR_LBOUND</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lbs</name></expr></argument>, <argument><expr><name>ndims</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CopyArrayEls</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
				 <argument><expr><name>elems</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>nelems</name></expr></argument>,
				 <argument><expr><name>elmlen</name></expr></argument>, <argument><expr><name>elmbyval</name></expr></argument>, <argument><expr><name>elmalign</name></expr></argument>,
				 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * construct_empty_array	--- make a zero-dimensional array of given type
 */</comment>
<function><type><name>ArrayType</name> <modifier>*</modifier></type>
<name>construct_empty_array</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>elmtype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>ArrayType</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ArrayType</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ArrayType</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>ndim</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dataoffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>elemtype</name></name> <operator>=</operator> <name>elmtype</name></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * construct_empty_expanded_array: make an empty expanded array
 * given only type information.  (metacache can be NULL if not needed.)
 */</comment>
<function><type><name>ExpandedArrayHeader</name> <modifier>*</modifier></type>
<name>construct_empty_expanded_array</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>element_type</name></decl></parameter>,
							   <parameter><decl><type><name>MemoryContext</name></type> <name>parentcontext</name></decl></parameter>,
							   <parameter><decl><type><name>ArrayMetaState</name> <modifier>*</modifier></type><name>metacache</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>array</name> <init>= <expr><call><name>construct_empty_array</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>d</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>expand_array</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>parentcontext</name></expr></argument>, <argument><expr><name>metacache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>ExpandedArrayHeader</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetEOHP</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * deconstruct_array  --- simple method for extracting data from an array
 *
 * array: array object to examine (must not be NULL)
 * elmtype, elmlen, elmbyval, elmalign: info for the datatype of the items
 * elemsp: return value, set to point to palloc'd array of Datum values
 * nullsp: return value, set to point to palloc'd array of isnull markers
 * nelemsp: return value, set to number of extracted values
 *
 * The caller may pass nullsp == NULL if it does not support NULLs in the
 * array.  Note that this produces a very uninformative error message,
 * so do it only in cases where a NULL is really not expected.
 *
 * If array elements are pass-by-ref data type, the returned Datums will
 * be pointers into the array object.
 *
 * NOTE: it would be cleaner to look up the elmlen/elmbval/elmalign info
 * from the system catalogs, given the elmtype.  However, in most current
 * uses the type is hard-wired into the caller and so we can save a lookup
 * cycle by hard-wiring the type info as well.
 */</comment>
<function><type><name>void</name></type>
<name>deconstruct_array</name><parameter_list>(<parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>array</name></decl></parameter>,
				  <parameter><decl><type><name>Oid</name></type> <name>elmtype</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>elmlen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>elmbyval</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>elmalign</name></decl></parameter>,
				  <parameter><decl><type><name>Datum</name> <modifier>*</modifier><modifier>*</modifier></type><name>elemsp</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier><modifier>*</modifier></type><name>nullsp</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nelemsp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>elems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nelems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bits8</name>	   <modifier>*</modifier></type><name>bitmap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bitmask</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>elmtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nelems</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>elemsp</name> <operator>=</operator> <name>elems</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nelems</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nullsp</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>nullsp</name> <operator>=</operator> <name>nulls</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nelems</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>nulls</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>nelemsp</name> <operator>=</operator> <name>nelems</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bitmap</name> <operator>=</operator> <call><name>ARR_NULLBITMAP</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bitmask</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* Get source element, checking for NULL */</comment>
		<if_stmt><if>if <condition>(<expr><name>bitmap</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>bitmap</name> <operator>&amp;</operator> <name>bitmask</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>elems</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>nulls</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"null array element not allowed in this context"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>elems</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>fetch_att</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>elmbyval</name></expr></argument>, <argument><expr><name>elmlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>att_addlength_pointer</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>elmlen</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>elmalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* advance bitmap pointer if any */</comment>
		<if_stmt><if>if <condition>(<expr><name>bitmap</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>bitmask</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>bitmask</name> <operator>==</operator> <literal type="number">0x100</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>bitmap</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>bitmask</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * array_contains_nulls --- detect whether an array has any null elements
 *
 * This gives an accurate answer, whereas testing ARR_HASNULL only tells
 * if the array *might* contain a null.
 */</comment>
<function><type><name>bool</name></type>
<name>array_contains_nulls</name><parameter_list>(<parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>array</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nelems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bits8</name>	   <modifier>*</modifier></type><name>bitmap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bitmask</name></decl>;</decl_stmt>

	<comment type="block">/* Easy answer if there's no null bitmap */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>nelems</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>bitmap</name> <operator>=</operator> <call><name>ARR_NULLBITMAP</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* check whole bytes of the bitmap byte-at-a-time */</comment>
	<while>while <condition>(<expr><name>nelems</name> <operator>&gt;=</operator> <literal type="number">8</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>bitmap</name> <operator>!=</operator> <literal type="number">0xFF</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>bitmap</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>nelems</name> <operator>-=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* check last partial byte */</comment>
	<expr_stmt><expr><name>bitmask</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>nelems</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>bitmap</name> <operator>&amp;</operator> <name>bitmask</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>bitmask</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>nelems</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * array_eq :
 *		  compares two arrays for equality
 * result :
 *		  returns true if the arrays are equal, false otherwise.
 *
 * Note: we do not use array_cmp here, since equality may be meaningful in
 * datatypes that don't have a total ordering (and hence no btree support).
 */</comment>
<function><type><name>Datum</name></type>
<name>array_eq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AnyArrayType</name> <modifier>*</modifier></type><name>array1</name> <init>= <expr><call><name>PG_GETARG_ANY_ARRAY_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AnyArrayType</name> <modifier>*</modifier></type><name>array2</name> <init>= <expr><call><name>PG_GETARG_ANY_ARRAY_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>collation</name> <init>= <expr><call><name>PG_GET_COLLATION</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndims1</name> <init>= <expr><call><name>AARR_NDIM</name><argument_list>(<argument><expr><name>array1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndims2</name> <init>= <expr><call><name>AARR_NDIM</name><argument_list>(<argument><expr><name>array2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>dims1</name> <init>= <expr><call><name>AARR_DIMS</name><argument_list>(<argument><expr><name>array1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>dims2</name> <init>= <expr><call><name>AARR_DIMS</name><argument_list>(<argument><expr><name>array2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>lbs1</name> <init>= <expr><call><name>AARR_LBOUND</name><argument_list>(<argument><expr><name>array1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>lbs2</name> <init>= <expr><call><name>AARR_LBOUND</name><argument_list>(<argument><expr><name>array2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>element_type</name> <init>= <expr><call><name>AARR_ELEMTYPE</name><argument_list>(<argument><expr><name>array1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nitems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>typlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typbyval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>typalign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>array_iter</name></type>	<name>it1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>array_iter</name></type>	<name>it2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FunctionCallInfoData</name></type> <name>locfcinfo</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>element_type</name> <operator>!=</operator> <call><name>AARR_ELEMTYPE</name><argument_list>(<argument><expr><name>array2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot compare arrays of different element types"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* fast path if the arrays do not have the same dimensionality */</comment>
	<if_stmt><if>if <condition>(<expr><name>ndims1</name> <operator>!=</operator> <name>ndims2</name> <operator>||</operator>
		<call><name>memcmp</name><argument_list>(<argument><expr><name>dims1</name></expr></argument>, <argument><expr><name>dims2</name></expr></argument>, <argument><expr><name>ndims1</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>memcmp</name><argument_list>(<argument><expr><name>lbs1</name></expr></argument>, <argument><expr><name>lbs2</name></expr></argument>, <argument><expr><name>ndims1</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We arrange to look up the equality function only once per series of
		 * calls, assuming the element type doesn't change underneath us.  The
		 * typcache is used so that we have no memory leakage when being used
		 * as an index support function.
		 */</comment>
		<expr_stmt><expr><name>typentry</name> <operator>=</operator> <operator>(</operator><name>TypeCacheEntry</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>typentry</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			<name><name>typentry</name><operator>-&gt;</operator><name>type_id</name></name> <operator>!=</operator> <name>element_type</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>,
										 <argument><expr><name>TYPECACHE_EQ_OPR_FINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>eq_opr_finfo</name><operator>.</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not identify an equality operator for type %s"</literal></expr></argument>,
								<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>typentry</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>typlen</name> <operator>=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>typbyval</name> <operator>=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>typalign</name> <operator>=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * apply the operator to each pair of array elements.
		 */</comment>
		<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><name>locfcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>typentry</name><operator>-&gt;</operator><name>eq_opr_finfo</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
								 <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Loop over source data */</comment>
		<expr_stmt><expr><name>nitems</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><name>ndims1</name></expr></argument>, <argument><expr><name>dims1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>array_iter_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it1</name></expr></argument>, <argument><expr><name>array1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>array_iter_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it2</name></expr></argument>, <argument><expr><name>array2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>elt1</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>elt2</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isnull1</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isnull2</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>oprresult</name></decl>;</decl_stmt>

			<comment type="block">/* Get elements, checking for NULL */</comment>
			<expr_stmt><expr><name>elt1</name> <operator>=</operator> <call><name>array_iter_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull1</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
								   <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>elt2</name> <operator>=</operator> <call><name>array_iter_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull2</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
								   <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We consider two NULLs equal; NULL and not-NULL are unequal.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>isnull1</name> <operator>&amp;&amp;</operator> <name>isnull2</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>isnull1</name> <operator>||</operator> <name>isnull2</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Apply the operator to the element pair
			 */</comment>
			<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>elt1</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>elt2</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>argnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>oprresult</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><operator>&amp;</operator><name>locfcinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>oprresult</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Avoid leaking memory when handed toasted input. */</comment>
	<expr_stmt><expr><call><name>AARR_FREE_IF_COPY</name><argument_list>(<argument><expr><name>array1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AARR_FREE_IF_COPY</name><argument_list>(<argument><expr><name>array2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*-----------------------------------------------------------------------------
 * array-array bool operators:
 *		Given two arrays, iterate comparison operators
 *		over the array. Uses logic similar to text comparison
 *		functions, except element-by-element instead of
 *		character-by-character.
 *----------------------------------------------------------------------------
 */</comment>

<function><type><name>Datum</name></type>
<name>array_ne</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>array_eq</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>array_lt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>array_cmp</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>array_gt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>array_cmp</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>array_le</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>array_cmp</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>array_ge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>array_cmp</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>btarraycmp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>array_cmp</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * array_cmp()
 * Internal comparison function for arrays.
 *
 * Returns -1, 0 or 1
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>array_cmp</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AnyArrayType</name> <modifier>*</modifier></type><name>array1</name> <init>= <expr><call><name>PG_GETARG_ANY_ARRAY_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AnyArrayType</name> <modifier>*</modifier></type><name>array2</name> <init>= <expr><call><name>PG_GETARG_ANY_ARRAY_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>collation</name> <init>= <expr><call><name>PG_GET_COLLATION</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndims1</name> <init>= <expr><call><name>AARR_NDIM</name><argument_list>(<argument><expr><name>array1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndims2</name> <init>= <expr><call><name>AARR_NDIM</name><argument_list>(<argument><expr><name>array2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>dims1</name> <init>= <expr><call><name>AARR_DIMS</name><argument_list>(<argument><expr><name>array1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>dims2</name> <init>= <expr><call><name>AARR_DIMS</name><argument_list>(<argument><expr><name>array2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nitems1</name> <init>= <expr><call><name>ArrayGetNItems</name><argument_list>(<argument><expr><name>ndims1</name></expr></argument>, <argument><expr><name>dims1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nitems2</name> <init>= <expr><call><name>ArrayGetNItems</name><argument_list>(<argument><expr><name>ndims2</name></expr></argument>, <argument><expr><name>dims2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>element_type</name> <init>= <expr><call><name>AARR_ELEMTYPE</name><argument_list>(<argument><expr><name>array1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>typlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typbyval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>typalign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>min_nitems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>array_iter</name></type>	<name>it1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>array_iter</name></type>	<name>it2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FunctionCallInfoData</name></type> <name>locfcinfo</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>element_type</name> <operator>!=</operator> <call><name>AARR_ELEMTYPE</name><argument_list>(<argument><expr><name>array2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot compare arrays of different element types"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We arrange to look up the comparison function only once per series of
	 * calls, assuming the element type doesn't change underneath us. The
	 * typcache is used so that we have no memory leakage when being used as
	 * an index support function.
	 */</comment>
	<expr_stmt><expr><name>typentry</name> <operator>=</operator> <operator>(</operator><name>TypeCacheEntry</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>typentry</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<name><name>typentry</name><operator>-&gt;</operator><name>type_id</name></name> <operator>!=</operator> <name>element_type</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>,
									 <argument><expr><name>TYPECACHE_CMP_PROC_FINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>cmp_proc_finfo</name><operator>.</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not identify a comparison function for type %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>typentry</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>typlen</name> <operator>=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>typbyval</name> <operator>=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>typalign</name> <operator>=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * apply the operator to each pair of array elements.
	 */</comment>
	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><name>locfcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>typentry</name><operator>-&gt;</operator><name>cmp_proc_finfo</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
							 <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Loop over source data */</comment>
	<expr_stmt><expr><name>min_nitems</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>nitems1</name></expr></argument>, <argument><expr><name>nitems2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_iter_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it1</name></expr></argument>, <argument><expr><name>array1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_iter_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it2</name></expr></argument>, <argument><expr><name>array2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>min_nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>elt1</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>elt2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull1</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>cmpresult</name></decl>;</decl_stmt>

		<comment type="block">/* Get elements, checking for NULL */</comment>
		<expr_stmt><expr><name>elt1</name> <operator>=</operator> <call><name>array_iter_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull1</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>elt2</name> <operator>=</operator> <call><name>array_iter_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull2</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We consider two NULLs equal; NULL &gt; not-NULL.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>isnull1</name> <operator>&amp;&amp;</operator> <name>isnull2</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>isnull1</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* arg1 is greater than arg2 */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>isnull2</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* arg1 is less than arg2 */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Compare the pair of elements */</comment>
		<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>elt1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>elt2</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>argnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cmpresult</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><operator>&amp;</operator><name>locfcinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>cmpresult</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* equal */</comment>

		<if_stmt><if>if <condition>(<expr><name>cmpresult</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* arg1 is less than arg2 */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* arg1 is greater than arg2 */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If arrays contain same data (up to end of shorter one), apply
	 * additional rules to sort by dimensionality.  The relative significance
	 * of the different bits of information is historical; mainly we just care
	 * that we don't say "equal" for arrays of different dimensionality.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>nitems1</name> <operator>!=</operator> <name>nitems2</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>nitems1</name> <operator>&lt;</operator> <name>nitems2</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>ndims1</name> <operator>!=</operator> <name>ndims2</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>ndims1</name> <operator>&lt;</operator> <name>ndims2</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndims1</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>dims1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>dims2</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>dims1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name><name>dims2</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>lbound1</name> <init>= <expr><call><name>AARR_LBOUND</name><argument_list>(<argument><expr><name>array1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>lbound2</name> <init>= <expr><call><name>AARR_LBOUND</name><argument_list>(<argument><expr><name>array2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndims1</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>lbound1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>lbound2</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>result</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>lbound1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name><name>lbound2</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Avoid leaking memory when handed toasted input. */</comment>
	<expr_stmt><expr><call><name>AARR_FREE_IF_COPY</name><argument_list>(<argument><expr><name>array1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AARR_FREE_IF_COPY</name><argument_list>(<argument><expr><name>array2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*-----------------------------------------------------------------------------
 * array hashing
 *		Hash the elements and combine the results.
 *----------------------------------------------------------------------------
 */</comment>

<function><type><name>Datum</name></type>
<name>hash_array</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AnyArrayType</name> <modifier>*</modifier></type><name>array</name> <init>= <expr><call><name>PG_GETARG_ANY_ARRAY_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndims</name> <init>= <expr><call><name>AARR_NDIM</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>dims</name> <init>= <expr><call><name>AARR_DIMS</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>element_type</name> <init>= <expr><call><name>AARR_ELEMTYPE</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>result</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nitems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>typlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typbyval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>typalign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>array_iter</name></type>	<name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FunctionCallInfoData</name></type> <name>locfcinfo</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We arrange to look up the hash function only once per series of calls,
	 * assuming the element type doesn't change underneath us.  The typcache
	 * is used so that we have no memory leakage when being used as an index
	 * support function.
	 */</comment>
	<expr_stmt><expr><name>typentry</name> <operator>=</operator> <operator>(</operator><name>TypeCacheEntry</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>typentry</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<name><name>typentry</name><operator>-&gt;</operator><name>type_id</name></name> <operator>!=</operator> <name>element_type</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>,
									 <argument><expr><name>TYPECACHE_HASH_PROC_FINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>hash_proc_finfo</name><operator>.</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not identify a hash function for type %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>typentry</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>typlen</name> <operator>=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>typbyval</name> <operator>=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>typalign</name> <operator>=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * apply the hash function to each array element.
	 */</comment>
	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><name>locfcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>typentry</name><operator>-&gt;</operator><name>hash_proc_finfo</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
							 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Loop over source data */</comment>
	<expr_stmt><expr><name>nitems</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><name>ndims</name></expr></argument>, <argument><expr><name>dims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_iter_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>, <argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>elt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>elthash</name></decl>;</decl_stmt>

		<comment type="block">/* Get element, checking for NULL */</comment>
		<expr_stmt><expr><name>elt</name> <operator>=</operator> <call><name>array_iter_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Treat nulls as having hashvalue 0 */</comment>
			<expr_stmt><expr><name>elthash</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Apply the hash function */</comment>
			<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>elt</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>elthash</name> <operator>=</operator> <call><name>DatumGetUInt32</name><argument_list>(<argument><expr><call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><operator>&amp;</operator><name>locfcinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Combine hash values of successive elements by multiplying the
		 * current value by 31 and adding on the new element's hash value.
		 *
		 * The result is a sum in which each element's hash value is
		 * multiplied by a different power of 31. This is modulo 2^32
		 * arithmetic, and the powers of 31 modulo 2^32 form a cyclic group of
		 * order 2^27. So for arrays of up to 2^27 elements, each element's
		 * hash value is multiplied by a different (odd) number, resulting in
		 * a good mixing of all the elements' hash values.
		 */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>result</name> <operator>&lt;&lt;</operator> <literal type="number">5</literal><operator>)</operator> <operator>-</operator> <name>result</name> <operator>+</operator> <name>elthash</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Avoid leaking memory when handed toasted input. */</comment>
	<expr_stmt><expr><call><name>AARR_FREE_IF_COPY</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_UINT32</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns 64-bit value by hashing a value to a 64-bit value, with a seed.
 * Otherwise, similar to hash_array.
 */</comment>
<function><type><name>Datum</name></type>
<name>hash_array_extended</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AnyArrayType</name> <modifier>*</modifier></type><name>array</name> <init>= <expr><call><name>PG_GETARG_ANY_ARRAY_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>seed</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndims</name> <init>= <expr><call><name>AARR_NDIM</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>dims</name> <init>= <expr><call><name>AARR_DIMS</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>element_type</name> <init>= <expr><call><name>AARR_ELEMTYPE</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>result</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nitems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>typlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typbyval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>typalign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>array_iter</name></type>	<name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FunctionCallInfoData</name></type> <name>locfcinfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>typentry</name> <operator>=</operator> <operator>(</operator><name>TypeCacheEntry</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>typentry</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<name><name>typentry</name><operator>-&gt;</operator><name>type_id</name></name> <operator>!=</operator> <name>element_type</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>,
									 <argument><expr><name>TYPECACHE_HASH_EXTENDED_PROC_FINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>hash_extended_proc_finfo</name><operator>.</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not identify an extended hash function for type %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>typentry</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>typlen</name> <operator>=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>typbyval</name> <operator>=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>typalign</name> <operator>=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><name>locfcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>typentry</name><operator>-&gt;</operator><name>hash_extended_proc_finfo</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
							 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Loop over source data */</comment>
	<expr_stmt><expr><name>nitems</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><name>ndims</name></expr></argument>, <argument><expr><name>dims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_iter_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>, <argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>elt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>elthash</name></decl>;</decl_stmt>

		<comment type="block">/* Get element, checking for NULL */</comment>
		<expr_stmt><expr><name>elt</name> <operator>=</operator> <call><name>array_iter_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>elthash</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Apply the hash function */</comment>
			<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>elt</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>argnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>elthash</name> <operator>=</operator> <call><name>DatumGetUInt64</name><argument_list>(<argument><expr><call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><operator>&amp;</operator><name>locfcinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>result</name> <operator>&lt;&lt;</operator> <literal type="number">5</literal><operator>)</operator> <operator>-</operator> <name>result</name> <operator>+</operator> <name>elthash</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>AARR_FREE_IF_COPY</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_UINT64</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*-----------------------------------------------------------------------------
 * array overlap/containment comparisons
 *		These use the same methods of comparing array elements as array_eq.
 *		We consider only the elements of the arrays, ignoring dimensionality.
 *----------------------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * array_contain_compare :
 *		  compares two arrays for overlap/containment
 *
 * When matchall is true, return true if all members of array1 are in array2.
 * When matchall is false, return true if any members of array1 are in array2.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>array_contain_compare</name><parameter_list>(<parameter><decl><type><name>AnyArrayType</name> <modifier>*</modifier></type><name>array1</name></decl></parameter>, <parameter><decl><type><name>AnyArrayType</name> <modifier>*</modifier></type><name>array2</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>matchall</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>fn_extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>matchall</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>element_type</name> <init>= <expr><call><name>AARR_ELEMTYPE</name><argument_list>(<argument><expr><name>array1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nelems1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nelems2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>typlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typbyval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>typalign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>array_iter</name></type>	<name>it1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FunctionCallInfoData</name></type> <name>locfcinfo</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>element_type</name> <operator>!=</operator> <call><name>AARR_ELEMTYPE</name><argument_list>(<argument><expr><name>array2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot compare arrays of different element types"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We arrange to look up the equality function only once per series of
	 * calls, assuming the element type doesn't change underneath us.  The
	 * typcache is used so that we have no memory leakage when being used as
	 * an index support function.
	 */</comment>
	<expr_stmt><expr><name>typentry</name> <operator>=</operator> <operator>(</operator><name>TypeCacheEntry</name> <operator>*</operator><operator>)</operator> <operator>*</operator><name>fn_extra</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>typentry</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<name><name>typentry</name><operator>-&gt;</operator><name>type_id</name></name> <operator>!=</operator> <name>element_type</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>,
									 <argument><expr><name>TYPECACHE_EQ_OPR_FINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>eq_opr_finfo</name><operator>.</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not identify an equality operator for type %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>fn_extra</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>typentry</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>typlen</name> <operator>=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>typbyval</name> <operator>=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>typalign</name> <operator>=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since we probably will need to scan array2 multiple times, it's
	 * worthwhile to use deconstruct_array on it.  We scan array1 the hard way
	 * however, since we very likely won't need to look at all of it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXPANDED_HEADER</name><argument_list>(<argument><expr><name>array2</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* This should be safe even if input is read-only */</comment>
		<expr_stmt><expr><call><name>deconstruct_expanded_array</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>array2</name><operator>-&gt;</operator><name>xpn</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>values2</name> <operator>=</operator> <name><name>array2</name><operator>-&gt;</operator><name>xpn</name><operator>.</operator><name>dvalues</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nulls2</name> <operator>=</operator> <name><name>array2</name><operator>-&gt;</operator><name>xpn</name><operator>.</operator><name>dnulls</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nelems2</name> <operator>=</operator> <name><name>array2</name><operator>-&gt;</operator><name>xpn</name><operator>.</operator><name>nelems</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>array2</name><operator>-&gt;</operator><name>flt</name></name><operator>)</operator></expr></argument>,
						  <argument><expr><name>element_type</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>values2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nelems2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Apply the comparison operator to each pair of array elements.
	 */</comment>
	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><name>locfcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>typentry</name><operator>-&gt;</operator><name>eq_opr_finfo</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
							 <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Loop over source data */</comment>
	<expr_stmt><expr><name>nelems1</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><call><name>AARR_NDIM</name><argument_list>(<argument><expr><name>array1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>AARR_DIMS</name><argument_list>(<argument><expr><name>array1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_iter_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it1</name></expr></argument>, <argument><expr><name>array1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelems1</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>elt1</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull1</name></decl>;</decl_stmt>

		<comment type="block">/* Get element, checking for NULL */</comment>
		<expr_stmt><expr><name>elt1</name> <operator>=</operator> <call><name>array_iter_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull1</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We assume that the comparison operator is strict, so a NULL can't
		 * match anything.  XXX this diverges from the "NULL=NULL" behavior of
		 * array_eq, should we act like that?
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>isnull1</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>matchall</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nelems2</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>elt2</name> <init>= <expr><name><name>values2</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isnull2</name> <init>= <expr><ternary><condition><expr><name>nulls2</name></expr> ?</condition><then> <expr><name><name>nulls2</name><index>[<expr><name>j</name></expr>]</index></name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>oprresult</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>isnull2</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* can't match */</comment>

			<comment type="block">/*
			 * Apply the operator to the element pair
			 */</comment>
			<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>elt1</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>elt2</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>argnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>oprresult</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><operator>&amp;</operator><name>locfcinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>oprresult</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <name>nelems2</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* found a match for elt1 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>matchall</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* no match for elt1 */</comment>
			<if_stmt><if>if <condition>(<expr><name>matchall</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>arrayoverlap</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AnyArrayType</name> <modifier>*</modifier></type><name>array1</name> <init>= <expr><call><name>PG_GETARG_ANY_ARRAY_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AnyArrayType</name> <modifier>*</modifier></type><name>array2</name> <init>= <expr><call><name>PG_GETARG_ANY_ARRAY_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>collation</name> <init>= <expr><call><name>PG_GET_COLLATION</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>array_contain_compare</name><argument_list>(<argument><expr><name>array1</name></expr></argument>, <argument><expr><name>array2</name></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Avoid leaking memory when handed toasted input. */</comment>
	<expr_stmt><expr><call><name>AARR_FREE_IF_COPY</name><argument_list>(<argument><expr><name>array1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AARR_FREE_IF_COPY</name><argument_list>(<argument><expr><name>array2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>arraycontains</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AnyArrayType</name> <modifier>*</modifier></type><name>array1</name> <init>= <expr><call><name>PG_GETARG_ANY_ARRAY_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AnyArrayType</name> <modifier>*</modifier></type><name>array2</name> <init>= <expr><call><name>PG_GETARG_ANY_ARRAY_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>collation</name> <init>= <expr><call><name>PG_GET_COLLATION</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>array_contain_compare</name><argument_list>(<argument><expr><name>array2</name></expr></argument>, <argument><expr><name>array1</name></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Avoid leaking memory when handed toasted input. */</comment>
	<expr_stmt><expr><call><name>AARR_FREE_IF_COPY</name><argument_list>(<argument><expr><name>array1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AARR_FREE_IF_COPY</name><argument_list>(<argument><expr><name>array2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>arraycontained</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AnyArrayType</name> <modifier>*</modifier></type><name>array1</name> <init>= <expr><call><name>PG_GETARG_ANY_ARRAY_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AnyArrayType</name> <modifier>*</modifier></type><name>array2</name> <init>= <expr><call><name>PG_GETARG_ANY_ARRAY_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>collation</name> <init>= <expr><call><name>PG_GET_COLLATION</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>array_contain_compare</name><argument_list>(<argument><expr><name>array1</name></expr></argument>, <argument><expr><name>array2</name></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Avoid leaking memory when handed toasted input. */</comment>
	<expr_stmt><expr><call><name>AARR_FREE_IF_COPY</name><argument_list>(<argument><expr><name>array1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AARR_FREE_IF_COPY</name><argument_list>(<argument><expr><name>array2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*-----------------------------------------------------------------------------
 * Array iteration functions
 *		These functions are used to iterate efficiently through arrays
 *-----------------------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * array_create_iterator --- set up to iterate through an array
 *
 * If slice_ndim is zero, we will iterate element-by-element; the returned
 * datums are of the array's element type.
 *
 * If slice_ndim is 1..ARR_NDIM(arr), we will iterate by slices: the
 * returned datums are of the same array type as 'arr', but of size
 * equal to the rightmost N dimensions of 'arr'.
 *
 * The passed-in array must remain valid for the lifetime of the iterator.
 */</comment>
<function><type><name>ArrayIterator</name></type>
<name>array_create_iterator</name><parameter_list>(<parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>arr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slice_ndim</name></decl></parameter>, <parameter><decl><type><name>ArrayMetaState</name> <modifier>*</modifier></type><name>mstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayIterator</name></type> <name>iterator</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ArrayIteratorData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Sanity-check inputs --- caller should have got this right already
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>slice_ndim</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>slice_ndim</name></expr></argument> &gt;</argument_list></name> <call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid arguments to array_create_iterator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Remember basic info about the array and its element type
	 */</comment>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>arr</name></name> <operator>=</operator> <name>arr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>nullbitmap</name></name> <operator>=</operator> <call><name>ARR_NULLBITMAP</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>nitems</name></name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>mstate</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mstate</name><operator>-&gt;</operator><name>element_type</name></name> <operator>==</operator> <call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>typlen</name></name> <operator>=</operator> <name><name>mstate</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>typbyval</name></name> <operator>=</operator> <name><name>mstate</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>typalign</name></name> <operator>=</operator> <name><name>mstate</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>iterator</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>iterator</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>iterator</name><operator>-&gt;</operator><name>typalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Remember the slicing parameters.
	 */</comment>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>slice_ndim</name></name> <operator>=</operator> <name>slice_ndim</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>slice_ndim</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Get pointers into the array's dims and lbound arrays to represent
		 * the dims/lbound arrays of a slice.  These are the same as the
		 * rightmost N dimensions of the array.
		 */</comment>
		<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>slice_dims</name></name> <operator>=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>slice_ndim</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>slice_lbound</name></name> <operator>=</operator> <call><name>ARR_LBOUND</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>slice_ndim</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Compute number of elements in a slice.
		 */</comment>
		<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>slice_len</name></name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><name>slice_ndim</name></expr></argument>,
											 <argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>slice_dims</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Create workspace for building sub-arrays.
		 */</comment>
		<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>slice_values</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc</name><argument_list>(<argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>slice_len</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>slice_nulls</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc</name><argument_list>(<argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>slice_len</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Initialize our data pointer and linear element number.  These will
	 * advance through the array during array_iterate().
	 */</comment>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>data_ptr</name></name> <operator>=</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>current_item</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<return>return <expr><name>iterator</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Iterate through the array referenced by 'iterator'.
 *
 * As long as there is another element (or slice), return it into
 * *value / *isnull, and return true.  Return false when no more data.
 */</comment>
<function><type><name>bool</name></type>
<name>array_iterate</name><parameter_list>(<parameter><decl><type><name>ArrayIterator</name></type> <name>iterator</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Done if we have reached the end of the array */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>iterator</name><operator>-&gt;</operator><name>current_item</name></name> <operator>&gt;=</operator> <name><name>iterator</name><operator>-&gt;</operator><name>nitems</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>iterator</name><operator>-&gt;</operator><name>slice_ndim</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Scalar case: return one element.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>array_get_isnull</name><argument_list>(<argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>nullbitmap</name></name></expr></argument>, <argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>current_item</name></name><operator>++</operator></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* non-NULL, so fetch the individual Datum to return */</comment>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>iterator</name><operator>-&gt;</operator><name>data_ptr</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <call><name>fetch_att</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>, <argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Move our data pointer forward to the next element */</comment>
			<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>att_addlength_pointer</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>typalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>data_ptr</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Slice case: build and return an array of the requested size.
		 */</comment>
		<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values</name> <init>= <expr><name><name>iterator</name><operator>-&gt;</operator><name>slice_values</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls</name> <init>= <expr><name><name>iterator</name><operator>-&gt;</operator><name>slice_nulls</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>iterator</name><operator>-&gt;</operator><name>data_ptr</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>iterator</name><operator>-&gt;</operator><name>slice_len</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>array_get_isnull</name><argument_list>(<argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>nullbitmap</name></name></expr></argument>,
								 <argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>current_item</name></name><operator>++</operator></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>fetch_att</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>, <argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Move our data pointer forward to the next element */</comment>
				<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>att_addlength_pointer</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>typalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>data_ptr</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>construct_md_array</name><argument_list>(<argument><expr><name>values</name></expr></argument>,
									<argument><expr><name>nulls</name></expr></argument>,
									<argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>slice_ndim</name></name></expr></argument>,
									<argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>slice_dims</name></name></expr></argument>,
									<argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>slice_lbound</name></name></expr></argument>,
									<argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>arr</name></name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>,
									<argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>,
									<argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>typalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Release an ArrayIterator data structure
 */</comment>
<function><type><name>void</name></type>
<name>array_free_iterator</name><parameter_list>(<parameter><decl><type><name>ArrayIterator</name></type> <name>iterator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>iterator</name><operator>-&gt;</operator><name>slice_ndim</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>slice_values</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>slice_nulls</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>iterator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/***************************************************************************/</comment>
<comment type="block" format="doxygen">/******************|		  Support  Routines			  |*****************/</comment>
<comment type="block" format="doxygen">/***************************************************************************/</comment>

<comment type="block">/*
 * Check whether a specific array element is NULL
 *
 * nullbitmap: pointer to array's null bitmap (NULL if none)
 * offset: 0-based linear element number of array element
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>array_get_isnull</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>bits8</name> <modifier>*</modifier></type><name>nullbitmap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>nullbitmap</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* assume not null */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>nullbitmap</name><index>[<expr><name>offset</name> <operator>/</operator> <literal type="number">8</literal></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>offset</name> <operator>%</operator> <literal type="number">8</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* not null */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Set a specific array element's null-bitmap entry
 *
 * nullbitmap: pointer to array's null bitmap (mustn't be NULL)
 * offset: 0-based linear element number of array element
 * isNull: null status to set
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>array_set_isnull</name><parameter_list>(<parameter><decl><type><name>bits8</name> <modifier>*</modifier></type><name>nullbitmap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isNull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>bitmask</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>nullbitmap</name> <operator>+=</operator> <name>offset</name> <operator>/</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>bitmask</name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>offset</name> <operator>%</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>nullbitmap</name> <operator>&amp;=</operator> <operator>~</operator><name>bitmask</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>nullbitmap</name> <operator>|=</operator> <name>bitmask</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch array element at pointer, converted correctly to a Datum
 *
 * Caller must have handled case of NULL element
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>ArrayCast</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>byval</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>fetch_att</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>byval</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Copy datum to *dest and return total space used (including align padding)
 *
 * Caller must have handled case of NULL element
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ArrayCastAndSet</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>src</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>typlen</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>typbyval</name></decl></parameter>,
				<parameter><decl><type><name>char</name></type> <name>typalign</name></decl></parameter>,
				<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>inc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>typlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>typbyval</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>store_att_byval</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>typlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>inc</name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>typbyval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>inc</name> <operator>=</operator> <call><name>att_addlength_datum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>inc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>inc</name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>inc</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>inc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Advance ptr over nitems array elements
 *
 * ptr: starting location in array
 * offset: 0-based linear element number of first element (the one at *ptr)
 * nullbitmap: start of array's null bitmap, or NULL if none
 * nitems: number of array elements to advance over (&gt;= 0)
 * typlen, typbyval, typalign: storage parameters of array element datatype
 *
 * It is caller's responsibility to ensure that nitems is within range
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>array_seek</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>bits8</name> <modifier>*</modifier></type><name>nullbitmap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nitems</name></decl></parameter>,
		   <parameter><decl><type><name>int</name></type> <name>typlen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>typbyval</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>typalign</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>bitmask</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* easy if fixed-size elements and no NULLs */</comment>
	<if_stmt><if>if <condition>(<expr><name>typlen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>nullbitmap</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ptr</name> <operator>+</operator> <name>nitems</name> <operator>*</operator> <operator>(</operator><operator>(</operator><name>Size</name><operator>)</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* seems worth having separate loops for NULL and no-NULLs cases */</comment>
	<if_stmt><if>if <condition>(<expr><name>nullbitmap</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>nullbitmap</name> <operator>+=</operator> <name>offset</name> <operator>/</operator> <literal type="number">8</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>bitmask</name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>offset</name> <operator>%</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>nullbitmap</name> <operator>&amp;</operator> <name>bitmask</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>att_addlength_pointer</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>bitmask</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>bitmask</name> <operator>==</operator> <literal type="number">0x100</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>nullbitmap</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>bitmask</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>att_addlength_pointer</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>ptr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compute total size of the nitems array elements starting at *ptr
 *
 * Parameters same as for array_seek
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>array_nelems_size</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>bits8</name> <modifier>*</modifier></type><name>nullbitmap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nitems</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>typlen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>typbyval</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>typalign</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>array_seek</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>nullbitmap</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>,
					  <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>ptr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Copy nitems array elements from srcptr to destptr
 *
 * destptr: starting destination location (must be enough room!)
 * nitems: number of array elements to copy (&gt;= 0)
 * srcptr: starting location in source array
 * offset: 0-based linear element number of first element (the one at *srcptr)
 * nullbitmap: start of source array's null bitmap, or NULL if none
 * typlen, typbyval, typalign: storage parameters of array element datatype
 *
 * Returns number of bytes copied
 *
 * NB: this does not take care of setting up the destination's null bitmap!
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>array_copy</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>destptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nitems</name></decl></parameter>,
		   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>srcptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>bits8</name> <modifier>*</modifier></type><name>nullbitmap</name></decl></parameter>,
		   <parameter><decl><type><name>int</name></type> <name>typlen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>typbyval</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>typalign</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>numbytes</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>numbytes</name> <operator>=</operator> <call><name>array_nelems_size</name><argument_list>(<argument><expr><name>srcptr</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>nullbitmap</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>,
								 <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>destptr</name></expr></argument>, <argument><expr><name>srcptr</name></expr></argument>, <argument><expr><name>numbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>numbytes</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Copy nitems null-bitmap bits from source to destination
 *
 * destbitmap: start of destination array's null bitmap (mustn't be NULL)
 * destoffset: 0-based linear element number of first dest element
 * srcbitmap: start of source array's null bitmap, or NULL if none
 * srcoffset: 0-based linear element number of first source element
 * nitems: number of bits to copy (&gt;= 0)
 *
 * If srcbitmap is NULL then we assume the source is all-non-NULL and
 * fill 1's into the destination bitmap.  Note that only the specified
 * bits in the destination map are changed, not any before or after.
 *
 * Note: this could certainly be optimized using standard bitblt methods.
 * However, it's not clear that the typical Postgres array has enough elements
 * to make it worth worrying too much.  For the moment, KISS.
 */</comment>
<function><type><name>void</name></type>
<name>array_bitmap_copy</name><parameter_list>(<parameter><decl><type><name>bits8</name> <modifier>*</modifier></type><name>destbitmap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>destoffset</name></decl></parameter>,
				  <parameter><decl><type><specifier>const</specifier> <name>bits8</name> <modifier>*</modifier></type><name>srcbitmap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcoffset</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>nitems</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>destbitmask</name></decl>,
				<decl><type ref="prev"/><name>destbitval</name></decl>,
				<decl><type ref="prev"/><name>srcbitmask</name></decl>,
				<decl><type ref="prev"/><name>srcbitval</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>destbitmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nitems</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* don't risk fetch off end of memory */</comment>
	<expr_stmt><expr><name>destbitmap</name> <operator>+=</operator> <name>destoffset</name> <operator>/</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>destbitmask</name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>destoffset</name> <operator>%</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>destbitval</name> <operator>=</operator> <operator>*</operator><name>destbitmap</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>srcbitmap</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>srcbitmap</name> <operator>+=</operator> <name>srcoffset</name> <operator>/</operator> <literal type="number">8</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>srcbitmask</name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>srcoffset</name> <operator>%</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>srcbitval</name> <operator>=</operator> <operator>*</operator><name>srcbitmap</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>nitems</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>srcbitval</name> <operator>&amp;</operator> <name>srcbitmask</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>destbitval</name> <operator>|=</operator> <name>destbitmask</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>destbitval</name> <operator>&amp;=</operator> <operator>~</operator><name>destbitmask</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>destbitmask</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>destbitmask</name> <operator>==</operator> <literal type="number">0x100</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>destbitmap</name><operator>++</operator> <operator>=</operator> <name>destbitval</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>destbitmask</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>nitems</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>destbitval</name> <operator>=</operator> <operator>*</operator><name>destbitmap</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>srcbitmask</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>srcbitmask</name> <operator>==</operator> <literal type="number">0x100</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>srcbitmap</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>srcbitmask</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>nitems</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>srcbitval</name> <operator>=</operator> <operator>*</operator><name>srcbitmap</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>
		<if_stmt><if>if <condition>(<expr><name>destbitmask</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>destbitmap</name> <operator>=</operator> <name>destbitval</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<while>while <condition>(<expr><name>nitems</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>destbitval</name> <operator>|=</operator> <name>destbitmask</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>destbitmask</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>destbitmask</name> <operator>==</operator> <literal type="number">0x100</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>destbitmap</name><operator>++</operator> <operator>=</operator> <name>destbitval</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>destbitmask</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>nitems</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>destbitval</name> <operator>=</operator> <operator>*</operator><name>destbitmap</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>
		<if_stmt><if>if <condition>(<expr><name>destbitmask</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>destbitmap</name> <operator>=</operator> <name>destbitval</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Compute space needed for a slice of an array
 *
 * We assume the caller has verified that the slice coordinates are valid.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>array_slice_size</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>arraydataptr</name></decl></parameter>, <parameter><decl><type><name>bits8</name> <modifier>*</modifier></type><name>arraynullsptr</name></decl></parameter>,
				 <parameter><decl><type><name>int</name></type> <name>ndim</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dim</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>lb</name></decl></parameter>,
				 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>endp</name></decl></parameter>,
				 <parameter><decl><type><name>int</name></type> <name>typlen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>typbyval</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>typalign</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>src_offset</name></decl>,
				<decl><type ref="prev"/><name><name>span</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name><name>prod</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name><name>dist</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name><name>indx</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>,
				<decl><type ref="prev"/><name>inc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>mda_get_range</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>span</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name>endp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Pretty easy for fixed element length without nulls ... */</comment>
	<if_stmt><if>if <condition>(<expr><name>typlen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>arraynullsptr</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>ArrayGetNItems</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>span</name></expr></argument>)</argument_list></call> <operator>*</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Else gotta do it the hard way */</comment>
	<expr_stmt><expr><name>src_offset</name> <operator>=</operator> <call><name>ArrayGetOffset</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>lb</name></expr></argument>, <argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>array_seek</name><argument_list>(<argument><expr><name>arraydataptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>arraynullsptr</name></expr></argument>, <argument><expr><name>src_offset</name></expr></argument>,
					 <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>mda_get_prod</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>prod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>mda_get_offset_values</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>dist</name></expr></argument>, <argument><expr><name>prod</name></expr></argument>, <argument><expr><name>span</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndim</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>indx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><name>j</name> <operator>=</operator> <name>ndim</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<do>do
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>dist</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>array_seek</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>src_offset</name></expr></argument>, <argument><expr><name>arraynullsptr</name></expr></argument>, <argument><expr><name><name>dist</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
							 <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>src_offset</name> <operator>+=</operator> <name><name>dist</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>array_get_isnull</name><argument_list>(<argument><expr><name>arraynullsptr</name></expr></argument>, <argument><expr><name>src_offset</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>inc</name> <operator>=</operator> <call><name>att_addlength_pointer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>inc</name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>inc</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>inc</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>count</name> <operator>+=</operator> <name>inc</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>src_offset</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><operator>(</operator><name>j</name> <operator>=</operator> <call><name>mda_next_tuple</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>indx</name></expr></argument>, <argument><expr><name>span</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>;</do>
	<return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Extract a slice of an array into consecutive elements in the destination
 * array.
 *
 * We assume the caller has verified that the slice coordinates are valid,
 * allocated enough storage for the result, and initialized the header
 * of the new array.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>array_extract_slice</name><parameter_list>(<parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>newarray</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>ndim</name></decl></parameter>,
					<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dim</name></decl></parameter>,
					<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>lb</name></decl></parameter>,
					<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>arraydataptr</name></decl></parameter>,
					<parameter><decl><type><name>bits8</name> <modifier>*</modifier></type><name>arraynullsptr</name></decl></parameter>,
					<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>st</name></decl></parameter>,
					<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>endp</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>typlen</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>typbyval</name></decl></parameter>,
					<parameter><decl><type><name>char</name></type> <name>typalign</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>destdataptr</name> <init>= <expr><call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>newarray</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bits8</name>	   <modifier>*</modifier></type><name>destnullsptr</name> <init>= <expr><call><name>ARR_NULLBITMAP</name><argument_list>(<argument><expr><name>newarray</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>srcdataptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>src_offset</name></decl>,
				<decl><type ref="prev"/><name>dest_offset</name></decl>,
				<decl><type ref="prev"/><name><name>prod</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name><name>span</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name><name>dist</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name><name>indx</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>,
				<decl><type ref="prev"/><name>inc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>src_offset</name> <operator>=</operator> <call><name>ArrayGetOffset</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>lb</name></expr></argument>, <argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>srcdataptr</name> <operator>=</operator> <call><name>array_seek</name><argument_list>(<argument><expr><name>arraydataptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>arraynullsptr</name></expr></argument>, <argument><expr><name>src_offset</name></expr></argument>,
							<argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>mda_get_prod</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>prod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>mda_get_range</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>span</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name>endp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>mda_get_offset_values</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>dist</name></expr></argument>, <argument><expr><name>prod</name></expr></argument>, <argument><expr><name>span</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndim</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>indx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><name>dest_offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>j</name> <operator>=</operator> <name>ndim</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<do>do
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>dist</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* skip unwanted elements */</comment>
			<expr_stmt><expr><name>srcdataptr</name> <operator>=</operator> <call><name>array_seek</name><argument_list>(<argument><expr><name>srcdataptr</name></expr></argument>, <argument><expr><name>src_offset</name></expr></argument>, <argument><expr><name>arraynullsptr</name></expr></argument>,
									<argument><expr><name><name>dist</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
									<argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>src_offset</name> <operator>+=</operator> <name><name>dist</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>inc</name> <operator>=</operator> <call><name>array_copy</name><argument_list>(<argument><expr><name>destdataptr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
						 <argument><expr><name>srcdataptr</name></expr></argument>, <argument><expr><name>src_offset</name></expr></argument>, <argument><expr><name>arraynullsptr</name></expr></argument>,
						 <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>destnullsptr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>array_bitmap_copy</name><argument_list>(<argument><expr><name>destnullsptr</name></expr></argument>, <argument><expr><name>dest_offset</name></expr></argument>,
							  <argument><expr><name>arraynullsptr</name></expr></argument>, <argument><expr><name>src_offset</name></expr></argument>,
							  <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>destdataptr</name> <operator>+=</operator> <name>inc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>srcdataptr</name> <operator>+=</operator> <name>inc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>src_offset</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>dest_offset</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><operator>(</operator><name>j</name> <operator>=</operator> <call><name>mda_next_tuple</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>indx</name></expr></argument>, <argument><expr><name>span</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>;</do>
</block_content>}</block></function>

<comment type="block">/*
 * Insert a slice into an array.
 *
 * ndim/dim[]/lb[] are dimensions of the original array.  A new array with
 * those same dimensions is to be constructed.  destArray must already
 * have been allocated and its header initialized.
 *
 * st[]/endp[] identify the slice to be replaced.  Elements within the slice
 * volume are taken from consecutive elements of the srcArray; elements
 * outside it are copied from origArray.
 *
 * We assume the caller has verified that the slice coordinates are valid.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>array_insert_slice</name><parameter_list>(<parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>destArray</name></decl></parameter>,
				   <parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>origArray</name></decl></parameter>,
				   <parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>srcArray</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>ndim</name></decl></parameter>,
				   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dim</name></decl></parameter>,
				   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>lb</name></decl></parameter>,
				   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>st</name></decl></parameter>,
				   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>endp</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>typlen</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>typbyval</name></decl></parameter>,
				   <parameter><decl><type><name>char</name></type> <name>typalign</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>destPtr</name> <init>= <expr><call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>destArray</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>origPtr</name> <init>= <expr><call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>origArray</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>srcPtr</name> <init>= <expr><call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>srcArray</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bits8</name>	   <modifier>*</modifier></type><name>destBitmap</name> <init>= <expr><call><name>ARR_NULLBITMAP</name><argument_list>(<argument><expr><name>destArray</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bits8</name>	   <modifier>*</modifier></type><name>origBitmap</name> <init>= <expr><call><name>ARR_NULLBITMAP</name><argument_list>(<argument><expr><name>origArray</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bits8</name>	   <modifier>*</modifier></type><name>srcBitmap</name> <init>= <expr><call><name>ARR_NULLBITMAP</name><argument_list>(<argument><expr><name>srcArray</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>orignitems</name> <init>= <expr><call><name>ArrayGetNItems</name><argument_list>(<argument><expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>origArray</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>origArray</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dest_offset</name></decl>,
				<decl><type ref="prev"/><name>orig_offset</name></decl>,
				<decl><type ref="prev"/><name>src_offset</name></decl>,
				<decl><type ref="prev"/><name><name>prod</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name><name>span</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name><name>dist</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name><name>indx</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>,
				<decl><type ref="prev"/><name>inc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dest_offset</name> <operator>=</operator> <call><name>ArrayGetOffset</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>lb</name></expr></argument>, <argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* copy items before the slice start */</comment>
	<expr_stmt><expr><name>inc</name> <operator>=</operator> <call><name>array_copy</name><argument_list>(<argument><expr><name>destPtr</name></expr></argument>, <argument><expr><name>dest_offset</name></expr></argument>,
					 <argument><expr><name>origPtr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>origBitmap</name></expr></argument>,
					 <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>destPtr</name> <operator>+=</operator> <name>inc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>origPtr</name> <operator>+=</operator> <name>inc</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>destBitmap</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>array_bitmap_copy</name><argument_list>(<argument><expr><name>destBitmap</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>origBitmap</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>dest_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>orig_offset</name> <operator>=</operator> <name>dest_offset</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>mda_get_prod</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>prod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>mda_get_range</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>span</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name>endp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>mda_get_offset_values</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>dist</name></expr></argument>, <argument><expr><name>prod</name></expr></argument>, <argument><expr><name>span</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndim</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>indx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><name>src_offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>j</name> <operator>=</operator> <name>ndim</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<do>do
	<block>{<block_content>
		<comment type="block">/* Copy/advance over elements between here and next part of slice */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dist</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>inc</name> <operator>=</operator> <call><name>array_copy</name><argument_list>(<argument><expr><name>destPtr</name></expr></argument>, <argument><expr><name><name>dist</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
							 <argument><expr><name>origPtr</name></expr></argument>, <argument><expr><name>orig_offset</name></expr></argument>, <argument><expr><name>origBitmap</name></expr></argument>,
							 <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>destPtr</name> <operator>+=</operator> <name>inc</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>origPtr</name> <operator>+=</operator> <name>inc</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>destBitmap</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>array_bitmap_copy</name><argument_list>(<argument><expr><name>destBitmap</name></expr></argument>, <argument><expr><name>dest_offset</name></expr></argument>,
								  <argument><expr><name>origBitmap</name></expr></argument>, <argument><expr><name>orig_offset</name></expr></argument>,
								  <argument><expr><name><name>dist</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>dest_offset</name> <operator>+=</operator> <name><name>dist</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>orig_offset</name> <operator>+=</operator> <name><name>dist</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Copy new element at this slice position */</comment>
		<expr_stmt><expr><name>inc</name> <operator>=</operator> <call><name>array_copy</name><argument_list>(<argument><expr><name>destPtr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
						 <argument><expr><name>srcPtr</name></expr></argument>, <argument><expr><name>src_offset</name></expr></argument>, <argument><expr><name>srcBitmap</name></expr></argument>,
						 <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>destBitmap</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>array_bitmap_copy</name><argument_list>(<argument><expr><name>destBitmap</name></expr></argument>, <argument><expr><name>dest_offset</name></expr></argument>,
							  <argument><expr><name>srcBitmap</name></expr></argument>, <argument><expr><name>src_offset</name></expr></argument>,
							  <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>destPtr</name> <operator>+=</operator> <name>inc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>srcPtr</name> <operator>+=</operator> <name>inc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dest_offset</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>src_offset</name><operator>++</operator></expr>;</expr_stmt>
		<comment type="block">/* Advance over old element at this slice position */</comment>
		<expr_stmt><expr><name>origPtr</name> <operator>=</operator> <call><name>array_seek</name><argument_list>(<argument><expr><name>origPtr</name></expr></argument>, <argument><expr><name>orig_offset</name></expr></argument>, <argument><expr><name>origBitmap</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
							 <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>orig_offset</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><operator>(</operator><name>j</name> <operator>=</operator> <call><name>mda_next_tuple</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>indx</name></expr></argument>, <argument><expr><name>span</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>;</do>

	<comment type="block">/* don't miss any data at the end */</comment>
	<expr_stmt><expr><call><name>array_copy</name><argument_list>(<argument><expr><name>destPtr</name></expr></argument>, <argument><expr><name>orignitems</name> <operator>-</operator> <name>orig_offset</name></expr></argument>,
			   <argument><expr><name>origPtr</name></expr></argument>, <argument><expr><name>orig_offset</name></expr></argument>, <argument><expr><name>origBitmap</name></expr></argument>,
			   <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>destBitmap</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>array_bitmap_copy</name><argument_list>(<argument><expr><name>destBitmap</name></expr></argument>, <argument><expr><name>dest_offset</name></expr></argument>,
						  <argument><expr><name>origBitmap</name></expr></argument>, <argument><expr><name>orig_offset</name></expr></argument>,
						  <argument><expr><name>orignitems</name> <operator>-</operator> <name>orig_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * initArrayResult - initialize an empty ArrayBuildState
 *
 *	element_type is the array element type (must be a valid array element type)
 *	rcontext is where to keep working state
 *	subcontext is a flag determining whether to use a separate memory context
 *
 * Note: there are two common schemes for using accumArrayResult().
 * In the older scheme, you start with a NULL ArrayBuildState pointer, and
 * call accumArrayResult once per element.  In this scheme you end up with
 * a NULL pointer if there were no elements, which you need to special-case.
 * In the newer scheme, call initArrayResult and then call accumArrayResult
 * once per element.  In this scheme you always end with a non-NULL pointer
 * that you can pass to makeArrayResult; you get an empty array if there
 * were no elements.  This is preferred if an empty array is what you want.
 *
 * It's possible to choose whether to create a separate memory context for the
 * array build state, or whether to allocate it directly within rcontext.
 *
 * When there are many concurrent small states (e.g. array_agg() using hash
 * aggregation of many small groups), using a separate memory context for each
 * one may result in severe memory bloat. In such cases, use the same memory
 * context to initialize all such array build states, and pass
 * subcontext=false.
 *
 * In cases when the array build states have different lifetimes, using a
 * single memory context is impractical. Instead, pass subcontext=true so that
 * the array build states can be freed individually.
 */</comment>
<function><type><name>ArrayBuildState</name> <modifier>*</modifier></type>
<name>initArrayResult</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>element_type</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>rcontext</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>subcontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayBuildState</name> <modifier>*</modifier></type><name>astate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>arr_context</name> <init>= <expr><name>rcontext</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Make a temporary context to hold all the junk */</comment>
	<if_stmt><if>if <condition>(<expr><name>subcontext</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>arr_context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>rcontext</name></expr></argument>,
											<argument><expr><literal type="string">"accumArrayResult"</literal></expr></argument>,
											<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>astate</name> <operator>=</operator> <operator>(</operator><name>ArrayBuildState</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>arr_context</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ArrayBuildState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>mcontext</name></name> <operator>=</operator> <name>arr_context</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>private_cxt</name></name> <operator>=</operator> <name>subcontext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>alen</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>subcontext</name></expr> ?</condition><then> <expr><literal type="number">64</literal></expr> </then><else>: <expr><literal type="number">8</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>	<comment type="block">/* arbitrary starting array size */</comment>
	<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>dvalues</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>arr_context</name></expr></argument>, <argument><expr><name><name>astate</name><operator>-&gt;</operator><name>alen</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>dnulls</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>arr_context</name></expr></argument>, <argument><expr><name><name>astate</name><operator>-&gt;</operator><name>alen</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>nelems</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>element_type</name></name> <operator>=</operator> <name>element_type</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>astate</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>astate</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>astate</name><operator>-&gt;</operator><name>typalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>astate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * accumArrayResult - accumulate one (more) Datum for an array result
 *
 *	astate is working state (can be NULL on first call)
 *	dvalue/disnull represent the new Datum to append to the array
 *	element_type is the Datum's type (must be a valid array element type)
 *	rcontext is where to keep working state
 */</comment>
<function><type><name>ArrayBuildState</name> <modifier>*</modifier></type>
<name>accumArrayResult</name><parameter_list>(<parameter><decl><type><name>ArrayBuildState</name> <modifier>*</modifier></type><name>astate</name></decl></parameter>,
				 <parameter><decl><type><name>Datum</name></type> <name>dvalue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>disnull</name></decl></parameter>,
				 <parameter><decl><type><name>Oid</name></type> <name>element_type</name></decl></parameter>,
				 <parameter><decl><type><name>MemoryContext</name></type> <name>rcontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>astate</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* First time through --- initialize */</comment>
		<expr_stmt><expr><name>astate</name> <operator>=</operator> <call><name>initArrayResult</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>, <argument><expr><name>rcontext</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>element_type</name></name> <operator>==</operator> <name>element_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>mcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* enlarge dvalues[]/dnulls[] if needed */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>astate</name><operator>-&gt;</operator><name>nelems</name></name> <operator>&gt;=</operator> <name><name>astate</name><operator>-&gt;</operator><name>alen</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>alen</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>dvalues</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator>
			<call><name>repalloc</name><argument_list>(<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>dvalues</name></name></expr></argument>, <argument><expr><name><name>astate</name><operator>-&gt;</operator><name>alen</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>dnulls</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator>
			<call><name>repalloc</name><argument_list>(<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>dnulls</name></name></expr></argument>, <argument><expr><name><name>astate</name><operator>-&gt;</operator><name>alen</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Ensure pass-by-ref stuff is copied into mcontext; and detoast it too if
	 * it's varlena.  (You might think that detoasting is not needed here
	 * because construct_md_array can detoast the array elements later.
	 * However, we must not let construct_md_array modify the ArrayBuildState
	 * because that would mean array_agg_finalfn damages its input, which is
	 * verboten.  Also, this way frequently saves one copying step.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>disnull</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>astate</name><operator>-&gt;</operator><name>typbyval</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>astate</name><operator>-&gt;</operator><name>typlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>dvalue</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM_COPY</name><argument_list>(<argument><expr><name>dvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>dvalue</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name>dvalue</name></expr></argument>, <argument><expr><name><name>astate</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>, <argument><expr><name><name>astate</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>dvalues</name><index>[<expr><name><name>astate</name><operator>-&gt;</operator><name>nelems</name></name></expr>]</index></name> <operator>=</operator> <name>dvalue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>dnulls</name><index>[<expr><name><name>astate</name><operator>-&gt;</operator><name>nelems</name></name></expr>]</index></name> <operator>=</operator> <name>disnull</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>nelems</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>astate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * makeArrayResult - produce 1-D final result of accumArrayResult
 *
 * Note: only releases astate if it was initialized within a separate memory
 * context (i.e. using subcontext=true when calling initArrayResult).
 *
 *	astate is working state (must not be NULL)
 *	rcontext is where to construct result
 */</comment>
<function><type><name>Datum</name></type>
<name>makeArrayResult</name><parameter_list>(<parameter><decl><type><name>ArrayBuildState</name> <modifier>*</modifier></type><name>astate</name></decl></parameter>,
				<parameter><decl><type><name>MemoryContext</name></type> <name>rcontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndims</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>dims</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>lbs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* If no elements were presented, we want to create an empty array */</comment>
	<expr_stmt><expr><name>ndims</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>astate</name><operator>-&gt;</operator><name>nelems</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dims</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>astate</name><operator>-&gt;</operator><name>nelems</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lbs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<return>return <expr><call><name>makeMdArrayResult</name><argument_list>(<argument><expr><name>astate</name></expr></argument>, <argument><expr><name>ndims</name></expr></argument>, <argument><expr><name>dims</name></expr></argument>, <argument><expr><name>lbs</name></expr></argument>, <argument><expr><name>rcontext</name></expr></argument>,
							 <argument><expr><name><name>astate</name><operator>-&gt;</operator><name>private_cxt</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * makeMdArrayResult - produce multi-D final result of accumArrayResult
 *
 * beware: no check that specified dimensions match the number of values
 * accumulated.
 *
 * Note: if the astate was not initialized within a separate memory context
 * (that is, initArrayResult was called with subcontext=false), then using
 * release=true is illegal. Instead, release astate along with the rest of its
 * context when appropriate.
 *
 *	astate is working state (must not be NULL)
 *	rcontext is where to construct result
 *	release is true if okay to release working state
 */</comment>
<function><type><name>Datum</name></type>
<name>makeMdArrayResult</name><parameter_list>(<parameter><decl><type><name>ArrayBuildState</name> <modifier>*</modifier></type><name>astate</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>ndims</name></decl></parameter>,
				  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dims</name></decl></parameter>,
				  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>lbs</name></decl></parameter>,
				  <parameter><decl><type><name>MemoryContext</name></type> <name>rcontext</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>release</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* Build the final array result in rcontext */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>rcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>construct_md_array</name><argument_list>(<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>dvalues</name></name></expr></argument>,
								<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>dnulls</name></name></expr></argument>,
								<argument><expr><name>ndims</name></expr></argument>,
								<argument><expr><name>dims</name></expr></argument>,
								<argument><expr><name>lbs</name></expr></argument>,
								<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>element_type</name></name></expr></argument>,
								<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>,
								<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>,
								<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>typalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clean up all the junk */</comment>
	<if_stmt><if>if <condition>(<expr><name>release</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>private_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>mcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * The following three functions provide essentially the same API as
 * initArrayResult/accumArrayResult/makeArrayResult, but instead of accepting
 * inputs that are array elements, they accept inputs that are arrays and
 * produce an output array having N+1 dimensions.  The inputs must all have
 * identical dimensionality as well as element type.
 */</comment>

<comment type="block">/*
 * initArrayResultArr - initialize an empty ArrayBuildStateArr
 *
 *	array_type is the array type (must be a valid varlena array type)
 *	element_type is the type of the array's elements (lookup if InvalidOid)
 *	rcontext is where to keep working state
 *	subcontext is a flag determining whether to use a separate memory context
 */</comment>
<function><type><name>ArrayBuildStateArr</name> <modifier>*</modifier></type>
<name>initArrayResultArr</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>array_type</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>element_type</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>rcontext</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>subcontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayBuildStateArr</name> <modifier>*</modifier></type><name>astate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>arr_context</name> <init>= <expr><name>rcontext</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* by default use the parent ctx */</comment>

	<comment type="block">/* Lookup element type, unless element_type already provided */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>element_type</name> <operator>=</operator> <call><name>get_element_type</name><argument_list>(<argument><expr><name>array_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"data type %s is not an array type"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>array_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Make a temporary context to hold all the junk */</comment>
	<if_stmt><if>if <condition>(<expr><name>subcontext</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>arr_context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>rcontext</name></expr></argument>,
											<argument><expr><literal type="string">"accumArrayResultArr"</literal></expr></argument>,
											<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Note we initialize all fields to zero */</comment>
	<expr_stmt><expr><name>astate</name> <operator>=</operator> <operator>(</operator><name>ArrayBuildStateArr</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>arr_context</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ArrayBuildStateArr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>mcontext</name></name> <operator>=</operator> <name>arr_context</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>private_cxt</name></name> <operator>=</operator> <name>subcontext</name></expr>;</expr_stmt>

	<comment type="block">/* Save relevant datatype information */</comment>
	<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>array_type</name></name> <operator>=</operator> <name>array_type</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>element_type</name></name> <operator>=</operator> <name>element_type</name></expr>;</expr_stmt>

	<return>return <expr><name>astate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * accumArrayResultArr - accumulate one (more) sub-array for an array result
 *
 *	astate is working state (can be NULL on first call)
 *	dvalue/disnull represent the new sub-array to append to the array
 *	array_type is the array type (must be a valid varlena array type)
 *	rcontext is where to keep working state
 */</comment>
<function><type><name>ArrayBuildStateArr</name> <modifier>*</modifier></type>
<name>accumArrayResultArr</name><parameter_list>(<parameter><decl><type><name>ArrayBuildStateArr</name> <modifier>*</modifier></type><name>astate</name></decl></parameter>,
					<parameter><decl><type><name>Datum</name></type> <name>dvalue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>disnull</name></decl></parameter>,
					<parameter><decl><type><name>Oid</name></type> <name>array_type</name></decl></parameter>,
					<parameter><decl><type><name>MemoryContext</name></type> <name>rcontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>dims</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>lbs</name></decl>,
				<decl><type ref="prev"/><name>ndims</name></decl>,
				<decl><type ref="prev"/><name>nitems</name></decl>,
				<decl><type ref="prev"/><name>ndatabytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We disallow accumulating null subarrays.  Another plausible definition
	 * is to ignore them, but callers that want that can just skip calling
	 * this function.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>disnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot accumulate null arrays"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Detoast input array in caller's context */</comment>
	<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>dvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>astate</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>astate</name> <operator>=</operator> <call><name>initArrayResultArr</name><argument_list>(<argument><expr><name>array_type</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>rcontext</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>array_type</name></name> <operator>==</operator> <name>array_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>mcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Collect this input's dimensions */</comment>
	<expr_stmt><expr><name>ndims</name> <operator>=</operator> <call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dims</name> <operator>=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lbs</name> <operator>=</operator> <call><name>ARR_LBOUND</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nitems</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><name>ndims</name></expr></argument>, <argument><expr><name>dims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ndatabytes</name> <operator>=</operator> <call><name>ARR_SIZE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>ARR_DATA_OFFSET</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>astate</name><operator>-&gt;</operator><name>ndims</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* First input; check/save the dimensionality info */</comment>

		<comment type="block">/* Should we allow empty inputs and just produce an empty output? */</comment>
		<if_stmt><if>if <condition>(<expr><name>ndims</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot accumulate empty arrays"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>ndims</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;</operator> <name>MAXDIM</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of array dimensions (%d) exceeds the maximum allowed (%d)"</literal></expr></argument>,
							<argument><expr><name>ndims</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>MAXDIM</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * The output array will have n+1 dimensions, with the ones after the
		 * first matching the input's dimensions.
		 */</comment>
		<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>ndims</name></name> <operator>=</operator> <name>ndims</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>dims</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>astate</name><operator>-&gt;</operator><name>dims</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>dims</name></expr></argument>, <argument><expr><name>ndims</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>lbs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>astate</name><operator>-&gt;</operator><name>lbs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>lbs</name></expr></argument>, <argument><expr><name>ndims</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Allocate at least enough data space for this item */</comment>
		<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>abytes</name></name> <operator>=</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><name><name>astate</name><operator>-&gt;</operator><name>abytes</name></name> <operator>&lt;=</operator> <name>ndatabytes</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>abytes</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></while>
		<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>abytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Second or later input: must match first input's dimensionality */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>astate</name><operator>-&gt;</operator><name>ndims</name></name> <operator>!=</operator> <name>ndims</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot accumulate arrays of different dimensionality"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndims</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>astate</name><operator>-&gt;</operator><name>dims</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name><name>dims</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator> <name><name>astate</name><operator>-&gt;</operator><name>lbs</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name><name>lbs</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot accumulate arrays of different dimensionality"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Enlarge data space if needed */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>astate</name><operator>-&gt;</operator><name>nbytes</name></name> <operator>+</operator> <name>ndatabytes</name> <operator>&gt;</operator> <name><name>astate</name><operator>-&gt;</operator><name>abytes</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>abytes</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>abytes</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>,
								 <argument><expr><name><name>astate</name><operator>-&gt;</operator><name>nbytes</name></name> <operator>+</operator> <name>ndatabytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>astate</name><operator>-&gt;</operator><name>abytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Copy the data portion of the sub-array.  Note we assume that the
	 * advertised data length of the sub-array is properly aligned.  We do not
	 * have to worry about detoasting elements since whatever's in the
	 * sub-array should be OK already.
	 */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name><name>astate</name><operator>-&gt;</operator><name>nbytes</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>ndatabytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>nbytes</name></name> <operator>+=</operator> <name>ndatabytes</name></expr>;</expr_stmt>

	<comment type="block">/* Deal with null bitmap if needed */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>astate</name><operator>-&gt;</operator><name>nullbitmap</name></name> <operator>||</operator> <call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>newnitems</name> <init>= <expr><name><name>astate</name><operator>-&gt;</operator><name>nitems</name></name> <operator>+</operator> <name>nitems</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>astate</name><operator>-&gt;</operator><name>nullbitmap</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * First input with nulls; we must retrospectively handle any
			 * previous inputs by marking all their items non-null.
			 */</comment>
			<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>aitems</name></name> <operator>=</operator> <literal type="number">256</literal></expr>;</expr_stmt>
			<while>while <condition>(<expr><name><name>astate</name><operator>-&gt;</operator><name>aitems</name></name> <operator>&lt;=</operator> <name>newnitems</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>aitems</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></while>
			<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>nullbitmap</name></name> <operator>=</operator> <operator>(</operator><name>bits8</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name><name>astate</name><operator>-&gt;</operator><name>aitems</name></name> <operator>+</operator> <literal type="number">7</literal><operator>)</operator> <operator>/</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>array_bitmap_copy</name><argument_list>(<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>nullbitmap</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							  <argument><expr><name><name>astate</name><operator>-&gt;</operator><name>nitems</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>newnitems</name> <operator>&gt;</operator> <name><name>astate</name><operator>-&gt;</operator><name>aitems</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>aitems</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>aitems</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>newnitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>nullbitmap</name></name> <operator>=</operator> <operator>(</operator><name>bits8</name> <operator>*</operator><operator>)</operator>
				<call><name>repalloc</name><argument_list>(<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>nullbitmap</name></name></expr></argument>, <argument><expr><operator>(</operator><name><name>astate</name><operator>-&gt;</operator><name>aitems</name></name> <operator>+</operator> <literal type="number">7</literal><operator>)</operator> <operator>/</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>array_bitmap_copy</name><argument_list>(<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>nullbitmap</name></name></expr></argument>, <argument><expr><name><name>astate</name><operator>-&gt;</operator><name>nitems</name></name></expr></argument>,
						  <argument><expr><call><name>ARR_NULLBITMAP</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
						  <argument><expr><name>nitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>nitems</name></name> <operator>+=</operator> <name>nitems</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>dims</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Release detoasted copy if any */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Pointer</name><operator>)</operator> <name>arg</name> <operator>!=</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>dvalue</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>astate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * makeArrayResultArr - produce N+1-D final result of accumArrayResultArr
 *
 *	astate is working state (must not be NULL)
 *	rcontext is where to construct result
 *	release is true if okay to release working state
 */</comment>
<function><type><name>Datum</name></type>
<name>makeArrayResultArr</name><parameter_list>(<parameter><decl><type><name>ArrayBuildStateArr</name> <modifier>*</modifier></type><name>astate</name></decl></parameter>,
				   <parameter><decl><type><name>MemoryContext</name></type> <name>rcontext</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>release</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* Build the final array result in rcontext */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>rcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>astate</name><operator>-&gt;</operator><name>ndims</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No inputs, return empty array */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>construct_empty_array</name><argument_list>(<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>element_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>dataoffset</name></decl>,
					<decl><type ref="prev"/><name>nbytes</name></decl>;</decl_stmt>

		<comment type="block">/* Check for overflow of the array dimensions */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>ndims</name></name></expr></argument>, <argument><expr><name><name>astate</name><operator>-&gt;</operator><name>dims</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ArrayCheckBounds</name><argument_list>(<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>ndims</name></name></expr></argument>, <argument><expr><name><name>astate</name><operator>-&gt;</operator><name>dims</name></name></expr></argument>, <argument><expr><name><name>astate</name><operator>-&gt;</operator><name>lbs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Compute required space */</comment>
		<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <name><name>astate</name><operator>-&gt;</operator><name>nbytes</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>astate</name><operator>-&gt;</operator><name>nullbitmap</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>dataoffset</name> <operator>=</operator> <call><name>ARR_OVERHEAD_WITHNULLS</name><argument_list>(<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>ndims</name></name></expr></argument>, <argument><expr><name><name>astate</name><operator>-&gt;</operator><name>nitems</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>nbytes</name> <operator>+=</operator> <name>dataoffset</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>dataoffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>nbytes</name> <operator>+=</operator> <call><name>ARR_OVERHEAD_NONULLS</name><argument_list>(<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>ndims</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>ArrayType</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>ndim</name></name> <operator>=</operator> <name><name>astate</name><operator>-&gt;</operator><name>ndims</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dataoffset</name></name> <operator>=</operator> <name>dataoffset</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>elemtype</name></name> <operator>=</operator> <name><name>astate</name><operator>-&gt;</operator><name>element_type</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>astate</name><operator>-&gt;</operator><name>dims</name></name></expr></argument>, <argument><expr><name><name>astate</name><operator>-&gt;</operator><name>ndims</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>ARR_LBOUND</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>astate</name><operator>-&gt;</operator><name>lbs</name></name></expr></argument>, <argument><expr><name><name>astate</name><operator>-&gt;</operator><name>ndims</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>astate</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>astate</name><operator>-&gt;</operator><name>nbytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>astate</name><operator>-&gt;</operator><name>nullbitmap</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>array_bitmap_copy</name><argument_list>(<argument><expr><call><name>ARR_NULLBITMAP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							  <argument><expr><name><name>astate</name><operator>-&gt;</operator><name>nullbitmap</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							  <argument><expr><name><name>astate</name><operator>-&gt;</operator><name>nitems</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clean up all the junk */</comment>
	<if_stmt><if>if <condition>(<expr><name>release</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>private_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>mcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * The following three functions provide essentially the same API as
 * initArrayResult/accumArrayResult/makeArrayResult, but can accept either
 * scalar or array inputs, invoking the appropriate set of functions above.
 */</comment>

<comment type="block">/*
 * initArrayResultAny - initialize an empty ArrayBuildStateAny
 *
 *	input_type is the input datatype (either element or array type)
 *	rcontext is where to keep working state
 *	subcontext is a flag determining whether to use a separate memory context
 */</comment>
<function><type><name>ArrayBuildStateAny</name> <modifier>*</modifier></type>
<name>initArrayResultAny</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>input_type</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>rcontext</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>subcontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayBuildStateAny</name> <modifier>*</modifier></type><name>astate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>element_type</name> <init>= <expr><call><name>get_element_type</name><argument_list>(<argument><expr><name>input_type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Array case */</comment>
		<decl_stmt><decl><type><name>ArrayBuildStateArr</name> <modifier>*</modifier></type><name>arraystate</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>arraystate</name> <operator>=</operator> <call><name>initArrayResultArr</name><argument_list>(<argument><expr><name>input_type</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>rcontext</name></expr></argument>, <argument><expr><name>subcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>astate</name> <operator>=</operator> <operator>(</operator><name>ArrayBuildStateAny</name> <operator>*</operator><operator>)</operator>
			<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>arraystate</name><operator>-&gt;</operator><name>mcontext</name></name></expr></argument>,
							   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ArrayBuildStateAny</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>scalarstate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>arraystate</name></name> <operator>=</operator> <name>arraystate</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Scalar case */</comment>
		<decl_stmt><decl><type><name>ArrayBuildState</name> <modifier>*</modifier></type><name>scalarstate</name></decl>;</decl_stmt>

		<comment type="block">/* Let's just check that we have a type that can be put into arrays */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>get_array_type</name><argument_list>(<argument><expr><name>input_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>scalarstate</name> <operator>=</operator> <call><name>initArrayResult</name><argument_list>(<argument><expr><name>input_type</name></expr></argument>, <argument><expr><name>rcontext</name></expr></argument>, <argument><expr><name>subcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>astate</name> <operator>=</operator> <operator>(</operator><name>ArrayBuildStateAny</name> <operator>*</operator><operator>)</operator>
			<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>scalarstate</name><operator>-&gt;</operator><name>mcontext</name></name></expr></argument>,
							   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ArrayBuildStateAny</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>scalarstate</name></name> <operator>=</operator> <name>scalarstate</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>arraystate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>astate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * accumArrayResultAny - accumulate one (more) input for an array result
 *
 *	astate is working state (can be NULL on first call)
 *	dvalue/disnull represent the new input to append to the array
 *	input_type is the input datatype (either element or array type)
 *	rcontext is where to keep working state
 */</comment>
<function><type><name>ArrayBuildStateAny</name> <modifier>*</modifier></type>
<name>accumArrayResultAny</name><parameter_list>(<parameter><decl><type><name>ArrayBuildStateAny</name> <modifier>*</modifier></type><name>astate</name></decl></parameter>,
					<parameter><decl><type><name>Datum</name></type> <name>dvalue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>disnull</name></decl></parameter>,
					<parameter><decl><type><name>Oid</name></type> <name>input_type</name></decl></parameter>,
					<parameter><decl><type><name>MemoryContext</name></type> <name>rcontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>astate</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>astate</name> <operator>=</operator> <call><name>initArrayResultAny</name><argument_list>(<argument><expr><name>input_type</name></expr></argument>, <argument><expr><name>rcontext</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>astate</name><operator>-&gt;</operator><name>scalarstate</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>accumArrayResult</name><argument_list>(<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>scalarstate</name></name></expr></argument>,
								<argument><expr><name>dvalue</name></expr></argument>, <argument><expr><name>disnull</name></expr></argument>,
								<argument><expr><name>input_type</name></expr></argument>, <argument><expr><name>rcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>accumArrayResultArr</name><argument_list>(<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>arraystate</name></name></expr></argument>,
								   <argument><expr><name>dvalue</name></expr></argument>, <argument><expr><name>disnull</name></expr></argument>,
								   <argument><expr><name>input_type</name></expr></argument>, <argument><expr><name>rcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>astate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * makeArrayResultAny - produce final result of accumArrayResultAny
 *
 *	astate is working state (must not be NULL)
 *	rcontext is where to construct result
 *	release is true if okay to release working state
 */</comment>
<function><type><name>Datum</name></type>
<name>makeArrayResultAny</name><parameter_list>(<parameter><decl><type><name>ArrayBuildStateAny</name> <modifier>*</modifier></type><name>astate</name></decl></parameter>,
				   <parameter><decl><type><name>MemoryContext</name></type> <name>rcontext</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>release</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>astate</name><operator>-&gt;</operator><name>scalarstate</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Must use makeMdArrayResult to support "release" parameter */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>ndims</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name><name>dims</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name><name>lbs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

		<comment type="block">/* If no elements were presented, we want to create an empty array */</comment>
		<expr_stmt><expr><name>ndims</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>astate</name><operator>-&gt;</operator><name>scalarstate</name><operator>-&gt;</operator><name>nelems</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dims</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>astate</name><operator>-&gt;</operator><name>scalarstate</name><operator>-&gt;</operator><name>nelems</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lbs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeMdArrayResult</name><argument_list>(<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>scalarstate</name></name></expr></argument>, <argument><expr><name>ndims</name></expr></argument>, <argument><expr><name>dims</name></expr></argument>, <argument><expr><name>lbs</name></expr></argument>,
								   <argument><expr><name>rcontext</name></expr></argument>, <argument><expr><name>release</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeArrayResultArr</name><argument_list>(<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>arraystate</name></name></expr></argument>,
									<argument><expr><name>rcontext</name></expr></argument>, <argument><expr><name>release</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>array_larger</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>array_cmp</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>array_smaller</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>array_cmp</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<typedef>typedef <type><struct>struct <name>generate_subscripts_fctx</name>
<block>{
	<decl_stmt><decl><type><name>int32</name></type>		<name>lower</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>upper</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>reverse</name></decl>;</decl_stmt>
}</block></struct></type> <name>generate_subscripts_fctx</name>;</typedef>

<comment type="block">/*
 * generate_subscripts(array anyarray, dim int [, reverse bool])
 *		Returns all subscripts of the array for any dimension
 */</comment>
<function><type><name>Datum</name></type>
<name>generate_subscripts</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>generate_subscripts_fctx</name> <modifier>*</modifier></type><name>fctx</name></decl>;</decl_stmt>

	<comment type="block">/* stuff done only on the first call of the function */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AnyArrayType</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>PG_GETARG_ANY_ARRAY_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>reqdim</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>lb</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>dimv</name></decl>;</decl_stmt>

		<comment type="block">/* create a function context for cross-call persistence */</comment>
		<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Sanity check: does it look like an array at all? */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>AARR_NDIM</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>AARR_NDIM</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>MAXDIM</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Sanity check: was the requested dim valid */</comment>
		<if_stmt><if>if <condition>(<expr><name>reqdim</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>reqdim</name> <operator>&gt;</operator> <call><name>AARR_NDIM</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * switch to memory context appropriate for multiple function calls
		 */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fctx</name> <operator>=</operator> <operator>(</operator><name>generate_subscripts_fctx</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>generate_subscripts_fctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>lb</name> <operator>=</operator> <call><name>AARR_LBOUND</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dimv</name> <operator>=</operator> <call><name>AARR_DIMS</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>lower</name></name> <operator>=</operator> <name><name>lb</name><index>[<expr><name>reqdim</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>upper</name></name> <operator>=</operator> <name><name>dimv</name><index>[<expr><name>reqdim</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>lb</name><index>[<expr><name>reqdim</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>reverse</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal><operator>)</operator></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <name>fctx</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fctx</name> <operator>=</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fctx</name><operator>-&gt;</operator><name>lower</name></name> <operator>&lt;=</operator> <name><name>fctx</name><operator>-&gt;</operator><name>upper</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fctx</name><operator>-&gt;</operator><name>reverse</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>fctx</name><operator>-&gt;</operator><name>lower</name></name><operator>++</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>fctx</name><operator>-&gt;</operator><name>upper</name></name><operator>--</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<comment type="block">/* done when there are no more elements left */</comment>
		<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * generate_subscripts_nodir
 *		Implements the 2-argument version of generate_subscripts
 */</comment>
<function><type><name>Datum</name></type>
<name>generate_subscripts_nodir</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* just call the other one -- it can handle both cases */</comment>
	<return>return <expr><call><name>generate_subscripts</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * array_fill_with_lower_bounds
 *		Create and fill array with defined lower bounds.
 */</comment>
<function><type><name>Datum</name></type>
<name>array_fill_with_lower_bounds</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>dims</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>lbs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>elmtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"dimension array or low bound array cannot be null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>dims</name> <operator>=</operator> <call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lbs</name> <operator>=</operator> <call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>elmtype</name> <operator>=</operator> <call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>elmtype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not determine data type of input"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>array_fill_internal</name><argument_list>(<argument><expr><name>dims</name></expr></argument>, <argument><expr><name>lbs</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>elmtype</name></expr></argument>, <argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * array_fill
 *		Create and fill array with default lower bounds.
 */</comment>
<function><type><name>Datum</name></type>
<name>array_fill</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>dims</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>elmtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"dimension array or low bound array cannot be null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>dims</name> <operator>=</operator> <call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>elmtype</name> <operator>=</operator> <call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>elmtype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not determine data type of input"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>array_fill_internal</name><argument_list>(<argument><expr><name>dims</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>elmtype</name></expr></argument>, <argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ArrayType</name> <modifier>*</modifier></type>
<name>create_array_envelope</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>ndims</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dimv</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>lbsv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nbytes</name></decl></parameter>,
					  <parameter><decl><type><name>Oid</name></type> <name>elmtype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dataoffset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>ArrayType</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>ndim</name></name> <operator>=</operator> <name>ndims</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dataoffset</name></name> <operator>=</operator> <name>dataoffset</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>elemtype</name></name> <operator>=</operator> <name>elmtype</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dimv</name></expr></argument>, <argument><expr><name>ndims</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>ARR_LBOUND</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lbsv</name></expr></argument>, <argument><expr><name>ndims</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ArrayType</name> <modifier>*</modifier></type>
<name>array_fill_internal</name><parameter_list>(<parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>dims</name></decl></parameter>, <parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>lbs</name></decl></parameter>,
					<parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>elmtype</name></decl></parameter>,
					<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>dimv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>lbsv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndims</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nitems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>deflbs</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>elmlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>elmbyval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>elmalign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayMetaState</name> <modifier>*</modifier></type><name>my_extra</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Params checks
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>dims</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"wrong number of array subscripts"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Dimension array must be one dimensional."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>array_contains_nulls</name><argument_list>(<argument><expr><name>dims</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"dimension values cannot be null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>dimv</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>dims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ndims</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>dims</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>dims</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ndims</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>				<comment type="block">/* we do allow zero-dimension arrays */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid number of dimensions: %d"</literal></expr></argument>, <argument><expr><name>ndims</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>ndims</name> <operator>&gt;</operator> <name>MAXDIM</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of array dimensions (%d) exceeds the maximum allowed (%d)"</literal></expr></argument>,
						<argument><expr><name>ndims</name></expr></argument>, <argument><expr><name>MAXDIM</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>lbs</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>lbs</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"wrong number of array subscripts"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Dimension array must be one dimensional."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>array_contains_nulls</name><argument_list>(<argument><expr><name>lbs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"dimension values cannot be null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>ndims</name> <operator>!=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>lbs</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>lbs</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"wrong number of array subscripts"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Low bound array has different size than dimensions array."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>lbsv</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>lbs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAXDIM</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>deflbs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>

		<expr_stmt><expr><name>lbsv</name> <operator>=</operator> <name>deflbs</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* This checks for overflow of the array dimensions */</comment>
	<expr_stmt><expr><name>nitems</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><name>ndims</name></expr></argument>, <argument><expr><name>dimv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ArrayCheckBounds</name><argument_list>(<argument><expr><name>ndims</name></expr></argument>, <argument><expr><name>dimv</name></expr></argument>, <argument><expr><name>lbsv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* fast track for empty array */</comment>
	<if_stmt><if>if <condition>(<expr><name>nitems</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>construct_empty_array</name><argument_list>(<argument><expr><name>elmtype</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We arrange to look up info about element type only once per series of
	 * calls, assuming the element type doesn't change underneath us.
	 */</comment>
	<expr_stmt><expr><name>my_extra</name> <operator>=</operator> <operator>(</operator><name>ArrayMetaState</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>my_extra</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>,
													  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ArrayMetaState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>my_extra</name> <operator>=</operator> <operator>(</operator><name>ArrayMetaState</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>my_extra</name><operator>-&gt;</operator><name>element_type</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>my_extra</name><operator>-&gt;</operator><name>element_type</name></name> <operator>!=</operator> <name>elmtype</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Get info about element type */</comment>
		<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><name>elmtype</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>typalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>my_extra</name><operator>-&gt;</operator><name>element_type</name></name> <operator>=</operator> <name>elmtype</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>elmlen</name> <operator>=</operator> <name><name>my_extra</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>elmbyval</name> <operator>=</operator> <name><name>my_extra</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>elmalign</name> <operator>=</operator> <name><name>my_extra</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>

	<comment type="block">/* compute required space */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nbytes</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>totbytes</name></decl>;</decl_stmt>

		<comment type="block">/* make sure data is not toasted */</comment>
		<if_stmt><if>if <condition>(<expr><name>elmlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>att_addlength_datum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>elmlen</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>elmalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nbytes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>totbytes</name> <operator>=</operator> <name>nbytes</name> <operator>*</operator> <name>nitems</name></expr>;</expr_stmt>

		<comment type="block">/* check for overflow of multiplication or total request */</comment>
		<if_stmt><if>if <condition>(<expr><name>totbytes</name> <operator>/</operator> <name>nbytes</name> <operator>!=</operator> <name>nitems</name> <operator>||</operator>
			<operator>!</operator><call><name>AllocSizeIsValid</name><argument_list>(<argument><expr><name>totbytes</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"array size exceeds the maximum allowed (%d)"</literal></expr></argument>,
							<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>MaxAllocSize</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * This addition can't overflow, but it might cause us to go past
		 * MaxAllocSize.  We leave it to palloc to complain in that case.
		 */</comment>
		<expr_stmt><expr><name>totbytes</name> <operator>+=</operator> <call><name>ARR_OVERHEAD_NONULLS</name><argument_list>(<argument><expr><name>ndims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>create_array_envelope</name><argument_list>(<argument><expr><name>ndims</name></expr></argument>, <argument><expr><name>dimv</name></expr></argument>, <argument><expr><name>lbsv</name></expr></argument>, <argument><expr><name>totbytes</name></expr></argument>,
									   <argument><expr><name>elmtype</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>ArrayCastAndSet</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>elmlen</name></expr></argument>, <argument><expr><name>elmbyval</name></expr></argument>, <argument><expr><name>elmalign</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>nbytes</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>dataoffset</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dataoffset</name> <operator>=</operator> <call><name>ARR_OVERHEAD_WITHNULLS</name><argument_list>(<argument><expr><name>ndims</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <name>dataoffset</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>create_array_envelope</name><argument_list>(<argument><expr><name>ndims</name></expr></argument>, <argument><expr><name>dimv</name></expr></argument>, <argument><expr><name>lbsv</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>,
									   <argument><expr><name>elmtype</name></expr></argument>, <argument><expr><name>dataoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* create_array_envelope already zeroed the bitmap, so we're done */</comment>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * UNNEST
 */</comment>
<function><type><name>Datum</name></type>
<name>array_unnest</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<typedef>typedef <type><struct>struct
	<block>{
		<decl_stmt><decl><type><name>array_iter</name></type>	<name>iter</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nextelem</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>numelems</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type>		<name>elmlen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>elmbyval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>elmalign</name></decl>;</decl_stmt>
	}</block></struct></type> <name>array_unnest_fctx</name>;</typedef>

	<decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>array_unnest_fctx</name> <modifier>*</modifier></type><name>fctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* stuff done only on the first call of the function */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AnyArrayType</name> <modifier>*</modifier></type><name>arr</name></decl>;</decl_stmt>

		<comment type="block">/* create a function context for cross-call persistence */</comment>
		<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * switch to memory context appropriate for multiple function calls
		 */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Get the array value and detoast if needed.  We can't do this
		 * earlier because if we have to detoast, we want the detoasted copy
		 * to be in multi_call_memory_ctx, so it will go away when we're done
		 * and not before.  (If no detoast happens, we assume the originally
		 * passed array will stick around till then.)
		 */</comment>
		<expr_stmt><expr><name>arr</name> <operator>=</operator> <call><name>PG_GETARG_ANY_ARRAY_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* allocate memory for user context */</comment>
		<expr_stmt><expr><name>fctx</name> <operator>=</operator> <operator>(</operator><name>array_unnest_fctx</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>array_unnest_fctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* initialize state */</comment>
		<expr_stmt><expr><call><name>array_iter_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fctx</name><operator>-&gt;</operator><name>iter</name></name></expr></argument>, <argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>nextelem</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>numelems</name></name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><call><name>AARR_NDIM</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>AARR_DIMS</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXPANDED_HEADER</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* we can just grab the type data from expanded array */</comment>
			<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>elmlen</name></name> <operator>=</operator> <name><name>arr</name><operator>-&gt;</operator><name>xpn</name><operator>.</operator><name>typlen</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>elmbyval</name></name> <operator>=</operator> <name><name>arr</name><operator>-&gt;</operator><name>xpn</name><operator>.</operator><name>typbyval</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>elmalign</name></name> <operator>=</operator> <name><name>arr</name><operator>-&gt;</operator><name>xpn</name><operator>.</operator><name>typalign</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><call><name>AARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>fctx</name><operator>-&gt;</operator><name>elmlen</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>fctx</name><operator>-&gt;</operator><name>elmbyval</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>fctx</name><operator>-&gt;</operator><name>elmalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <name>fctx</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* stuff done on every call of the function */</comment>
	<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fctx</name> <operator>=</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fctx</name><operator>-&gt;</operator><name>nextelem</name></name> <operator>&lt;</operator> <name><name>fctx</name><operator>-&gt;</operator><name>numelems</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>offset</name> <init>= <expr><name><name>fctx</name><operator>-&gt;</operator><name>nextelem</name></name><operator>++</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>elem</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>elem</name> <operator>=</operator> <call><name>array_iter_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fctx</name><operator>-&gt;</operator><name>iter</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>,
							   <argument><expr><name><name>fctx</name><operator>-&gt;</operator><name>elmlen</name></name></expr></argument>, <argument><expr><name><name>fctx</name><operator>-&gt;</operator><name>elmbyval</name></name></expr></argument>, <argument><expr><name><name>fctx</name><operator>-&gt;</operator><name>elmalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* do when there is no more left */</comment>
		<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * array_replace/array_remove support
 *
 * Find all array entries matching (not distinct from) search/search_isnull,
 * and delete them if remove is true, else replace them with
 * replace/replace_isnull.  Comparisons are done using the specified
 * collation.  fcinfo is passed only for caching purposes.
 */</comment>
<function><type><specifier>static</specifier> <name>ArrayType</name> <modifier>*</modifier></type>
<name>array_replace_internal</name><parameter_list>(<parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>array</name></decl></parameter>,
					   <parameter><decl><type><name>Datum</name></type> <name>search</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>search_isnull</name></decl></parameter>,
					   <parameter><decl><type><name>Datum</name></type> <name>replace</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>replace_isnull</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>remove</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>,
					   <parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>element_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>dim</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndim</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nitems</name></decl>,
				<decl><type ref="prev"/><name>nresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>nbytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>dataoffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasnulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>typlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typbyval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>typalign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>arraydataptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bits8</name>	   <modifier>*</modifier></type><name>bitmap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bitmask</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>changed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FunctionCallInfoData</name></type> <name>locfcinfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>element_type</name> <operator>=</operator> <call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ndim</name> <operator>=</operator> <call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dim</name> <operator>=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nitems</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Return input array unmodified if it is empty */</comment>
	<if_stmt><if>if <condition>(<expr><name>nitems</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>array</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We can't remove elements from multi-dimensional arrays, since the
	 * result might not be rectangular.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>remove</name> <operator>&amp;&amp;</operator> <name>ndim</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"removing elements from multidimensional arrays is not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We arrange to look up the equality function only once per series of
	 * calls, assuming the element type doesn't change underneath us.
	 */</comment>
	<expr_stmt><expr><name>typentry</name> <operator>=</operator> <operator>(</operator><name>TypeCacheEntry</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>typentry</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<name><name>typentry</name><operator>-&gt;</operator><name>type_id</name></name> <operator>!=</operator> <name>element_type</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>,
									 <argument><expr><name>TYPECACHE_EQ_OPR_FINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>eq_opr_finfo</name><operator>.</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not identify an equality operator for type %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>typentry</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>typlen</name> <operator>=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>typbyval</name> <operator>=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>typalign</name> <operator>=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Detoast values if they are toasted.  The replacement value must be
	 * detoasted for insertion into the result array, while detoasting the
	 * search value only once saves cycles.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>typlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>search_isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>search</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name>search</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>replace_isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>replace</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Prepare to apply the comparison operator */</comment>
	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><name>locfcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>typentry</name><operator>-&gt;</operator><name>eq_opr_finfo</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
							 <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allocate temporary arrays for new values */</comment>
	<expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nitems</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nulls</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nitems</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Loop over source data */</comment>
	<expr_stmt><expr><name>arraydataptr</name> <operator>=</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bitmap</name> <operator>=</operator> <call><name>ARR_NULLBITMAP</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bitmask</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>hasnulls</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nresult</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>elt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>oprresult</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>skip</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Get source element, checking for NULL */</comment>
		<if_stmt><if>if <condition>(<expr><name>bitmap</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>bitmap</name> <operator>&amp;</operator> <name>bitmask</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>isNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<comment type="block">/* If searching for NULL, we have a match */</comment>
			<if_stmt><if>if <condition>(<expr><name>search_isnull</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>remove</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>skip</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><operator>!</operator><name>replace_isnull</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>values</name><index>[<expr><name>nresult</name></expr>]</index></name> <operator>=</operator> <name>replace</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>isNull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>isNull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>elt</name> <operator>=</operator> <call><name>fetch_att</name><argument_list>(<argument><expr><name>arraydataptr</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>arraydataptr</name> <operator>=</operator> <call><name>att_addlength_datum</name><argument_list>(<argument><expr><name>arraydataptr</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>arraydataptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>arraydataptr</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>search_isnull</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* no match possible, keep element */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>nresult</name></expr>]</index></name> <operator>=</operator> <name>elt</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Apply the operator to the element pair
				 */</comment>
				<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>elt</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>search</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>argnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>oprresult</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><operator>&amp;</operator><name>locfcinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>oprresult</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* no match, keep element */</comment>
					<expr_stmt><expr><name><name>values</name><index>[<expr><name>nresult</name></expr>]</index></name> <operator>=</operator> <name>elt</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* match, so replace or delete */</comment>
					<expr_stmt><expr><name>changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>remove</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>skip</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name><name>values</name><index>[<expr><name>nresult</name></expr>]</index></name> <operator>=</operator> <name>replace</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>isNull</name> <operator>=</operator> <name>replace_isnull</name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>skip</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>nresult</name></expr>]</index></name> <operator>=</operator> <name>isNull</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>hasnulls</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Update total result size */</comment>
				<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>att_addlength_datum</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>nresult</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* check for overflow of total request */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AllocSizeIsValid</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"array size exceeds the maximum allowed (%d)"</literal></expr></argument>,
									<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>MaxAllocSize</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><name>nresult</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* advance bitmap pointer if any */</comment>
		<if_stmt><if>if <condition>(<expr><name>bitmap</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>bitmask</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>bitmask</name> <operator>==</operator> <literal type="number">0x100</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>bitmap</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>bitmask</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If not changed just return the original array
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>changed</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>array</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If all elements were removed return an empty array */</comment>
	<if_stmt><if>if <condition>(<expr><name>nresult</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>construct_empty_array</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Allocate and initialize the result array */</comment>
	<if_stmt><if>if <condition>(<expr><name>hasnulls</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>dataoffset</name> <operator>=</operator> <call><name>ARR_OVERHEAD_WITHNULLS</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>nresult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nbytes</name> <operator>+=</operator> <name>dataoffset</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>dataoffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* marker for no null bitmap */</comment>
		<expr_stmt><expr><name>nbytes</name> <operator>+=</operator> <call><name>ARR_OVERHEAD_NONULLS</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>ArrayType</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>ndim</name></name> <operator>=</operator> <name>ndim</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dataoffset</name></name> <operator>=</operator> <name>dataoffset</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>elemtype</name></name> <operator>=</operator> <name>element_type</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ndim</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>ARR_LBOUND</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ARR_LBOUND</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ndim</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>remove</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Adjust the result length */</comment>
		<expr_stmt><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <name>nresult</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Insert data into result array */</comment>
	<expr_stmt><expr><call><name>CopyArrayEls</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
				 <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>nresult</name></expr></argument>,
				 <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>,
				 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Remove any occurrences of an element from an array
 *
 * If used on a multi-dimensional array this will raise an error.
 */</comment>
<function><type><name>Datum</name></type>
<name>array_remove</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>array</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>search</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>search_isnull</name> <init>= <expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>array</name> <operator>=</operator> <call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>array</name> <operator>=</operator> <call><name>array_replace_internal</name><argument_list>(<argument><expr><name>array</name></expr></argument>,
								   <argument><expr><name>search</name></expr></argument>, <argument><expr><name>search_isnull</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								   <argument><expr><name>true</name></expr></argument>, <argument><expr><call><name>PG_GET_COLLATION</name><argument_list>()</argument_list></call></expr></argument>,
								   <argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Replace any occurrences of an element in an array
 */</comment>
<function><type><name>Datum</name></type>
<name>array_replace</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>array</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>search</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>search_isnull</name> <init>= <expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>replace</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>replace_isnull</name> <init>= <expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>array</name> <operator>=</operator> <call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>array</name> <operator>=</operator> <call><name>array_replace_internal</name><argument_list>(<argument><expr><name>array</name></expr></argument>,
								   <argument><expr><name>search</name></expr></argument>, <argument><expr><name>search_isnull</name></expr></argument>,
								   <argument><expr><name>replace</name></expr></argument>, <argument><expr><name>replace_isnull</name></expr></argument>,
								   <argument><expr><name>false</name></expr></argument>, <argument><expr><call><name>PG_GET_COLLATION</name><argument_list>()</argument_list></call></expr></argument>,
								   <argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Implements width_bucket(anyelement, anyarray).
 *
 * 'thresholds' is an array containing lower bound values for each bucket;
 * these must be sorted from smallest to largest, or bogus results will be
 * produced.  If N thresholds are supplied, the output is from 0 to N:
 * 0 is for inputs &lt; first threshold, N is for inputs &gt;= last threshold.
 */</comment>
<function><type><name>Datum</name></type>
<name>width_bucket_array</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>operand</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>thresholds</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>collation</name> <init>= <expr><call><name>PG_GET_COLLATION</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>element_type</name> <init>= <expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>thresholds</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Check input */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>thresholds</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"thresholds must be one-dimensional array"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>array_contains_nulls</name><argument_list>(<argument><expr><name>thresholds</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"thresholds array must not contain NULLs"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* We have a dedicated implementation for float8 data */</comment>
	<if_stmt><if>if <condition>(<expr><name>element_type</name> <operator>==</operator> <name>FLOAT8OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>width_bucket_array_float8</name><argument_list>(<argument><expr><name>operand</name></expr></argument>, <argument><expr><name>thresholds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>

		<comment type="block">/* Cache information about the input type */</comment>
		<expr_stmt><expr><name>typentry</name> <operator>=</operator> <operator>(</operator><name>TypeCacheEntry</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>typentry</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			<name><name>typentry</name><operator>-&gt;</operator><name>type_id</name></name> <operator>!=</operator> <name>element_type</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>,
										 <argument><expr><name>TYPECACHE_CMP_PROC_FINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>cmp_proc_finfo</name><operator>.</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not identify a comparison function for type %s"</literal></expr></argument>,
								<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>typentry</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We have separate implementation paths for fixed- and variable-width
		 * types, since indexing the array is a lot cheaper in the first case.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>typlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>width_bucket_array_fixed</name><argument_list>(<argument><expr><name>operand</name></expr></argument>, <argument><expr><name>thresholds</name></expr></argument>,
											  <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>width_bucket_array_variable</name><argument_list>(<argument><expr><name>operand</name></expr></argument>, <argument><expr><name>thresholds</name></expr></argument>,
												 <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Avoid leaking memory when handed toasted input. */</comment>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>thresholds</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * width_bucket_array for float8 data.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>width_bucket_array_float8</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>operand</name></decl></parameter>, <parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>thresholds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>op</name> <init>= <expr><call><name>DatumGetFloat8</name><argument_list>(<argument><expr><name>operand</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name>	   <modifier>*</modifier></type><name>thresholds_data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>left</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>right</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Since we know the array contains no NULLs, we can just index it
	 * directly.
	 */</comment>
	<expr_stmt><expr><name>thresholds_data</name> <operator>=</operator> <operator>(</operator><name>float8</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>thresholds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>left</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>right</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>thresholds</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>thresholds</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the probe value is a NaN, it's greater than or equal to all possible
	 * threshold values (including other NaNs), so we need not search.  Note
	 * that this would give the same result as searching even if the array
	 * contains multiple NaNs (as long as they're correctly sorted), since the
	 * loop logic will find the rightmost of multiple equal threshold values.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>right</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Find the bucket */</comment>
	<while>while <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>mid</name> <init>= <expr><operator>(</operator><name>left</name> <operator>+</operator> <name>right</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name><name>thresholds_data</name><index>[<expr><name>mid</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <name>op</name> <operator>&lt;</operator> <name><name>thresholds_data</name><index>[<expr><name>mid</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>right</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>left</name> <operator>=</operator> <name>mid</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>left</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * width_bucket_array for generic fixed-width data types.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>width_bucket_array_fixed</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>operand</name></decl></parameter>,
						 <parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>thresholds</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>,
						 <parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>thresholds_data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>typlen</name> <init>= <expr><name><name>typentry</name><operator>-&gt;</operator><name>typlen</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typbyval</name> <init>= <expr><name><name>typentry</name><operator>-&gt;</operator><name>typbyval</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FunctionCallInfoData</name></type> <name>locfcinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>left</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>right</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Since we know the array contains no NULLs, we can just index it
	 * directly.
	 */</comment>
	<expr_stmt><expr><name>thresholds_data</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>thresholds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><name>locfcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>typentry</name><operator>-&gt;</operator><name>cmp_proc_finfo</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
							 <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Find the bucket */</comment>
	<expr_stmt><expr><name>left</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>right</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>thresholds</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>thresholds</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>mid</name> <init>= <expr><operator>(</operator><name>left</name> <operator>+</operator> <name>right</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>cmpresult</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>thresholds_data</name> <operator>+</operator> <name>mid</name> <operator>*</operator> <name>typlen</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>operand</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>fetch_att</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>argnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>cmpresult</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><operator>&amp;</operator><name>locfcinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>cmpresult</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>right</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>left</name> <operator>=</operator> <name>mid</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>left</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * width_bucket_array for generic variable-width data types.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>width_bucket_array_variable</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>operand</name></decl></parameter>,
							<parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>thresholds</name></decl></parameter>,
							<parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>,
							<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>thresholds_data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>typlen</name> <init>= <expr><name><name>typentry</name><operator>-&gt;</operator><name>typlen</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typbyval</name> <init>= <expr><name><name>typentry</name><operator>-&gt;</operator><name>typbyval</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>typalign</name> <init>= <expr><name><name>typentry</name><operator>-&gt;</operator><name>typalign</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FunctionCallInfoData</name></type> <name>locfcinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>left</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>right</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>thresholds_data</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>thresholds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><name>locfcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>typentry</name><operator>-&gt;</operator><name>cmp_proc_finfo</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
							 <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Find the bucket */</comment>
	<expr_stmt><expr><name>left</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>right</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>thresholds</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>thresholds</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>mid</name> <init>= <expr><operator>(</operator><name>left</name> <operator>+</operator> <name>right</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>cmpresult</name></decl>;</decl_stmt>

		<comment type="block">/* Locate mid'th array element by advancing from left element */</comment>
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>thresholds_data</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>left</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>mid</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>att_addlength_pointer</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>operand</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>fetch_att</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>argnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>locfcinfo</name><operator>.</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>cmpresult</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><operator>&amp;</operator><name>locfcinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>cmpresult</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>right</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>left</name> <operator>=</operator> <name>mid</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

			<comment type="block">/*
			 * Move the thresholds pointer to match new "left" index, so we
			 * don't have to seek over those elements again.  This trick
			 * ensures we do only O(N) array indexing work, not O(N^2).
			 */</comment>
			<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>att_addlength_pointer</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>thresholds_data</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>left</name></expr>;</return>
</block_content>}</block></function>
</unit>
