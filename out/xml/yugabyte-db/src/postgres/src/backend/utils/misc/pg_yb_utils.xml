<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/utils/misc/pg_yb_utils.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pg_yb_utils.c
 *	  Utilities for YugaByte/PostgreSQL integration that have to be defined on
 *	  the PostgreSQL side.
 *
 * Copyright (c) YugaByte, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * IDENTIFICATION
 *	  src/backend/utils/misc/pg_yb_utils.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_yb_utils.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;inttypes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"c.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupdesc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/ybcExpr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_amproc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_attrdef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_auth_members.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_cast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_database.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_db_role_setting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opclass.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_partitioned_table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_policy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_rewrite.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_yb_catalog_version.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/yb_catalog_version.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/yb_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/variable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/pg_yb_common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_locale.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/spccache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"yb/common/ybc_util.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"yb/yql/pggate/ybc_pggate.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__linux__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/prctl.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>uint64_t</name></type> <name>yb_catalog_cache_version</name> <init>= <expr><name>YB_CATCACHE_VERSION_UNINITIALIZED</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint64_t</name></type> <name>yb_last_known_catalog_cache_version</name> <init>=
	<expr><name>YB_CATCACHE_VERSION_UNINITIALIZED</name></expr></init></decl>;</decl_stmt>

<function><type><name>uint64_t</name></type> <name>YBGetActiveCatalogCacheVersion</name><parameter_list>()</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>yb_catalog_version_type</name> <operator>==</operator> <name>CATALOG_VERSION_CATALOG_TABLE</name> <operator>&amp;&amp;</operator>
	    <call><name>YBGetDdlNestingLevel</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>yb_catalog_cache_version</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>yb_catalog_cache_version</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint64_t</name></type>
<name>YbGetCatalogCacheVersion</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<return>return <expr><name>yb_catalog_cache_version</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint64_t</name></type>
<name>YbGetLastKnownCatalogCacheVersion</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>shared_catalog_version</name> <init>= <expr><call><name>YbGetSharedCatalogVersion</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><ternary><condition><expr><name>shared_catalog_version</name> <operator>&gt;</operator> <name>yb_last_known_catalog_cache_version</name></expr> ?</condition><then>
		<expr><name>shared_catalog_version</name></expr> </then><else>: <expr><name>yb_last_known_catalog_cache_version</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint64_t</name></type>
<name>YbGetCatalogCacheVersionForTablePrefetching</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<comment type="line">// TODO: In future YBGetLastKnownCatalogCacheVersion must be used instead of</comment>
	<comment type="line">//       YbGetMasterCatalogVersion to reduce numer of RPCs to a master.</comment>
	<comment type="line">//       But this requires some additional changes. This optimization will</comment>
	<comment type="line">//       be done separately.</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><call><name>YBCGetGFlags</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>ysql_enable_read_request_caching</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>YB_CATCACHE_VERSION_UNINITIALIZED</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>YBCPgResetCatalogReadTime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>YbGetMasterCatalogVersion</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>YbUpdateCatalogCacheVersion</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>catalog_cache_version</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>yb_catalog_cache_version</name> <operator>=</operator> <name>catalog_cache_version</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>YbUpdateLastKnownCatalogCacheVersion</name><argument_list>(<argument><expr><name>yb_catalog_cache_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><call><name>YBCGetGFlags</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>log_ysql_catalog_versions</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
		        <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set local catalog version: %"</literal> <name>PRIu64</name></expr></argument>,
		                <argument><expr><name>yb_catalog_cache_version</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>
<name>YbUpdateLastKnownCatalogCacheVersion</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>catalog_cache_version</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>yb_last_known_catalog_cache_version</name> <operator>&lt;</operator> <name>catalog_cache_version</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>yb_last_known_catalog_cache_version</name>	<operator>=</operator> <name>catalog_cache_version</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>YbResetCatalogCacheVersion</name><parameter_list>()</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name>yb_catalog_cache_version</name> <operator>=</operator> <name>YB_CATCACHE_VERSION_UNINITIALIZED</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** These values are lazily initialized based on corresponding environment variables. */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>ybc_pg_double_write</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ybc_disable_pg_locking</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Forward declarations */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>YBCInstallTxnDdlHook</name><parameter_list>()</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>bool</name></type> <name>yb_read_from_followers</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>yb_follower_read_staleness_ms</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<function><type><name>bool</name></type>
<name>IsYugaByteEnabled</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<comment type="block">/* We do not support Init/Bootstrap processing modes yet. */</comment>
	<return>return <expr><call><name>YBCPgIsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>CheckIsYBSupportedRelation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name>relkind</name> <init>= <expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>CheckIsYBSupportedRelationByKind</name><argument_list>(<argument><expr><name>relkind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>CheckIsYBSupportedRelationByKind</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>relkind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator> <name>relkind</name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
		  <name>relkind</name> <operator>==</operator> <name>RELKIND_VIEW</name> <operator>||</operator> <name>relkind</name> <operator>==</operator> <name>RELKIND_SEQUENCE</name> <operator>||</operator>
		  <name>relkind</name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name> <operator>||</operator> <name>relkind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>||</operator>
		  <name>relkind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name> <operator>||</operator> <name>relkind</name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>||</operator>
		  <name>relkind</name> <operator>==</operator> <name>RELKIND_MATVIEW</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"This feature is not supported in YugaByte."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>IsYBRelation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * NULL relation is possible if regular ForeignScan is confused for
	 * Yugabyte sequential scan, which is backed by ForeignScan, too.
	 * Rather than performing probably not trivial and unreliable checks by
	 * the caller to distinguish them, we allow NULL argument here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><name>relation</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name>relkind</name> <init>= <expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CheckIsYBSupportedRelationByKind</name><argument_list>(<argument><expr><name>relkind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Currently only support regular tables and indexes.
	 * Temp tables and views are supported, but they are not YB relations. */</comment>
	<return>return <expr><operator>(</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator> <name>relkind</name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator> <name>relkind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>||</operator>
			<name>relkind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name> <operator>||</operator> <name>relkind</name> <operator>==</operator> <name>RELKIND_MATVIEW</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>!=</operator> <name>RELPERSISTENCE_TEMP</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>IsYBRelationById</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name>     <init>= <expr><call><name>RelationIdGetRelation</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>     <name>is_supported</name> <init>= <expr><call><name>IsYBRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>is_supported</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>IsYBBackedRelation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>IsYBRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>(</operator><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name> <operator>&amp;&amp;</operator>
		<name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>!=</operator> <name>RELPERSISTENCE_TEMP</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>YbIsTempRelation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>IsRealYBColumn</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attrNum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>attrNum</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>attrNum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attisdropped</name><operator>)</operator> <operator>||</operator>
	       <operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name> <operator>&amp;&amp;</operator> <name>attrNum</name> <operator>==</operator> <name>ObjectIdAttributeNumber</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>IsYBSystemColumn</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>attrNum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>attrNum</name> <operator>==</operator> <name>YBRowIdAttributeNumber</name> <operator>||</operator>
			<name>attrNum</name> <operator>==</operator> <name>YBIdxBaseTupleIdAttributeNumber</name> <operator>||</operator>
			<name>attrNum</name> <operator>==</operator> <name>YBUniqueIdxKeySuffixAttributeNumber</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>YBNeedRetryAfterCacheRefresh</name><parameter_list>(<parameter><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// TODO Inspect error code to distinguish retryable errors.</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>AttrNumber</name></type> <name>YBGetFirstLowInvalidAttributeNumber</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><ternary><condition><expr><call><name>IsYBRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>
	       ?</condition><then> <expr><name>YBFirstLowInvalidAttributeNumber</name></expr>
	       </then><else>: <expr><name>FirstLowInvalidHeapAttributeNumber</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>AttrNumber</name></type> <name>YBGetFirstLowInvalidAttributeNumberFromOid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>   <name>relation</name> <init>= <expr><call><name>RelationIdGetRelation</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>attr_num</name> <init>= <expr><call><name>YBGetFirstLowInvalidAttributeNumber</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>attr_num</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>YBAttnumToBmsIndex</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>attnum</name> <operator>-</operator> <call><name>YBGetFirstLowInvalidAttributeNumber</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>AttrNumber</name></type> <name>YBBmsIndexToAttnum</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>idx</name> <operator>+</operator> <call><name>YBGetFirstLowInvalidAttributeNumber</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get primary key columns as bitmap of a table,
 * subtracting minattr from attributes.
 */</comment>
<function><type><specifier>static</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>GetTablePrimaryKeyBms</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
                                        <parameter><decl><type><name>AttrNumber</name></type> <name>minattr</name></decl></parameter>,
                                        <parameter><decl><type><name>bool</name></type> <name>includeYBSystemColumns</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>            <name>dboid</name>         <init>= <expr><call><name>YBCGetDatabaseOid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>            <name>natts</name>         <init>= <expr><call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>      <modifier>*</modifier></type><name>pkey</name>         <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YBCPgTableDesc</name></type> <name>ybc_tabledesc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Get the primary key columns 'pkey' from YugaByte. */</comment>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgGetTableDesc</name><argument_list>(<argument><expr><name>dboid</name></expr></argument>, <argument><expr><call><name>YbGetStorageRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>ybc_tabledesc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>AttrNumber</name></type> <name>attnum</name> <init>= <expr><name>minattr</name></expr></init></decl>;</init> <condition><expr><name>attnum</name> <operator>&lt;=</operator> <name>natts</name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name>includeYBSystemColumns</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsRealYBColumn</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
			<operator>(</operator><operator>!</operator><call><name>IsRealYBColumn</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsYBSystemColumn</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>YBCPgColumnInfo</name></type> <name>column_info</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>HandleYBTableDescStatus</name><argument_list>(<argument><expr><call><name>YBCPgGetColumnInfo</name><argument_list>(<argument><expr><name>ybc_tabledesc</name></expr></argument>,
		                                           <argument><expr><name>attnum</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>column_info</name></expr></argument>)</argument_list></call></expr></argument>,
		                        <argument><expr><name>ybc_tabledesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>column_info</name><operator>.</operator><name>is_hash</name></name> <operator>||</operator> <name><name>column_info</name><operator>.</operator><name>is_primary</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>pkey</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>pkey</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <name>minattr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>pkey</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Bitmapset</name> <modifier>*</modifier></type><name>YBGetTablePrimaryKeyBms</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>GetTablePrimaryKeyBms</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
	                             <argument><expr><call><name>YBGetFirstLowInvalidAttributeNumber</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument> <comment type="block">/* minattr */</comment>,
	                             <argument><expr><name>false</name></expr></argument> <comment type="block">/* includeYBSystemColumns */</comment>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Bitmapset</name> <modifier>*</modifier></type><name>YBGetTableFullPrimaryKeyBms</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>GetTablePrimaryKeyBms</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
	                             <argument><expr><name>YBSystemFirstLowInvalidAttributeNumber</name> <operator>+</operator> <literal type="number">1</literal></expr></argument> <comment type="block">/* minattr */</comment>,
	                             <argument><expr><name>true</name></expr></argument> <comment type="block">/* includeYBSystemColumns */</comment>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>bool</name></type> <name>YBRelHasOldRowTriggers</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>CmdType</name></type> <name>operation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigdesc</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>trigdesc</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>trigdesc</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>operation</name> <operator>==</operator> <name>CMD_DELETE</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name><name>trigdesc</name><operator>-&gt;</operator><name>trig_delete_after_row</name></name> <operator>||</operator>
			   <name><name>trigdesc</name><operator>-&gt;</operator><name>trig_delete_before_row</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>operation</name> <operator>!=</operator> <name>CMD_UPDATE</name></expr>)</condition>
	<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name><name>trigdesc</name><operator>-&gt;</operator><name>trig_update_after_row</name></name> <operator>||</operator>
			   <name><name>trigdesc</name><operator>-&gt;</operator><name>trig_update_before_row</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/*
	 * This is an update operation. We look for both update and delete triggers
	 * as update on partitioned tables can result in deletes as well.
	 */</comment>
	<return>return <expr><name><name>trigdesc</name><operator>-&gt;</operator><name>trig_update_after_row</name></name> <operator>||</operator>
		 <name><name>trigdesc</name><operator>-&gt;</operator><name>trig_update_before_row</name></name> <operator>||</operator>
		 <name><name>trigdesc</name><operator>-&gt;</operator><name>trig_delete_after_row</name></name> <operator>||</operator>
		 <name><name>trigdesc</name><operator>-&gt;</operator><name>trig_delete_before_row</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>YbIsDatabaseColocated</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>dbid</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>legacy_colocated_database</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>colocated</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgIsDatabaseColocated</name><argument_list>(<argument><expr><name>dbid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>colocated</name></expr></argument>,
											<argument><expr><name>legacy_colocated_database</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>colocated</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>YBRelHasSecondaryIndices</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasindex</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type>	 <name>has_indices</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	 <modifier>*</modifier></type><name>indexlist</name> <init>= <expr><call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>indexlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_pkindex</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>has_indices</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<break>break;</break>
	</block_content>}</block>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>indexlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>has_indices</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>YBTransactionsEnabled</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>cached_value</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>cached_value</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>cached_value</name> <operator>=</operator> <call><name>YBCIsEnvVarTrueWithDefault</name><argument_list>(<argument><expr><literal type="string">"YB_PG_TRANSACTIONS_ENABLED"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>cached_value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>IsYBReadCommitted</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>cached_value</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>cached_value</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>cached_value</name> <operator>=</operator> <call><name>YBCIsEnvVarTrueWithDefault</name><argument_list>(<argument><expr><literal type="string">"FLAGS_yb_enable_read_committed_isolation"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>cached_value</name> <operator>&amp;&amp;</operator>
				 <operator>(</operator><name>XactIsoLevel</name> <operator>==</operator> <name>XACT_READ_COMMITTED</name> <operator>||</operator> <name>XactIsoLevel</name> <operator>==</operator> <name>XACT_READ_UNCOMMITTED</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>YBIsWaitQueueEnabled</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>cached_value</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>cached_value</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>cached_value</name> <operator>=</operator> <call><name>YBCIsEnvVarTrueWithDefault</name><argument_list>(<argument><expr><literal type="string">"FLAGS_enable_wait_queues"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>cached_value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>YBSavepointsEnabled</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>cached_value</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>cached_value</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>cached_value</name> <operator>=</operator> <call><name>YBCIsEnvVarTrueWithDefault</name><argument_list>(<argument><expr><literal type="string">"FLAGS_enable_pg_savepoints"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>YBTransactionsEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>cached_value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>YBIsDBCatalogVersionMode</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>cached_value</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>cached_value</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>cached_value</name> <operator>=</operator> <call><name>YBCIsEnvVarTrueWithDefault</name><argument_list>(
			<argument><expr><literal type="string">"FLAGS_TEST_enable_db_catalog_version_mode"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/*
	 * During initdb (bootstrap mode), CATALOG_VERSION_PROTOBUF_ENTRY is used
	 * for catalog version type.
	 */</comment>
	<return>return <expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
		   <call><name>YbGetCatalogVersionType</name><argument_list>()</argument_list></call> <operator>==</operator> <name>CATALOG_VERSION_CATALOG_TABLE</name> <operator>&amp;&amp;</operator>
		   <name>cached_value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>YBReportFeatureUnsupported</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type>
<name>YBShouldReportErrorStatus</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>cached_value</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>cached_value</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>cached_value</name> <operator>=</operator> <call><name>YBCIsEnvVarTrue</name><argument_list>(<argument><expr><literal type="string">"YB_PG_REPORT_ERROR_STATUS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>cached_value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>HandleYBStatus</name><parameter_list>(<parameter><decl><type><name>YBCStatus</name></type> <name>status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
   <expr_stmt><expr><call><name>HandleYBStatusAtErrorLevel</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type>
<name>FetchUniqueConstraintName</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relation_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>RelationIdGetRelation</name><argument_list>(<argument><expr><name>relation_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_index</name></name> <operator>&amp;&amp;</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_pkindex</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type> <name>pkey</name> <init>= <expr><call><name>RelationIdGetRelation</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_pkindex</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>pkey</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name>pkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>name</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>HandleYBStatusAtErrorLevel</name><parameter_list>(<parameter><decl><type><name>YBCStatus</name></type> <name>status</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>error_level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>status</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Build message in the current memory context. */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>msg_buf</name> <init>= <expr><call><name>BuildYBStatusMessage</name><argument_list>(
			<argument><expr><name>status</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>FetchUniqueConstraintName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>YBShouldReportErrorStatus</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>YBC_LOG_ERROR</name><argument_list>(<argument><expr><literal type="string">"HandleYBStatus: %s"</literal></expr></argument>, <argument><expr><name>msg_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>pg_err_code</name> <init>= <expr><call><name>YBCStatusPgsqlError</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>uint16_t</name></type> <name>txn_err_code</name> <init>= <expr><call><name>YBCStatusTransactionError</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>YBCFreeStatus</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>error_level</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>msg_buf</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errcode</name><argument_list>(<argument><expr><name>pg_err_code</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>yb_txn_errcode</name><argument_list>(<argument><expr><name>txn_err_code</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errhidecontext</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>HandleYBStatusIgnoreNotFound</name><parameter_list>(<parameter><decl><type><name>YBCStatus</name></type> <name>status</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>not_found</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>status</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>YBCStatusIsNotFound</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>not_found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>YBCFreeStatus</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>not_found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>HandleYBTableDescStatus</name><parameter_list>(<parameter><decl><type><name>YBCStatus</name></type> <name>status</name></decl></parameter>, <parameter><decl><type><name>YBCPgTableDesc</name></type> <name>table</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>status</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type>
<name>GetDebugQueryString</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<return>return <expr><name>debug_query_string</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Ensure we've defined the correct postgres Oid values. This function only
 * contains compile-time assertions. It would have been made 'static' but it is
 * not called anywhere and making it 'static' caused compiler warning which
 * broke the build.
 */</comment>
<function><type><name>void</name></type>
<name>YBCheckDefinedOids</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>static_assert</name><argument_list>(<argument><expr><name>kInvalidOid</name> <operator>==</operator> <name>InvalidOid</name></expr></argument>, <argument><expr><literal type="string">"Oid mismatch"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>static_assert</name><argument_list>(<argument><expr><name>kByteArrayOid</name> <operator>==</operator> <name>BYTEAOID</name></expr></argument>, <argument><expr><literal type="string">"Oid mismatch"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>YBInitPostgresBackend</name><parameter_list>(
	<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>program_name</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>db_name</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>user_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCInit</name><argument_list>(<argument><expr><name>program_name</name></expr></argument>, <argument><expr><name>palloc</name></expr></argument>, <argument><expr><name>cstring_to_text_with_len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Enable "YB mode" for PostgreSQL so that we will initiate a connection
	 * to the YugaByte cluster right away from every backend process. We only

	 * do this if this env variable is set, so we can still run the regular
	 * PostgreSQL "make check".
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>YBIsEnabledInPostgresEnvVar</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>YBCPgTypeEntity</name> <modifier>*</modifier></type><name>type_table</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>YbGetTypeTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name>type_table</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>YBCPgCallbacks</name></type> <name>callbacks</name></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>callbacks</name><operator>.</operator><name>GetCurrentYbMemctx</name></name> <operator>=</operator> <operator>&amp;</operator><name>GetCurrentYbMemctx</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>callbacks</name><operator>.</operator><name>GetDebugQueryString</name></name> <operator>=</operator> <operator>&amp;</operator><name>GetDebugQueryString</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>callbacks</name><operator>.</operator><name>WriteExecOutParam</name></name> <operator>=</operator> <operator>&amp;</operator><name>YbWriteExecOutParam</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>YBCInitPgGate</name><argument_list>(<argument><expr><name>type_table</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>callbacks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>YBCInstallTxnDdlHook</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * For each process, we create one YBC session for PostgreSQL to use
		 * when accessing YugaByte storage.
		 *
		 * TODO: do we really need to DB name / username here?
		 */</comment>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgInitSession</name><argument_list>(<argument><expr><ternary><condition><expr><name>db_name</name></expr> ?</condition><then> <expr><name>db_name</name></expr> </then><else>: <expr><name>user_name</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>YBOnPostgresBackendShutdown</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>YBCDestroyPgGate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>YBCRecreateTransaction</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgRecreateTransaction</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>YBCRestartTransaction</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgRestartTransaction</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>YBCCommitTransaction</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgCommitTransaction</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>YBCAbortTransaction</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>YBTransactionsEnabled</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgAbortTransaction</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>YBCSetActiveSubTransaction</name><parameter_list>(<parameter><decl><type><name>SubTransactionId</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>YBSavepointsEnabled</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgSetActiveSubTransaction</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>YBCRollbackToSubTransaction</name><parameter_list>(<parameter><decl><type><name>SubTransactionId</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>YBSavepointsEnabled</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgRollbackToSubTransaction</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>YBIsPgLockingEnabled</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>!</operator><call><name>YBTransactionsEnabled</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>yb_connected_to_template_db</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<function><type><name>void</name></type>
<name>YbSetConnectedToTemplateDb</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>yb_connected_to_template_db</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>YbIsConnectedToTemplateDb</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<return>return <expr><name>yb_connected_to_template_db</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Oid</name></type>
<name>GetTypeId</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>attrNum</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>attrNum</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SelfItemPointerAttributeNumber</name></expr>:</case>
			<return>return <expr><name>TIDOID</name></expr>;</return>
		<case>case <expr><name>ObjectIdAttributeNumber</name></expr>:</case>
			<return>return <expr><name>OIDOID</name></expr>;</return>
		<case>case <expr><name>MinTransactionIdAttributeNumber</name></expr>:</case>
			<return>return <expr><name>XIDOID</name></expr>;</return>
		<case>case <expr><name>MinCommandIdAttributeNumber</name></expr>:</case>
			<return>return <expr><name>CIDOID</name></expr>;</return>
		<case>case <expr><name>MaxTransactionIdAttributeNumber</name></expr>:</case>
			<return>return <expr><name>XIDOID</name></expr>;</return>
		<case>case <expr><name>MaxCommandIdAttributeNumber</name></expr>:</case>
			<return>return <expr><name>CIDOID</name></expr>;</return>
		<case>case <expr><name>TableOidAttributeNumber</name></expr>:</case>
			<return>return <expr><name>OIDOID</name></expr>;</return>
		<default>default:</default>
			<if_stmt><if>if <condition>(<expr><name>attrNum</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>attrNum</name> <operator>&lt;=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>attrNum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr>;</return></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type>
<name>YBPgTypeOidToStr</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type_id</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<switch>switch <condition>(<expr><name>type_id</name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>BOOLOID</name></expr>:</case> <return>return <expr><literal type="string">"BOOL"</literal></expr>;</return>
		<case>case <expr><name>BYTEAOID</name></expr>:</case> <return>return <expr><literal type="string">"BYTEA"</literal></expr>;</return>
		<case>case <expr><name>CHAROID</name></expr>:</case> <return>return <expr><literal type="string">"CHAR"</literal></expr>;</return>
		<case>case <expr><name>NAMEOID</name></expr>:</case> <return>return <expr><literal type="string">"NAME"</literal></expr>;</return>
		<case>case <expr><name>INT8OID</name></expr>:</case> <return>return <expr><literal type="string">"INT8"</literal></expr>;</return>
		<case>case <expr><name>INT2OID</name></expr>:</case> <return>return <expr><literal type="string">"INT2"</literal></expr>;</return>
		<case>case <expr><name>INT2VECTOROID</name></expr>:</case> <return>return <expr><literal type="string">"INT2VECTOR"</literal></expr>;</return>
		<case>case <expr><name>INT4OID</name></expr>:</case> <return>return <expr><literal type="string">"INT4"</literal></expr>;</return>
		<case>case <expr><name>REGPROCOID</name></expr>:</case> <return>return <expr><literal type="string">"REGPROC"</literal></expr>;</return>
		<case>case <expr><name>TEXTOID</name></expr>:</case> <return>return <expr><literal type="string">"TEXT"</literal></expr>;</return>
		<case>case <expr><name>OIDOID</name></expr>:</case> <return>return <expr><literal type="string">"OID"</literal></expr>;</return>
		<case>case <expr><name>TIDOID</name></expr>:</case> <return>return <expr><literal type="string">"TID"</literal></expr>;</return>
		<case>case <expr><name>XIDOID</name></expr>:</case> <return>return <expr><literal type="string">"XID"</literal></expr>;</return>
		<case>case <expr><name>CIDOID</name></expr>:</case> <return>return <expr><literal type="string">"CID"</literal></expr>;</return>
		<case>case <expr><name>OIDVECTOROID</name></expr>:</case> <return>return <expr><literal type="string">"OIDVECTOR"</literal></expr>;</return>
		<case>case <expr><name>JSONOID</name></expr>:</case> <return>return <expr><literal type="string">"JSON"</literal></expr>;</return>
		<case>case <expr><name>XMLOID</name></expr>:</case> <return>return <expr><literal type="string">"XML"</literal></expr>;</return>
		<case>case <expr><name>PGNODETREEOID</name></expr>:</case> <return>return <expr><literal type="string">"PGNODETREE"</literal></expr>;</return>
		<case>case <expr><name>PGNDISTINCTOID</name></expr>:</case> <return>return <expr><literal type="string">"PGNDISTINCT"</literal></expr>;</return>
		<case>case <expr><name>PGDEPENDENCIESOID</name></expr>:</case> <return>return <expr><literal type="string">"PGDEPENDENCIES"</literal></expr>;</return>
		<case>case <expr><name>PGDDLCOMMANDOID</name></expr>:</case> <return>return <expr><literal type="string">"PGDDLCOMMAND"</literal></expr>;</return>
		<case>case <expr><name>POINTOID</name></expr>:</case> <return>return <expr><literal type="string">"POINT"</literal></expr>;</return>
		<case>case <expr><name>LSEGOID</name></expr>:</case> <return>return <expr><literal type="string">"LSEG"</literal></expr>;</return>
		<case>case <expr><name>PATHOID</name></expr>:</case> <return>return <expr><literal type="string">"PATH"</literal></expr>;</return>
		<case>case <expr><name>BOXOID</name></expr>:</case> <return>return <expr><literal type="string">"BOX"</literal></expr>;</return>
		<case>case <expr><name>POLYGONOID</name></expr>:</case> <return>return <expr><literal type="string">"POLYGON"</literal></expr>;</return>
		<case>case <expr><name>LINEOID</name></expr>:</case> <return>return <expr><literal type="string">"LINE"</literal></expr>;</return>
		<case>case <expr><name>FLOAT4OID</name></expr>:</case> <return>return <expr><literal type="string">"FLOAT4"</literal></expr>;</return>
		<case>case <expr><name>FLOAT8OID</name></expr>:</case> <return>return <expr><literal type="string">"FLOAT8"</literal></expr>;</return>
		<case>case <expr><name>ABSTIMEOID</name></expr>:</case> <return>return <expr><literal type="string">"ABSTIME"</literal></expr>;</return>
		<case>case <expr><name>RELTIMEOID</name></expr>:</case> <return>return <expr><literal type="string">"RELTIME"</literal></expr>;</return>
		<case>case <expr><name>TINTERVALOID</name></expr>:</case> <return>return <expr><literal type="string">"TINTERVAL"</literal></expr>;</return>
		<case>case <expr><name>UNKNOWNOID</name></expr>:</case> <return>return <expr><literal type="string">"UNKNOWN"</literal></expr>;</return>
		<case>case <expr><name>CIRCLEOID</name></expr>:</case> <return>return <expr><literal type="string">"CIRCLE"</literal></expr>;</return>
		<case>case <expr><name>CASHOID</name></expr>:</case> <return>return <expr><literal type="string">"CASH"</literal></expr>;</return>
		<case>case <expr><name>MACADDROID</name></expr>:</case> <return>return <expr><literal type="string">"MACADDR"</literal></expr>;</return>
		<case>case <expr><name>INETOID</name></expr>:</case> <return>return <expr><literal type="string">"INET"</literal></expr>;</return>
		<case>case <expr><name>CIDROID</name></expr>:</case> <return>return <expr><literal type="string">"CIDR"</literal></expr>;</return>
		<case>case <expr><name>MACADDR8OID</name></expr>:</case> <return>return <expr><literal type="string">"MACADDR8"</literal></expr>;</return>
		<case>case <expr><name>INT2ARRAYOID</name></expr>:</case> <return>return <expr><literal type="string">"INT2ARRAY"</literal></expr>;</return>
		<case>case <expr><name>INT4ARRAYOID</name></expr>:</case> <return>return <expr><literal type="string">"INT4ARRAY"</literal></expr>;</return>
		<case>case <expr><name>TEXTARRAYOID</name></expr>:</case> <return>return <expr><literal type="string">"TEXTARRAY"</literal></expr>;</return>
		<case>case <expr><name>OIDARRAYOID</name></expr>:</case> <return>return <expr><literal type="string">"OIDARRAY"</literal></expr>;</return>
		<case>case <expr><name>FLOAT4ARRAYOID</name></expr>:</case> <return>return <expr><literal type="string">"FLOAT4ARRAY"</literal></expr>;</return>
		<case>case <expr><name>ACLITEMOID</name></expr>:</case> <return>return <expr><literal type="string">"ACLITEM"</literal></expr>;</return>
		<case>case <expr><name>CSTRINGARRAYOID</name></expr>:</case> <return>return <expr><literal type="string">"CSTRINGARRAY"</literal></expr>;</return>
		<case>case <expr><name>BPCHAROID</name></expr>:</case> <return>return <expr><literal type="string">"BPCHAR"</literal></expr>;</return>
		<case>case <expr><name>VARCHAROID</name></expr>:</case> <return>return <expr><literal type="string">"VARCHAR"</literal></expr>;</return>
		<case>case <expr><name>DATEOID</name></expr>:</case> <return>return <expr><literal type="string">"DATE"</literal></expr>;</return>
		<case>case <expr><name>TIMEOID</name></expr>:</case> <return>return <expr><literal type="string">"TIME"</literal></expr>;</return>
		<case>case <expr><name>TIMESTAMPOID</name></expr>:</case> <return>return <expr><literal type="string">"TIMESTAMP"</literal></expr>;</return>
		<case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case> <return>return <expr><literal type="string">"TIMESTAMPTZ"</literal></expr>;</return>
		<case>case <expr><name>INTERVALOID</name></expr>:</case> <return>return <expr><literal type="string">"INTERVAL"</literal></expr>;</return>
		<case>case <expr><name>TIMETZOID</name></expr>:</case> <return>return <expr><literal type="string">"TIMETZ"</literal></expr>;</return>
		<case>case <expr><name>BITOID</name></expr>:</case> <return>return <expr><literal type="string">"BIT"</literal></expr>;</return>
		<case>case <expr><name>VARBITOID</name></expr>:</case> <return>return <expr><literal type="string">"VARBIT"</literal></expr>;</return>
		<case>case <expr><name>NUMERICOID</name></expr>:</case> <return>return <expr><literal type="string">"NUMERIC"</literal></expr>;</return>
		<case>case <expr><name>REFCURSOROID</name></expr>:</case> <return>return <expr><literal type="string">"REFCURSOR"</literal></expr>;</return>
		<case>case <expr><name>REGPROCEDUREOID</name></expr>:</case> <return>return <expr><literal type="string">"REGPROCEDURE"</literal></expr>;</return>
		<case>case <expr><name>REGOPEROID</name></expr>:</case> <return>return <expr><literal type="string">"REGOPER"</literal></expr>;</return>
		<case>case <expr><name>REGOPERATOROID</name></expr>:</case> <return>return <expr><literal type="string">"REGOPERATOR"</literal></expr>;</return>
		<case>case <expr><name>REGCLASSOID</name></expr>:</case> <return>return <expr><literal type="string">"REGCLASS"</literal></expr>;</return>
		<case>case <expr><name>REGTYPEOID</name></expr>:</case> <return>return <expr><literal type="string">"REGTYPE"</literal></expr>;</return>
		<case>case <expr><name>REGROLEOID</name></expr>:</case> <return>return <expr><literal type="string">"REGROLE"</literal></expr>;</return>
		<case>case <expr><name>REGNAMESPACEOID</name></expr>:</case> <return>return <expr><literal type="string">"REGNAMESPACE"</literal></expr>;</return>
		<case>case <expr><name>REGTYPEARRAYOID</name></expr>:</case> <return>return <expr><literal type="string">"REGTYPEARRAY"</literal></expr>;</return>
		<case>case <expr><name>UUIDOID</name></expr>:</case> <return>return <expr><literal type="string">"UUID"</literal></expr>;</return>
		<case>case <expr><name>LSNOID</name></expr>:</case> <return>return <expr><literal type="string">"LSN"</literal></expr>;</return>
		<case>case <expr><name>TSVECTOROID</name></expr>:</case> <return>return <expr><literal type="string">"TSVECTOR"</literal></expr>;</return>
		<case>case <expr><name>GTSVECTOROID</name></expr>:</case> <return>return <expr><literal type="string">"GTSVECTOR"</literal></expr>;</return>
		<case>case <expr><name>TSQUERYOID</name></expr>:</case> <return>return <expr><literal type="string">"TSQUERY"</literal></expr>;</return>
		<case>case <expr><name>REGCONFIGOID</name></expr>:</case> <return>return <expr><literal type="string">"REGCONFIG"</literal></expr>;</return>
		<case>case <expr><name>REGDICTIONARYOID</name></expr>:</case> <return>return <expr><literal type="string">"REGDICTIONARY"</literal></expr>;</return>
		<case>case <expr><name>JSONBOID</name></expr>:</case> <return>return <expr><literal type="string">"JSONB"</literal></expr>;</return>
		<case>case <expr><name>INT4RANGEOID</name></expr>:</case> <return>return <expr><literal type="string">"INT4RANGE"</literal></expr>;</return>
		<case>case <expr><name>RECORDOID</name></expr>:</case> <return>return <expr><literal type="string">"RECORD"</literal></expr>;</return>
		<case>case <expr><name>RECORDARRAYOID</name></expr>:</case> <return>return <expr><literal type="string">"RECORDARRAY"</literal></expr>;</return>
		<case>case <expr><name>CSTRINGOID</name></expr>:</case> <return>return <expr><literal type="string">"CSTRING"</literal></expr>;</return>
		<case>case <expr><name>ANYOID</name></expr>:</case> <return>return <expr><literal type="string">"ANY"</literal></expr>;</return>
		<case>case <expr><name>ANYARRAYOID</name></expr>:</case> <return>return <expr><literal type="string">"ANYARRAY"</literal></expr>;</return>
		<case>case <expr><name>VOIDOID</name></expr>:</case> <return>return <expr><literal type="string">"VOID"</literal></expr>;</return>
		<case>case <expr><name>TRIGGEROID</name></expr>:</case> <return>return <expr><literal type="string">"TRIGGER"</literal></expr>;</return>
		<case>case <expr><name>EVTTRIGGEROID</name></expr>:</case> <return>return <expr><literal type="string">"EVTTRIGGER"</literal></expr>;</return>
		<case>case <expr><name>LANGUAGE_HANDLEROID</name></expr>:</case> <return>return <expr><literal type="string">"LANGUAGE_HANDLER"</literal></expr>;</return>
		<case>case <expr><name>INTERNALOID</name></expr>:</case> <return>return <expr><literal type="string">"INTERNAL"</literal></expr>;</return>
		<case>case <expr><name>OPAQUEOID</name></expr>:</case> <return>return <expr><literal type="string">"OPAQUE"</literal></expr>;</return>
		<case>case <expr><name>ANYELEMENTOID</name></expr>:</case> <return>return <expr><literal type="string">"ANYELEMENT"</literal></expr>;</return>
		<case>case <expr><name>ANYNONARRAYOID</name></expr>:</case> <return>return <expr><literal type="string">"ANYNONARRAY"</literal></expr>;</return>
		<case>case <expr><name>ANYENUMOID</name></expr>:</case> <return>return <expr><literal type="string">"ANYENUM"</literal></expr>;</return>
		<case>case <expr><name>FDW_HANDLEROID</name></expr>:</case> <return>return <expr><literal type="string">"FDW_HANDLER"</literal></expr>;</return>
		<case>case <expr><name>INDEX_AM_HANDLEROID</name></expr>:</case> <return>return <expr><literal type="string">"INDEX_AM_HANDLER"</literal></expr>;</return>
		<case>case <expr><name>TSM_HANDLEROID</name></expr>:</case> <return>return <expr><literal type="string">"TSM_HANDLER"</literal></expr>;</return>
		<case>case <expr><name>ANYRANGEOID</name></expr>:</case> <return>return <expr><literal type="string">"ANYRANGE"</literal></expr>;</return>
		<default>default:</default> <return>return <expr><literal type="string">"user_defined_type"</literal></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type>
<name>YBCPgDataTypeToStr</name><parameter_list>(<parameter><decl><type><name>YBCPgDataType</name></type> <name>yb_type</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<switch>switch <condition>(<expr><name>yb_type</name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>YB_YQL_DATA_TYPE_NOT_SUPPORTED</name></expr>:</case> <return>return <expr><literal type="string">"NOT_SUPPORTED"</literal></expr>;</return>
		<case>case <expr><name>YB_YQL_DATA_TYPE_UNKNOWN_DATA</name></expr>:</case> <return>return <expr><literal type="string">"UNKNOWN_DATA"</literal></expr>;</return>
		<case>case <expr><name>YB_YQL_DATA_TYPE_NULL_VALUE_TYPE</name></expr>:</case> <return>return <expr><literal type="string">"NULL_VALUE_TYPE"</literal></expr>;</return>
		<case>case <expr><name>YB_YQL_DATA_TYPE_INT8</name></expr>:</case> <return>return <expr><literal type="string">"INT8"</literal></expr>;</return>
		<case>case <expr><name>YB_YQL_DATA_TYPE_INT16</name></expr>:</case> <return>return <expr><literal type="string">"INT16"</literal></expr>;</return>
		<case>case <expr><name>YB_YQL_DATA_TYPE_INT32</name></expr>:</case> <return>return <expr><literal type="string">"INT32"</literal></expr>;</return>
		<case>case <expr><name>YB_YQL_DATA_TYPE_INT64</name></expr>:</case> <return>return <expr><literal type="string">"INT64"</literal></expr>;</return>
		<case>case <expr><name>YB_YQL_DATA_TYPE_STRING</name></expr>:</case> <return>return <expr><literal type="string">"STRING"</literal></expr>;</return>
		<case>case <expr><name>YB_YQL_DATA_TYPE_BOOL</name></expr>:</case> <return>return <expr><literal type="string">"BOOL"</literal></expr>;</return>
		<case>case <expr><name>YB_YQL_DATA_TYPE_FLOAT</name></expr>:</case> <return>return <expr><literal type="string">"FLOAT"</literal></expr>;</return>
		<case>case <expr><name>YB_YQL_DATA_TYPE_DOUBLE</name></expr>:</case> <return>return <expr><literal type="string">"DOUBLE"</literal></expr>;</return>
		<case>case <expr><name>YB_YQL_DATA_TYPE_BINARY</name></expr>:</case> <return>return <expr><literal type="string">"BINARY"</literal></expr>;</return>
		<case>case <expr><name>YB_YQL_DATA_TYPE_TIMESTAMP</name></expr>:</case> <return>return <expr><literal type="string">"TIMESTAMP"</literal></expr>;</return>
		<case>case <expr><name>YB_YQL_DATA_TYPE_DECIMAL</name></expr>:</case> <return>return <expr><literal type="string">"DECIMAL"</literal></expr>;</return>
		<case>case <expr><name>YB_YQL_DATA_TYPE_VARINT</name></expr>:</case> <return>return <expr><literal type="string">"VARINT"</literal></expr>;</return>
		<case>case <expr><name>YB_YQL_DATA_TYPE_INET</name></expr>:</case> <return>return <expr><literal type="string">"INET"</literal></expr>;</return>
		<case>case <expr><name>YB_YQL_DATA_TYPE_LIST</name></expr>:</case> <return>return <expr><literal type="string">"LIST"</literal></expr>;</return>
		<case>case <expr><name>YB_YQL_DATA_TYPE_MAP</name></expr>:</case> <return>return <expr><literal type="string">"MAP"</literal></expr>;</return>
		<case>case <expr><name>YB_YQL_DATA_TYPE_SET</name></expr>:</case> <return>return <expr><literal type="string">"SET"</literal></expr>;</return>
		<case>case <expr><name>YB_YQL_DATA_TYPE_UUID</name></expr>:</case> <return>return <expr><literal type="string">"UUID"</literal></expr>;</return>
		<case>case <expr><name>YB_YQL_DATA_TYPE_TIMEUUID</name></expr>:</case> <return>return <expr><literal type="string">"TIMEUUID"</literal></expr>;</return>
		<case>case <expr><name>YB_YQL_DATA_TYPE_TUPLE</name></expr>:</case> <return>return <expr><literal type="string">"TUPLE"</literal></expr>;</return>
		<case>case <expr><name>YB_YQL_DATA_TYPE_TYPEARGS</name></expr>:</case> <return>return <expr><literal type="string">"TYPEARGS"</literal></expr>;</return>
		<case>case <expr><name>YB_YQL_DATA_TYPE_USER_DEFINED_TYPE</name></expr>:</case> <return>return <expr><literal type="string">"USER_DEFINED_TYPE"</literal></expr>;</return>
		<case>case <expr><name>YB_YQL_DATA_TYPE_FROZEN</name></expr>:</case> <return>return <expr><literal type="string">"FROZEN"</literal></expr>;</return>
		<case>case <expr><name>YB_YQL_DATA_TYPE_DATE</name></expr>:</case> <return>return <expr><literal type="string">"DATE"</literal></expr>;</return>
		<case>case <expr><name>YB_YQL_DATA_TYPE_TIME</name></expr>:</case> <return>return <expr><literal type="string">"TIME"</literal></expr>;</return>
		<case>case <expr><name>YB_YQL_DATA_TYPE_JSONB</name></expr>:</case> <return>return <expr><literal type="string">"JSONB"</literal></expr>;</return>
		<case>case <expr><name>YB_YQL_DATA_TYPE_UINT8</name></expr>:</case> <return>return <expr><literal type="string">"UINT8"</literal></expr>;</return>
		<case>case <expr><name>YB_YQL_DATA_TYPE_UINT16</name></expr>:</case> <return>return <expr><literal type="string">"UINT16"</literal></expr>;</return>
		<case>case <expr><name>YB_YQL_DATA_TYPE_UINT32</name></expr>:</case> <return>return <expr><literal type="string">"UINT32"</literal></expr>;</return>
		<case>case <expr><name>YB_YQL_DATA_TYPE_UINT64</name></expr>:</case> <return>return <expr><literal type="string">"UINT64"</literal></expr>;</return>
		<default>default:</default> <return>return <expr><literal type="string">"unknown"</literal></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>YBReportIfYugaByteEnabled</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>YBIsEnabledInPostgresEnvVar</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
			<argument><expr><literal type="string">"YugaByte is ENABLED in PostgreSQL. Transactions are %s."</literal></expr></argument>,
			<argument><expr><ternary><condition><expr><call><name>YBCIsEnvVarTrue</name><argument_list>(<argument><expr><literal type="string">"YB_PG_TRANSACTIONS_ENABLED"</literal></expr></argument>)</argument_list></call></expr> ?</condition><then>
			<expr><literal type="string">"enabled"</literal></expr> </then><else>: <expr><literal type="string">"disabled"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"YugaByte is NOT ENABLED -- "</literal>
							<literal type="string">"this is a vanilla PostgreSQL server!"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>YBShouldRestartAllChildrenIfOneCrashes</name><parameter_list>()</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>YBIsEnabledInPostgresEnvVar</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"YBShouldRestartAllChildrenIfOneCrashes returning 0, YBIsEnabledInPostgresEnvVar is false"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="line">// We will use PostgreSQL's default behavior (restarting all children if one of them crashes)</comment>
	<comment type="line">// if the flag env variable is not specified or the file pointed by it does not exist.</comment>
	<return>return <expr><call><name>YBCIsEnvVarTrueWithDefault</name><argument_list>(<argument><expr><literal type="string">"FLAGS_yb_pg_terminate_child_backend"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>YBShouldLogStackTraceOnError</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>cached_value</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>cached_value</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>cached_value</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>cached_value</name> <operator>=</operator> <call><name>YBCIsEnvVarTrue</name><argument_list>(<argument><expr><literal type="string">"YB_PG_STACK_TRACE_ON_ERROR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>cached_value</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type>
<name>YBPgErrorLevelToString</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<switch>switch <condition>(<expr><name>elevel</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DEBUG5</name></expr>:</case> <return>return <expr><literal type="string">"DEBUG5"</literal></expr>;</return>
		<case>case <expr><name>DEBUG4</name></expr>:</case> <return>return <expr><literal type="string">"DEBUG4"</literal></expr>;</return>
		<case>case <expr><name>DEBUG3</name></expr>:</case> <return>return <expr><literal type="string">"DEBUG3"</literal></expr>;</return>
		<case>case <expr><name>DEBUG2</name></expr>:</case> <return>return <expr><literal type="string">"DEBUG2"</literal></expr>;</return>
		<case>case <expr><name>DEBUG1</name></expr>:</case> <return>return <expr><literal type="string">"DEBUG1"</literal></expr>;</return>
		<case>case <expr><name>LOG</name></expr>:</case> <return>return <expr><literal type="string">"LOG"</literal></expr>;</return>
		<case>case <expr><name>LOG_SERVER_ONLY</name></expr>:</case> <return>return <expr><literal type="string">"LOG_SERVER_ONLY"</literal></expr>;</return>
		<case>case <expr><name>INFO</name></expr>:</case> <return>return <expr><literal type="string">"INFO"</literal></expr>;</return>
		<case>case <expr><name>WARNING</name></expr>:</case> <return>return <expr><literal type="string">"WARNING"</literal></expr>;</return>
		<case>case <expr><name>ERROR</name></expr>:</case> <return>return <expr><literal type="string">"ERROR"</literal></expr>;</return>
		<case>case <expr><name>FATAL</name></expr>:</case> <return>return <expr><literal type="string">"FATAL"</literal></expr>;</return>
		<case>case <expr><name>PANIC</name></expr>:</case> <return>return <expr><literal type="string">"PANIC"</literal></expr>;</return>
		<default>default:</default> <return>return <expr><literal type="string">"UNKNOWN"</literal></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type>
<name>YBCGetDatabaseName</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Hardcode the names for system db since the cache might not
	 * be initialized during initdb (bootstrap mode).
	 * For shared rels (e.g. pg_database) we may not have a database id yet,
	 * so assuming template1 in that case since that's where shared tables are
	 * stored in YB.
	 * TODO Eventually YB should switch to using oid's everywhere so
	 * that dbname and schemaname should not be needed at all.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>MyDatabaseId</name> <operator>==</operator> <name>TemplateDbOid</name> <operator>||</operator> <call><name>IsSharedRelation</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="string">"template1"</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type>
<name>YBCGetSchemaName</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>schemaoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Hardcode the names for system namespaces since the cache might not
	 * be initialized during initdb (bootstrap mode).
	 * TODO Eventually YB should switch to using oid's everywhere so
	 * that dbname and schemaname should not be needed at all.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsSystemNamespace</name><argument_list>(<argument><expr><name>schemaoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="string">"pg_catalog"</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsToastNamespace</name><argument_list>(<argument><expr><name>schemaoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="string">"pg_toast"</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>schemaoid</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>Oid</name></type>
<name>YBCGetDatabaseOid</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>YBCGetDatabaseOidFromShared</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relisshared</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Oid</name></type>
<name>YBCGetDatabaseOidByRelid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name>    <init>= <expr><call><name>RelationIdGetRelation</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>     <name>relisshared</name> <init>= <expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relisshared</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>YBCGetDatabaseOidFromShared</name><argument_list>(<argument><expr><name>relisshared</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Oid</name></type>
<name>YBCGetDatabaseOidFromShared</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>relisshared</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><ternary><condition><expr><name>relisshared</name></expr> ?</condition><then> <expr><name>TemplateDbOid</name></expr> </then><else>: <expr><name>MyDatabaseId</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>YBRaiseNotSupported</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>issue_no</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>YBRaiseNotSupportedSignal</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>issue_no</name></expr></argument>, <argument><expr><call><name>YBUnsupportedFeatureSignalLevel</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>YBRaiseNotSupportedSignal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>issue_no</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>signal_level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>issue_no</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>signal_level</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"See https://github.com/yugabyte/yugabyte-db/issues/%d. "</literal>
						 <literal type="string">"React with thumbs up to raise its priority"</literal></expr></argument>, <argument><expr><name>issue_no</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>signal_level</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Please report the issue on "</literal>
						 <literal type="string">"https://github.com/YugaByte/yugabyte-db/issues"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>double</name></type>
<name>PowerWithUpperLimit</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>exp</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>upper_limit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>base</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>exp</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>double</name></type> <name>res</name> <init>= <expr><literal type="number">1.0</literal></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><name>exp</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>exp</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>res</name> <operator>*=</operator> <name>base</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&gt;=</operator> <name>upper_limit</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>upper_limit</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>exp</name> <operator>=</operator> <name>exp</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>base</name> <operator>*=</operator> <name>base</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// YB GUC variables.</comment>

<decl_stmt><decl><type><name>bool</name></type> <name>yb_enable_create_with_table_oid</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>yb_index_state_flags_update_delay</name> <init>= <expr><literal type="number">1000</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>yb_enable_expression_pushdown</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>yb_enable_optimizer_statistics</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>yb_make_next_ddl_statement_nonbreaking</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>yb_plpgsql_disable_prefetch_in_for_query</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="line">//------------------------------------------------------------------------------</comment>
<comment type="line">// YB Debug utils.</comment>

<decl_stmt><decl><type><name>bool</name></type> <name>yb_debug_report_error_stacktrace</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>yb_debug_log_catcache_events</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>yb_debug_log_internal_restarts</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>yb_test_system_catalogs_creation</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>yb_test_fail_next_ddl</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>yb_test_block_index_state_change</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<function><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type>
<name>YBDatumToString</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>datum</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typoutput</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typisvarlena</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name>typid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typoutput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typisvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typoutput</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type>
<name>YbHeapTupleToString</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>attr</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>natts</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>attnum</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>attnum</name> <operator>&lt;=</operator> <name>natts</name></expr>;</condition> <incr><expr><operator>++</operator><name>attnum</name></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>typid</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>YBDatumToString</name><argument_list>(<argument><expr><name>attr</name></expr></argument>, <argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>!=</operator> <name>natts</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type>
<name>YbBitmapsetToString</name><parameter_list>(<parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>bms</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>str</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>outBitmapset</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>bms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>str</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>YBIsInitDbAlreadyDone</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgIsInitDbDone</name><argument_list>(<argument><expr><operator>&amp;</operator><name>done</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>done</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*---------------------------------------------------------------------------*/</comment>
<comment type="block">/* Transactional DDL support                                                 */</comment>
<comment type="block">/*---------------------------------------------------------------------------*/</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>ProcessUtility_hook_type</name></type> <name>prev_ProcessUtility</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<typedef>typedef <type><struct>struct <name>DdlTransactionState</name> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>nesting_level</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>mem_context</name></decl>;</decl_stmt>
}</block></struct></type> <name>DdlTransactionState</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>DdlTransactionState</name></type> <name>ddl_transaction_state</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>YBResetEnableNonBreakingDDLMode</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Reset yb_make_next_ddl_statement_nonbreaking to avoid its further side
	 * effect that may not be intended.
	 */</comment>
	<expr_stmt><expr><name>yb_make_next_ddl_statement_nonbreaking</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Release all space allocated in the yb_memctx of a context and all of
 * its descendants, but don't delete the yb_memctx themselves.
 */</comment>
<function><type><specifier>static</specifier> <name>YBCStatus</name></type>
<name>YbMemCtxReset</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>MemoryContext</name></type> <name>child</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>firstchild</name></name></expr></init></decl>;</init>
		 <condition><expr><name>child</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
		 <incr><expr><name>child</name> <operator>=</operator> <name><name>child</name><operator>-&gt;</operator><name>nextchild</name></name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>YBCStatus</name></type> <name>status</name> <init>= <expr><call><name>YbMemCtxReset</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>status</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>status</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><ternary><condition><expr><name><name>context</name><operator>-&gt;</operator><name>yb_memctx</name></name></expr> ?</condition><then> <expr><call><name>YBCPgResetMemctx</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>yb_memctx</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>YBResetDdlState</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>YBCStatus</name></type> <name>status</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>ddl_transaction_state</name><operator>.</operator><name>mem_context</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call> <operator>==</operator> <name><name>ddl_transaction_state</name><operator>.</operator><name>mem_context</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>ddl_transaction_state</name><operator>.</operator><name>mem_context</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* Reset the yb_memctx of the ddl memory context including its descendants.
		 * This is to ensure that all the operations in this ddl transaction are
		 * completed before we abort the ddl transaction. For example, when a ddl
		 * transaction aborts there may be a PgDocOp in this ddl transaction which
		 * still has a pending Perform operation to pre-fetch the next batch of
		 * rows and the Perform's RPC call has not completed yet. Releasing the ddl
		 * memory context will trigger the call to ~PgDocOp where we'll wait for
		 * the pending operation to complete. Because all the objects allocated
		 * during this ddl transaction are released, we assume they are no longer
		 * needed after the ddl transaction aborts.
		 */</comment>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>YbMemCtxReset</name><argument_list>(<argument><expr><name><name>ddl_transaction_state</name><operator>.</operator><name>mem_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>ddl_transaction_state</name> <operator>=</operator> <operator>(</operator>struct <name>DdlTransactionState</name><operator>)</operator><block>{<expr><literal type="number">0</literal></expr>}</block></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>YBResetEnableNonBreakingDDLMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>YBCPgClearSeparateDdlTxnMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>YBGetDdlNestingLevel</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>ddl_transaction_state</name><operator>.</operator><name>nesting_level</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>YBIncrementDdlNestingLevel</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>ddl_transaction_state</name><operator>.</operator><name>nesting_level</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ddl_transaction_state</name><operator>.</operator><name>mem_context</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(
			<argument><expr><call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"aux ddl memory context"</literal></expr></argument>,
			<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>ddl_transaction_state</name><operator>.</operator><name>mem_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgEnterSeparateDdlTxnMode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>++</operator><name><name>ddl_transaction_state</name><operator>.</operator><name>nesting_level</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>YBDecrementDdlNestingLevel</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>is_catalog_version_increment</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>is_breaking_catalog_change</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>--</operator><name><name>ddl_transaction_state</name><operator>.</operator><name>nesting_level</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>ddl_transaction_state</name><operator>.</operator><name>nesting_level</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>yb_test_fail_next_ddl</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>yb_test_fail_next_ddl</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Failed DDL operation as requested"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call> <operator>==</operator> <name><name>ddl_transaction_state</name><operator>.</operator><name>mem_context</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>ddl_transaction_state</name><operator>.</operator><name>mem_context</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/*
		 * We cannot reset the ddl memory context as we do in the abort case
		 * (see YBResetDdlState) because there are cases where objects
		 * allocated during the ddl transaction are still needed after this
		 * ddl transaction commits successfully.
		 */</comment>
		<expr_stmt><expr><name><name>ddl_transaction_state</name><operator>.</operator><name>mem_context</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>YBResetEnableNonBreakingDDLMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>increment_done</name> <init>=
			<expr><name>is_catalog_version_increment</name> <operator>&amp;&amp;</operator>
			<call><name>YBCPgHasWriteOperationsInDdlTxnMode</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>YbIncrementMasterCatalogVersionTableEntry</name><argument_list>(<argument><expr><name>is_breaking_catalog_change</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgExitSeparateDdlTxnMode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Optimization to avoid redundant cache refresh on the current session
		 * since we should have already updated the cache locally while
		 * applying the DDL changes.
		 * (Doing this after YBCPgExitSeparateDdlTxnMode so it only executes
		 * if DDL txn commit succeeds.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>increment_done</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>yb_catalog_cache_version</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><call><name>YBCGetGFlags</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>log_ysql_catalog_versions</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s: set local catalog version: %"</literal> <name>PRIu64</name></expr></argument>,
								<argument><expr><name>__func__</name></expr></argument>, <argument><expr><name>yb_catalog_cache_version</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>handles</name> <init>= <expr><call><name>YBGetDdlHandles</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>handles</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>YBCPgStatement</name></type> <name>handle</name> <init>= <expr><operator>(</operator><name>YBCPgStatement</name><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<comment type="block">/*
			 * At this point we have already applied the DDL in the YSQL layer and
			 * executing the postponed DocDB statement is not strictly required.
			 * Ignore 'NotFound' because DocDB might already notice applied DDL.
			 * See comment for YBGetDdlHandles in xact.h for more details.
			 */</comment>
			<decl_stmt><decl><type><name>YBCStatus</name></type> <name>status</name> <init>= <expr><call><name>YBCPgExecPostponedDdlStmt</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>YBCStatusIsNotFound</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>YBCFreeStatus</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if> <else>else <block>{<block_content>
				<expr_stmt><expr><call><name>HandleYBStatusAtErrorLevel</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>YBClearDdlHandles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name><modifier>*</modifier></type>
<name>GetActualStmtNode</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_ExplainStmt</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExplainStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ExplainStmt</name></expr></argument>, <argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>actual_stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>utilityStmt</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>actual_stmt</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * EXPLAIN statement may have multiple ANALYZE options.
			 * The value of the last one will take effect.
			 */</comment>
			<decl_stmt><decl><type><name>bool</name></type> <name>analyze</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt-&gt;options</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>opt</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"analyze"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>analyze</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<if_stmt><if>if <condition>(<expr><name>analyze</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>actual_stmt</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>IsTransactionalDdlStatement</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>,
                                 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_catalog_version_increment</name></decl></parameter>,
                                 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_breaking_catalog_change</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Assume the worst. */</comment>
	<expr_stmt><expr><operator>*</operator><name>is_catalog_version_increment</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>is_breaking_catalog_change</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>is_ddl</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name> <init>= <expr><call><name>GetActualStmtNode</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>NodeTag</name></type> <name>node_tag</name> <init>= <expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<switch>switch <condition>(<expr><name>node_tag</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// The lists of tags here have been generated using e.g.:</comment>
		<comment type="line">// cat $( find src/postgres -name "nodes.h" ) | grep "T_Create" | sort | uniq |</comment>
		<comment type="line">//   sed 's/,//g' | while read s; do echo -e "\t\tcase $s:"; done</comment>
		<comment type="line">// All T_Create... tags from nodes.h:</comment>

		<case>case <expr><name>T_CreateDomainStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateEnumStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateTableGroupStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateTableSpaceStmt</name></expr>:</case>
		<case>case <expr><name>T_DefineStmt</name></expr>:</case> <comment type="line">// CREATE OPERATOR/AGGREGATE/COLLATION/etc</comment>
		<case>case <expr><name>T_CommentStmt</name></expr>:</case> <comment type="line">// COMMENT (create new comment)</comment>
		<case>case <expr><name>T_DiscardStmt</name></expr>:</case> <comment type="line">// DISCARD ALL/SEQUENCES/TEMP affects only objects of current connection</comment>
		<case>case <expr><name>T_RuleStmt</name></expr>:</case> <comment type="line">// CREATE RULE</comment>
		<case>case <expr><name>T_TruncateStmt</name></expr>:</case> <comment type="line">// TRUNCATE changes system catalog in case of non-YB (i.e. TEMP) tables</comment>
		<block>{<block_content>
			<comment type="block">/*
			 * Simple add objects are not breaking changes, and they do not even require
			 * a version increment because we do not do any negative caching for them.
			 */</comment>
			<expr_stmt><expr><operator>*</operator><name>is_catalog_version_increment</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>is_breaking_catalog_change</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
		<case>case <expr><name>T_ViewStmt</name></expr>:</case> <comment type="line">// CREATE VIEW</comment>
		<block>{<block_content>
			<comment type="block">/*
			 * For system catalog additions we need to force cache refresh
			 * because of negative caching of pg_class and pg_type
			 * (see SearchCatCacheMiss).
			 * Concurrent transaction needs not to be aborted though.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>IsYsqlUpgrade</name> <operator>&amp;&amp;</operator>
				<call><name>YbIsSystemNamespaceByName</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>ViewStmt</name></expr></argument>, <argument><expr><name>parsetree</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>view</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>is_breaking_catalog_change</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><operator>*</operator><name>is_catalog_version_increment</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>is_breaking_catalog_change</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
		<case>case <expr><name>T_CreatedbStmt</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>is_catalog_version_increment</name> <operator>=</operator>
				<operator>*</operator><call><name>YBCGetGFlags</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>ysql_enable_read_request_caching</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>is_breaking_catalog_change</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
		<case>case <expr><name>T_CompositeTypeStmt</name></expr>:</case> <comment type="line">// CREATE TYPE</comment>
		<case>case <expr><name>T_CreateAmStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateCastStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateConversionStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateEventTrigStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateExtensionStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateFdwStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateForeignServerStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateForeignTableStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateOpClassItem</name></expr>:</case>
		<case>case <expr><name>T_CreateOpClassStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateOpFamilyStmt</name></expr>:</case>
		<case>case <expr><name>T_CreatePLangStmt</name></expr>:</case>
		<case>case <expr><name>T_CreatePolicyStmt</name></expr>:</case>
		<case>case <expr><name>T_CreatePublicationStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateRangeStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateReplicationSlotCmd</name></expr>:</case>
		<case>case <expr><name>T_CreateRoleStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateSchemaStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateStatsStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateSubscriptionStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateTableAsStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateTransformStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateTrigStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateUserMappingStmt</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/*
			 * Add objects that may reference/alter other objects so we need to increment the
			 * catalog version to ensure the other objects' metadata is refreshed.
			 * This is either for:
			 * 		- objects that may refresh/alter other objects, to maintain
			 *		  such other objects' consistency and keep their metadata
			 *		  fresh
			 *		- objects where we have negative caching enabled in
			 *		  order to correctly invalidate negative cache entries
			 */</comment>
			<expr_stmt><expr><operator>*</operator><name>is_breaking_catalog_change</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
		<case>case <expr><name>T_CreateStmt</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CreateStmt</name></expr></argument>, <argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<comment type="block">/*
			 * If a partition table is being created, this means pg_inherits
			 * table that is being cached should be invalidated. If the cache
			 * is not invalidated here, it is possible that one connection
			 * could create a new partition and insert data into it without
			 * the other connections knowing about this. However, due to
			 * snapshot isolation guarantees, transactions that are already
			 * underway need not abort.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>is_breaking_catalog_change</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * For system catalog additions we need to force cache refresh
			 * because of negative caching of pg_class and pg_type
			 * (see SearchCatCacheMiss).
			 * Concurrent transaction needs not to be aborted though.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>IsYsqlUpgrade</name> <operator>&amp;&amp;</operator>
				<call><name>YbIsSystemNamespaceByName</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>is_breaking_catalog_change</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>stmt-&gt;constraints</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>con</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_FOREIGN</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Increment catalog version as it effectively alters the referenced table.
					 * TODO Technically this could also be a breaking change in case we have
					 * ongoing transactions affecting the referenced table.
					 * But we do not support consistent FK checks (w.r.t concurrent
					 * writes) yet anyway and the (upcoming) online, async
					 * implementation should wait for ongoing transactions so we do not
					 * have to force a transaction abort on PG side.
					 */</comment>
					<expr_stmt><expr><operator>*</operator><name>is_breaking_catalog_change</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>

			<comment type="block">/*
			 * If no FK constraints, this is a simple add object so nothing to
			 * do (due to no negative caching).
			 */</comment>
			<expr_stmt><expr><operator>*</operator><name>is_catalog_version_increment</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>is_breaking_catalog_change</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
		<case>case <expr><name>T_CreateSeqStmt</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CreateSeqStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CreateSeqStmt</name></expr></argument>, <argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<comment type="block">/* Need to increment if owner is set to ensure its dependency cache is updated. */</comment>
			<expr_stmt><expr><operator>*</operator><name>is_breaking_catalog_change</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>ownerId</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>is_catalog_version_increment</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block>
		<case>case <expr><name>T_CreateFunctionStmt</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CreateFunctionStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CreateFunctionStmt</name></expr></argument>, <argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><operator>*</operator><name>is_breaking_catalog_change</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>replace</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>is_catalog_version_increment</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block>

		<comment type="line">// All T_Drop... tags from nodes.h:</comment>
		<case>case <expr><name>T_DropOwnedStmt</name></expr>:</case>
		<case>case <expr><name>T_DropReplicationSlotCmd</name></expr>:</case>
		<case>case <expr><name>T_DropRoleStmt</name></expr>:</case>
		<case>case <expr><name>T_DropSubscriptionStmt</name></expr>:</case>
		<case>case <expr><name>T_DropTableSpaceStmt</name></expr>:</case>
		<case>case <expr><name>T_DropUserMappingStmt</name></expr>:</case>
			<break>break;</break>

		<case>case <expr><name>T_DropStmt</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>is_breaking_catalog_change</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DropdbStmt</name></expr>:</case>
		    <comment type="block">/*
			 * We already invalidate all connections to that DB by dropping it
			 * so nothing to do on the cache side.
			 */</comment>
			<expr_stmt><expr><operator>*</operator><name>is_breaking_catalog_change</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>

		<comment type="line">// All T_Alter... tags from nodes.h:</comment>
		<case>case <expr><name>T_AlterCollationStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterDatabaseSetStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterDatabaseStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterDefaultPrivilegesStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterDomainStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterEnumStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterEventTrigStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterExtensionContentsStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterExtensionStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterFdwStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterForeignServerStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterFunctionStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterObjectDependsStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterObjectSchemaStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterOpFamilyStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterOperatorStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterOwnerStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterPolicyStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterPublicationStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterRoleSetStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterRoleStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterSeqStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterSubscriptionStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterSystemStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterTSConfigurationStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterTSDictionaryStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterTableCmd</name></expr>:</case>
		<case>case <expr><name>T_AlterTableMoveAllStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterTableSpaceOptionsStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterUserMappingStmt</name></expr>:</case>
		<case>case <expr><name>T_AlternativeSubPlan</name></expr>:</case>
		<case>case <expr><name>T_AlternativeSubPlanState</name></expr>:</case>
		<case>case <expr><name>T_ReassignOwnedStmt</name></expr>:</case>
		<comment type="block">/* ALTER .. RENAME TO syntax gets parsed into a T_RenameStmt node. */</comment>
		<case>case <expr><name>T_RenameStmt</name></expr>:</case>
			<break>break;</break>

		<case>case <expr><name>T_AlterTableStmt</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>is_breaking_catalog_change</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<comment type="line">// T_Grant...</comment>
		<case>case <expr><name>T_GrantStmt</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/* Grant (add permission) is not a breaking change, but revoke is. */</comment>
			<decl_stmt><decl><type><name>GrantStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>GrantStmt</name></expr></argument>, <argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><operator>*</operator><name>is_breaking_catalog_change</name> <operator>=</operator> <operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>is_grant</name></name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
		<case>case <expr><name>T_GrantRoleStmt</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/* Grant (add permission) is not a breaking change, but revoke is. */</comment>
			<decl_stmt><decl><type><name>GrantRoleStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>GrantRoleStmt</name></expr></argument>, <argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><operator>*</operator><name>is_breaking_catalog_change</name> <operator>=</operator> <operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>is_grant</name></name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<comment type="line">// T_Index...</comment>
		<case>case <expr><name>T_IndexStmt</name></expr>:</case>
			<comment type="block">/*
			 * For nonconcurrent index backfill we do not guarantee global consistency anyway.
			 * For (new) concurrent backfill the backfill process should wait for ongoing
			 * transactions so we don't have to force a transaction abort on PG side.
			 */</comment>
			<expr_stmt><expr><operator>*</operator><name>is_breaking_catalog_change</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_VacuumStmt</name></expr>:</case>
			<comment type="block">/* Vacuum with analyze updates relation and attribute statistics */</comment>
			<expr_stmt><expr><operator>*</operator><name>is_catalog_version_increment</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>is_breaking_catalog_change</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>is_ddl</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>VacuumStmt</name></expr></argument>, <argument><expr><name>parsetree</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>options</name> <operator>&amp;</operator> <name>VACOPT_ANALYZE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_RefreshMatViewStmt</name></expr>:</case>
			<break>break;</break>

		<case>case <expr><name>T_ReindexStmt</name></expr>:</case>
			<comment type="block">/*
			 * Does not need catalog version increment since only data changes,
			 * not metadata--unless the data itself is metadata (system index).
			 * It could be nice to force a cache refresh when fixing a system
			 * index corruption, but just because a system index is REINDEXed
			 * doesn't mean it had a corruption.  If there's a system index
			 * corruption, manual intervention is already needed, so might as
			 * well let the user deal with refreshing clients.
			 */</comment>
			<expr_stmt><expr><operator>*</operator><name>is_catalog_version_increment</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>is_breaking_catalog_change</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<comment type="block">/* Not a DDL operation. */</comment>
			<expr_stmt><expr><operator>*</operator><name>is_catalog_version_increment</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>is_breaking_catalog_change</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>is_ddl</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * If yb_make_next_ddl_statement_nonbreaking is true, then no DDL statement
	 * will cause a breaking catalog change.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>yb_make_next_ddl_statement_nonbreaking</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>is_breaking_catalog_change</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * For DDL, it does not make sense to get breaking catalog change without
	 * catalog version increment.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>is_ddl</name> <operator>&amp;&amp;</operator>
			 <operator>*</operator><name>is_breaking_catalog_change</name> <operator>&amp;&amp;</operator>
			 <operator>!</operator><operator>*</operator><name>is_catalog_version_increment</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>is_ddl</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>YBTxnDdlProcessUtility</name><parameter_list>(
		<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
		<parameter><decl><type><name>ProcessUtilityContext</name></type> <name>context</name></decl></parameter>,
		<parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
		<parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
		<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
		<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list> <block>{<block_content>

	<comment type="block">/* Assuming this is a breaking change by default. */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_catalog_version_increment</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_breaking_catalog_change</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_txn_ddl</name> <init>= <expr><call><name>IsTransactionalDdlStatement</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>,
	                                              <argument><expr><operator>&amp;</operator><name>is_catalog_version_increment</name></expr></argument>,
	                                              <argument><expr><operator>&amp;</operator><name>is_breaking_catalog_change</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_txn_ddl</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>YBIncrementDdlNestingLevel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>prev_ProcessUtility</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>prev_ProcessUtility</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
								<argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
								<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>standard_ProcessUtility</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
									<argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
									<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>is_txn_ddl</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/*
			 * It is possible that nesting_level has wrong value due to error.
			 * Ddl transaction state should be reset.
			 */</comment>
			<expr_stmt><expr><call><name>YBResetDdlState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>is_txn_ddl</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>YBDecrementDdlNestingLevel</name><argument_list>(<argument><expr><name>is_catalog_version_increment</name></expr></argument>, <argument><expr><name>is_breaking_catalog_change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>YBCInstallTxnDdlHook</name><parameter_list>()</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>YBCIsInitDbModeEnvVarSet</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>prev_ProcessUtility</name> <operator>=</operator> <name>ProcessUtility_hook</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ProcessUtility_hook</name> <operator>=</operator> <name>YBTxnDdlProcessUtility</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>buffering_nesting_level</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<function><type><name>void</name></type> <name>YBBeginOperationsBuffering</name><parameter_list>()</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>++</operator><name>buffering_nesting_level</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgStartOperationsBuffering</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>YBEndOperationsBuffering</name><parameter_list>()</parameter_list> <block>{<block_content>
	<comment type="line">// buffering_nesting_level could be 0 because YBResetOperationsBuffering was called</comment>
	<comment type="line">// on starting new query and postgres calls standard_ExecutorFinish on non finished executor</comment>
	<comment type="line">// from previous failed query.</comment>
	<if_stmt><if>if <condition>(<expr><name>buffering_nesting_level</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>--</operator><name>buffering_nesting_level</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgStopOperationsBuffering</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>YBResetOperationsBuffering</name><parameter_list>()</parameter_list> <block>{<block_content>
	<expr_stmt><expr><name>buffering_nesting_level</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>YBCPgResetOperationsBuffering</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>YBFlushBufferedOperations</name><parameter_list>()</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgFlushBufferedOperations</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>YBGetAndResetOperationFlushRpcStats</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>count</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>wait_time</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>YBCPgGetAndResetOperationFlushRpcStats</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>wait_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>YBReadFromFollowersEnabled</name><parameter_list>()</parameter_list> <block>{<block_content>
  <return>return <expr><name>yb_read_from_followers</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>YBFollowerReadStalenessMs</name><parameter_list>()</parameter_list> <block>{<block_content>
  <return>return <expr><name>yb_follower_read_staleness_ms</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>YBCPgYBTupleIdDescriptor</name><modifier>*</modifier></type> <name>YBCCreateYBTupleIdDescriptor</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>db_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>table_oid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nattrs</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>mem</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>YBCPgYBTupleIdDescriptor</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nattrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>YBCPgAttrValueDescriptor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YBCPgYBTupleIdDescriptor</name><modifier>*</modifier></type> <name>result</name> <init>= <expr><name>mem</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nattrs</name></name> <operator>=</operator> <name>nattrs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>attrs</name></name> <operator>=</operator> <name>mem</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>YBCPgYBTupleIdDescriptor</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>database_oid</name></name> <operator>=</operator> <name>db_oid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>table_oid</name></name> <operator>=</operator> <name>table_oid</name></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>YBCFillUniqueIndexNullAttribute</name><parameter_list>(<parameter><decl><type><name>YBCPgYBTupleIdDescriptor</name><modifier>*</modifier></type> <name>descr</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>YBCPgAttrValueDescriptor</name><modifier>*</modifier></type> <name>last_attr</name> <init>= <expr><name><name>descr</name><operator>-&gt;</operator><name>attrs</name></name> <operator>+</operator> <name><name>descr</name><operator>-&gt;</operator><name>nattrs</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>last_attr</name><operator>-&gt;</operator><name>attr_num</name></name> <operator>=</operator> <name>YBUniqueIdxKeySuffixAttributeNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>last_attr</name><operator>-&gt;</operator><name>type_entity</name></name> <operator>=</operator> <call><name>YbDataTypeFromOidMod</name><argument_list>(<argument><expr><name>YBUniqueIdxKeySuffixAttributeNumber</name></expr></argument>, <argument><expr><name>BYTEAOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>last_attr</name><operator>-&gt;</operator><name>collation_id</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>last_attr</name><operator>-&gt;</operator><name>is_null</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>YbTestGucBlockWhileStrEqual</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>actual</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>expected</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>kSpinWaitMs</name> <init>= <expr><literal type="number">100</literal></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>*</operator><name>actual</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"blocking %s for %dms"</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>kSpinWaitMs</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhidecontext</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>kSpinWaitMs</name> <operator>*</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Reload config in hopes that guc var actual changed. */</comment>
		<if_stmt><if>if <condition>(<expr><name>ConfigReloadPending</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ConfigReloadPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>YbGetNumberOfFunctionOutputColumns</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>func_oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ncols</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Equals to the number of OUT arguments. */</comment>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>proctup</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>func_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>func_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>is_null</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>proargmodes</name> <init>= <expr><call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>proctup</name></expr></argument>,
										<argument><expr><name>Anum_pg_proc_proargmodes</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>ArrayType</name><modifier>*</modifier></type> <name>proargmodes_arr</name> <init>= <expr><call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>proargmodes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>ncols</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>proargmodes_arr</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>proargmodes_arr</name></expr></argument>)</argument_list></call><index>[<expr><name>i</name></expr>]</index> <operator>==</operator> <name>PROARGMODE_OUT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>++</operator><name>ncols</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ncols</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * For backward compatibility, this function dynamically adapts to the number
 * of output columns defined in pg_proc.
 */</comment>
<function><type><name>Datum</name></type>
<name>yb_servers</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>expected_ncols</name> <init>= <expr><literal type="number">9</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>ncols</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>ncols</name> <operator>&lt;</operator> <name>expected_ncols</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ncols</name> <operator>=</operator> <call><name>YbGetNumberOfFunctionOutputColumns</name><argument_list>(<argument><expr><literal type="number">8019</literal></expr></argument> <comment type="block">/* yb_servers function
												   oid hardcoded in pg_proc.dat */</comment>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>ncols</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>,
						   <argument><expr><literal type="string">"host"</literal></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>,
						   <argument><expr><literal type="string">"port"</literal></expr></argument>, <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>,
						   <argument><expr><literal type="string">"num_connections"</literal></expr></argument>, <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">4</literal></expr></argument>,
						   <argument><expr><literal type="string">"node_type"</literal></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">5</literal></expr></argument>,
						   <argument><expr><literal type="string">"cloud"</literal></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">6</literal></expr></argument>,
						   <argument><expr><literal type="string">"region"</literal></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">7</literal></expr></argument>,
						   <argument><expr><literal type="string">"zone"</literal></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">8</literal></expr></argument>,
						   <argument><expr><literal type="string">"public_ip"</literal></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ncols</name> <operator>&gt;=</operator> <name>expected_ncols</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">9</literal></expr></argument>,
							   <argument><expr><literal type="string">"uuid"</literal></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>YBCServerDescriptor</name> <modifier>*</modifier></type><name>servers</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>numservers</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCGetTabletServerHosts</name><argument_list>(<argument><expr><operator>&amp;</operator><name>servers</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numservers</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>max_calls</name></name> <operator>=</operator> <name>numservers</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <name>servers</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>funcctx</name><operator>-&gt;</operator><name>call_cntr</name></name> <operator>&lt;</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>max_calls</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>ncols</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>ncols</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>cntr</name> <init>= <expr><name><name>funcctx</name><operator>-&gt;</operator><name>call_cntr</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>YBCServerDescriptor</name> <modifier>*</modifier></type><name>server</name> <init>= <expr><operator>(</operator><name>YBCServerDescriptor</name> <operator>*</operator><operator>)</operator><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>+</operator> <name>cntr</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>is_primary</name> <init>= <expr><name><name>server</name><operator>-&gt;</operator><name>is_primary</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>node_type</name> <init>= <expr><ternary><condition><expr><name>is_primary</name></expr> ?</condition><then> <expr><literal type="string">"primary"</literal></expr> </then><else>: <expr><literal type="string">"read_replica"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<comment type="line">// TODO: Remove hard coding of port and num_connections</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>server</name><operator>-&gt;</operator><name>host</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>server</name><operator>-&gt;</operator><name>pg_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>node_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>server</name><operator>-&gt;</operator><name>cloud</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>server</name><operator>-&gt;</operator><name>region</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>server</name><operator>-&gt;</operator><name>zone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>server</name><operator>-&gt;</operator><name>public_ip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ncols</name> <operator>&gt;=</operator> <name>expected_ncols</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>server</name><operator>-&gt;</operator><name>uuid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>YBIsSupportedLibcLocale</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>localebuf</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="block">/*
	 * For libc mode, Yugabyte only supports the basic locales.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>localebuf</name></expr></argument>, <argument><expr><literal type="string">"C"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>localebuf</name></expr></argument>, <argument><expr><literal type="string">"POSIX"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>localebuf</name></expr></argument>, <argument><expr><literal type="string">"en_US.utf8"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		   <call><name>strcasecmp</name><argument_list>(<argument><expr><name>localebuf</name></expr></argument>, <argument><expr><literal type="string">"en_US.UTF-8"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>YBCStatus</name></type>
<name>YbGetTablePropertiesCommon</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>yb_table_properties</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Already loaded, nothing to do */</comment>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>dbid</name>          <init>= <expr><call><name>YBCGetDatabaseOid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>storage_relid</name> <init>= <expr><call><name>YbGetStorageRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>YBCPgTableDesc</name></type> <name>desc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YBCStatus</name></type> <name>status</name> <init>= <expr><call><name>YBCPgGetTableDesc</name><argument_list>(<argument><expr><name>dbid</name></expr></argument>, <argument><expr><name>storage_relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>desc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>status</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>status</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Relcache entry data must live in CacheMemoryContext */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>yb_table_properties</name></name> <operator>=</operator>
		<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>YbTablePropertiesData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>YBCPgGetTableProperties</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>yb_table_properties</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>YbTableProperties</name></type>
<name>YbGetTableProperties</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YbGetTablePropertiesCommon</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>rel</name><operator>-&gt;</operator><name>yb_table_properties</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>YbTableProperties</name></type>
<name>YbGetTablePropertiesById</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name>     <init>= <expr><call><name>RelationIdGetRelation</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YbGetTablePropertiesCommon</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>relation</name><operator>-&gt;</operator><name>yb_table_properties</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>YbTableProperties</name></type>
<name>YbTryGetTableProperties</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>not_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>HandleYBStatusIgnoreNotFound</name><argument_list>(<argument><expr><call><name>YbGetTablePropertiesCommon</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>not_found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><ternary><condition><expr><name>not_found</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name><name>rel</name><operator>-&gt;</operator><name>yb_table_properties</name></name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>yb_hash_code</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Create buffer for hashing */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg_buf</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PG_NARGS</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>	<name>argtype</name> <init>= <expr><call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>argtype</name> <operator>==</operator> <name>UNKNOWNOID</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDETERMINATE_DATATYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"undefined datatype given to yb_hash_code"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>size_t</name></type> <name>typesize</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>YBCPgTypeEntity</name> <modifier>*</modifier></type><name>typeentity</name> <init>=
				 <expr><call><name>YbDataTypeFromOidMod</name><argument_list>(<argument><expr><name>InvalidAttrNumber</name></expr></argument>, <argument><expr><name>argtype</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>YBCStatus</name></type> <name>status</name> <init>= <expr><call><name>YBCGetDocDBKeySize</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>typeentity</name></expr></argument>,
							<argument><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>typesize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>YBCFreeStatus</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unsupported datatype given to yb_hash_code"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Only types supported by HASH key columns are allowed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use explicit casts to ensure input types are as desired"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>size</name> <operator>+=</operator> <name>typesize</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>arg_buf</name> <operator>=</operator> <call><name>alloca</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* TODO(Tanuj): Look into caching the above buffer */</comment>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg_buf_pos</name> <init>= <expr><name>arg_buf</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>size_t</name></type> <name>total_bytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PG_NARGS</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>	<name>argtype</name> <init>= <expr><call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>YBCPgTypeEntity</name> <modifier>*</modifier></type><name>typeentity</name> <init>=
				 <expr><call><name>YbDataTypeFromOidMod</name><argument_list>(<argument><expr><name>InvalidAttrNumber</name></expr></argument>, <argument><expr><name>argtype</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>written</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>YBCStatus</name></type> <name>status</name> <init>= <expr><call><name>YBCAppendDatumToKey</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>typeentity</name></expr></argument>,
							<argument><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg_buf_pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>written</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>YBCFreeStatus</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unsupported datatype given to yb_hash_code"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Only types supported by HASH key columns are allowed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use explicit casts to ensure input types are as desired"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>arg_buf_pos</name> <operator>+=</operator> <name>written</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>total_bytes</name> <operator>+=</operator> <name>written</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* hash the contents of the buffer and return */</comment>
	<decl_stmt><decl><type><name>uint16_t</name></type> <name>hashed_val</name> <init>= <expr><call><name>YBCCompoundHash</name><argument_list>(<argument><expr><name>arg_buf</name></expr></argument>, <argument><expr><name>total_bytes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_UINT16</name><argument_list>(<argument><expr><name>hashed_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * For backward compatibility, this function dynamically adapts to the number
 * of output columns defined in pg_proc.
 */</comment>
<function><type><name>Datum</name></type>
<name>yb_table_properties</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>expected_ncols</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>ncols</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>ncols</name> <operator>&lt;</operator> <name>expected_ncols</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ncols</name> <operator>=</operator> <call><name>YbGetNumberOfFunctionOutputColumns</name><argument_list>(<argument><expr><literal type="number">8033</literal></expr></argument> <comment type="block">/* yb_table_properties function
												   oid hardcoded in pg_proc.dat */</comment>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>ncols</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>ncols</name></expr>]</index></name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>YbTableProperties</name></type> <name>yb_props</name> <init>= <expr><call><name>YbTryGetTableProperties</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>ncols</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>,
					   <argument><expr><literal type="string">"num_tablets"</literal></expr></argument>, <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>,
					   <argument><expr><literal type="string">"num_hash_key_columns"</literal></expr></argument>, <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>,
					   <argument><expr><literal type="string">"is_colocated"</literal></expr></argument>, <argument><expr><name>BOOLOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ncols</name> <operator>&gt;=</operator> <name>expected_ncols</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">4</literal></expr></argument>,
						   <argument><expr><literal type="string">"tablegroup_oid"</literal></expr></argument>, <argument><expr><name>OIDOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">5</literal></expr></argument>,
						   <argument><expr><literal type="string">"colocation_id"</literal></expr></argument>, <argument><expr><name>OIDOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>yb_props</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>yb_props</name><operator>-&gt;</operator><name>num_tablets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>yb_props</name><operator>-&gt;</operator><name>num_hash_key_columns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>yb_props</name><operator>-&gt;</operator><name>is_colocated</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ncols</name> <operator>&gt;=</operator> <name>expected_ncols</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator>
				<ternary><condition><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>yb_props</name><operator>-&gt;</operator><name>tablegroup_oid</name></name></expr></argument>)</argument_list></call></expr>
					?</condition><then> <expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>yb_props</name><operator>-&gt;</operator><name>tablegroup_oid</name></name></expr></argument>)</argument_list></call></expr>
					</then><else>: <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator>
				<ternary><condition><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>yb_props</name><operator>-&gt;</operator><name>colocation_id</name></name></expr></argument>)</argument_list></call></expr>
					?</condition><then> <expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>yb_props</name><operator>-&gt;</operator><name>colocation_id</name></name></expr></argument>)</argument_list></call></expr>
					</then><else>: <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ncols</name> <operator>&gt;=</operator> <name>expected_ncols</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>yb_props</name><operator>-&gt;</operator><name>tablegroup_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>yb_props</name><operator>-&gt;</operator><name>colocation_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Table does not exist in YB, set nulls for all columns. */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This function is adapted from code of PQescapeLiteral() in fe-exec.c.
 * Convert a string value to an SQL string literal and append it to
 * the given StringInfo.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendStringLiteral</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_quotes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_backslashes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> 		<name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>input_len</name></decl>;</decl_stmt>

	<comment type="block">/* Scan the string for characters that must be escaped. */</comment>
	<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>str</name></expr>;</init> <condition><expr><operator>(</operator><name>s</name> <operator>-</operator> <name>str</name><operator>)</operator> <operator>&lt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><operator>++</operator><name>s</name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>++</operator><name>num_quotes</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>++</operator><name>num_backslashes</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>charlen</name></decl>;</decl_stmt>

			<comment type="block">/* Slow path for possible multibyte characters */</comment>
			<expr_stmt><expr><name>charlen</name> <operator>=</operator> <call><name>pg_encoding_mblen</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Multibyte character overruns allowable length. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>s</name> <operator>-</operator> <name>str</name><operator>)</operator> <operator>+</operator> <name>charlen</name> <operator>&gt;</operator> <name>len</name> <operator>||</operator> <call><name>memchr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>charlen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"incomplete multibyte character"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Adjust s, bearing in mind that for loop will increment it. */</comment>
			<expr_stmt><expr><name>s</name> <operator>+=</operator> <name>charlen</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>input_len</name> <operator>=</operator> <name>s</name> <operator>-</operator> <name>str</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we are escaping a literal that contains backslashes, we use the
	 * escape string syntax so that the result is correct under either value
	 * of standard_conforming_strings.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>num_backslashes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'E'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Opening quote. */</comment>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Use fast path if possible.
	 *
	 * We've already verified that the input string is well-formed in the
	 * current encoding.  If it contains no quotes and, in the case of
	 * literal-escaping, no backslashes, then we can just copy it directly to
	 * the output buffer, adding the necessary quotes.
	 *
	 * If not, we must rescan the input and process each character
	 * individually.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>num_quotes</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>num_backslashes</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>str</name></expr>;</init> <condition><expr><name>s</name> <operator>-</operator> <name>str</name> <operator>&lt;</operator> <name>input_len</name></expr>;</condition> <incr><expr><operator>++</operator><name>s</name></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\''</literal> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>	<name>charlen</name> <init>= <expr><call><name>pg_encoding_mblen</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>--</operator><name>charlen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
					<expr_stmt><expr><operator>++</operator><name>s</name></expr>;</expr_stmt>		<comment type="block">/* for loop will provide the final increment */</comment>
				</block_content>}</block></while>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Closing quote. */</comment>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This function is adapted from code in pg_dump.c.
 * It converts an internal raw datum value to a output string based on
 * column type, and append the string to the StringInfo input parameter.
 * Datum of all types can be generated in a quoted string format
 * (e.g., '100' for integer 100), and rely on PG's type cast to function
 * correctly. Here, we specifically handle some cases to ignore quotes to
 * make the generated string look better.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendDatumToString</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>datum</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>datum_str</name> <init>= <expr><call><name>YBDatumToString</name><argument_list>(<argument><expr><name>datum</name></expr></argument>, <argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<switch>switch <condition>(<expr><name>typid</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INT2OID</name></expr>:</case>
		<case>case <expr><name>INT4OID</name></expr>:</case>
		<case>case <expr><name>INT8OID</name></expr>:</case>
		<case>case <expr><name>OIDOID</name></expr>:</case>
		<case>case <expr><name>FLOAT4OID</name></expr>:</case>
		<case>case <expr><name>FLOAT8OID</name></expr>:</case>
		<case>case <expr><name>NUMERICOID</name></expr>:</case>
			<comment type="block">/*
			 * These types are converted to string without quotes unless
			 * they contain values: Infinity and NaN.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strspn</name><argument_list>(<argument><expr><name>datum_str</name></expr></argument>, <argument><expr><literal type="string">"0123456789 +-eE."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>datum_str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>datum_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"'%s'"</literal></expr></argument>, <argument><expr><name>datum_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<comment type="block">/*
		 * Currently, cannot create tables/indexes with a key containing
		 * type 'BIT' or 'VARBIT'.
		 */</comment>
		<case>case <expr><name>BITOID</name></expr>:</case>
		<case>case <expr><name>VARBITOID</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type: %s not yet supported"</literal></expr></argument>,
							<argument><expr><call><name>YBPgTypeOidToStr</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* All other types are appended as string literals. */</comment>
			<expr_stmt><expr><call><name>appendStringLiteral</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>datum_str</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * This function gets range relations' split point values as PG datums.
 * It also stores key columns' data types in input parameters: pkeys_atttypid.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>getSplitPointsInfo</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>YBCPgTableDesc</name></type> <name>yb_tabledesc</name></decl></parameter>,
				   <parameter><decl><type><name>YbTableProperties</name></type> <name>yb_table_properties</name></decl></parameter>,
				   <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>pkeys_atttypid</name></decl></parameter>,
				   <parameter><decl><type><name>YBCPgSplitDatum</name> <modifier>*</modifier></type><name>split_datums</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>has_null</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>yb_table_properties</name><operator>-&gt;</operator><name>num_tablets</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get key columns' YBCPgTypeEntity and YBCPgTypeAttrs */</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>num_range_key_columns</name> <init>= <expr><name><name>yb_table_properties</name><operator>-&gt;</operator><name>num_range_key_columns</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>YBCPgTypeEntity</name> <modifier>*</modifier></type><name><name>type_entities</name><index>[<expr><name>num_range_key_columns</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YBCPgTypeAttrs</name></type> <name><name>type_attrs_arr</name><index>[<expr><name>num_range_key_columns</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupledesc</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>pkey</name> <init>= <expr><call><name>YBGetTablePrimaryKeyBms</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>attr_offset</name> <init>= <expr><call><name>YBGetFirstLowInvalidAttributeNumber</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>key_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupledesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupledesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* Key column */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attnum</name></name> <operator>-</operator> <name>attr_offset</name></expr></argument>, <argument><expr><name>pkey</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>type_entities</name><index>[<expr><name>key_idx</name></expr>]</index></name> <operator>=</operator> <call><name>YbDataTypeFromOidMod</name><argument_list>(<argument><expr><name>InvalidAttrNumber</name></expr></argument>,
														  <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>YBCPgTypeAttrs</name></type> <name>type_attrs</name></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>type_attrs</name><operator>.</operator><name>typmod</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>type_attrs_arr</name><index>[<expr><name>key_idx</name></expr>]</index></name> <operator>=</operator> <name>type_attrs</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pkeys_atttypid</name><index>[<expr><name>key_idx</name></expr>]</index></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>++</operator><name>key_idx</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Get Split point values as Postgres datums */</comment>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCGetSplitPoints</name><argument_list>(<argument><expr><name>yb_tabledesc</name></expr></argument>, <argument><expr><name>type_entities</name></expr></argument>,
									 <argument><expr><name>type_attrs_arr</name></expr></argument>, <argument><expr><name>split_datums</name></expr></argument>, <argument><expr><name>has_null</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This function constructs SPLIT AT VALUES clause for range-partitioned tables
 * with more than one tablet.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>rangeSplitClause</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>YBCPgTableDesc</name></type> <name>yb_tabledesc</name></decl></parameter>,
				 <parameter><decl><type><name>YbTableProperties</name></type> <name>yb_table_properties</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>str</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>yb_table_properties</name><operator>-&gt;</operator><name>num_tablets</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>num_range_key_columns</name> <init>= <expr><name><name>yb_table_properties</name><operator>-&gt;</operator><name>num_range_key_columns</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>num_splits</name> <init>= <expr><name><name>yb_table_properties</name><operator>-&gt;</operator><name>num_tablets</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name><name>pkeys_atttypid</name><index>[<expr><name>num_range_key_columns</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YBCPgSplitDatum</name></type> <name><name>split_datums</name><index>[<expr><name>num_splits</name> <operator>*</operator> <name>num_range_key_columns</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>prev_split_point</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>cur_split_point</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>has_null</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Get Split point values as Postgres datum */</comment>
	<expr_stmt><expr><call><name>getSplitPointsInfo</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>yb_tabledesc</name></expr></argument>, <argument><expr><name>yb_table_properties</name></expr></argument>, <argument><expr><name>pkeys_atttypid</name></expr></argument>,
					   <argument><expr><name>split_datums</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>has_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check for existence of NULL in split points.
	 * We don't support specify NULL in SPLIT AT VALUES clause for both
	 * CREATE TABLE and CREATE INDEX.
	 * However, split points of indexes generated by tablet splitting can have
	 * NULLs in its split points.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>has_null</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"NULL value present in split points"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Specifying NULL value in SPLIT AT VALUES clause is "</literal>
						   <literal type="string">"not supported."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Process Datum and use StringInfo to accumulate c-string data */</comment>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"SPLIT AT VALUES ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>split_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>split_idx</name> <operator>&lt;</operator> <name>num_splits</name></expr>;</condition> <incr><expr><operator>++</operator><name>split_idx</name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>split_idx</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>cur_split_point</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>col_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>col_idx</name> <operator>&lt;</operator> <name>num_range_key_columns</name></expr>;</condition> <incr><expr><operator>++</operator><name>col_idx</name></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>col_idx</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>cur_split_point</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>split_datum_idx</name> <init>= <expr><name>split_idx</name> <operator>*</operator> <name>num_range_key_columns</name> <operator>+</operator> <name>col_idx</name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>split_datums</name><index>[<expr><name>split_datum_idx</name></expr>]</index></name><operator>.</operator><name>datum_kind</name> <operator>==</operator>
				<name>YB_YQL_DATUM_LIMIT_MIN</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Min boundary */</comment>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>cur_split_point</name></expr></argument>, <argument><expr><literal type="string">"MINVALUE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>split_datums</name><index>[<expr><name>split_datum_idx</name></expr>]</index></name><operator>.</operator><name>datum_kind</name> <operator>==</operator>
					 <name>YB_YQL_DATUM_LIMIT_MAX</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Max boundary */</comment>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>cur_split_point</name></expr></argument>, <argument><expr><literal type="string">"MAXVALUE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Actual datum value */</comment>
				<expr_stmt><expr><call><name>appendDatumToString</name><argument_list>(<argument><expr><name>cur_split_point</name></expr></argument>,
									<argument><expr><name><name>split_datums</name><index>[<expr><name>split_datum_idx</name></expr>]</index></name><operator>.</operator><name>datum</name></expr></argument>,
									<argument><expr><name><name>pkeys_atttypid</name><index>[<expr><name>col_idx</name></expr>]</index></name></expr></argument>,
									<argument><expr><call><name>pg_get_client_encoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>cur_split_point</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check for duplicate split points.
		 * Given current syntax of SPLIT AT VALUES doesn't allow specifying
		 * hidden column values for indexes, and tablet splitting can
		 * happen on hidden columns of indexes,
		 * duplicate split points (excluding the hidden column)
		 * can happen for indexes.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>cur_split_point</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>prev_split_point</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WARNING</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duplicate split points in SPLIT AT VALUES clause "</literal>
							<literal type="string">"of relation with oid %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Empty string if duplicate split points exist. */</comment>
			<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>cur_split_point</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name>prev_split_point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>prev_split_point</name></expr></argument>, <argument><expr><name><name>cur_split_point</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name>cur_split_point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>yb_get_range_split_clause</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>exists_in_yb</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YBCPgTableDesc</name></type> <name>yb_tabledesc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YbTablePropertiesData</name></type> <name>yb_table_properties</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>range_split_clause</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgTableExists</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exists_in_yb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>exists_in_yb</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"relation with oid %u is not backed by YB"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgGetTableDesc</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yb_tabledesc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgGetTableProperties</name><argument_list>(<argument><expr><name>yb_tabledesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yb_table_properties</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>yb_table_properties</name><operator>.</operator><name>num_hash_key_columns</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"relation with oid %u is not range-partitioned"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Get SPLIT AT VALUES clause for range relations with more than one tablet.
	 * Skip one-tablet range-partition relations such that this function
	 * return an empty string for them.
	 */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>yb_table_properties</name><operator>.</operator><name>num_tablets</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>rangeSplitClause</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>yb_tabledesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yb_table_properties</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>range_split_clause</name> <operator>=</operator> <name><name>str</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>range_split_clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type>
<name>yb_fetch_current_transaction_priority</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TxnPriorityRequirement</name></type> <name>txn_priority_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>				   <name>txn_priority</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type>			   <name><name>buf</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>txn_priority_type</name> <operator>=</operator> <call><name>YBCGetTransactionPriorityType</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>txn_priority</name>	  <operator>=</operator> <call><name>YBCGetTransactionPriority</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>txn_priority_type</name> <operator>==</operator> <name>kHighestPriority</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Highest priority transaction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>txn_priority_type</name> <operator>==</operator> <name>kHigherPriorityRange</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><literal type="string">"%.9lf (High priority transaction)"</literal></expr></argument>, <argument><expr><name>txn_priority</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><literal type="string">"%.9lf (Normal priority transaction)"</literal></expr></argument>, <argument><expr><name>txn_priority</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>yb_get_current_transaction_priority</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><call><name>yb_fetch_current_transaction_priority</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>yb_get_effective_transaction_isolation_level</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><call><name>yb_fetch_effective_transaction_isolation_level</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>yb_is_database_colocated</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>MyDatabaseColocated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This function serves mostly as a helper for YSQL migration to introduce
 * pg_yb_catalog_version table without breaking version continuity.
 */</comment>
<function><type><name>Datum</name></type>
<name>yb_catalog_version</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_UINT64</name><argument_list>(<argument><expr><call><name>YbGetMasterCatalogVersion</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>yb_is_local_table</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>tableOid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Fetch required info about the relation */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>tableOid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>tablespaceId</name> <init>= <expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltablespace</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isTempTable</name> <init>=
		<expr><operator>(</operator><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Temp tables are local. */</comment>
	<if_stmt><if>if <condition>(<expr><name>isTempTable</name></expr>)</condition>
	<block>{<block_content>
			<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>GeolocationDistance</name></type> <name>distance</name> <init>= <expr><call><name>get_tablespace_distance</name><argument_list>(<argument><expr><name>tablespaceId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>distance</name> <operator>==</operator> <name>REGION_LOCAL</name> <operator>||</operator> <name>distance</name> <operator>==</operator> <name>ZONE_LOCAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>yb_server_region</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>current_region</name> <init>= <expr><call><name>YBGetCurrentRegion</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>current_region</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>current_region</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>yb_server_cloud</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>current_cloud</name> <init>= <expr><call><name>YBGetCurrentCloud</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>current_cloud</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>current_cloud</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>yb_server_zone</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>current_zone</name> <init>= <expr><call><name>YBGetCurrentZone</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>current_zone</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>current_zone</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*---------------------------------------------------------------------------*/</comment>
<comment type="block">/* Deterministic DETAIL order                                                */</comment>
<comment type="block">/*---------------------------------------------------------------------------*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>yb_detail_sort_comparator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>a</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>b</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>lines</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>length</name></decl>;</decl_stmt>
}</block></struct></type> <name>DetailSorter</name>;</typedef>

<function><type><name>void</name></type> <name>detail_sorter_from_list</name><parameter_list>(<parameter><decl><type><name>DetailSorter</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>litems</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>capacity</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>lines</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>capacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>litems</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>length</name></name> <operator>&lt;</operator> <name>capacity</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>lines</name><index>[<expr><name><name>v</name><operator>-&gt;</operator><name>length</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>detail_sorter_lines_sorted</name><parameter_list>(<parameter><decl><type><name>DetailSorter</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>lines</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>length</name></name></expr></argument>,
		<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>yb_detail_sort_comparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>v</name><operator>-&gt;</operator><name>lines</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>detail_sorter_free</name><parameter_list>(<parameter><decl><type><name>DetailSorter</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>lines</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type><name>YBDetailSorted</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>input</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>input</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// this delimiter is hard coded in backend/catalog/pg_shdepend.c,</comment>
	<comment type="line">// inside of the storeObjectDescription function:</comment>
	<decl_stmt><decl><type><name>char</name></type> <name><name>delimiter</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><literal type="string">"\n"</literal></expr></init></decl>;</decl_stmt>

	<comment type="line">// init stringinfo used for concatenation of the output:</comment>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>s</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// this list stores the non-empty tokens, extra counter to know how many:</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>line_store</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>line_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>strtok</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><name>delimiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>token</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>line_store</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>line_store</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>line_count</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>delimiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<decl_stmt><decl><type><name>DetailSorter</name></type> <name>sorter</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>detail_sorter_from_list</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sorter</name></expr></argument>, <argument><expr><name>line_store</name></expr></argument>, <argument><expr><name>line_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>line_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// put the original input in:</comment>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>sortedLines</name> <init>= <expr><call><name>detail_sorter_lines_sorted</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sorter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>line_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>sortedLines</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>delimiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name><name>sortedLines</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>detail_sorter_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sorter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>line_store</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>s</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This function is adapted from code in varlena.c.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type>
<name>YBComputeNonCSortKey</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>collation_id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>bytes</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="block">/*
	 * We expect collation_id is a valid non-C collation.
	 */</comment>
	<decl_stmt><decl><type><name>pg_locale_t</name></type> <name>locale</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>collation_id</name> <operator>!=</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>locale</name> <operator>=</operator> <call><name>pg_newlocale_from_collation</name><argument_list>(<argument><expr><name>collation_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>locale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>kTextBufLen</name> <init>= <expr><literal type="number">1024</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type> <name>bsize</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_icu_provider</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>buflen1</name> <init>= <expr><name>bytes</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>buf1</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><name>buflen1</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>buf2</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><name>kTextBufLen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>buflen2</name> <init>= <expr><name>kTextBufLen</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf1</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf1</name><index>[<expr><name>buflen1</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ICU</name></cpp:ifdef>
	<decl_stmt><decl><type><name>int32_t</name></type>		<name>ulen</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UChar</name>	   <modifier>*</modifier></type><name>uchar</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ICU</name></cpp:ifdef>
	<comment type="block">/* When using ICU, convert string to UChar. */</comment>
	<if_stmt><if>if <condition>(<expr><name>locale</name> <operator>&amp;&amp;</operator> <name><name>locale</name><operator>-&gt;</operator><name>provider</name></name> <operator>==</operator> <name>COLLPROVIDER_ICU</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>is_icu_provider</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ulen</name> <operator>=</operator> <call><name>icu_to_uchar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uchar</name></expr></argument>, <argument><expr><name>buf1</name></expr></argument>, <argument><expr><name>buflen1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Loop: Call strxfrm() or ucol_getSortKey(), possibly enlarge buffer,
	 * and try again.  Both of these functions have the result buffer
	 * content undefined if the result did not fit, so we need to retry
	 * until everything fits.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ICU</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>locale</name> <operator>&amp;&amp;</operator> <name><name>locale</name><operator>-&gt;</operator><name>provider</name></name> <operator>==</operator> <name>COLLPROVIDER_ICU</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>bsize</name> <operator>=</operator> <call><name>ucol_getSortKey</name><argument_list>(<argument><expr><name><name>locale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>icu</name><operator>.</operator><name>ucol</name></name></expr></argument>,
									<argument><expr><name>uchar</name></expr></argument>, <argument><expr><name>ulen</name></expr></argument>,
									<argument><expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator> <name>buf2</name></expr></argument>, <argument><expr><name>buflen2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
		if <condition>(<expr><name>locale</name> <operator>&amp;&amp;</operator> <name><name>locale</name><operator>-&gt;</operator><name>provider</name></name> <operator>==</operator> <name>COLLPROVIDER_LIBC</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>bsize</name> <operator>=</operator> <call><name>strxfrm_l</name><argument_list>(<argument><expr><name>buf2</name></expr></argument>, <argument><expr><name>buf1</name></expr></argument>, <argument><expr><name>buflen2</name></expr></argument>, <argument><expr><name><name>locale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><name>bsize</name> <operator>=</operator> <call><name>strxfrm</name><argument_list>(<argument><expr><name>buf2</name></expr></argument>, <argument><expr><name>buf1</name></expr></argument>, <argument><expr><name>buflen2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>bsize</name> <operator>&lt;</operator> <name>buflen2</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Grow buffer and retry.
		 */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buf2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buflen2</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>bsize</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>buflen2</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>MaxAllocSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf2</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>buflen2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ICU</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>uchar</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>uchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buf1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>is_icu_provider</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bsize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		 * Each sort key ends with one \0 byte and does not contain any
		 * other \0 byte. The terminating \0 byte is included in bsize.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf2</name><index>[<expr><name>bsize</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bsize</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		 * Both strxfrm and strxfrm_l return the length of the transformed
		 * string not including the terminating \0 byte.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf2</name><index>[<expr><name>bsize</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>buf2</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>YBGetCollationInfo</name><parameter_list>(
	<parameter><decl><type><name>Oid</name></type> <name>collation_id</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>YBCPgTypeEntity</name> <modifier>*</modifier></type><name>type_entity</name></decl></parameter>,
	<parameter><decl><type><name>Datum</name></type> <name>datum</name></decl></parameter>,
	<parameter><decl><type><name>bool</name></type> <name>is_null</name></decl></parameter>,
	<parameter><decl><type><name>YBCPgCollationInfo</name> <modifier>*</modifier></type><name>collation_info</name></decl></parameter>)</parameter_list> <block>{<block_content>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>type_entity</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>collation_id</name> <operator>==</operator> <name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>collation_info</name><operator>-&gt;</operator><name>collate_is_valid_non_c</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>collation_info</name><operator>-&gt;</operator><name>sortkey</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>type_entity</name><operator>-&gt;</operator><name>yb_type</name></name> <operator>!=</operator> <name>YB_YQL_DATA_TYPE_STRING</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * A character array type is processed as YB_YQL_DATA_TYPE_BINARY but it
		 * can have a collation. For example:
		 *   CREATE TABLE t (id text[] COLLATE "en_US.utf8");
		 *
		 * GIN indexes have null categories, so ybgin indexes pass the category
		 * number down using GIN_NULL type.  Even if the column is collatable,
		 * nulls should be unaffected by collation.
		 *
		 * pg_trgm GIN indexes have key type int32 but also valid collation for
		 * regex purposes on the indexed type text.  Add an exception here for
		 * int32.  Since this relaxes the assert for other situations involving
		 * int32, a proper fix should be done in the future.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>collation_id</name> <operator>==</operator> <name>InvalidOid</name> <operator>||</operator>
			   <name><name>type_entity</name><operator>-&gt;</operator><name>yb_type</name></name> <operator>==</operator> <name>YB_YQL_DATA_TYPE_BINARY</name> <operator>||</operator>
			   <name><name>type_entity</name><operator>-&gt;</operator><name>yb_type</name></name> <operator>==</operator> <name>YB_YQL_DATA_TYPE_GIN_NULL</name> <operator>||</operator>
			   <name><name>type_entity</name><operator>-&gt;</operator><name>yb_type</name></name> <operator>==</operator> <name>YB_YQL_DATA_TYPE_INT32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>collation_info</name><operator>-&gt;</operator><name>collate_is_valid_non_c</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>collation_info</name><operator>-&gt;</operator><name>sortkey</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<switch>switch <condition>(<expr><name><name>type_entity</name><operator>-&gt;</operator><name>type_oid</name></name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>NAMEOID</name></expr>:</case>
			<comment type="block">/*
			 * In bootstrap code, postgres 11.2 hard coded to InvalidOid but
			 * postgres 13.2 hard coded to C_COLLATION_OID. Adjust the assertion
			 * when we upgrade to postgres 13.2.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>collation_id</name> <operator>==</operator> <name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>collation_id</name> <operator>=</operator> <name>C_COLLATION_OID</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>TEXTOID</name></expr>:</case>
		<case>case <expr><name>BPCHAROID</name></expr>:</case>
		<case>case <expr><name>VARCHAROID</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>collation_id</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition> <block>{<block_content>
				<comment type="block">/*
				 * In postgres, an index can include columns. Included columns
				 * have no collation. Included character column value will be
				 * stored as C collation. It can only be stored and retrieved
				 * as a value in DocDB. Any comparison must be done by the
				 * postgres layer.
				 */</comment>
				<expr_stmt><expr><name>collation_id</name> <operator>=</operator> <name>C_COLLATION_OID</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>CSTRINGOID</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>collation_id</name> <operator>==</operator> <name>C_COLLATION_OID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* Not supported text type. */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
	<expr_stmt><expr><name><name>collation_info</name><operator>-&gt;</operator><name>collate_is_valid_non_c</name></name> <operator>=</operator> <call><name>YBIsCollationValidNonC</name><argument_list>(<argument><expr><name>collation_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_null</name> <operator>&amp;&amp;</operator> <name><name>collation_info</name><operator>-&gt;</operator><name>collate_is_valid_non_c</name></name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64_t</name></type> <name>bytes</name> <init>= <expr><name><name>type_entity</name><operator>-&gt;</operator><name>datum_fixed_size</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name><name>type_entity</name><operator>-&gt;</operator><name>datum_to_yb</name></name><argument_list>(<argument><expr><name>datum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		 * Collation sort keys are compared using strcmp so they are null
		 * terminated and cannot have embedded \0 byte.
		 */</comment>
		<expr_stmt><expr><name><name>collation_info</name><operator>-&gt;</operator><name>sortkey</name></name> <operator>=</operator> <call><name>YBComputeNonCSortKey</name><argument_list>(<argument><expr><name>collation_id</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name><name>collation_info</name><operator>-&gt;</operator><name>sortkey</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>YBNeedCollationEncoding</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>YBCPgColumnInfo</name> <modifier>*</modifier></type><name>column_info</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* We only need collation encoding for range keys. */</comment>
  <return>return <expr><operator>(</operator><name><name>column_info</name><operator>-&gt;</operator><name>is_primary</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>column_info</name><operator>-&gt;</operator><name>is_hash</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>YBSetupAttrCollationInfo</name><parameter_list>(<parameter><decl><type><name>YBCPgAttrValueDescriptor</name> <modifier>*</modifier></type><name>attr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>YBCPgColumnInfo</name> <modifier>*</modifier></type><name>column_info</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>collation_id</name></name> <operator>!=</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>YBNeedCollationEncoding</name><argument_list>(<argument><expr><name>column_info</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>collation_id</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>YBGetCollationInfo</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>collation_id</name></name></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>type_entity</name></name></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>datum</name></name></expr></argument>,
					   <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>is_null</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>attr</name><operator>-&gt;</operator><name>collation_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>YBIsCollationValidNonC</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>collation_id</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="block">/*
	 * For now we only allow database to have C collation. Therefore for
	 * DEFAULT_COLLATION_OID it cannot be a valid non-C collation. This
	 * special case for DEFAULT_COLLATION_OID is made here because YB
	 * PgExpr code is called before Postgres has properly setup the default
	 * collation to that of the database connected. So lc_collate_is_c can
	 * return false for DEFAULT_COLLATION_OID which isn't correct.
	 * We stop support non-C collation if collation support is disabled.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_valid_non_c</name> <init>= <expr><call><name>YBIsCollationEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
						  <call><name>OidIsValid</name><argument_list>(<argument><expr><name>collation_id</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
						  <name>collation_id</name> <operator>!=</operator> <name>DEFAULT_COLLATION_OID</name> <operator>&amp;&amp;</operator>
						  <operator>!</operator><call><name>lc_collate_is_c</name><argument_list>(<argument><expr><name>collation_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="block">/*
	 * For testing only, we use en_US.UTF-8 for default collation and
	 * this is a valid non-C collation.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>kTestOnlyUseOSDefaultCollation</name> <operator>||</operator> <call><name>YBIsCollationEnabled</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>kTestOnlyUseOSDefaultCollation</name> <operator>&amp;&amp;</operator> <name>collation_id</name> <operator>==</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>is_valid_non_c</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>is_valid_non_c</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Oid</name></type> <name>YBEncodingCollation</name><parameter_list>(<parameter><decl><type><name>YBCPgStatement</name></type> <name>handle</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attr_num</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>attcollation</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>attcollation</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>
	<decl_stmt><decl><type><name>YBCPgColumnInfo</name></type> <name>column_info</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlGetColumnInfo</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>attr_num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>column_info</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><ternary><condition><expr><call><name>YBNeedCollationEncoding</name><argument_list>(<argument><expr><operator>&amp;</operator><name>column_info</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>attcollation</name></expr> </then><else>: <expr><name>InvalidOid</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>IsYbExtensionUser</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>member</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>has_privs_of_role</name><argument_list>(<argument><expr><name>member</name></expr></argument>, <argument><expr><name>DEFAULT_ROLE_YB_EXTENSION</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>IsYbFdwUser</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>member</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>has_privs_of_role</name><argument_list>(<argument><expr><name>member</name></expr></argument>, <argument><expr><name>DEFAULT_ROLE_YB_FDW</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>YBSetParentDeathSignal</name><parameter_list>()</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__linux__</name></cpp:ifdef>
	<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>pdeathsig_str</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"YB_PG_PDEATHSIG"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>pdeathsig_str</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>end_ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>long</name> <name>int</name></type> <name>pdeathsig</name> <init>= <expr><call><name>strtol</name><argument_list>(<argument><expr><name>pdeathsig_str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end_ptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>end_ptr</name> <operator>==</operator> <name>pdeathsig_str</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>pdeathsig_str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>pdeathsig</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>pdeathsig</name> <operator>&lt;=</operator> <literal type="number">31</literal></expr>)</condition> <block>{<block_content>
				<comment type="line">// TODO: prctl(PR_SET_PDEATHSIG) is Linux-specific, look into portable ways to</comment>
				<comment type="line">// prevent orphans when parent is killed.</comment>
				<expr_stmt><expr><call><name>prctl</name><argument_list>(<argument><expr><name>PR_SET_PDEATHSIG</name></expr></argument>, <argument><expr><name>pdeathsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(
					<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><literal type="string">"Error: YB_PG_PDEATHSIG is an invalid signal value: %ld"</literal></expr></argument>,
					<argument><expr><name>pdeathsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(
				<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><literal type="string">"Error: failed to parse the value of YB_PG_PDEATHSIG: %s"</literal></expr></argument>,
				<argument><expr><name>pdeathsig_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>Oid</name></type> <name>YbGetStorageRelid</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator>
		<name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relfilenode</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relfilenode</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>IsYbDbAdminUser</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>member</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>has_privs_of_role</name><argument_list>(<argument><expr><name>member</name></expr></argument>, <argument><expr><name>DEFAULT_ROLE_YB_DB_ADMIN</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>IsYbDbAdminUserNosuper</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>member</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>is_member_of_role_nosuper</name><argument_list>(<argument><expr><name>member</name></expr></argument>, <argument><expr><name>DEFAULT_ROLE_YB_DB_ADMIN</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>YbCheckUnsupportedSystemColumns</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<switch>switch <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SelfItemPointerAttributeNumber</name></expr>:</case>
		<case>case <expr><name>MinTransactionIdAttributeNumber</name></expr>:</case>
		<case>case <expr><name>MinCommandIdAttributeNumber</name></expr>:</case>
		<case>case <expr><name>MaxTransactionIdAttributeNumber</name></expr>:</case>
		<case>case <expr><name>MaxCommandIdAttributeNumber</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"System column \"%s\" is not supported yet"</literal></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>YbRegisterSysTableForPrefetching</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sys_table_id</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>db_id</name> <init>= <expr><name>MyDatabaseId</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>sys_table_index_id</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<switch>switch<condition>(<expr><name>sys_table_id</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// TemplateDb tables</comment>
		<case>case <expr><name>AuthMemRelationId</name></expr>:</case>                           <comment type="line">// pg_auth_members</comment>
			<expr_stmt><expr><name>sys_table_index_id</name> <operator>=</operator> <name>AuthMemMemRoleIndexId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>db_id</name> <operator>=</operator> <name>TemplateDbOid</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AuthIdRelationId</name></expr>:</case>                            <comment type="line">// pg_authid</comment>
			<expr_stmt><expr><name>db_id</name> <operator>=</operator> <name>TemplateDbOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>sys_table_index_id</name> <operator>=</operator> <name>AuthIdRolnameIndexId</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DatabaseRelationId</name></expr>:</case>                          <comment type="line">// pg_database</comment>
			<expr_stmt><expr><name>db_id</name> <operator>=</operator> <name>TemplateDbOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>sys_table_index_id</name> <operator>=</operator> <name>DatabaseNameIndexId</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>DbRoleSettingRelationId</name></expr>:</case> <expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// pg_db_role_setting</comment>
		<case>case <expr><name>YBCatalogVersionRelationId</name></expr>:</case>                    <comment type="line">// pg_yb_catalog_version</comment>
			<expr_stmt><expr><name>db_id</name> <operator>=</operator> <name>TemplateDbOid</name></expr>;</expr_stmt>
			<break>break;</break>

		<comment type="line">// MyDb tables</comment>
		<case>case <expr><name>AccessMethodProcedureRelationId</name></expr>:</case>             <comment type="line">// pg_amproc</comment>
			<expr_stmt><expr><name>sys_table_index_id</name> <operator>=</operator> <name>AccessMethodProcedureIndexId</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AccessMethodRelationId</name></expr>:</case>                      <comment type="line">// pg_am AmNameIndexId</comment>
			<expr_stmt><expr><name>sys_table_index_id</name> <operator>=</operator> <name>AmNameIndexId</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AttrDefaultRelationId</name></expr>:</case>                       <comment type="line">// pg_attrdef</comment>
			<expr_stmt><expr><name>sys_table_index_id</name> <operator>=</operator> <name>AttrDefaultIndexId</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AttributeRelationId</name></expr>:</case>                         <comment type="line">// pg_attribute</comment>
			<expr_stmt><expr><name>sys_table_index_id</name> <operator>=</operator> <name>AttributeRelidNameIndexId</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ConstraintRelationId</name></expr>:</case>                        <comment type="line">// pg_constraint</comment>
			<expr_stmt><expr><name>sys_table_index_id</name> <operator>=</operator> <name>ConstraintRelidTypidNameIndexId</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>IndexRelationId</name></expr>:</case>                             <comment type="line">// pg_index</comment>
			<expr_stmt><expr><name>sys_table_index_id</name> <operator>=</operator> <name>IndexIndrelidIndexId</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>InheritsRelationId</name></expr>:</case>                          <comment type="line">// pg_inherits</comment>
			<expr_stmt><expr><name>sys_table_index_id</name> <operator>=</operator> <name>InheritsParentIndexId</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>NamespaceRelationId</name></expr>:</case>                         <comment type="line">// pg_namespace</comment>
			<expr_stmt><expr><name>sys_table_index_id</name> <operator>=</operator> <name>NamespaceNameIndexId</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OperatorClassRelationId</name></expr>:</case>                     <comment type="line">// pg_opclass</comment>
			<expr_stmt><expr><name>sys_table_index_id</name> <operator>=</operator> <name>OpclassAmNameNspIndexId</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OperatorRelationId</name></expr>:</case>                          <comment type="line">// pg_operator</comment>
			<expr_stmt><expr><name>sys_table_index_id</name> <operator>=</operator> <name>OperatorNameNspIndexId</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PolicyRelationId</name></expr>:</case>                            <comment type="line">// pg_policy</comment>
			<expr_stmt><expr><name>sys_table_index_id</name> <operator>=</operator> <name>PolicyPolrelidPolnameIndexId</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RelationRelationId</name></expr>:</case>                          <comment type="line">// pg_class</comment>
			<expr_stmt><expr><name>sys_table_index_id</name> <operator>=</operator> <name>ClassNameNspIndexId</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RewriteRelationId</name></expr>:</case>                           <comment type="line">// pg_rewrite</comment>
			<expr_stmt><expr><name>sys_table_index_id</name> <operator>=</operator> <name>RewriteRelRulenameIndexId</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>TriggerRelationId</name></expr>:</case>                           <comment type="line">// pg_trigger</comment>
			<expr_stmt><expr><name>sys_table_index_id</name> <operator>=</operator> <name>TriggerRelidNameIndexId</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>TypeRelationId</name></expr>:</case>                              <comment type="line">// pg_type</comment>
			<expr_stmt><expr><name>sys_table_index_id</name> <operator>=</operator> <name>TypeNameNspIndexId</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CastRelationId</name></expr>:</case>        <expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// pg_cast</comment>
		<case>case <expr><name>PartitionedRelationId</name></expr>:</case> <expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// pg_partitioned_table</comment>
		<case>case <expr><name>ProcedureRelationId</name></expr>:</case>   <break>break;</break>                <comment type="line">// pg_proc</comment>

		<default>default:</default>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
			        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
			         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Sys table '%d' is not yet inteded for preloading"</literal></expr></argument>, <argument><expr><name>sys_table_id</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		</block_content>}</block>
	</block_content>}</block></switch>
	<expr_stmt><expr><call><name>YBCRegisterSysTableForPrefetching</name><argument_list>(<argument><expr><name>db_id</name></expr></argument>, <argument><expr><name>sys_table_id</name></expr></argument>, <argument><expr><name>sys_table_index_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>YbTryRegisterCatalogVersionTableForPrefetching</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>YbGetCatalogVersionType</name><argument_list>()</argument_list></call> <operator>==</operator> <name>CATALOG_VERSION_CATALOG_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>YbRegisterSysTableForPrefetching</name><argument_list>(<argument><expr><name>YBCatalogVersionRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>YBCIsRegionLocal</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type> <name>cost</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>IsNormalProcessingMode</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>get_yb_tablespace_cost</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltablespace</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cost</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name>cost</name> <operator>&lt;=</operator> <name>yb_interzone_cost</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>check_yb_xcluster_consistency_level</name><parameter_list>(<parameter><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier><modifier>*</modifier></type> <name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>newConsistency</name> <init>= <expr><name>XCLUSTER_CONSISTENCY_TABLET</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>, <argument><expr><literal type="string">"tablet"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>newConsistency</name> <operator>=</operator> <name>XCLUSTER_CONSISTENCY_TABLET</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>, <argument><expr><literal type="string">"database"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>newConsistency</name> <operator>=</operator> <name>XCLUSTER_CONSISTENCY_DATABASE</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>extra</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>extra</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><operator>*</operator><name>extra</name><operator>)</operator> <operator>=</operator> <name>newConsistency</name></expr>;</expr_stmt>

  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>assign_yb_xcluster_consistency_level</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>extra</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name>yb_xcluster_consistency_level</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><name>extra</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>YBCheckServerAccessIsAllowed</name><parameter_list>()</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><call><name>YBCGetGFlags</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>ysql_disable_server_file_access</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"server file access disabled"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"tserver flag ysql_disable_server_file_access is "</literal>
						   <literal type="string">"set to true"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>YbUpdateReadRpcStats</name><parameter_list>(<parameter><decl><type><name>YBCPgStatement</name></type> <name>handle</name></decl></parameter>,
						  <parameter><decl><type><name>YbPgRpcStats</name> <modifier>*</modifier></type><name>reads</name></decl></parameter>, <parameter><decl><type><name>YbPgRpcStats</name> <modifier>*</modifier></type><name>tbl_reads</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>read_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>read_wait</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>tbl_read_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>tbl_read_wait</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>YBCGetAndResetReadRpcStats</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>read_count</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>read_wait</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>tbl_read_count</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tbl_read_wait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>reads</name><operator>-&gt;</operator><name>count</name></name> <operator>+=</operator> <name>read_count</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>reads</name><operator>-&gt;</operator><name>wait_time</name></name> <operator>+=</operator> <name>read_wait</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tbl_reads</name><operator>-&gt;</operator><name>count</name></name> <operator>+=</operator> <name>tbl_read_count</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tbl_reads</name><operator>-&gt;</operator><name>wait_time</name></name> <operator>+=</operator> <name>tbl_read_wait</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>YbSetCatalogCacheVersion</name><parameter_list>(<parameter><decl><type><name>YBCPgStatement</name></type> <name>handle</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>version</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><ternary><condition><expr><call><name>YBIsDBCatalogVersionMode</name><argument_list>()</argument_list></call></expr>
		?</condition><then> <expr><call><name>YBCPgSetDBCatalogCacheVersion</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>MyDatabaseId</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>
		</then><else>: <expr><call><name>YBCPgSetCatalogCacheVersion</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>uint64_t</name></type> <name>YbGetSharedCatalogVersion</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>version</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><ternary><condition><expr><call><name>YBIsDBCatalogVersionMode</name><argument_list>()</argument_list></call></expr>
		?</condition><then> <expr><call><name>YBCGetSharedDBCatalogVersion</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>version</name></expr></argument>)</argument_list></call></expr>
		</then><else>: <expr><call><name>YBCGetSharedCatalogVersion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>version</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>version</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>YBUpdateRowLockPolicyForSerializable</name><parameter_list>(
		<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>effectiveWaitPolicy</name></decl></parameter>, <parameter><decl><type><name>LockWaitPolicy</name></type> <name>userLockWaitPolicy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * TODO(concurrency-control): We don't honour SKIP LOCKED/ NO WAIT yet in serializable isolation
	 * level.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>userLockWaitPolicy</name> <operator>==</operator> <name>LockWaitSkip</name> <operator>||</operator> <name>userLockWaitPolicy</name> <operator>==</operator> <name>LockWaitError</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"%s clause is not supported yet for SERIALIZABLE isolation (GH issue #11761)"</literal></expr></argument>,
			<argument><expr><ternary><condition><expr><name>userLockWaitPolicy</name> <operator>==</operator> <name>LockWaitSkip</name></expr> ?</condition><then> <expr><literal type="string">"SKIP LOCKED"</literal></expr> </then><else>: <expr><literal type="string">"NO WAIT"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>effectiveWaitPolicy</name> <operator>=</operator> <name>LockWaitBlock</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>YBIsWaitQueueEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If wait-queues are not enabled, we default to the "Fail-on-Conflict" policy which is
		 * mapped to LockWaitError right now (see WaitPolicy proto for meaning of
		 * "Fail-on-Conflict" and the reason why LockWaitError is not mapped to no-wait
		 * semantics but to Fail-on-Conflict semantics).
		 */</comment>
		<expr_stmt><expr><operator>*</operator><name>effectiveWaitPolicy</name> <operator>=</operator> <name>LockWaitError</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>uint32_t</name></type> <name>YbGetNumberOfDatabases</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>YBIsDBCatalogVersionMode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>num_databases</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCGetNumberOfDatabases</name><argument_list>(<argument><expr><operator>&amp;</operator><name>num_databases</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>num_databases</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>num_databases</name></expr>;</return>
</block_content>}</block></function>
</unit>
