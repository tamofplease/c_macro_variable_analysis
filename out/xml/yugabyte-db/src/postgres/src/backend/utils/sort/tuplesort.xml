<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/utils/sort/tuplesort.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * tuplesort.c
 *	  Generalized tuple sorting routines.
 *
 * This module handles sorting of heap tuples, index tuples, or single
 * Datums (and could easily support other kinds of sortable objects,
 * if necessary).  It works efficiently for both small and large amounts
 * of data.  Small amounts are sorted in-memory using qsort().  Large
 * amounts are sorted using temporary files and a standard external sort
 * algorithm.
 *
 * See Knuth, volume 3, for more than you want to know about the external
 * sorting algorithm.  Historically, we divided the input into sorted runs
 * using replacement selection, in the form of a priority tree implemented
 * as a heap (essentially his Algorithm 5.2.3H), but now we always use
 * quicksort for run generation.  We merge the runs using polyphase merge,
 * Knuth's Algorithm 5.4.2D.  The logical "tapes" used by Algorithm D are
 * implemented by logtape.c, which avoids space wastage by recycling disk
 * space as soon as each block is read from its "tape".
 *
 * The approximate amount of memory allowed for any one sort operation
 * is specified in kilobytes by the caller (most pass work_mem).  Initially,
 * we absorb tuples and simply store them in an unsorted array as long as
 * we haven't exceeded workMem.  If we reach the end of the input without
 * exceeding workMem, we sort the array using qsort() and subsequently return
 * tuples just by scanning the tuple array sequentially.  If we do exceed
 * workMem, we begin to emit tuples into sorted runs in temporary tapes.
 * When tuples are dumped in batch after quicksorting, we begin a new run
 * with a new output tape (selected per Algorithm D).  After the end of the
 * input is reached, we dump out remaining tuples in memory into a final run,
 * then merge the runs using Algorithm D.
 *
 * When merging runs, we use a heap containing just the frontmost tuple from
 * each source run; we repeatedly output the smallest tuple and replace it
 * with the next tuple from its source tape (if any).  When the heap empties,
 * the merge is complete.  The basic merge algorithm thus needs very little
 * memory --- only M tuples for an M-way merge, and M is constrained to a
 * small number.  However, we can still make good use of our full workMem
 * allocation by pre-reading additional blocks from each source tape.  Without
 * prereading, our access pattern to the temporary file would be very erratic;
 * on average we'd read one block from each of M source tapes during the same
 * time that we're writing M blocks to the output tape, so there is no
 * sequentiality of access at all, defeating the read-ahead methods used by
 * most Unix kernels.  Worse, the output tape gets written into a very random
 * sequence of blocks of the temp file, ensuring that things will be even
 * worse when it comes time to read that tape.  A straightforward merge pass
 * thus ends up doing a lot of waiting for disk seeks.  We can improve matters
 * by prereading from each source tape sequentially, loading about workMem/M
 * bytes from each tape in turn, and making the sequential blocks immediately
 * available for reuse.  This approach helps to localize both read and write
 * accesses.  The pre-reading is handled by logtape.c, we just tell it how
 * much memory to use for the buffers.
 *
 * When the caller requests random access to the sort result, we form
 * the final sorted run on a logical tape which is then "frozen", so
 * that we can access it randomly.  When the caller does not need random
 * access, we return from tuplesort_performsort() as soon as we are down
 * to one run per logical tape.  The final merge is then performed
 * on-the-fly as the caller repeatedly calls tuplesort_getXXX; this
 * saves one cycle of writing all the data out to disk and reading it in.
 *
 * Before Postgres 8.2, we always used a seven-tape polyphase merge, on the
 * grounds that 7 is the "sweet spot" on the tapes-to-passes curve according
 * to Knuth's figure 70 (section 5.4.2).  However, Knuth is assuming that
 * tape drives are expensive beasts, and in particular that there will always
 * be many more runs than tape drives.  In our implementation a "tape drive"
 * doesn't cost much more than a few Kb of memory buffers, so we can afford
 * to have lots of them.  In particular, if we can have as many tape drives
 * as sorted runs, we can eliminate any repeated I/O at all.  In the current
 * code we determine the number of tapes M on the basis of workMem: we want
 * workMem/M to be large enough that we read a fair amount of data each time
 * we preread from a tape, so as to maintain the locality of access described
 * above.  Nonetheless, with large workMem we can have many tapes (but not
 * too many -- see the comments in tuplesort_merge_order).
 *
 * This module supports parallel sorting.  Parallel sorts involve coordination
 * among one or more worker processes, and a leader process, each with its own
 * tuplesort state.  The leader process (or, more accurately, the
 * Tuplesortstate associated with a leader process) creates a full tapeset
 * consisting of worker tapes with one run to merge; a run for every
 * worker process.  This is then merged.  Worker processes are guaranteed to
 * produce exactly one output run from their partial input.
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/utils/sort/tuplesort.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_trace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/logtape.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_rusage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/sortsupport.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tuplesort.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_yb_utils.h"</cpp:file></cpp:include>

<comment type="block">/* sort-type codes for sort__start probes */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEAP_SORT</name></cpp:macro>		<cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INDEX_SORT</name></cpp:macro>		<cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DATUM_SORT</name></cpp:macro>		<cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLUSTER_SORT</name></cpp:macro>	<cpp:value>3</cpp:value></cpp:define>

<comment type="block">/* Sort parallel code from state for sort__start probes */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_SORT</name><parameter_list>(<parameter><type><name>state</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((state)-&gt;shared == NULL ? 0 : \
								 (state)-&gt;worker &gt;= 0 ? 1 : 2)</cpp:value></cpp:define>

<comment type="block">/* GUC variables */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRACE_SORT</name></cpp:ifdef>
<decl_stmt><decl><type><name>bool</name></type>		<name>trace_sort</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_BOUNDED_SORT</name></cpp:ifdef>
<decl_stmt><decl><type><name>bool</name></type>		<name>optimize_bounded_sort</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
 * The objects we actually sort are SortTuple structs.  These contain
 * a pointer to the tuple proper (might be a MinimalTuple or IndexTuple),
 * which is a separate palloc chunk --- we assume it is just one chunk and
 * can be freed by a simple pfree() (except during merge, when we use a
 * simple slab allocator).  SortTuples also contain the tuple's first key
 * column in Datum/nullflag format, and an index integer.
 *
 * Storing the first key column lets us save heap_getattr or index_getattr
 * calls during tuple comparisons.  We could extract and save all the key
 * columns not just the first, but this would increase code complexity and
 * overhead, and wouldn't actually save any comparison cycles in the common
 * case where the first key determines the comparison result.  Note that
 * for a pass-by-reference datatype, datum1 points into the "tuple" storage.
 *
 * There is one special case: when the sort support infrastructure provides an
 * "abbreviated key" representation, where the key is (typically) a pass by
 * value proxy for a pass by reference type.  In this case, the abbreviated key
 * is stored in datum1 in place of the actual first key column.
 *
 * When sorting single Datums, the data value is represented directly by
 * datum1/isnull1 for pass by value types (or null values).  If the datatype is
 * pass-by-reference and isnull1 is false, then "tuple" points to a separately
 * palloc'd data value, otherwise "tuple" is NULL.  The value of datum1 is then
 * either the same pointer as "tuple", or is an abbreviated key value as
 * described above.  Accordingly, "tuple" is always used in preference to
 * datum1 as the authoritative value for pass-by-reference cases.
 *
 * tupindex holds the input tape number that each tuple in the heap was read
 * from during merge passes.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>tuple</name></decl>;</decl_stmt>			<comment type="block">/* the tuple itself */</comment>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>datum1</name></decl>;</decl_stmt>			<comment type="block">/* value of first key column */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull1</name></decl>;</decl_stmt>		<comment type="block">/* is first key column NULL? */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>tupindex</name></decl>;</decl_stmt>		<comment type="block">/* see notes above */</comment>
}</block></struct></type> <name>SortTuple</name>;</typedef>

<comment type="block">/*
 * During merge, we use a pre-allocated set of fixed-size slots to hold
 * tuples.  To avoid palloc/pfree overhead.
 *
 * Merge doesn't require a lot of memory, so we can afford to waste some,
 * by using gratuitously-sized slots.  If a tuple is larger than 1 kB, the
 * palloc() overhead is not significant anymore.
 *
 * 'nextfree' is valid when this chunk is in the free list.  When in use, the
 * slot holds a tuple.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLAB_SLOT_SIZE</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>

<typedef>typedef <type><union>union <name>SlabSlot</name>
<block>{
	<decl_stmt><decl><type><name><name>union</name> <name>SlabSlot</name></name> <modifier>*</modifier></type><name>nextfree</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buffer</name><index>[<expr><name>SLAB_SLOT_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
}</block></union></type> <name>SlabSlot</name>;</typedef>

<comment type="block">/*
 * Possible states of a Tuplesort object.  These denote the states that
 * persist between calls of Tuplesort routines.
 */</comment>
<typedef>typedef <type><enum>enum
<block>{
	<decl><name>TSS_INITIAL</name></decl>,				<comment type="block">/* Loading tuples; still within memory limit */</comment>
	<decl><name>TSS_BOUNDED</name></decl>,				<comment type="block">/* Loading tuples into bounded-size heap */</comment>
	<decl><name>TSS_BUILDRUNS</name></decl>,				<comment type="block">/* Loading tuples; writing to tape */</comment>
	<decl><name>TSS_SORTEDINMEM</name></decl>,			<comment type="block">/* Sort completed entirely in memory */</comment>
	<decl><name>TSS_SORTEDONTAPE</name></decl>,			<comment type="block">/* Sort completed, final run is on tape */</comment>
	<decl><name>TSS_FINALMERGE</name></decl>				<comment type="block">/* Performing final merge on-the-fly */</comment>
}</block></enum></type> <name>TupSortStatus</name>;</typedef>

<comment type="block">/*
 * Parameters for calculation of number of tapes to use --- see inittapes()
 * and tuplesort_merge_order().
 *
 * In this calculation we assume that each tape will cost us about 1 blocks
 * worth of buffer space.  This ignores the overhead of all the other data
 * structures needed for each tape, but it's probably close enough.
 *
 * MERGE_BUFFER_SIZE is how much data we'd like to read from each input
 * tape during a preread cycle (see discussion at top of file).
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MINORDER</name></cpp:macro>		<cpp:value>6</cpp:value></cpp:define>		<comment type="block">/* minimum merge order */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXORDER</name></cpp:macro>		<cpp:value>500</cpp:value></cpp:define>		<comment type="block">/* maximum merge order */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TAPE_BUFFER_OVERHEAD</name></cpp:macro>		<cpp:value>BLCKSZ</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MERGE_BUFFER_SIZE</name></cpp:macro>			<cpp:value>(BLCKSZ * 32)</cpp:value></cpp:define>

<typedef>typedef <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>SortTupleComparator</name>) <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SortTuple</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SortTuple</name> <modifier>*</modifier></type><name>b</name></decl></parameter>,
									<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<comment type="block">/*
 * Private state of a Tuplesort operation.
 */</comment>
<struct>struct <name>Tuplesortstate</name>
<block>{
	<decl_stmt><decl><type><name>TupSortStatus</name></type> <name>status</name></decl>;</decl_stmt>		<comment type="block">/* enumerated value as shown above */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nKeys</name></decl>;</decl_stmt>			<comment type="block">/* number of columns in sort key */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>randomAccess</name></decl>;</decl_stmt>	<comment type="block">/* did caller request random access? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>bounded</name></decl>;</decl_stmt>		<comment type="block">/* did caller specify a maximum number of
								 * tuples to return? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>boundUsed</name></decl>;</decl_stmt>		<comment type="block">/* true if we made use of a bounded heap */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>bound</name></decl>;</decl_stmt>			<comment type="block">/* if bounded, the maximum number of tuples */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>tuples</name></decl>;</decl_stmt>			<comment type="block">/* Can SortTuple.tuple ever be set? */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>availMem</name></decl>;</decl_stmt>		<comment type="block">/* remaining memory available, in bytes */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>allowedMem</name></decl>;</decl_stmt>		<comment type="block">/* total memory allowed, in bytes */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxTapes</name></decl>;</decl_stmt>		<comment type="block">/* number of tapes (Knuth's T) */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>tapeRange</name></decl>;</decl_stmt>		<comment type="block">/* maxTapes-1 (Knuth's P) */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>sortcontext</name></decl>;</decl_stmt>	<comment type="block">/* memory context holding most sort data */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>tuplecontext</name></decl>;</decl_stmt> <comment type="block">/* sub-context of sortcontext for tuple data */</comment>
	<decl_stmt><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>tapeset</name></decl>;</decl_stmt>	<comment type="block">/* logtape.c object for tapes in a temp file */</comment>

	<comment type="block">/*
	 * These function pointers decouple the routines that must know what kind
	 * of tuple we are sorting from the routines that don't need to know it.
	 * They are set up by the tuplesort_begin_xxx routines.
	 *
	 * Function to compare two tuples; result is per qsort() convention, ie:
	 * &lt;0, 0, &gt;0 according as a&lt;b, a=b, a&gt;b.  The API must match
	 * qsort_arg_comparator.
	 */</comment>
	<decl_stmt><decl><type><name>SortTupleComparator</name></type> <name>comparetup</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Function to copy a supplied input tuple into palloc'd space and set up
	 * its SortTuple representation (ie, set tuple/datum1/isnull1).  Also,
	 * state-&gt;availMem must be decreased by the amount of space used for the
	 * tuple copy (note the SortTuple struct itself is not counted).
	 */</comment>
	<function_decl><type><name>void</name></type>		(<modifier>*</modifier><name>copytup</name>) <parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>stup</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>tup</name></decl></parameter>)</parameter_list>;</function_decl>

	<comment type="block">/*
	 * Function to write a stored tuple onto tape.  The representation of the
	 * tuple on tape need not be the same as it is in memory; requirements on
	 * the tape representation are given below.  Unless the slab allocator is
	 * used, after writing the tuple, pfree() the out-of-line data (not the
	 * SortTuple struct!), and increase state-&gt;availMem by the amount of
	 * memory space thereby released.
	 */</comment>
	<function_decl><type><name>void</name></type>		(<modifier>*</modifier><name>writetup</name>) <parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>,
							 <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>stup</name></decl></parameter>)</parameter_list>;</function_decl>

	<comment type="block">/*
	 * Function to read a stored tuple from tape back into memory. 'len' is
	 * the already-read length of the stored tuple.  The tuple is allocated
	 * from the slab memory arena, or is palloc'd, see readtup_alloc().
	 */</comment>
	<function_decl><type><name>void</name></type>		(<modifier>*</modifier><name>readtup</name>) <parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>stup</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>

	<comment type="block">/*
	 * This array holds the tuples now in sort memory.  If we are in state
	 * INITIAL, the tuples are in no particular order; if we are in state
	 * SORTEDINMEM, the tuples are in final sorted order; in states BUILDRUNS
	 * and FINALMERGE, the tuples are organized in "heap" order per Algorithm
	 * H.  In state SORTEDONTAPE, the array is not used.
	 */</comment>
	<decl_stmt><decl><type><name>SortTuple</name>  <modifier>*</modifier></type><name>memtuples</name></decl>;</decl_stmt>		<comment type="block">/* array of SortTuple structs */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>memtupcount</name></decl>;</decl_stmt>	<comment type="block">/* number of tuples currently present */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>memtupsize</name></decl>;</decl_stmt>		<comment type="block">/* allocated length of memtuples array */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>growmemtuples</name></decl>;</decl_stmt>	<comment type="block">/* memtuples' growth still underway? */</comment>

	<comment type="block">/*
	 * Memory for tuples is sometimes allocated using a simple slab allocator,
	 * rather than with palloc().  Currently, we switch to slab allocation
	 * when we start merging.  Merging only needs to keep a small, fixed
	 * number of tuples in memory at any time, so we can avoid the
	 * palloc/pfree overhead by recycling a fixed number of fixed-size slots
	 * to hold the tuples.
	 *
	 * For the slab, we use one large allocation, divided into SLAB_SLOT_SIZE
	 * slots.  The allocation is sized to have one slot per tape, plus one
	 * additional slot.  We need that many slots to hold all the tuples kept
	 * in the heap during merge, plus the one we have last returned from the
	 * sort, with tuplesort_gettuple.
	 *
	 * Initially, all the slots are kept in a linked list of free slots.  When
	 * a tuple is read from a tape, it is put to the next available slot, if
	 * it fits.  If the tuple is larger than SLAB_SLOT_SIZE, it is palloc'd
	 * instead.
	 *
	 * When we're done processing a tuple, we return the slot back to the free
	 * list, or pfree() if it was palloc'd.  We know that a tuple was
	 * allocated from the slab, if its pointer value is between
	 * slabMemoryBegin and -End.
	 *
	 * When the slab allocator is used, the USEMEM/LACKMEM mechanism of
	 * tracking memory usage is not used.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>slabAllocatorUsed</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>slabMemoryBegin</name></decl>;</decl_stmt>	<comment type="block">/* beginning of slab memory arena */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>slabMemoryEnd</name></decl>;</decl_stmt>	<comment type="block">/* end of slab memory arena */</comment>
	<decl_stmt><decl><type><name>SlabSlot</name>   <modifier>*</modifier></type><name>slabFreeHead</name></decl>;</decl_stmt>	<comment type="block">/* head of free list */</comment>

	<comment type="block">/* Buffer size to use for reading input tapes, during merge. */</comment>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>read_buffer_size</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * When we return a tuple to the caller in tuplesort_gettuple_XXX, that
	 * came from a tape (that is, in TSS_SORTEDONTAPE or TSS_FINALMERGE
	 * modes), we remember the tuple in 'lastReturnedTuple', so that we can
	 * recycle the memory on next gettuple call.
	 */</comment>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>lastReturnedTuple</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * While building initial runs, this is the current output run number.
	 * Afterwards, it is the number of initial runs we made.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>currentRun</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Unless otherwise noted, all pointer variables below are pointers to
	 * arrays of length maxTapes, holding per-tape data.
	 */</comment>

	<comment type="block">/*
	 * This variable is only used during merge passes.  mergeactive[i] is true
	 * if we are reading an input run from (actual) tape number i and have not
	 * yet exhausted that run.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>mergeactive</name></decl>;</decl_stmt>	<comment type="block">/* active input run source? */</comment>

	<comment type="block">/*
	 * Variables for Algorithm D.  Note that destTape is a "logical" tape
	 * number, ie, an index into the tp_xxx[] arrays.  Be careful to keep
	 * "logical" and "actual" tape numbers straight!
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>Level</name></decl>;</decl_stmt>			<comment type="block">/* Knuth's l */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>destTape</name></decl>;</decl_stmt>		<comment type="block">/* current output tape (Knuth's j, less 1) */</comment>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>tp_fib</name></decl>;</decl_stmt>			<comment type="block">/* Target Fibonacci run counts (A[]) */</comment>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>tp_runs</name></decl>;</decl_stmt>		<comment type="block">/* # of real runs on each tape */</comment>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>tp_dummy</name></decl>;</decl_stmt>		<comment type="block">/* # of dummy runs for each tape (D[]) */</comment>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>tp_tapenum</name></decl>;</decl_stmt>		<comment type="block">/* Actual tape numbers (TAPE[]) */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>activeTapes</name></decl>;</decl_stmt>	<comment type="block">/* # of active input tapes in merge pass */</comment>

	<comment type="block">/*
	 * These variables are used after completion of sorting to keep track of
	 * the next tuple to return.  (In the tape case, the tape's current read
	 * position is also critical state.)
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>result_tape</name></decl>;</decl_stmt>	<comment type="block">/* actual tape number of finished output */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>current</name></decl>;</decl_stmt>		<comment type="block">/* array index (only used if SORTEDINMEM) */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>eof_reached</name></decl>;</decl_stmt>	<comment type="block">/* reached EOF (needed for cursors) */</comment>

	<comment type="block">/* markpos_xxx holds marked position for mark and restore */</comment>
	<decl_stmt><decl><type><name>long</name></type>		<name>markpos_block</name></decl>;</decl_stmt>	<comment type="block">/* tape block# (only used if SORTEDONTAPE) */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>markpos_offset</name></decl>;</decl_stmt> <comment type="block">/* saved "current", or offset in tape block */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>markpos_eof</name></decl>;</decl_stmt>	<comment type="block">/* saved "eof_reached" */</comment>

	<comment type="block">/*
	 * These variables are used during parallel sorting.
	 *
	 * worker is our worker identifier.  Follows the general convention that
	 * -1 value relates to a leader tuplesort, and values &gt;= 0 worker
	 * tuplesorts. (-1 can also be a serial tuplesort.)
	 *
	 * shared is mutable shared memory state, which is used to coordinate
	 * parallel sorts.
	 *
	 * nParticipants is the number of worker Tuplesortstates known by the
	 * leader to have actually been launched, which implies that they must
	 * finish a run leader can merge.  Typically includes a worker state held
	 * by the leader process itself.  Set in the leader Tuplesortstate only.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>worker</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Sharedsort</name> <modifier>*</modifier></type><name>shared</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nParticipants</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The sortKeys variable is used by every case other than the hash index
	 * case; it is set by tuplesort_begin_xxx.  tupDesc is only used by the
	 * MinimalTuple and CLUSTER routines, though.
	 */</comment>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SortSupport</name></type> <name>sortKeys</name></decl>;</decl_stmt>		<comment type="block">/* array of length nKeys */</comment>

	<comment type="block">/*
	 * This variable is shared by the single-key MinimalTuple case and the
	 * Datum case (which both use qsort_ssup()).  Otherwise it's NULL.
	 */</comment>
	<decl_stmt><decl><type><name>SortSupport</name></type> <name>onlyKey</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Additional state for managing "abbreviated key" sortsupport routines
	 * (which currently may be used by all cases except the hash index case).
	 * Tracks the intervals at which the optimization's effectiveness is
	 * tested.
	 */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>abbrevNext</name></decl>;</decl_stmt>		<comment type="block">/* Tuple # at which to next check
								 * applicability */</comment>

	<comment type="block">/*
	 * These variables are specific to the CLUSTER case; they are set by
	 * tuplesort_begin_cluster.
	 */</comment>
	<decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>indexInfo</name></decl>;</decl_stmt>		<comment type="block">/* info about index being used for reference */</comment>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>			<comment type="block">/* for evaluating index expressions */</comment>

	<comment type="block">/*
	 * These variables are specific to the IndexTuple case; they are set by
	 * tuplesort_begin_index_xxx and used only by the IndexTuple routines.
	 */</comment>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>heapRel</name></decl>;</decl_stmt>		<comment type="block">/* table the index is being built on */</comment>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>indexRel</name></decl>;</decl_stmt>		<comment type="block">/* index being built */</comment>

	<comment type="block">/* These are specific to the index_btree subcase: */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>enforceUnique</name></decl>;</decl_stmt>	<comment type="block">/* complain if we find duplicate tuples */</comment>

	<comment type="block">/* These are specific to the index_hash subcase: */</comment>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>high_mask</name></decl>;</decl_stmt>		<comment type="block">/* masks for sortable part of hash code */</comment>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>low_mask</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>max_buckets</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * These variables are specific to the Datum case; they are set by
	 * tuplesort_begin_datum and used only by the DatumTuple routines.
	 */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>datumType</name></decl>;</decl_stmt>
	<comment type="block">/* we need typelen in order to know how to copy the Datums. */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>datumTypeLen</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Resource snapshot for time of sort start.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRACE_SORT</name></cpp:ifdef>
	<decl_stmt><decl><type><name>PGRUsage</name></type>	<name>ru_start</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>

<comment type="block">/*
 * Private mutable state of tuplesort-parallel-operation.  This is allocated
 * in shared memory.
 */</comment>
<struct>struct <name>Sharedsort</name>
<block>{
	<comment type="block">/* mutex protects all fields prior to tapes */</comment>
	<decl_stmt><decl><type><name>slock_t</name></type>		<name>mutex</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * currentWorker generates ordinal identifier numbers for parallel sort
	 * workers.  These start from 0, and are always gapless.
	 *
	 * Workers increment workersFinished to indicate having finished.  If this
	 * is equal to state.nParticipants within the leader, leader is ready to
	 * merge worker runs.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>currentWorker</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>workersFinished</name></decl>;</decl_stmt>

	<comment type="block">/* Temporary file space */</comment>
	<decl_stmt><decl><type><name>SharedFileSet</name></type> <name>fileset</name></decl>;</decl_stmt>

	<comment type="block">/* Size of tapes flexible array */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nTapes</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Tapes array used by workers to report back information needed by the
	 * leader to concatenate all worker tapes into one for merging
	 */</comment>
	<decl_stmt><decl><type><name>TapeShare</name></type>	<name><name>tapes</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
 * Is the given tuple allocated from the slab memory arena?
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_SLAB_SLOT</name><parameter_list>(<parameter><type><name>state</name></type></parameter>, <parameter><type><name>tuple</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((char *) (tuple) &gt;= (state)-&gt;slabMemoryBegin &amp;&amp; \
	 (char *) (tuple) &lt; (state)-&gt;slabMemoryEnd)</cpp:value></cpp:define>

<comment type="block">/*
 * Return the given tuple to the slab memory free list, or free it
 * if it was palloc'd.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RELEASE_SLAB_SLOT</name><parameter_list>(<parameter><type><name>state</name></type></parameter>, <parameter><type><name>tuple</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		SlabSlot *buf = (SlabSlot *) tuple; \
		\
		if (IS_SLAB_SLOT((state), buf)) \
		{ \
			buf-&gt;nextfree = (state)-&gt;slabFreeHead; \
			(state)-&gt;slabFreeHead = buf; \
		} else \
			pfree(buf); \
	} while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPARETUP</name><parameter_list>(<parameter><type><name>state</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((*(state)-&gt;comparetup) (a, b, state))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COPYTUP</name><parameter_list>(<parameter><type><name>state</name></type></parameter>,<parameter><type><name>stup</name></type></parameter>,<parameter><type><name>tup</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((*(state)-&gt;copytup) (state, stup, tup))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITETUP</name><parameter_list>(<parameter><type><name>state</name></type></parameter>,<parameter><type><name>tape</name></type></parameter>,<parameter><type><name>stup</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((*(state)-&gt;writetup) (state, tape, stup))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READTUP</name><parameter_list>(<parameter><type><name>state</name></type></parameter>,<parameter><type><name>stup</name></type></parameter>,<parameter><type><name>tape</name></type></parameter>,<parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((*(state)-&gt;readtup) (state, stup, tape, len))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LACKMEM</name><parameter_list>(<parameter><type><name>state</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((state)-&gt;availMem &lt; 0 &amp;&amp; !(state)-&gt;slabAllocatorUsed)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USEMEM</name><parameter_list>(<parameter><type><name>state</name></type></parameter>,<parameter><type><name>amt</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((state)-&gt;availMem -= (amt))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FREEMEM</name><parameter_list>(<parameter><type><name>state</name></type></parameter>,<parameter><type><name>amt</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((state)-&gt;availMem += (amt))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SERIAL</name><parameter_list>(<parameter><type><name>state</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((state)-&gt;shared == NULL)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WORKER</name><parameter_list>(<parameter><type><name>state</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((state)-&gt;shared &amp;&amp; (state)-&gt;worker != -1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEADER</name><parameter_list>(<parameter><type><name>state</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((state)-&gt;shared &amp;&amp; (state)-&gt;worker == -1)</cpp:value></cpp:define>

<comment type="block">/*
 * NOTES about on-tape representation of tuples:
 *
 * We require the first "unsigned int" of a stored tuple to be the total size
 * on-tape of the tuple, including itself (so it is never zero; an all-zero
 * unsigned int is used to delimit runs).  The remainder of the stored tuple
 * may or may not match the in-memory representation of the tuple ---
 * any conversion needed is the job of the writetup and readtup routines.
 *
 * If state-&gt;randomAccess is true, then the stored representation of the
 * tuple must be followed by another "unsigned int" that is a copy of the
 * length --- so the total tape space used is actually sizeof(unsigned int)
 * more than the stored length value.  This allows read-backwards.  When
 * randomAccess is not true, the write/read routines may omit the extra
 * length word.
 *
 * writetup is expected to write both length words as well as the tuple
 * data.  When readtup is called, the tape is positioned just after the
 * front length word; readtup must read the tuple data and advance past
 * the back length word (if present).
 *
 * The write/read routines can make use of the tuple description data
 * stored in the Tuplesortstate record, if needed.  They are also expected
 * to adjust state-&gt;availMem by the amount of memory space (not tape space!)
 * released or consumed.  There is no error return from either writetup
 * or readtup; they should ereport() on failure.
 *
 *
 * NOTES about memory consumption calculations:
 *
 * We count space allocated for tuples against the workMem limit, plus
 * the space used by the variable-size memtuples array.  Fixed-size space
 * is not counted; it's small enough to not be interesting.
 *
 * Note that we count actual space used (as shown by GetMemoryChunkSpace)
 * rather than the originally-requested size.  This is important since
 * palloc can add substantial overhead.  It's not a complete answer since
 * we won't count any wasted space in palloc allocation blocks, but it's
 * a lot better than what we were doing before 7.3.  As of 9.6, a
 * separate memory context is used for caller passed tuples.  Resetting
 * it at certain key increments significantly ameliorates fragmentation.
 * Note that this places a responsibility on readtup and copytup routines
 * to use the right memory context for these tuples (and to not use the
 * reset context for anything whose lifetime needs to span multiple
 * external sort runs).
 */</comment>

<comment type="block">/* When using this macro, beware of double evaluation of len */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LogicalTapeReadExact</name><parameter_list>(<parameter><type><name>tapeset</name></type></parameter>, <parameter><type><name>tapenum</name></type></parameter>, <parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		if (LogicalTapeRead(tapeset, tapenum, ptr, len) != (size_t) (len)) \
			elog(ERROR, "unexpected end of data"); \
	} while(0)</cpp:value></cpp:define>


<function_decl><type><specifier>static</specifier> <name>Tuplesortstate</name> <modifier>*</modifier></type><name>tuplesort_begin_common</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>workMem</name></decl></parameter>,
					   <parameter><decl><type><name>SortCoordinate</name></type> <name>coordinate</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>randomAccess</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>puttuple_common</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>tuple</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>consider_abort_common</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>inittapes</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>mergeruns</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>inittapestate</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxTapes</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>selectnewtape</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>init_slab_allocator</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numSlots</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>mergeruns</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>mergeonerun</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>beginmerge</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>mergereadnext</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcTape</name></decl></parameter>, <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>stup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumptuples</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>alltuples</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>make_bounded_heap</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sort_bounded_heap</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>tuplesort_sort_memtuples</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>tuplesort_heap_insert</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>tuple</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>tuplesort_heap_replace_top</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>tuple</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>tuplesort_heap_delete_top</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>reversedirection</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>getlen</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>eofOK</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>markrunend</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>readtup_alloc</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>tuplen</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>comparetup_heap</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SortTuple</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SortTuple</name> <modifier>*</modifier></type><name>b</name></decl></parameter>,
				<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>copytup_heap</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>stup</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>tup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>writetup_heap</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>,
			  <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>stup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>readtup_heap</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>stup</name></decl></parameter>,
			 <parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>comparetup_cluster</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SortTuple</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SortTuple</name> <modifier>*</modifier></type><name>b</name></decl></parameter>,
				   <parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>copytup_cluster</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>stup</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>tup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>writetup_cluster</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>,
				 <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>stup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>readtup_cluster</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>stup</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>comparetup_index_btree</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SortTuple</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SortTuple</name> <modifier>*</modifier></type><name>b</name></decl></parameter>,
					   <parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>comparetup_index_hash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SortTuple</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SortTuple</name> <modifier>*</modifier></type><name>b</name></decl></parameter>,
					  <parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>copytup_index</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>stup</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>tup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>writetup_index</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>,
			   <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>stup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>readtup_index</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>stup</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>comparetup_datum</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SortTuple</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SortTuple</name> <modifier>*</modifier></type><name>b</name></decl></parameter>,
				 <parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>copytup_datum</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>stup</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>tup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>writetup_datum</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>,
			   <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>stup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>readtup_datum</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>stup</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>worker_get_identifier</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>worker_freeze_result_tape</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>worker_nomergeruns</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>leader_takeover_tapes</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>free_sort_tuple</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>stup</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Special versions of qsort just for SortTuple objects.  qsort_tuple() sorts
 * any variant of SortTuples, using the appropriate comparetup function.
 * qsort_ssup() is specialized for the case where the comparetup function
 * reduces to ApplySortComparator(), that is single-key MinimalTuple sorts
 * and Datum sorts.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"qsort_tuple.c"</cpp:file></cpp:include>


<comment type="block">/*
 *		tuplesort_begin_xxx
 *
 * Initialize for a tuple sort operation.
 *
 * After calling tuplesort_begin, the caller should call tuplesort_putXXX
 * zero or more times, then call tuplesort_performsort when all the tuples
 * have been supplied.  After performsort, retrieve the tuples in sorted
 * order by calling tuplesort_getXXX until it returns false/NULL.  (If random
 * access was requested, rescan, markpos, and restorepos can also be called.)
 * Call tuplesort_end to terminate the operation and release memory/disk space.
 *
 * Each variant of tuplesort_begin has a workMem parameter specifying the
 * maximum number of kilobytes of RAM to use before spilling data to disk.
 * (The normal value of this parameter is work_mem, but some callers use
 * other values.)  Each variant also has a randomAccess parameter specifying
 * whether the caller needs non-sequential access to the sort result.
 */</comment>

<function><type><specifier>static</specifier> <name>Tuplesortstate</name> <modifier>*</modifier></type>
<name>tuplesort_begin_common</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>workMem</name></decl></parameter>, <parameter><decl><type><name>SortCoordinate</name></type> <name>coordinate</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>randomAccess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>sortcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>tuplecontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* See leader_takeover_tapes() remarks on randomAccess support */</comment>
	<if_stmt><if>if <condition>(<expr><name>coordinate</name> <operator>&amp;&amp;</operator> <name>randomAccess</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"random access disallowed under parallel sort"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Create a working memory context for this sort operation. All data
	 * needed by the sort will live inside this context.
	 */</comment>
	<expr_stmt><expr><name>sortcontext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr></argument>,
										<argument><expr><literal type="string">"TupleSort main"</literal></expr></argument>,
										<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Caller tuple (e.g. IndexTuple) memory context.
	 *
	 * A dedicated child context used exclusively for caller passed tuples
	 * eases memory management.  Resetting at key points reduces
	 * fragmentation. Note that the memtuples array of SortTuples is allocated
	 * in the parent context, not this context, because there is no need to
	 * free memtuples early.
	 */</comment>
	<expr_stmt><expr><name>tuplecontext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>sortcontext</name></expr></argument>,
										 <argument><expr><literal type="string">"Caller tuples"</literal></expr></argument>,
										 <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make the Tuplesortstate within the per-sort context.  This way, we
	 * don't need a separate pfree() operation for it at shutdown.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>sortcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>Tuplesortstate</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Tuplesortstate</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRACE_SORT</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>trace_sort</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_rusage_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>ru_start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>TSS_INITIAL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>randomAccess</name></name> <operator>=</operator> <name>randomAccess</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>bounded</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>boundUsed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * workMem is forced to be at least 64KB, the current minimum valid value
	 * for the work_mem GUC.  This is a defense against parallel sort callers
	 * that divide out memory among many workers in a way that leaves each
	 * with very little memory.
	 */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>allowedMem</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>workMem</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call> <operator>*</operator> <operator>(</operator><name>int64</name><operator>)</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>availMem</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>allowedMem</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>sortcontext</name></name> <operator>=</operator> <name>sortcontext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tuplecontext</name></name> <operator>=</operator> <name>tuplecontext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initial size of array must be more than ALLOCSET_SEPARATE_THRESHOLD;
	 * see comments in grow_memtuples().
	 */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>memtupsize</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><literal type="number">1024</literal></expr></argument>,
							<argument><expr><name>ALLOCSET_SEPARATE_THRESHOLD</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SortTuple</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>growmemtuples</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>slabAllocatorUsed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name></name> <operator>=</operator> <operator>(</operator><name>SortTuple</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtupsize</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SortTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>USEMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>GetMemoryChunkSpace</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* workMem must be large enough for the minimal memtuples array */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>LACKMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"insufficient memory allowed for sort"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>currentRun</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * maxTapes, tapeRange, and Algorithm D variables will be initialized by
	 * inittapes(), if needed
	 */</comment>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>result_tape</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* flag that result tape has not been formed */</comment>

	<comment type="block">/*
	 * Initialize parallel-related state based on coordination information
	 * from caller
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>coordinate</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Serial sort */</comment>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>shared</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>worker</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nParticipants</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>coordinate</name><operator>-&gt;</operator><name>isWorker</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Parallel worker produces exactly one final run from all input */</comment>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>shared</name></name> <operator>=</operator> <name><name>coordinate</name><operator>-&gt;</operator><name>sharedsort</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>worker</name></name> <operator>=</operator> <call><name>worker_get_identifier</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nParticipants</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Parallel leader state only used for final merge */</comment>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>shared</name></name> <operator>=</operator> <name><name>coordinate</name><operator>-&gt;</operator><name>sharedsort</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>worker</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nParticipants</name></name> <operator>=</operator> <name><name>coordinate</name><operator>-&gt;</operator><name>nParticipants</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>nParticipants</name></name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Tuplesortstate</name> <modifier>*</modifier></type>
<name>tuplesort_begin_heap</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupDesc</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attNums</name></decl></parameter>,
					 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>sortOperators</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>sortCollations</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nullsFirstFlags</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>workMem</name></decl></parameter>, <parameter><decl><type><name>SortCoordinate</name></type> <name>coordinate</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>randomAccess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><call><name>tuplesort_begin_common</name><argument_list>(<argument><expr><name>workMem</name></expr></argument>, <argument><expr><name>coordinate</name></expr></argument>,
												   <argument><expr><name>randomAccess</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sortcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>nkeys</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRACE_SORT</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>trace_sort</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			 <argument><expr><literal type="string">"begin tuple sort: nkeys = %d, workMem = %d, randomAccess = %c"</literal></expr></argument>,
			 <argument><expr><name>nkeys</name></expr></argument>, <argument><expr><name>workMem</name></expr></argument>, <argument><expr><ternary><condition><expr><name>randomAccess</name></expr> ?</condition><then> <expr><literal type="char">'t'</literal></expr> </then><else>: <expr><literal type="char">'f'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nKeys</name></name> <operator>=</operator> <name>nkeys</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_SORT_START</name><argument_list>(<argument><expr><name>HEAP_SORT</name></expr></argument>,
								<argument><expr><name>false</name></expr></argument>,	<comment type="block">/* no unique check */</comment>
								<argument><expr><name>nkeys</name></expr></argument>,
								<argument><expr><name>workMem</name></expr></argument>,
								<argument><expr><name>randomAccess</name></expr></argument>,
								<argument><expr><call><name>PARALLEL_SORT</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>comparetup</name></name> <operator>=</operator> <name>comparetup_heap</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>copytup</name></name> <operator>=</operator> <name>copytup_heap</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>writetup</name></name> <operator>=</operator> <name>writetup_heap</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readtup</name></name> <operator>=</operator> <name>readtup_heap</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>=</operator> <name>tupDesc</name></expr>;</expr_stmt>	<comment type="block">/* assume we need not copy tupDesc */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>abbrevNext</name></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>

	<comment type="block">/* Prepare SortSupport data for each column */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name></name> <operator>=</operator> <operator>(</operator><name>SortSupport</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SortSupportData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nkeys</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortSupport</name></type> <name>sortKey</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name><name>attNums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name><name>sortOperators</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>sortKey</name><operator>-&gt;</operator><name>ssup_cxt</name></name> <operator>=</operator> <call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sortKey</name><operator>-&gt;</operator><name>ssup_collation</name></name> <operator>=</operator> <name><name>sortCollations</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sortKey</name><operator>-&gt;</operator><name>ssup_nulls_first</name></name> <operator>=</operator> <name><name>nullsFirstFlags</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sortKey</name><operator>-&gt;</operator><name>ssup_attno</name></name> <operator>=</operator> <name><name>attNums</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<comment type="block">/* Convey if abbreviation optimization is applicable in principle */</comment>
		<expr_stmt><expr><name><name>sortKey</name><operator>-&gt;</operator><name>abbreviate</name></name> <operator>=</operator> <operator>(</operator><name>i</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PrepareSortSupportFromOrderingOp</name><argument_list>(<argument><expr><name><name>sortOperators</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>sortKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * The "onlyKey" optimization cannot be used with abbreviated keys, since
	 * tie-breaker comparisons may be required.  Typically, the optimization
	 * is only of value to pass-by-value types anyway, whereas abbreviated
	 * keys are typically only of value to pass-by-reference types.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nkeys</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><operator>-&gt;</operator><name>abbrev_converter</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>onlyKey</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>sortKeys</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Tuplesortstate</name> <modifier>*</modifier></type>
<name>tuplesort_begin_cluster</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupDesc</name></decl></parameter>,
						<parameter><decl><type><name>Relation</name></type> <name>indexRel</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>workMem</name></decl></parameter>,
						<parameter><decl><type><name>SortCoordinate</name></type> <name>coordinate</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>randomAccess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><call><name>tuplesort_begin_common</name><argument_list>(<argument><expr><name>workMem</name></expr></argument>, <argument><expr><name>coordinate</name></expr></argument>,
												   <argument><expr><name>randomAccess</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKey</name></type>		<name>indexScanKey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>indexRel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name> <operator>==</operator> <name>BTREE_AM_OID</name> <operator>||</operator>
		   <name><name>indexRel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name> <operator>==</operator> <name>LSM_AM_OID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sortcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRACE_SORT</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>trace_sort</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			 <argument><expr><literal type="string">"begin tuple sort: nkeys = %d, workMem = %d, randomAccess = %c"</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><name>workMem</name></expr></argument>, <argument><expr><ternary><condition><expr><name>randomAccess</name></expr> ?</condition><then> <expr><literal type="char">'t'</literal></expr> </then><else>: <expr><literal type="char">'f'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nKeys</name></name> <operator>=</operator> <call><name>IndexRelationGetNumberOfKeyAttributes</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_SORT_START</name><argument_list>(<argument><expr><name>CLUSTER_SORT</name></expr></argument>,
								<argument><expr><name>false</name></expr></argument>,	<comment type="block">/* no unique check */</comment>
								<argument><expr><name><name>state</name><operator>-&gt;</operator><name>nKeys</name></name></expr></argument>,
								<argument><expr><name>workMem</name></expr></argument>,
								<argument><expr><name>randomAccess</name></expr></argument>,
								<argument><expr><call><name>PARALLEL_SORT</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>comparetup</name></name> <operator>=</operator> <name>comparetup_cluster</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>copytup</name></name> <operator>=</operator> <name>copytup_cluster</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>writetup</name></name> <operator>=</operator> <name>writetup_cluster</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readtup</name></name> <operator>=</operator> <name>readtup_cluster</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>abbrevNext</name></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>indexInfo</name></name> <operator>=</operator> <call><name>BuildIndexInfo</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>=</operator> <name>tupDesc</name></expr>;</expr_stmt>	<comment type="block">/* assume we need not copy tupDesc */</comment>

	<expr_stmt><expr><name>indexScanKey</name> <operator>=</operator> <call><name>_bt_mkscankey_nodata</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>indexInfo</name><operator>-&gt;</operator><name>ii_Expressions</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We will need to use FormIndexDatum to evaluate the index
		 * expressions.  To do that, we need an EState, as well as a
		 * TupleTableSlot to put the table tuples into.  The econtext's
		 * scantuple has to point to that slot, too.
		 */</comment>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>estate</name></name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>estate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Prepare SortSupport data for each column */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name></name> <operator>=</operator> <operator>(</operator><name>SortSupport</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>nKeys</name></name> <operator>*</operator>
											<sizeof>sizeof<argument_list>(<argument><expr><name>SortSupportData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>nKeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortSupport</name></type> <name>sortKey</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ScanKey</name></type>		<name>scanKey</name> <init>= <expr><name>indexScanKey</name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type>		<name>strategy</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>sortKey</name><operator>-&gt;</operator><name>ssup_cxt</name></name> <operator>=</operator> <call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sortKey</name><operator>-&gt;</operator><name>ssup_collation</name></name> <operator>=</operator> <name><name>scanKey</name><operator>-&gt;</operator><name>sk_collation</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sortKey</name><operator>-&gt;</operator><name>ssup_nulls_first</name></name> <operator>=</operator>
			<operator>(</operator><name><name>scanKey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_NULLS_FIRST</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sortKey</name><operator>-&gt;</operator><name>ssup_attno</name></name> <operator>=</operator> <name><name>scanKey</name><operator>-&gt;</operator><name>sk_attno</name></name></expr>;</expr_stmt>
		<comment type="block">/* Convey if abbreviation optimization is applicable in principle */</comment>
		<expr_stmt><expr><name><name>sortKey</name><operator>-&gt;</operator><name>abbreviate</name></name> <operator>=</operator> <operator>(</operator><name>i</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><name><name>sortKey</name><operator>-&gt;</operator><name>ssup_attno</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>strategy</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>scanKey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_DESC</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then>
			<expr><name>BTGreaterStrategyNumber</name></expr> </then><else>: <expr><name>BTLessStrategyNumber</name></expr></else></ternary></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PrepareSortSupportFromIndexRel</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>, <argument><expr><name>sortKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>_bt_freeskey</name><argument_list>(<argument><expr><name>indexScanKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Tuplesortstate</name> <modifier>*</modifier></type>
<name>tuplesort_begin_index_btree</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heapRel</name></decl></parameter>,
							<parameter><decl><type><name>Relation</name></type> <name>indexRel</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>enforceUnique</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>workMem</name></decl></parameter>,
							<parameter><decl><type><name>SortCoordinate</name></type> <name>coordinate</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>randomAccess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><call><name>tuplesort_begin_common</name><argument_list>(<argument><expr><name>workMem</name></expr></argument>, <argument><expr><name>coordinate</name></expr></argument>,
												   <argument><expr><name>randomAccess</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKey</name></type>		<name>indexScanKey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sortcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRACE_SORT</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>trace_sort</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			 <argument><expr><literal type="string">"begin index sort: unique = %c, workMem = %d, randomAccess = %c"</literal></expr></argument>,
			 <argument><expr><ternary><condition><expr><name>enforceUnique</name></expr> ?</condition><then> <expr><literal type="char">'t'</literal></expr> </then><else>: <expr><literal type="char">'f'</literal></expr></else></ternary></expr></argument>,
			 <argument><expr><name>workMem</name></expr></argument>, <argument><expr><ternary><condition><expr><name>randomAccess</name></expr> ?</condition><then> <expr><literal type="char">'t'</literal></expr> </then><else>: <expr><literal type="char">'f'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nKeys</name></name> <operator>=</operator> <call><name>IndexRelationGetNumberOfKeyAttributes</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_SORT_START</name><argument_list>(<argument><expr><name>INDEX_SORT</name></expr></argument>,
								<argument><expr><name>enforceUnique</name></expr></argument>,
								<argument><expr><name><name>state</name><operator>-&gt;</operator><name>nKeys</name></name></expr></argument>,
								<argument><expr><name>workMem</name></expr></argument>,
								<argument><expr><name>randomAccess</name></expr></argument>,
								<argument><expr><call><name>PARALLEL_SORT</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>comparetup</name></name> <operator>=</operator> <name>comparetup_index_btree</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>copytup</name></name> <operator>=</operator> <name>copytup_index</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>writetup</name></name> <operator>=</operator> <name>writetup_index</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readtup</name></name> <operator>=</operator> <name>readtup_index</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>abbrevNext</name></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>heapRel</name></name> <operator>=</operator> <name>heapRel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>indexRel</name></name> <operator>=</operator> <name>indexRel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>enforceUnique</name></name> <operator>=</operator> <name>enforceUnique</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>indexScanKey</name> <operator>=</operator> <call><name>_bt_mkscankey_nodata</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Prepare SortSupport data for each column */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name></name> <operator>=</operator> <operator>(</operator><name>SortSupport</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>nKeys</name></name> <operator>*</operator>
											<sizeof>sizeof<argument_list>(<argument><expr><name>SortSupportData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>nKeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortSupport</name></type> <name>sortKey</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ScanKey</name></type>		<name>scanKey</name> <init>= <expr><name>indexScanKey</name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type>		<name>strategy</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>sortKey</name><operator>-&gt;</operator><name>ssup_cxt</name></name> <operator>=</operator> <call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sortKey</name><operator>-&gt;</operator><name>ssup_collation</name></name> <operator>=</operator> <name><name>scanKey</name><operator>-&gt;</operator><name>sk_collation</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sortKey</name><operator>-&gt;</operator><name>ssup_nulls_first</name></name> <operator>=</operator>
			<operator>(</operator><name><name>scanKey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_NULLS_FIRST</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sortKey</name><operator>-&gt;</operator><name>ssup_attno</name></name> <operator>=</operator> <name><name>scanKey</name><operator>-&gt;</operator><name>sk_attno</name></name></expr>;</expr_stmt>
		<comment type="block">/* Convey if abbreviation optimization is applicable in principle */</comment>
		<expr_stmt><expr><name><name>sortKey</name><operator>-&gt;</operator><name>abbreviate</name></name> <operator>=</operator> <operator>(</operator><name>i</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><name><name>sortKey</name><operator>-&gt;</operator><name>ssup_attno</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>strategy</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>scanKey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_DESC</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then>
			<expr><name>BTGreaterStrategyNumber</name></expr> </then><else>: <expr><name>BTLessStrategyNumber</name></expr></else></ternary></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PrepareSortSupportFromIndexRel</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>, <argument><expr><name>sortKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>_bt_freeskey</name><argument_list>(<argument><expr><name>indexScanKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Tuplesortstate</name> <modifier>*</modifier></type>
<name>tuplesort_begin_index_hash</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heapRel</name></decl></parameter>,
						   <parameter><decl><type><name>Relation</name></type> <name>indexRel</name></decl></parameter>,
						   <parameter><decl><type><name>uint32</name></type> <name>high_mask</name></decl></parameter>,
						   <parameter><decl><type><name>uint32</name></type> <name>low_mask</name></decl></parameter>,
						   <parameter><decl><type><name>uint32</name></type> <name>max_buckets</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>workMem</name></decl></parameter>,
						   <parameter><decl><type><name>SortCoordinate</name></type> <name>coordinate</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>randomAccess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><call><name>tuplesort_begin_common</name><argument_list>(<argument><expr><name>workMem</name></expr></argument>, <argument><expr><name>coordinate</name></expr></argument>,
												   <argument><expr><name>randomAccess</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sortcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRACE_SORT</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>trace_sort</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			 <argument><expr><literal type="string">"begin index sort: high_mask = 0x%x, low_mask = 0x%x, "</literal>
			 <literal type="string">"max_buckets = 0x%x, workMem = %d, randomAccess = %c"</literal></expr></argument>,
			 <argument><expr><name>high_mask</name></expr></argument>,
			 <argument><expr><name>low_mask</name></expr></argument>,
			 <argument><expr><name>max_buckets</name></expr></argument>,
			 <argument><expr><name>workMem</name></expr></argument>, <argument><expr><ternary><condition><expr><name>randomAccess</name></expr> ?</condition><then> <expr><literal type="char">'t'</literal></expr> </then><else>: <expr><literal type="char">'f'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nKeys</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>			<comment type="block">/* Only one sort column, the hash code */</comment>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>comparetup</name></name> <operator>=</operator> <name>comparetup_index_hash</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>copytup</name></name> <operator>=</operator> <name>copytup_index</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>writetup</name></name> <operator>=</operator> <name>writetup_index</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readtup</name></name> <operator>=</operator> <name>readtup_index</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>heapRel</name></name> <operator>=</operator> <name>heapRel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>indexRel</name></name> <operator>=</operator> <name>indexRel</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>high_mask</name></name> <operator>=</operator> <name>high_mask</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>low_mask</name></name> <operator>=</operator> <name>low_mask</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>max_buckets</name></name> <operator>=</operator> <name>max_buckets</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Tuplesortstate</name> <modifier>*</modifier></type>
<name>tuplesort_begin_datum</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>datumType</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>sortOperator</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>sortCollation</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>nullsFirstFlag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>workMem</name></decl></parameter>,
					  <parameter><decl><type><name>SortCoordinate</name></type> <name>coordinate</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>randomAccess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><call><name>tuplesort_begin_common</name><argument_list>(<argument><expr><name>workMem</name></expr></argument>, <argument><expr><name>coordinate</name></expr></argument>,
												   <argument><expr><name>randomAccess</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>typlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typbyval</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sortcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRACE_SORT</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>trace_sort</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			 <argument><expr><literal type="string">"begin datum sort: workMem = %d, randomAccess = %c"</literal></expr></argument>,
			 <argument><expr><name>workMem</name></expr></argument>, <argument><expr><ternary><condition><expr><name>randomAccess</name></expr> ?</condition><then> <expr><literal type="char">'t'</literal></expr> </then><else>: <expr><literal type="char">'f'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nKeys</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>			<comment type="block">/* always a one-column sort */</comment>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_SORT_START</name><argument_list>(<argument><expr><name>DATUM_SORT</name></expr></argument>,
								<argument><expr><name>false</name></expr></argument>,	<comment type="block">/* no unique check */</comment>
								<argument><expr><literal type="number">1</literal></expr></argument>,
								<argument><expr><name>workMem</name></expr></argument>,
								<argument><expr><name>randomAccess</name></expr></argument>,
								<argument><expr><call><name>PARALLEL_SORT</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>comparetup</name></name> <operator>=</operator> <name>comparetup_datum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>copytup</name></name> <operator>=</operator> <name>copytup_datum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>writetup</name></name> <operator>=</operator> <name>writetup_datum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readtup</name></name> <operator>=</operator> <name>readtup_datum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>abbrevNext</name></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>datumType</name></name> <operator>=</operator> <name>datumType</name></expr>;</expr_stmt>

	<comment type="block">/* lookup necessary attributes of the datum type */</comment>
	<expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name>datumType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typbyval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>datumTypeLen</name></name> <operator>=</operator> <name>typlen</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator> <operator>!</operator><name>typbyval</name></expr>;</expr_stmt>

	<comment type="block">/* Prepare SortSupport data */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name></name> <operator>=</operator> <operator>(</operator><name>SortSupport</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SortSupportData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><operator>-&gt;</operator><name>ssup_cxt</name></name> <operator>=</operator> <call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><operator>-&gt;</operator><name>ssup_collation</name></name> <operator>=</operator> <name>sortCollation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><operator>-&gt;</operator><name>ssup_nulls_first</name></name> <operator>=</operator> <name>nullsFirstFlag</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Abbreviation is possible here only for by-reference types.  In theory,
	 * a pass-by-value datatype could have an abbreviated form that is cheaper
	 * to compare.  In a tuple sort, we could support that, because we can
	 * always extract the original datum from the tuple is needed.  Here, we
	 * can't, because a datum sort only stores a single copy of the datum; the
	 * "tuple" field of each sortTuple is NULL.
	 */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><operator>-&gt;</operator><name>abbreviate</name></name> <operator>=</operator> <operator>!</operator><name>typbyval</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PrepareSortSupportFromOrderingOp</name><argument_list>(<argument><expr><name>sortOperator</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The "onlyKey" optimization cannot be used with abbreviated keys, since
	 * tie-breaker comparisons may be required.  Typically, the optimization
	 * is only of value to pass-by-value types anyway, whereas abbreviated
	 * keys are typically only of value to pass-by-reference types.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><operator>-&gt;</operator><name>abbrev_converter</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>onlyKey</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>sortKeys</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * tuplesort_set_bound
 *
 *	Advise tuplesort that at most the first N result tuples are required.
 *
 * Must be called before inserting any tuples.  (Actually, we could allow it
 * as long as the sort hasn't spilled to disk, but there seems no need for
 * delayed calls at the moment.)
 *
 * This is a hint only. The tuplesort may still return more tuples than
 * requested.  Parallel leader tuplesorts will always ignore the hint.
 */</comment>
<function><type><name>void</name></type>
<name>tuplesort_set_bound</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>bound</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Assert we're called before loading any tuples */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>TSS_INITIAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>bounded</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>WORKER</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_BOUNDED_SORT</name></cpp:ifdef>
	<comment type="block">/* Honor GUC setting that disables the feature (for easy testing) */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>optimize_bounded_sort</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Parallel leader ignores hint */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>LEADER</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* We want to be able to compute bound * 2, so limit the setting */</comment>
	<if_stmt><if>if <condition>(<expr><name>bound</name> <operator>&gt;</operator> <operator>(</operator><name>int64</name><operator>)</operator> <operator>(</operator><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>bounded</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>bound</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>bound</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Bounded sorts are not an effective target for abbreviated key
	 * optimization.  Disable by setting state to be consistent with no
	 * abbreviation support.
	 */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><operator>-&gt;</operator><name>abbrev_converter</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><operator>-&gt;</operator><name>abbrev_full_comparator</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><operator>-&gt;</operator><name>comparator</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><operator>-&gt;</operator><name>abbrev_full_comparator</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Not strictly necessary, but be tidy */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><operator>-&gt;</operator><name>abbrev_abort</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><operator>-&gt;</operator><name>abbrev_full_comparator</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tuplesort_end
 *
 *	Release resources and clean up.
 *
 * NOTE: after calling this, any pointers returned by tuplesort_getXXX are
 * pointing to garbage.  Be careful not to attempt to use or free such
 * pointers afterwards!
 */</comment>
<function><type><name>void</name></type>
<name>tuplesort_end</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* context swap probably not needed, but let's be safe */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sortcontext</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRACE_SORT</name></cpp:ifdef>
	<decl_stmt><decl><type><name>long</name></type>		<name>spaceUsed</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>spaceUsed</name> <operator>=</operator> <call><name>LogicalTapeSetBlocks</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>spaceUsed</name> <operator>=</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>allowedMem</name></name> <operator>-</operator> <name><name>state</name><operator>-&gt;</operator><name>availMem</name></name> <operator>+</operator> <literal type="number">1023</literal><operator>)</operator> <operator>/</operator> <literal type="number">1024</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Delete temporary "tape" files, if any.
	 *
	 * Note: want to include this in reported total cost of sort, hence need
	 * for two #ifdef TRACE_SORT sections.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LogicalTapeSetClose</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRACE_SORT</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>trace_sort</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"%s of worker %d ended, %ld disk blocks used: %s"</literal></expr></argument>,
				 <argument><expr><ternary><condition><expr><call><name>SERIAL</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"external sort"</literal></expr> </then><else>: <expr><literal type="string">"parallel external sort"</literal></expr></else></ternary></expr></argument>,
				 <argument><expr><name><name>state</name><operator>-&gt;</operator><name>worker</name></name></expr></argument>, <argument><expr><name>spaceUsed</name></expr></argument>, <argument><expr><call><name>pg_rusage_show</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>ru_start</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"%s of worker %d ended, %ld KB used: %s"</literal></expr></argument>,
				 <argument><expr><ternary><condition><expr><call><name>SERIAL</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"internal sort"</literal></expr> </then><else>: <expr><literal type="string">"unperformed parallel sort"</literal></expr></else></ternary></expr></argument>,
				 <argument><expr><name><name>state</name><operator>-&gt;</operator><name>worker</name></name></expr></argument>, <argument><expr><name>spaceUsed</name></expr></argument>, <argument><expr><call><name>pg_rusage_show</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>ru_start</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_SORT_DONE</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>, <argument><expr><name>spaceUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

	<comment type="block">/*
	 * If you disabled TRACE_SORT, you can still probe sort__done, but you
	 * ain't getting space-used stats.
	 */</comment>
	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_SORT_DONE</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Free any execution state created for CLUSTER case */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>estate</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>estate</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>estate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Free the per-sort memory context, thereby releasing all working memory,
	 * including the Tuplesortstate struct itself.
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sortcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Grow the memtuples[] array, if possible within our memory constraint.  We
 * must not exceed INT_MAX tuples in memory or the caller-provided memory
 * limit.  Return true if we were able to enlarge the array, false if not.
 *
 * Normally, at each increment we double the size of the array.  When doing
 * that would exceed a limit, we attempt one last, smaller increase (and then
 * clear the growmemtuples flag so we don't try any more).  That allows us to
 * use memory as fully as permitted; sticking to the pure doubling rule could
 * result in almost half going unused.  Because availMem moves around with
 * tuple addition/removal, we need some rule to prevent making repeated small
 * increases in memtupsize, which would just be useless thrashing.  The
 * growmemtuples flag accomplishes that and also prevents useless
 * recalculations in this function.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>grow_memtuples</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>newmemtupsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>memtupsize</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>memtupsize</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>memNowUsed</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>allowedMem</name></name> <operator>-</operator> <name><name>state</name><operator>-&gt;</operator><name>availMem</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Forget it if we've already maxed out memtuples, per comment above */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>growmemtuples</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Select new value of memtupsize */</comment>
	<if_stmt><if>if <condition>(<expr><name>memNowUsed</name> <operator>&lt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>availMem</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We've used no more than half of allowedMem; double our usage,
		 * clamping at INT_MAX tuples.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>memtupsize</name> <operator>&lt;</operator> <name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newmemtupsize</name> <operator>=</operator> <name>memtupsize</name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>newmemtupsize</name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>growmemtuples</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * This will be the last increment of memtupsize.  Abandon doubling
		 * strategy and instead increase as much as we safely can.
		 *
		 * To stay within allowedMem, we can't increase memtupsize by more
		 * than availMem / sizeof(SortTuple) elements.  In practice, we want
		 * to increase it by considerably less, because we need to leave some
		 * space for the tuples to which the new array slots will refer.  We
		 * assume the new tuples will be about the same size as the tuples
		 * we've already seen, and thus we can extrapolate from the space
		 * consumption so far to estimate an appropriate new size for the
		 * memtuples array.  The optimal value might be higher or lower than
		 * this estimate, but it's hard to know that in advance.  We again
		 * clamp at INT_MAX tuples.
		 *
		 * This calculation is safe against enlarging the array so much that
		 * LACKMEM becomes true, because the memory currently used includes
		 * the present array; thus, there would be enough allowedMem for the
		 * new array elements even if no other memory were currently used.
		 *
		 * We do the arithmetic in float8, because otherwise the product of
		 * memtupsize and allowedMem could overflow.  Any inaccuracy in the
		 * result should be insignificant; but even if we computed a
		 * completely insane result, the checks below will prevent anything
		 * really bad from happening.
		 */</comment>
		<decl_stmt><decl><type><name>double</name></type>		<name>grow_ratio</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>grow_ratio</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>allowedMem</name></name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>memNowUsed</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>memtupsize</name> <operator>*</operator> <name>grow_ratio</name> <operator>&lt;</operator> <name>INT_MAX</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newmemtupsize</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>memtupsize</name> <operator>*</operator> <name>grow_ratio</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>newmemtupsize</name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* We won't make any further enlargement attempts */</comment>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>growmemtuples</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Must enlarge array by at least one element, else report failure */</comment>
	<if_stmt><if>if <condition>(<expr><name>newmemtupsize</name> <operator>&lt;=</operator> <name>memtupsize</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>noalloc</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * On a 32-bit machine, allowedMem could exceed MaxAllocHugeSize.  Clamp
	 * to ensure our request won't be rejected.  Note that we can easily
	 * exhaust address space before facing this outcome.  (This is presently
	 * impossible due to guc.c's MAX_KILOBYTES limitation on work_mem, but
	 * don't rely on that at this distance.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Size</name><operator>)</operator> <name>newmemtupsize</name> <operator>&gt;=</operator> <name>MaxAllocHugeSize</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SortTuple</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>newmemtupsize</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>MaxAllocHugeSize</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SortTuple</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>growmemtuples</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* can't grow any more */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We need to be sure that we do not cause LACKMEM to become true, else
	 * the space management algorithm will go nuts.  The code above should
	 * never generate a dangerous request, but to be safe, check explicitly
	 * that the array growth fits within availMem.  (We could still cause
	 * LACKMEM if the memory chunk overhead associated with the memtuples
	 * array were to increase.  That shouldn't happen because we chose the
	 * initial array size large enough to ensure that palloc will be treating
	 * both old and new arrays as separate chunks.  But we'll check LACKMEM
	 * explicitly below just in case.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>availMem</name></name> <operator>&lt;</operator> <operator>(</operator><name>int64</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>newmemtupsize</name> <operator>-</operator> <name>memtupsize</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SortTuple</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>noalloc</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* OK, do it */</comment>
	<expr_stmt><expr><call><name>FREEMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>GetMemoryChunkSpace</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>memtupsize</name></name> <operator>=</operator> <name>newmemtupsize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name></name> <operator>=</operator> <operator>(</operator><name>SortTuple</name> <operator>*</operator><operator>)</operator>
		<call><name>repalloc_huge</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name></name></expr></argument>,
					  <argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtupsize</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SortTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>USEMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>GetMemoryChunkSpace</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>LACKMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected out-of-memory situation in tuplesort"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>

<label><name>noalloc</name>:</label>
	<comment type="block">/* If for any reason we didn't realloc, shut off future attempts */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>growmemtuples</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Accept one tuple while collecting input data for sort.
 *
 * Note that the input data is always copied; the caller need not save it.
 */</comment>
<function><type><name>void</name></type>
<name>tuplesort_puttupleslot</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sortcontext</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SortTuple</name></type>	<name>stup</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Copy the given tuple into memory we control, and decrease availMem.
	 * Then call the common code.
	 */</comment>
	<expr_stmt><expr><call><name>COPYTUP</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stup</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>puttuple_common</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Accept one tuple while collecting input data for sort.
 *
 * Note that the input data is always copied; the caller need not save it.
 */</comment>
<function><type><name>void</name></type>
<name>tuplesort_putheaptuple</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sortcontext</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SortTuple</name></type>	<name>stup</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Copy the given tuple into memory we control, and decrease availMem.
	 * Then call the common code.
	 */</comment>
	<expr_stmt><expr><call><name>COPYTUP</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stup</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>puttuple_common</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Collect one index tuple while collecting input data for sort, building
 * it from caller-supplied values.
 */</comment>
<function><type><name>void</name></type>
<name>tuplesort_putindextuplevalues</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
							  <parameter><decl><type><name>ItemPointer</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tuplecontext</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SortTuple</name></type>	<name>stup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>original</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>stup</name><operator>.</operator><name>tuple</name></name> <operator>=</operator> <call><name>index_form_tuple</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>IndexTuple</name><operator>)</operator> <name><name>stup</name><operator>.</operator><name>tuple</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_tid</name></name> <operator>=</operator> <operator>*</operator><name>self</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>USEMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>GetMemoryChunkSpace</name><argument_list>(<argument><expr><name><name>stup</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* set up first-column key value */</comment>
	<expr_stmt><expr><name>original</name> <operator>=</operator> <call><name>index_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
							 <argument><expr><literal type="number">1</literal></expr></argument>,
							 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>indexRel</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>stup</name><operator>.</operator><name>isnull1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sortcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name></name> <operator>||</operator> <operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><operator>-&gt;</operator><name>abbrev_converter</name></name> <operator>||</operator> <name><name>stup</name><operator>.</operator><name>isnull1</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Store ordinary Datum representation, or NULL value.  If there is a
		 * converter it won't expect NULL values, and cost model is not
		 * required to account for NULL, so in that case we avoid calling
		 * converter and just set datum1 to zeroed representation (to be
		 * consistent, and to support cheap inequality tests for NULL
		 * abbreviated keys).
		 */</comment>
		<expr_stmt><expr><name><name>stup</name><operator>.</operator><name>datum1</name></name> <operator>=</operator> <name>original</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>consider_abort_common</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Store abbreviated key representation */</comment>
		<expr_stmt><expr><name><name>stup</name><operator>.</operator><name>datum1</name></name> <operator>=</operator> <call><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><operator>-&gt;</operator><name>abbrev_converter</name></name><argument_list>(<argument><expr><name>original</name></expr></argument>,
														<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Abort abbreviation */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>stup</name><operator>.</operator><name>datum1</name></name> <operator>=</operator> <name>original</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Set state to be consistent with never trying abbreviation.
		 *
		 * Alter datum1 representation in already-copied tuples, so as to
		 * ensure a consistent representation (current tuple was just
		 * handled).  It does not matter if some dumped tuples are already
		 * sorted on tape, since serialized tuples lack abbreviated keys
		 * (TSS_BUILDRUNS state prevents control reaching here in any case).
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SortTuple</name>  <modifier>*</modifier></type><name>mtup</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>memtuples</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <name><name>mtup</name><operator>-&gt;</operator><name>tuple</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mtup</name><operator>-&gt;</operator><name>datum1</name></name> <operator>=</operator> <call><name>index_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
										 <argument><expr><literal type="number">1</literal></expr></argument>,
										 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>indexRel</name></name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name><name>mtup</name><operator>-&gt;</operator><name>isnull1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>puttuple_common</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Accept one Datum while collecting input data for sort.
 *
 * If the Datum is pass-by-ref type, the value will be copied.
 */</comment>
<function><type><name>void</name></type>
<name>tuplesort_putdatum</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isNull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tuplecontext</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SortTuple</name></type>	<name>stup</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Pass-by-value types or null values are just stored directly in
	 * stup.datum1 (and stup.tuple is not used and set to NULL).
	 *
	 * Non-null pass-by-reference values need to be copied into memory we
	 * control, and possibly abbreviated. The copied value is pointed to by
	 * stup.tuple and is treated as the canonical copy (e.g. to return via
	 * tuplesort_getdatum or when writing to tape); stup.datum1 gets the
	 * abbreviated value if abbreviation is happening, otherwise it's
	 * identical to stup.tuple.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><name>isNull</name> <operator>||</operator> <operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>tuples</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Set datum1 to zeroed representation for NULLs (to be consistent,
		 * and to support cheap inequality tests for NULL abbreviated keys).
		 */</comment>
		<expr_stmt><expr><name><name>stup</name><operator>.</operator><name>datum1</name></name> <operator>=</operator> <ternary><condition><expr><operator>!</operator><name>isNull</name></expr> ?</condition><then> <expr><name>val</name></expr> </then><else>: <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stup</name><operator>.</operator><name>isnull1</name></name> <operator>=</operator> <name>isNull</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stup</name><operator>.</operator><name>tuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* no separate storage */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sortcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>original</name> <init>= <expr><call><name>datumCopy</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>datumTypeLen</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>stup</name><operator>.</operator><name>isnull1</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stup</name><operator>.</operator><name>tuple</name></name> <operator>=</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>original</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>USEMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>GetMemoryChunkSpace</name><argument_list>(<argument><expr><name><name>stup</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sortcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><operator>-&gt;</operator><name>abbrev_converter</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>stup</name><operator>.</operator><name>datum1</name></name> <operator>=</operator> <name>original</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>consider_abort_common</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Store abbreviated key representation */</comment>
			<expr_stmt><expr><name><name>stup</name><operator>.</operator><name>datum1</name></name> <operator>=</operator> <call><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><operator>-&gt;</operator><name>abbrev_converter</name></name><argument_list>(<argument><expr><name>original</name></expr></argument>,
															<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Abort abbreviation */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>stup</name><operator>.</operator><name>datum1</name></name> <operator>=</operator> <name>original</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Set state to be consistent with never trying abbreviation.
			 *
			 * Alter datum1 representation in already-copied tuples, so as to
			 * ensure a consistent representation (current tuple was just
			 * handled).  It does not matter if some dumped tuples are already
			 * sorted on tape, since serialized tuples lack abbreviated keys
			 * (TSS_BUILDRUNS state prevents control reaching here in any
			 * case).
			 */</comment>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SortTuple</name>  <modifier>*</modifier></type><name>mtup</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>memtuples</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>mtup</name><operator>-&gt;</operator><name>datum1</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>mtup</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>puttuple_common</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Shared code for tuple and datum cases.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>puttuple_common</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>LEADER</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TSS_INITIAL</name></expr>:</case>

			<comment type="block">/*
			 * Save the tuple into the unsorted array.  First, grow the array
			 * as needed.  Note that we try to grow the array when there is
			 * still one free slot remaining --- if we fail, there'll still be
			 * room to store the incoming tuple, and then we'll switch to
			 * tape-based operation.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name> <operator>&gt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupsize</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>grow_memtuples</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>tuple</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Check if it's time to switch over to a bounded heapsort. We do
			 * so if the input tuple count exceeds twice the desired tuple
			 * count (this is a heuristic for where heapsort becomes cheaper
			 * than a quicksort), or if we've just filled workMem and have
			 * enough tuples to meet the bound.
			 *
			 * Note that once we enter TSS_BOUNDED state we will always try to
			 * complete the sort that way.  In the worst case, if later input
			 * tuples are larger than earlier ones, this might cause us to
			 * exceed workMem significantly.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>bounded</name></name> <operator>&amp;&amp;</operator>
				<operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name> <operator>&gt;</operator> <name><name>state</name><operator>-&gt;</operator><name>bound</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>||</operator>
				 <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name> <operator>&gt;</operator> <name><name>state</name><operator>-&gt;</operator><name>bound</name></name> <operator>&amp;&amp;</operator> <call><name>LACKMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition>
			<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRACE_SORT</name></cpp:ifdef>
				<if_stmt><if>if <condition>(<expr><name>trace_sort</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"switching to bounded heapsort at %d tuples: %s"</literal></expr></argument>,
						 <argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name></expr></argument>,
						 <argument><expr><call><name>pg_rusage_show</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>ru_start</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<expr_stmt><expr><call><name>make_bounded_heap</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Done if we still fit in available memory and have array slots.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupsize</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>LACKMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Nope; time to switch to tape-based operation.
			 */</comment>
			<expr_stmt><expr><call><name>inittapes</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Dump all tuples.
			 */</comment>
			<expr_stmt><expr><call><name>dumptuples</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>TSS_BOUNDED</name></expr>:</case>

			<comment type="block">/*
			 * We don't want to grow the array here, so check whether the new
			 * tuple can be discarded before putting it in.  This should be a
			 * good speed optimization, too, since when there are many more
			 * input tuples than the bound, most input tuples can be discarded
			 * with just this one comparison.  Note that because we currently
			 * have the sort direction reversed, we must check for &lt;= not &gt;=.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>COMPARETUP</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>memtuples</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* new tuple &lt;= top of the heap, so we can discard it */</comment>
				<expr_stmt><expr><call><name>free_sort_tuple</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* discard top of heap, replacing it with the new tuple */</comment>
				<expr_stmt><expr><call><name>free_sort_tuple</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>memtuples</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>tuplesort_heap_replace_top</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><name>TSS_BUILDRUNS</name></expr>:</case>

			<comment type="block">/*
			 * Save the tuple into the unsorted array (there must be space)
			 */</comment>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>tuple</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * If we are over the memory limit, dump all tuples.
			 */</comment>
			<expr_stmt><expr><call><name>dumptuples</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid tuplesort state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>consider_abort_common</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>abbrev_converter</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>abbrev_abort</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>abbrev_full_comparator</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check effectiveness of abbreviation optimization.  Consider aborting
	 * when still within memory limit.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>TSS_INITIAL</name> <operator>&amp;&amp;</operator>
		<name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name> <operator>&gt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>abbrevNext</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>abbrevNext</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check opclass-supplied abbreviation abort routine.  It may indicate
		 * that abbreviation should not proceed.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><operator>-&gt;</operator><name>abbrev_abort</name></name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name></expr></argument>,
										   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Finally, restore authoritative comparator, and indicate that
		 * abbreviation is not in play by setting abbrev_converter to NULL
		 */</comment>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>comparator</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>abbrev_full_comparator</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>abbrev_converter</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<comment type="block">/* Not strictly necessary, but be tidy */</comment>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>abbrev_abort</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>abbrev_full_comparator</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/* Give up - expect original pass-by-value representation */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * All tuples have been provided; finish the sort.
 */</comment>
<function><type><name>void</name></type>
<name>tuplesort_performsort</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sortcontext</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRACE_SORT</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>trace_sort</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"performsort of worker %d starting: %s"</literal></expr></argument>,
			 <argument><expr><name><name>state</name><operator>-&gt;</operator><name>worker</name></name></expr></argument>, <argument><expr><call><name>pg_rusage_show</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>ru_start</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<switch>switch <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TSS_INITIAL</name></expr>:</case>

			<comment type="block">/*
			 * We were able to accumulate all the tuples within the allowed
			 * amount of memory, or leader to take over worker tapes
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>SERIAL</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Just qsort 'em and we're done */</comment>
				<expr_stmt><expr><call><name>tuplesort_sort_memtuples</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>TSS_SORTEDINMEM</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>WORKER</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Parallel workers must still dump out tuples to tape.  No
				 * merge is required to produce single output run, though.
				 */</comment>
				<expr_stmt><expr><call><name>inittapes</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>dumptuples</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>worker_nomergeruns</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>TSS_SORTEDONTAPE</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Leader will take over worker tapes and merge worker runs.
				 * Note that mergeruns sets the correct state-&gt;status.
				 */</comment>
				<expr_stmt><expr><call><name>leader_takeover_tapes</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>mergeruns</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>eof_reached</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>markpos_block</name></name> <operator>=</operator> <literal type="number">0L</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>markpos_offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>markpos_eof</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>TSS_BOUNDED</name></expr>:</case>

			<comment type="block">/*
			 * We were able to accumulate all the tuples required for output
			 * in memory, using a heap to eliminate excess tuples.  Now we
			 * have to transform the heap to a properly-sorted array.
			 */</comment>
			<expr_stmt><expr><call><name>sort_bounded_heap</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>eof_reached</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>markpos_offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>markpos_eof</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>TSS_SORTEDINMEM</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>TSS_BUILDRUNS</name></expr>:</case>

			<comment type="block">/*
			 * Finish tape-based sort.  First, flush all tuples remaining in
			 * memory out to tape; then merge until we have a single remaining
			 * run (or, if !randomAccess and !WORKER(), one run per tape).
			 * Note that mergeruns sets the correct state-&gt;status.
			 */</comment>
			<expr_stmt><expr><call><name>dumptuples</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>mergeruns</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>eof_reached</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>markpos_block</name></name> <operator>=</operator> <literal type="number">0L</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>markpos_offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>markpos_eof</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid tuplesort state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRACE_SORT</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>trace_sort</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>TSS_FINALMERGE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"performsort of worker %d done (except %d-way final merge): %s"</literal></expr></argument>,
				 <argument><expr><name><name>state</name><operator>-&gt;</operator><name>worker</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>activeTapes</name></name></expr></argument>,
				 <argument><expr><call><name>pg_rusage_show</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>ru_start</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"performsort of worker %d done: %s"</literal></expr></argument>,
				 <argument><expr><name><name>state</name><operator>-&gt;</operator><name>worker</name></name></expr></argument>, <argument><expr><call><name>pg_rusage_show</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>ru_start</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Internal routine to fetch the next tuple in either forward or back
 * direction into *stup.  Returns false if no more tuples.
 * Returned tuple belongs to tuplesort memory context, and must not be freed
 * by caller.  Note that fetched tuple is stored in memory that may be
 * recycled by any future fetch.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>tuplesort_gettuple_common</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>forward</name></decl></parameter>,
						  <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>stup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tuplen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>nmoved</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>WORKER</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TSS_SORTEDINMEM</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>forward</name> <operator>||</operator> <name><name>state</name><operator>-&gt;</operator><name>randomAccess</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>slabAllocatorUsed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>forward</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name>stup</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>memtuples</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
					<return>return <expr><name>true</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>eof_reached</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Complain if caller tries to retrieve more tuples than
				 * originally asked for in a bounded sort.  This is because
				 * returning EOF here might be the wrong thing.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>bounded</name></name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>-&gt;</operator><name>current</name></name> <operator>&gt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>bound</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"retrieved too many tuples in a bounded sort"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * if all tuples are fetched already then we return last
				 * tuple, else - tuple before last returned.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>eof_reached</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>eof_reached</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name><operator>--</operator></expr>;</expr_stmt>	<comment type="block">/* last returned tuple */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></else></if_stmt>
				<expr_stmt><expr><operator>*</operator><name>stup</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>memtuples</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><name>TSS_SORTEDONTAPE</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>forward</name> <operator>||</operator> <name><name>state</name><operator>-&gt;</operator><name>randomAccess</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>slabAllocatorUsed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * The slot that held the tuple that we returned in previous
			 * gettuple call can now be reused.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>lastReturnedTuple</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>RELEASE_SLAB_SLOT</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>lastReturnedTuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lastReturnedTuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>forward</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>eof_reached</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>(</operator><name>tuplen</name> <operator>=</operator> <call><name>getlen</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>result_tape</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>READTUP</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>stup</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>result_tape</name></name></expr></argument>, <argument><expr><name>tuplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Remember the tuple we return, so that we can recycle
					 * its memory on next call.  (This can be NULL, in the
					 * !state-&gt;tuples case).
					 */</comment>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lastReturnedTuple</name></name> <operator>=</operator> <name><name>stup</name><operator>-&gt;</operator><name>tuple</name></name></expr>;</expr_stmt>

					<return>return <expr><name>true</name></expr>;</return>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>eof_reached</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Backward.
			 *
			 * if all tuples are fetched already then we return last tuple,
			 * else - tuple before last returned.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>eof_reached</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Seek position is pointing just past the zero tuplen at the
				 * end of file; back up to fetch last tuple's ending length
				 * word.  If seek fails we must have a completely empty file.
				 */</comment>
				<expr_stmt><expr><name>nmoved</name> <operator>=</operator> <call><name>LogicalTapeBackspace</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>,
											  <argument><expr><name><name>state</name><operator>-&gt;</operator><name>result_tape</name></name></expr></argument>,
											  <argument><expr><literal type="number">2</literal> <operator>*</operator> sizeof<operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>nmoved</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>nmoved</name> <operator>!=</operator> <literal type="number">2</literal> <operator>*</operator> sizeof<operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected tape position"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>eof_reached</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Back up and fetch previously-returned tuple's ending length
				 * word.  If seek fails, assume we are at start of file.
				 */</comment>
				<expr_stmt><expr><name>nmoved</name> <operator>=</operator> <call><name>LogicalTapeBackspace</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>,
											  <argument><expr><name><name>state</name><operator>-&gt;</operator><name>result_tape</name></name></expr></argument>,
											  <argument><expr>sizeof<operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>nmoved</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>nmoved</name> <operator>!=</operator> sizeof<operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected tape position"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>tuplen</name> <operator>=</operator> <call><name>getlen</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>result_tape</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Back up to get ending length word of tuple before it.
				 */</comment>
				<expr_stmt><expr><name>nmoved</name> <operator>=</operator> <call><name>LogicalTapeBackspace</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>,
											  <argument><expr><name><name>state</name><operator>-&gt;</operator><name>result_tape</name></name></expr></argument>,
											  <argument><expr><name>tuplen</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> sizeof<operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>nmoved</name> <operator>==</operator> <name>tuplen</name> <operator>+</operator> sizeof<operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * We backed up over the previous tuple, but there was no
					 * ending length word before it.  That means that the prev
					 * tuple is the first tuple in the file.  It is now the
					 * next to read in forward direction (not obviously right,
					 * but that is what in-memory case does).
					 */</comment>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>nmoved</name> <operator>!=</operator> <name>tuplen</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> sizeof<operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus tuple length in backward scan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>tuplen</name> <operator>=</operator> <call><name>getlen</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>result_tape</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Now we have the length of the prior tuple, back up and read it.
			 * Note: READTUP expects we are positioned after the initial
			 * length word of the tuple, so back up to that point.
			 */</comment>
			<expr_stmt><expr><name>nmoved</name> <operator>=</operator> <call><name>LogicalTapeBackspace</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>,
										  <argument><expr><name><name>state</name><operator>-&gt;</operator><name>result_tape</name></name></expr></argument>,
										  <argument><expr><name>tuplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>nmoved</name> <operator>!=</operator> <name>tuplen</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus tuple length in backward scan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>READTUP</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>stup</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>result_tape</name></name></expr></argument>, <argument><expr><name>tuplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Remember the tuple we return, so that we can recycle its memory
			 * on next call. (This can be NULL, in the Datum case).
			 */</comment>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lastReturnedTuple</name></name> <operator>=</operator> <name><name>stup</name><operator>-&gt;</operator><name>tuple</name></name></expr>;</expr_stmt>

			<return>return <expr><name>true</name></expr>;</return>

		<case>case <expr><name>TSS_FINALMERGE</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>forward</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* We are managing memory ourselves, with the slab allocator. */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>slabAllocatorUsed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * The slab slot holding the tuple that we returned in previous
			 * gettuple call can now be reused.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>lastReturnedTuple</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>RELEASE_SLAB_SLOT</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>lastReturnedTuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lastReturnedTuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * This code should match the inner loop of mergeonerun().
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>srcTape</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>tupindex</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>SortTuple</name></type>	<name>newtup</name></decl>;</decl_stmt>

				<expr_stmt><expr><operator>*</operator><name>stup</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>memtuples</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Remember the tuple we return, so that we can recycle its
				 * memory on next call. (This can be NULL, in the Datum case).
				 */</comment>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lastReturnedTuple</name></name> <operator>=</operator> <name><name>stup</name><operator>-&gt;</operator><name>tuple</name></name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Pull next tuple from tape, and replace the returned tuple
				 * at top of the heap with it.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>mergereadnext</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>srcTape</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newtup</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * If no more data, we've reached end of run on this tape.
					 * Remove the top node from the heap.
					 */</comment>
					<expr_stmt><expr><call><name>tuplesort_heap_delete_top</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Rewind to free the read buffer.  It'd go away at the
					 * end of the sort anyway, but better to release the
					 * memory early.
					 */</comment>
					<expr_stmt><expr><call><name>LogicalTapeRewindForWrite</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>, <argument><expr><name>srcTape</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>true</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name><name>newtup</name><operator>.</operator><name>tupindex</name></name> <operator>=</operator> <name>srcTape</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>tuplesort_heap_replace_top</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>false</name></expr>;</return>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid tuplesort state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>		<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch the next tuple in either forward or back direction.
 * If successful, put tuple in slot and return true; else, clear the slot
 * and return false.
 *
 * Caller may optionally be passed back abbreviated value (on true return
 * value) when abbreviation was used, which can be used to cheaply avoid
 * equality checks that might otherwise be required.  Caller can safely make a
 * determination of "non-equal tuple" based on simple binary inequality.  A
 * NULL value in leading attribute will set abbreviated value to zeroed
 * representation, which caller may rely on in abbreviated inequality check.
 *
 * If copy is true, the slot receives a tuple that's been copied into the
 * caller's memory context, so that it will stay valid regardless of future
 * manipulations of the tuplesort's state (up to and including deleting the
 * tuplesort).  If copy is false, the slot will just receive a pointer to a
 * tuple held within the tuplesort, which is more efficient, but only safe for
 * callers that are prepared to have any subsequent manipulation of the
 * tuplesort's state invalidate slot contents.
 */</comment>
<function><type><name>bool</name></type>
<name>tuplesort_gettupleslot</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>forward</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>copy</name></decl></parameter>,
					   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>abbrev</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sortcontext</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SortTuple</name></type>	<name>stup</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplesort_gettuple_common</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>forward</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>stup</name><operator>.</operator><name>tuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stup</name><operator>.</operator><name>tuple</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Record abbreviated key for caller */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><operator>-&gt;</operator><name>abbrev_converter</name></name> <operator>&amp;&amp;</operator> <name>abbrev</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>abbrev</name> <operator>=</operator> <name><name>stup</name><operator>.</operator><name>datum1</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>copy</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stup</name><operator>.</operator><name>tuple</name></name> <operator>=</operator> <call><name>heap_copy_minimal_tuple</name><argument_list>(<argument><expr><operator>(</operator><name>MinimalTuple</name><operator>)</operator> <name><name>stup</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ExecStoreMinimalTuple</name><argument_list>(<argument><expr><operator>(</operator><name>MinimalTuple</name><operator>)</operator> <name><name>stup</name><operator>.</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch the next tuple in either forward or back direction.
 * Returns NULL if no more tuples.  Returned tuple belongs to tuplesort memory
 * context, and must not be freed by caller.  Caller may not rely on tuple
 * remaining valid after any further manipulation of tuplesort.
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>tuplesort_getheaptuple</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>forward</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sortcontext</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SortTuple</name></type>	<name>stup</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplesort_gettuple_common</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>forward</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>stup</name><operator>.</operator><name>tuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>stup</name><operator>.</operator><name>tuple</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch the next index tuple in either forward or back direction.
 * Returns NULL if no more tuples.  Returned tuple belongs to tuplesort memory
 * context, and must not be freed by caller.  Caller may not rely on tuple
 * remaining valid after any further manipulation of tuplesort.
 */</comment>
<function><type><name>IndexTuple</name></type>
<name>tuplesort_getindextuple</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>forward</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sortcontext</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SortTuple</name></type>	<name>stup</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplesort_gettuple_common</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>forward</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>stup</name><operator>.</operator><name>tuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>IndexTuple</name><operator>)</operator> <name><name>stup</name><operator>.</operator><name>tuple</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch the next Datum in either forward or back direction.
 * Returns false if no more datums.
 *
 * If the Datum is pass-by-ref type, the returned value is freshly palloc'd
 * in caller's context, and is now owned by the caller (this differs from
 * similar routines for other types of tuplesorts).
 *
 * Caller may optionally be passed back abbreviated value (on true return
 * value) when abbreviation was used, which can be used to cheaply avoid
 * equality checks that might otherwise be required.  Caller can safely make a
 * determination of "non-equal tuple" based on simple binary inequality.  A
 * NULL value will have a zeroed abbreviated value representation, which caller
 * may rely on in abbreviated inequality check.
 */</comment>
<function><type><name>bool</name></type>
<name>tuplesort_getdatum</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>forward</name></decl></parameter>,
				   <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>abbrev</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sortcontext</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SortTuple</name></type>	<name>stup</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplesort_gettuple_common</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>forward</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Ensure we copy into caller's memory context */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Record abbreviated key for caller */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><operator>-&gt;</operator><name>abbrev_converter</name></name> <operator>&amp;&amp;</operator> <name>abbrev</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>abbrev</name> <operator>=</operator> <name><name>stup</name><operator>.</operator><name>datum1</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stup</name><operator>.</operator><name>isnull1</name></name> <operator>||</operator> <operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>tuples</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>val</name> <operator>=</operator> <name><name>stup</name><operator>.</operator><name>datum1</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name><name>stup</name><operator>.</operator><name>isnull1</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* use stup.tuple because stup.datum1 may be an abbreviation */</comment>
		<expr_stmt><expr><operator>*</operator><name>val</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>stup</name><operator>.</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>datumTypeLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Advance over N tuples in either forward or back direction,
 * without returning any data.  N==0 is a no-op.
 * Returns true if successful, false if ran out of tuples.
 */</comment>
<function><type><name>bool</name></type>
<name>tuplesort_skiptuples</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>ntuples</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>forward</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We don't actually support backwards skip yet, because no callers need
	 * it.  The API is designed to allow for that later, though.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>forward</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ntuples</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>WORKER</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TSS_SORTEDINMEM</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name> <operator>-</operator> <name><name>state</name><operator>-&gt;</operator><name>current</name></name> <operator>&gt;=</operator> <name>ntuples</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name> <operator>+=</operator> <name>ntuples</name></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>eof_reached</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Complain if caller tries to retrieve more tuples than
			 * originally asked for in a bounded sort.  This is because
			 * returning EOF here might be the wrong thing.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>bounded</name></name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>-&gt;</operator><name>current</name></name> <operator>&gt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>bound</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"retrieved too many tuples in a bounded sort"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<return>return <expr><name>false</name></expr>;</return>

		<case>case <expr><name>TSS_SORTEDONTAPE</name></expr>:</case>
		<case>case <expr><name>TSS_FINALMERGE</name></expr>:</case>

			<comment type="block">/*
			 * We could probably optimize these cases better, but for now it's
			 * not worth the trouble.
			 */</comment>
			<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sortcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<while>while <condition>(<expr><name>ntuples</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SortTuple</name></type>	<name>stup</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplesort_gettuple_common</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>forward</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stup</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></while>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid tuplesort state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>		<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * tuplesort_merge_order - report merge order we'll use for given memory
 * (note: "merge order" just means the number of input tapes in the merge).
 *
 * This is exported for use by the planner.  allowedMem is in bytes.
 */</comment>
<function><type><name>int</name></type>
<name>tuplesort_merge_order</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>allowedMem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>mOrder</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We need one tape for each merge input, plus another one for the output,
	 * and each of these tapes needs buffer space.  In addition we want
	 * MERGE_BUFFER_SIZE workspace per input tape (but the output tape doesn't
	 * count).
	 *
	 * Note: you might be thinking we need to account for the memtuples[]
	 * array in this calculation, but we effectively treat that as part of the
	 * MERGE_BUFFER_SIZE workspace.
	 */</comment>
	<expr_stmt><expr><name>mOrder</name> <operator>=</operator> <operator>(</operator><name>allowedMem</name> <operator>-</operator> <name>TAPE_BUFFER_OVERHEAD</name><operator>)</operator> <operator>/</operator>
		<operator>(</operator><name>MERGE_BUFFER_SIZE</name> <operator>+</operator> <name>TAPE_BUFFER_OVERHEAD</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Even in minimum memory, use at least a MINORDER merge.  On the other
	 * hand, even when we have lots of memory, do not use more than a MAXORDER
	 * merge.  Tapes are pretty cheap, but they're not entirely free.  Each
	 * additional tape reduces the amount of memory available to build runs,
	 * which in turn can cause the same sort to need more runs, which makes
	 * merging slower even if it can still be done in a single pass.  Also,
	 * high order merges are quite slow due to CPU cache effects; it can be
	 * faster to pay the I/O cost of a polyphase merge than to perform a
	 * single merge pass across many hundreds of tapes.
	 */</comment>
	<expr_stmt><expr><name>mOrder</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>mOrder</name></expr></argument>, <argument><expr><name>MINORDER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mOrder</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>mOrder</name></expr></argument>, <argument><expr><name>MAXORDER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>mOrder</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * inittapes - initialize for tape sorting.
 *
 * This is called only if we have found we won't sort in memory.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>inittapes</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>mergeruns</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxTapes</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>LEADER</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>mergeruns</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Compute number of tapes to use: merge order plus 1 */</comment>
		<expr_stmt><expr><name>maxTapes</name> <operator>=</operator> <call><name>tuplesort_merge_order</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>allowedMem</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Workers can sometimes produce single run, output without merge */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>WORKER</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>maxTapes</name> <operator>=</operator> <name>MINORDER</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRACE_SORT</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>trace_sort</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"worker %d switching to external sort with %d tapes: %s"</literal></expr></argument>,
			 <argument><expr><name><name>state</name><operator>-&gt;</operator><name>worker</name></name></expr></argument>, <argument><expr><name>maxTapes</name></expr></argument>, <argument><expr><call><name>pg_rusage_show</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>ru_start</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Create the tape set and allocate the per-tape data arrays */</comment>
	<expr_stmt><expr><call><name>inittapestate</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>maxTapes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name> <operator>=</operator>
		<call><name>LogicalTapeSetCreate</name><argument_list>(<argument><expr><name>maxTapes</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><ternary><condition><expr><name><name>state</name><operator>-&gt;</operator><name>shared</name></name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>fileset</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,
							 <argument><expr><name><name>state</name><operator>-&gt;</operator><name>worker</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>currentRun</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize variables of Algorithm D (step D1).
	 */</comment>
	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>maxTapes</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tp_fib</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tp_runs</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tp_dummy</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tp_tapenum</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tp_fib</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>tapeRange</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tp_dummy</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>tapeRange</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>Level</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>destTape</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>TSS_BUILDRUNS</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * inittapestate - initialize generic tape management state
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>inittapestate</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxTapes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>		<name>tapeSpace</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Decrease availMem to reflect the space needed for tape buffers; but
	 * don't decrease it to the point that we have no room for tuples. (That
	 * case is only likely to occur if sorting pass-by-value Datums; in all
	 * other scenarios the memtuples[] array is unlikely to occupy more than
	 * half of allowedMem.  In the pass-by-value case it's not important to
	 * account for tuple space, so we don't care if LACKMEM becomes
	 * inaccurate.)
	 */</comment>
	<expr_stmt><expr><name>tapeSpace</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name>maxTapes</name> <operator>*</operator> <name>TAPE_BUFFER_OVERHEAD</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>tapeSpace</name> <operator>+</operator> <call><name>GetMemoryChunkSpace</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>allowedMem</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>USEMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>tapeSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Make sure that the temp file(s) underlying the tape set are created in
	 * suitable temp tablespaces.  For parallel sorts, this should have been
	 * called already, but it doesn't matter if it is called a second time.
	 */</comment>
	<expr_stmt><expr><call><name>PrepareTempTablespaces</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mergeactive</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>maxTapes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tp_fib</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>maxTapes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tp_runs</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>maxTapes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tp_dummy</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>maxTapes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tp_tapenum</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>maxTapes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Record # of tapes allocated (for duration of sort) */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>maxTapes</name></name> <operator>=</operator> <name>maxTapes</name></expr>;</expr_stmt>
	<comment type="block">/* Record maximum # of tapes usable as inputs when merging */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tapeRange</name></name> <operator>=</operator> <name>maxTapes</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * selectnewtape -- select new tape for new initial run.
 *
 * This is called after finishing a run when we know another run
 * must be started.  This implements steps D3, D4 of Algorithm D.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>selectnewtape</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>a</name></decl>;</decl_stmt>

	<comment type="block">/* Step D3: advance j (destTape) */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>tp_dummy</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>destTape</name></name></expr>]</index></name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>tp_dummy</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>destTape</name></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>destTape</name></name><operator>++</operator></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>tp_dummy</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>destTape</name></name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>destTape</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Step D4: increase level */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>Level</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>a</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>tp_fib</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>tapeRange</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tp_dummy</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>a</name> <operator>+</operator> <name><name>state</name><operator>-&gt;</operator><name>tp_fib</name><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>state</name><operator>-&gt;</operator><name>tp_fib</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tp_fib</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>a</name> <operator>+</operator> <name><name>state</name><operator>-&gt;</operator><name>tp_fib</name><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>destTape</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the slab allocation arena, for the given number of slots.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_slab_allocator</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numSlots</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>numSlots</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>slabMemoryBegin</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numSlots</name> <operator>*</operator> <name>SLAB_SLOT_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>slabMemoryEnd</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>slabMemoryBegin</name></name> <operator>+</operator>
			<name>numSlots</name> <operator>*</operator> <name>SLAB_SLOT_SIZE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>slabFreeHead</name></name> <operator>=</operator> <operator>(</operator><name>SlabSlot</name> <operator>*</operator><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>slabMemoryBegin</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>USEMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>numSlots</name> <operator>*</operator> <name>SLAB_SLOT_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>slabMemoryBegin</name></name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numSlots</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>SlabSlot</name> <operator>*</operator><operator>)</operator> <name>p</name><operator>)</operator><operator>-&gt;</operator><name>nextfree</name> <operator>=</operator> <operator>(</operator><name>SlabSlot</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>p</name> <operator>+</operator> <name>SLAB_SLOT_SIZE</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>SLAB_SLOT_SIZE</name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>SlabSlot</name> <operator>*</operator><operator>)</operator> <name>p</name><operator>)</operator><operator>-&gt;</operator><name>nextfree</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>slabMemoryBegin</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>slabMemoryEnd</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>slabFreeHead</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>slabAllocatorUsed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * mergeruns -- merge all the completed initial runs.
 *
 * This implements steps D5, D6 of Algorithm D.  All input data has
 * already been written to initial runs on tape (see dumptuples).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>mergeruns</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>tapenum</name></decl>,
				<decl><type ref="prev"/><name>svTape</name></decl>,
				<decl><type ref="prev"/><name>svRuns</name></decl>,
				<decl><type ref="prev"/><name>svDummy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numTapes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numInputTapes</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>TSS_BUILDRUNS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><operator>-&gt;</operator><name>abbrev_converter</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If there are multiple runs to be merged, when we go to read back
		 * tuples from disk, abbreviated keys will not have been stored, and
		 * we don't care to regenerate them.  Disable abbreviation from this
		 * point on.
		 */</comment>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><operator>-&gt;</operator><name>abbrev_converter</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><operator>-&gt;</operator><name>comparator</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><operator>-&gt;</operator><name>abbrev_full_comparator</name></name></expr>;</expr_stmt>

		<comment type="block">/* Not strictly necessary, but be tidy */</comment>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><operator>-&gt;</operator><name>abbrev_abort</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><operator>-&gt;</operator><name>abbrev_full_comparator</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Reset tuple memory.  We've freed all the tuples that we previously
	 * allocated.  We will use the slab allocator from now on.
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tuplecontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tuplecontext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We no longer need a large memtuples array.  (We will allocate a smaller
	 * one for the heap later.)
	 */</comment>
	<expr_stmt><expr><call><name>FREEMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>GetMemoryChunkSpace</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we had fewer runs than tapes, refund the memory that we imagined we
	 * would need for the tape buffers of the unused tapes.
	 *
	 * numTapes and numInputTapes reflect the actual number of tapes we will
	 * use.  Note that the output tape's tape number is maxTapes - 1, so the
	 * tape numbers of the used tapes are not consecutive, and you cannot just
	 * loop from 0 to numTapes to visit all used tapes!
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>Level</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>numInputTapes</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>currentRun</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>numTapes</name> <operator>=</operator> <name>numInputTapes</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FREEMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>maxTapes</name></name> <operator>-</operator> <name>numTapes</name><operator>)</operator> <operator>*</operator> <name>TAPE_BUFFER_OVERHEAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>numInputTapes</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>tapeRange</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>numTapes</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>maxTapes</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Initialize the slab allocator.  We need one slab slot per input tape,
	 * for the tuples in the heap, plus one to hold the tuple last returned
	 * from tuplesort_gettuple.  (If we're sorting pass-by-val Datums,
	 * however, we don't need to do allocate anything.)
	 *
	 * From this point on, we no longer use the USEMEM()/LACKMEM() mechanism
	 * to track memory usage of individual tuples.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>tuples</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>init_slab_allocator</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>numInputTapes</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>init_slab_allocator</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Allocate a new 'memtuples' array, for the heap.  It will hold one tuple
	 * from each input tape.
	 */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>memtupsize</name></name> <operator>=</operator> <name>numInputTapes</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name></name> <operator>=</operator> <operator>(</operator><name>SortTuple</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numInputTapes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SortTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>USEMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>GetMemoryChunkSpace</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Use all the remaining memory we have available for read buffers among
	 * the input tapes.
	 *
	 * We don't try to "rebalance" the memory among tapes, when we start a new
	 * merge phase, even if some tapes are inactive in the new phase.  That
	 * would be hard, because logtape.c doesn't know where one run ends and
	 * another begins.  When a new merge phase begins, and a tape doesn't
	 * participate in it, its buffer nevertheless already contains tuples from
	 * the next run on same tape, so we cannot release the buffer.  That's OK
	 * in practice, merge performance isn't that sensitive to the amount of
	 * buffers used, and most merge phases use all or almost all tapes,
	 * anyway.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRACE_SORT</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>trace_sort</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"worker %d using "</literal> <name>INT64_FORMAT</name> <literal type="string">" KB of memory for read buffers among %d input tapes"</literal></expr></argument>,
			 <argument><expr><name><name>state</name><operator>-&gt;</operator><name>worker</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>availMem</name></name> <operator>/</operator> <literal type="number">1024</literal></expr></argument>, <argument><expr><name>numInputTapes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>read_buffer_size</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>availMem</name></name> <operator>/</operator> <name>numInputTapes</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>USEMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>read_buffer_size</name></name> <operator>*</operator> <name>numInputTapes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* End of step D2: rewind all output tapes to prepare for merging */</comment>
	<for>for <control>(<init><expr><name>tapenum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>tapenum</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>tapeRange</name></name></expr>;</condition> <incr><expr><name>tapenum</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LogicalTapeRewindForRead</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>, <argument><expr><name>tapenum</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>read_buffer_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * At this point we know that tape[T] is empty.  If there's just one
		 * (real or dummy) run left on each input tape, then only one merge
		 * pass remains.  If we don't have to produce a materialized sorted
		 * tape, we can stop at this point and do the final merge on-the-fly.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>randomAccess</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>WORKER</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>allOneRun</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tp_runs</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>tapeRange</name></name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>tapenum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>tapenum</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>tapeRange</name></name></expr>;</condition> <incr><expr><name>tapenum</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>tp_runs</name><index>[<expr><name>tapenum</name></expr>]</index></name> <operator>+</operator> <name><name>state</name><operator>-&gt;</operator><name>tp_dummy</name><index>[<expr><name>tapenum</name></expr>]</index></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>allOneRun</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><name>allOneRun</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Tell logtape.c we won't be writing anymore */</comment>
				<expr_stmt><expr><call><name>LogicalTapeSetForgetFreeSpace</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Initialize for the final merge pass */</comment>
				<expr_stmt><expr><call><name>beginmerge</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>TSS_FINALMERGE</name></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Step D5: merge runs onto tape[T] until tape[P] is empty */</comment>
		<while>while <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>tp_runs</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>tapeRange</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>||</operator>
			   <name><name>state</name><operator>-&gt;</operator><name>tp_dummy</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>tapeRange</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>allDummy</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>tapenum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>tapenum</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>tapeRange</name></name></expr>;</condition> <incr><expr><name>tapenum</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>tp_dummy</name><index>[<expr><name>tapenum</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>allDummy</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

			<if_stmt><if>if <condition>(<expr><name>allDummy</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tp_dummy</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>tapeRange</name></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>tapenum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>tapenum</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>tapeRange</name></name></expr>;</condition> <incr><expr><name>tapenum</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tp_dummy</name><index>[<expr><name>tapenum</name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt></block_content></block></for>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>mergeonerun</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></while>

		<comment type="block">/* Step D6: decrease level */</comment>
		<if_stmt><if>if <condition>(<expr><operator>--</operator><name><name>state</name><operator>-&gt;</operator><name>Level</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<comment type="block">/* rewind output tape T to use as new input */</comment>
		<expr_stmt><expr><call><name>LogicalTapeRewindForRead</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>tp_tapenum</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>tapeRange</name></name></expr>]</index></name></expr></argument>,
								 <argument><expr><name><name>state</name><operator>-&gt;</operator><name>read_buffer_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* rewind used-up input tape P, and prepare it for write pass */</comment>
		<expr_stmt><expr><call><name>LogicalTapeRewindForWrite</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>tp_tapenum</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>tapeRange</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tp_runs</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>tapeRange</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * reassign tape units per step D6; note we no longer care about A[]
		 */</comment>
		<expr_stmt><expr><name>svTape</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>tp_tapenum</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>tapeRange</name></name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>svDummy</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>tp_dummy</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>tapeRange</name></name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>svRuns</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>tp_runs</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>tapeRange</name></name></expr>]</index></name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>tapenum</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>tapeRange</name></name></expr>;</init> <condition><expr><name>tapenum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>tapenum</name><operator>--</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tp_tapenum</name><index>[<expr><name>tapenum</name></expr>]</index></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>tp_tapenum</name><index>[<expr><name>tapenum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tp_dummy</name><index>[<expr><name>tapenum</name></expr>]</index></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>tp_dummy</name><index>[<expr><name>tapenum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tp_runs</name><index>[<expr><name>tapenum</name></expr>]</index></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>tp_runs</name><index>[<expr><name>tapenum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tp_tapenum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>svTape</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tp_dummy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>svDummy</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tp_runs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>svRuns</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Done.  Knuth says that the result is on TAPE[1], but since we exited
	 * the loop without performing the last iteration of step D6, we have not
	 * rearranged the tape unit assignment, and therefore the result is on
	 * TAPE[T].  We need to do it this way so that we can freeze the final
	 * output tape while rewinding it.  The last iteration of step D6 would be
	 * a waste of cycles anyway...
	 */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>result_tape</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>tp_tapenum</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>tapeRange</name></name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>WORKER</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LogicalTapeFreeze</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>result_tape</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>worker_freeze_result_tape</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>TSS_SORTEDONTAPE</name></expr>;</expr_stmt>

	<comment type="block">/* Release the read buffers of all the other tapes, by rewinding them. */</comment>
	<for>for <control>(<init><expr><name>tapenum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>tapenum</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>maxTapes</name></name></expr>;</condition> <incr><expr><name>tapenum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>tapenum</name> <operator>!=</operator> <name><name>state</name><operator>-&gt;</operator><name>result_tape</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LogicalTapeRewindForWrite</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>, <argument><expr><name>tapenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Merge one run from each input tape, except ones with dummy runs.
 *
 * This is the inner loop of Algorithm D step D5.  We know that the
 * output tape is TAPE[T].
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>mergeonerun</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>destTape</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>tp_tapenum</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>tapeRange</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>srcTape</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Start the merge by loading one tuple from each active source tape into
	 * the heap.  We can also decrease the input run/dummy run counts.
	 */</comment>
	<expr_stmt><expr><call><name>beginmerge</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Execute merge by repeatedly extracting lowest tuple in heap, writing it
	 * out, and replacing it with next tuple from same tape (if there is
	 * another one).
	 */</comment>
	<while>while <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortTuple</name></type>	<name>stup</name></decl>;</decl_stmt>

		<comment type="block">/* write the tuple to destTape */</comment>
		<expr_stmt><expr><name>srcTape</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>memtuples</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>tupindex</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WRITETUP</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>destTape</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>memtuples</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* recycle the slot of the tuple we just wrote out, for the next read */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>tuple</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>RELEASE_SLAB_SLOT</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * pull next tuple from the tape, and replace the written-out tuple in
		 * the heap with it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>mergereadnext</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>srcTape</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stup</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>stup</name><operator>.</operator><name>tupindex</name></name> <operator>=</operator> <name>srcTape</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>tuplesort_heap_replace_top</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>tuplesort_heap_delete_top</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * When the heap empties, we're done.  Write an end-of-run marker on the
	 * output tape, and increment its count of real runs.
	 */</comment>
	<expr_stmt><expr><call><name>markrunend</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>destTape</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tp_runs</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>tapeRange</name></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRACE_SORT</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>trace_sort</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"worker %d finished %d-way merge step: %s"</literal></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>worker</name></name></expr></argument>,
			 <argument><expr><name><name>state</name><operator>-&gt;</operator><name>activeTapes</name></name></expr></argument>, <argument><expr><call><name>pg_rusage_show</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>ru_start</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * beginmerge - initialize for a merge pass
 *
 * We decrease the counts of real and dummy runs for each tape, and mark
 * which tapes contain active input runs in mergeactive[].  Then, fill the
 * merge heap with the first tuple from each active tape.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>beginmerge</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>activeTapes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tapenum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>srcTape</name></decl>;</decl_stmt>

	<comment type="block">/* Heap should be empty here */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Adjust run counts and mark the active tapes */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>mergeactive</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
		   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>maxTapes</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>state</name><operator>-&gt;</operator><name>mergeactive</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>activeTapes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>tapenum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>tapenum</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>tapeRange</name></name></expr>;</condition> <incr><expr><name>tapenum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>tp_dummy</name><index>[<expr><name>tapenum</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tp_dummy</name><index>[<expr><name>tapenum</name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tp_runs</name><index>[<expr><name>tapenum</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tp_runs</name><index>[<expr><name>tapenum</name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>srcTape</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>tp_tapenum</name><index>[<expr><name>tapenum</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mergeactive</name><index>[<expr><name>srcTape</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>activeTapes</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>activeTapes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>activeTapes</name></name> <operator>=</operator> <name>activeTapes</name></expr>;</expr_stmt>

	<comment type="block">/* Load the merge heap with the first tuple from each input tape */</comment>
	<for>for <control>(<init><expr><name>srcTape</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>srcTape</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>maxTapes</name></name></expr>;</condition> <incr><expr><name>srcTape</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortTuple</name></type>	<name>tup</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>mergereadnext</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>srcTape</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tup</name><operator>.</operator><name>tupindex</name></name> <operator>=</operator> <name>srcTape</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>tuplesort_heap_insert</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * mergereadnext - read next tuple from one merge input tape
 *
 * Returns false on EOF.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>mergereadnext</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcTape</name></decl></parameter>, <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>stup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tuplen</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>mergeactive</name><index>[<expr><name>srcTape</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* tape's run is already exhausted */</comment>

	<comment type="block">/* read next tuple, if any */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>tuplen</name> <operator>=</operator> <call><name>getlen</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>srcTape</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mergeactive</name><index>[<expr><name>srcTape</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>READTUP</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>stup</name></expr></argument>, <argument><expr><name>srcTape</name></expr></argument>, <argument><expr><name>tuplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * dumptuples - remove tuples from memtuples and write initial run to tape
 *
 * When alltuples = true, dump everything currently in memory.  (This case is
 * only used at end of input data.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumptuples</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>alltuples</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>memtupwrite</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Nothing to do if we still fit in available memory and have array slots,
	 * unless this is the final call during initial run generation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupsize</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>LACKMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><name>alltuples</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Final call might require no sorting, in rare cases where we just so
	 * happen to have previously LACKMEM()'d at the point where exactly all
	 * remaining tuples are loaded into memory, just before input was
	 * exhausted.
	 *
	 * In general, short final runs are quite possible.  Rather than allowing
	 * a special case where there was a superfluous selectnewtape() call (i.e.
	 * a call with no subsequent run actually written to destTape), we prefer
	 * to write out a 0 tuple run.
	 *
	 * mergereadnext() is prepared for 0 tuple runs, and will reliably mark
	 * the tape inactive for the merge when called from beginmerge().  This
	 * case is therefore similar to the case where mergeonerun() finds a dummy
	 * run for the tape, and so doesn't need to merge a run from the tape (or
	 * conceptually "merges" the dummy run, if you prefer).  According to
	 * Knuth, Algorithm D "isn't strictly optimal" in its method of
	 * distribution and dummy run assignment; this edge case seems very
	 * unlikely to make that appreciably worse.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>TSS_BUILDRUNS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * It seems unlikely that this limit will ever be exceeded, but take no
	 * chances
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>currentRun</name></name> <operator>==</operator> <name>INT_MAX</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot have more than %d runs for an external sort"</literal></expr></argument>,
						<argument><expr><name>INT_MAX</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>currentRun</name></name><operator>++</operator></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRACE_SORT</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>trace_sort</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"worker %d starting quicksort of run %d: %s"</literal></expr></argument>,
			 <argument><expr><name><name>state</name><operator>-&gt;</operator><name>worker</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>currentRun</name></name></expr></argument>,
			 <argument><expr><call><name>pg_rusage_show</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>ru_start</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Sort all tuples accumulated within the allowed amount of memory for
	 * this run using quicksort
	 */</comment>
	<expr_stmt><expr><call><name>tuplesort_sort_memtuples</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRACE_SORT</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>trace_sort</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"worker %d finished quicksort of run %d: %s"</literal></expr></argument>,
			 <argument><expr><name><name>state</name><operator>-&gt;</operator><name>worker</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>currentRun</name></name></expr></argument>,
			 <argument><expr><call><name>pg_rusage_show</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>ru_start</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>memtupwrite</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>memtupwrite</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>WRITETUP</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>tp_tapenum</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>destTape</name></name></expr>]</index></name></expr></argument>,
				 <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>memtuples</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Reset tuple memory.  We've freed all of the tuples that we previously
	 * allocated.  It's important to avoid fragmentation when there is a stark
	 * change in the sizes of incoming tuples.  Fragmentation due to
	 * AllocSetFree's bucketing by size class might be particularly bad if
	 * this step wasn't taken.
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tuplecontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>markrunend</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>tp_tapenum</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>destTape</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tp_runs</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>destTape</name></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tp_dummy</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>destTape</name></name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt> <comment type="block">/* per Alg D step D2 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRACE_SORT</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>trace_sort</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"worker %d finished writing run %d to tape %d: %s"</literal></expr></argument>,
			 <argument><expr><name><name>state</name><operator>-&gt;</operator><name>worker</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>currentRun</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>destTape</name></name></expr></argument>,
			 <argument><expr><call><name>pg_rusage_show</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>ru_start</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>alltuples</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>selectnewtape</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tuplesort_rescan		- rewind and replay the scan
 */</comment>
<function><type><name>void</name></type>
<name>tuplesort_rescan</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sortcontext</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>randomAccess</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TSS_SORTEDINMEM</name></expr>:</case>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>eof_reached</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>markpos_offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>markpos_eof</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>TSS_SORTEDONTAPE</name></expr>:</case>
			<expr_stmt><expr><call><name>LogicalTapeRewindForRead</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>,
									 <argument><expr><name><name>state</name><operator>-&gt;</operator><name>result_tape</name></name></expr></argument>,
									 <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>eof_reached</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>markpos_block</name></name> <operator>=</operator> <literal type="number">0L</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>markpos_offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>markpos_eof</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid tuplesort state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tuplesort_markpos	- saves current position in the merged sort file
 */</comment>
<function><type><name>void</name></type>
<name>tuplesort_markpos</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sortcontext</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>randomAccess</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TSS_SORTEDINMEM</name></expr>:</case>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>markpos_offset</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>current</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>markpos_eof</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>eof_reached</name></name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>TSS_SORTEDONTAPE</name></expr>:</case>
			<expr_stmt><expr><call><name>LogicalTapeTell</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>,
							<argument><expr><name><name>state</name><operator>-&gt;</operator><name>result_tape</name></name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>markpos_block</name></name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>markpos_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>markpos_eof</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>eof_reached</name></name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid tuplesort state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tuplesort_restorepos - restores current position in merged sort file to
 *						  last saved position
 */</comment>
<function><type><name>void</name></type>
<name>tuplesort_restorepos</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sortcontext</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>randomAccess</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TSS_SORTEDINMEM</name></expr>:</case>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>markpos_offset</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>eof_reached</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>markpos_eof</name></name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>TSS_SORTEDONTAPE</name></expr>:</case>
			<expr_stmt><expr><call><name>LogicalTapeSeek</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>,
							<argument><expr><name><name>state</name><operator>-&gt;</operator><name>result_tape</name></name></expr></argument>,
							<argument><expr><name><name>state</name><operator>-&gt;</operator><name>markpos_block</name></name></expr></argument>,
							<argument><expr><name><name>state</name><operator>-&gt;</operator><name>markpos_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>eof_reached</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>markpos_eof</name></name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid tuplesort state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tuplesort_get_stats - extract summary statistics
 *
 * This can be called after tuplesort_performsort() finishes to obtain
 * printable summary information about how the sort was performed.
 */</comment>
<function><type><name>void</name></type>
<name>tuplesort_get_stats</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
					<parameter><decl><type><name>TuplesortInstrumentation</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Note: it might seem we should provide both memory and disk usage for a
	 * disk-based sort.  However, the current code doesn't track memory space
	 * accurately once we have begun to return tuples to the caller (since we
	 * don't account for pfree's the caller is expected to do), so we cannot
	 * rely on availMem in a disk sort.  This does not seem worth the overhead
	 * to fix.  Is it worth creating an API for the memory context code to
	 * tell us how much is actually used in sortcontext?
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>spaceType</name></name> <operator>=</operator> <name>SORT_SPACE_TYPE_DISK</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>=</operator> <call><name>LogicalTapeSetBlocks</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <operator>(</operator><name>BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>spaceType</name></name> <operator>=</operator> <name>SORT_SPACE_TYPE_MEMORY</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>=</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>allowedMem</name></name> <operator>-</operator> <name><name>state</name><operator>-&gt;</operator><name>availMem</name></name> <operator>+</operator> <literal type="number">1023</literal><operator>)</operator> <operator>/</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<switch>switch <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TSS_SORTEDINMEM</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>boundUsed</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>sortMethod</name></name> <operator>=</operator> <name>SORT_TYPE_TOP_N_HEAPSORT</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>sortMethod</name></name> <operator>=</operator> <name>SORT_TYPE_QUICKSORT</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>TSS_SORTEDONTAPE</name></expr>:</case>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>sortMethod</name></name> <operator>=</operator> <name>SORT_TYPE_EXTERNAL_SORT</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>TSS_FINALMERGE</name></expr>:</case>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>sortMethod</name></name> <operator>=</operator> <name>SORT_TYPE_EXTERNAL_MERGE</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>sortMethod</name></name> <operator>=</operator> <name>SORT_TYPE_STILL_IN_PROGRESS</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Convert TuplesortMethod to a string.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>tuplesort_method_name</name><parameter_list>(<parameter><decl><type><name>TuplesortMethod</name></type> <name>m</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>m</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SORT_TYPE_STILL_IN_PROGRESS</name></expr>:</case>
			<return>return <expr><literal type="string">"still in progress"</literal></expr>;</return>
		<case>case <expr><name>SORT_TYPE_TOP_N_HEAPSORT</name></expr>:</case>
			<return>return <expr><literal type="string">"top-N heapsort"</literal></expr>;</return>
		<case>case <expr><name>SORT_TYPE_QUICKSORT</name></expr>:</case>
			<return>return <expr><literal type="string">"quicksort"</literal></expr>;</return>
		<case>case <expr><name>SORT_TYPE_EXTERNAL_SORT</name></expr>:</case>
			<return>return <expr><literal type="string">"external sort"</literal></expr>;</return>
		<case>case <expr><name>SORT_TYPE_EXTERNAL_MERGE</name></expr>:</case>
			<return>return <expr><literal type="string">"external merge"</literal></expr>;</return>
	</block_content>}</block></switch>

	<return>return <expr><literal type="string">"unknown"</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert TuplesortSpaceType to a string.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>tuplesort_space_type_name</name><parameter_list>(<parameter><decl><type><name>TuplesortSpaceType</name></type> <name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>t</name> <operator>==</operator> <name>SORT_SPACE_TYPE_DISK</name> <operator>||</operator> <name>t</name> <operator>==</operator> <name>SORT_SPACE_TYPE_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><ternary><condition><expr><name>t</name> <operator>==</operator> <name>SORT_SPACE_TYPE_DISK</name></expr> ?</condition><then> <expr><literal type="string">"Disk"</literal></expr> </then><else>: <expr><literal type="string">"Memory"</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Heap manipulation routines, per Knuth's Algorithm 5.2.3H.
 */</comment>

<comment type="block">/*
 * Convert the existing unordered array of SortTuples to a bounded heap,
 * discarding all but the smallest "state-&gt;bound" tuples.
 *
 * When working with a bounded heap, we want to keep the largest entry
 * at the root (array entry zero), instead of the smallest as in the normal
 * sort case.  This allows us to discard the largest entry cheaply.
 * Therefore, we temporarily reverse the sort direction.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>make_bounded_heap</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>tupcount</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>TSS_INITIAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>bounded</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tupcount</name> <operator>&gt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>bound</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>SERIAL</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reverse sort direction so largest entry will be at root */</comment>
	<expr_stmt><expr><call><name>reversedirection</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>		<comment type="block">/* make the heap empty */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>tupcount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>bound</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Insert next tuple into heap */</comment>
			<comment type="block">/* Must copy source tuple to avoid possible overwrite */</comment>
			<decl_stmt><decl><type><name>SortTuple</name></type>	<name>stup</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>tuplesort_heap_insert</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * The heap is full.  Replace the largest entry with the new
			 * tuple, or just discard it, if it's larger than anything already
			 * in the heap.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>COMPARETUP</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>memtuples</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>memtuples</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>free_sort_tuple</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>memtuples</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>tuplesort_heap_replace_top</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>memtuples</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>bound</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>TSS_BOUNDED</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Convert the bounded heap to a properly-sorted array
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sort_bounded_heap</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>tupcount</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>TSS_BOUNDED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>bounded</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tupcount</name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>bound</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>SERIAL</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We can unheapify in place because each delete-top call will remove the
	 * largest entry, which we can promptly store in the newly freed slot at
	 * the end.  Once we're down to a single-entry heap, we're done.
	 */</comment>
	<while>while <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortTuple</name></type>	<name>stup</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* this sifts-up the next-largest entry and decreases memtupcount */</comment>
		<expr_stmt><expr><call><name>tuplesort_heap_delete_top</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name></expr>]</index></name> <operator>=</operator> <name>stup</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name> <operator>=</operator> <name>tupcount</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reverse sort direction back to the original state.  This is not
	 * actually necessary but seems like a good idea for tidiness.
	 */</comment>
	<expr_stmt><expr><call><name>reversedirection</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>TSS_SORTEDINMEM</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>boundUsed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Sort all memtuples using specialized qsort() routines.
 *
 * Quicksort is used for small in-memory sorts, and external sort runs.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>tuplesort_sort_memtuples</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>LEADER</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Can we use the single-key sort function? */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>onlyKey</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>qsort_ssup</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name></expr></argument>,
					   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>onlyKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>qsort_tuple</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name></name></expr></argument>,
						<argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name></expr></argument>,
						<argument><expr><name><name>state</name><operator>-&gt;</operator><name>comparetup</name></name></expr></argument>,
						<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Insert a new tuple into an empty or existing heap, maintaining the
 * heap invariant.  Caller is responsible for ensuring there's room.
 *
 * Note: For some callers, tuple points to a memtuples[] entry above the
 * end of the heap.  This is safe as long as it's not immediately adjacent
 * to the end of the heap (ie, in the [memtupcount] array entry) --- if it
 * is, it might get overwritten before being moved into the heap!
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>tuplesort_heap_insert</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SortTuple</name>  <modifier>*</modifier></type><name>memtuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>memtuples</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>memtuples</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Sift-up the new entry, per Knuth 5.2.3 exercise 16. Note that Knuth is
	 * using 1-based array indexes, not 0-based.
	 */</comment>
	<expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name><operator>++</operator></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><operator>(</operator><name>j</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>COMPARETUP</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>memtuples</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>memtuples</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>memtuples</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>j</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><name><name>memtuples</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>tuple</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Remove the tuple at state-&gt;memtuples[0] from the heap.  Decrement
 * memtupcount, and sift up to maintain the heap invariant.
 *
 * The caller has already free'd the tuple the top node points to,
 * if necessary.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>tuplesort_heap_delete_top</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SortTuple</name>  <modifier>*</modifier></type><name>memtuples</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SortTuple</name>  <modifier>*</modifier></type><name>tuple</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>--</operator><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Remove the last tuple in the heap, and re-insert it, by replacing the
	 * current top node with it.
	 */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <operator>&amp;</operator><name><name>memtuples</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tuplesort_heap_replace_top</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Replace the tuple at state-&gt;memtuples[0] with a new tuple.  Sift up to
 * maintain the heap invariant.
 *
 * This corresponds to Knuth's "sift-up" algorithm (Algorithm 5.2.3H,
 * Heapsort, steps H3-H8).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>tuplesort_heap_replace_top</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SortTuple</name>  <modifier>*</modifier></type><name>memtuples</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>,
				<decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * state-&gt;memtupcount is "int", but we use "unsigned int" for i, j, n.
	 * This prevents overflow in the "2 * i + 1" calculation, since at the top
	 * of the loop we must have i &lt; n &lt;= INT_MAX &lt;= UINT_MAX/2.
	 */</comment>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>						<comment type="block">/* i is where the "hole" is */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>j</name> <init>= <expr><literal type="number">2</literal> <operator>*</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;=</operator> <name>n</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>n</name> <operator>&amp;&amp;</operator>
			<call><name>COMPARETUP</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>memtuples</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>memtuples</name><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>COMPARETUP</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>memtuples</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>memtuples</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>memtuples</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>memtuples</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>tuple</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Function to reverse the sort direction from its current state
 *
 * It is not safe to call this when performing hash tuplesorts
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>reversedirection</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SortSupport</name></type> <name>sortKey</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nkey</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>nkey</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>nkey</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>nKeys</name></name></expr>;</condition> <incr><expr><name>nkey</name><operator>++</operator></expr><operator>,</operator> <expr><name>sortKey</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>sortKey</name><operator>-&gt;</operator><name>ssup_reverse</name></name> <operator>=</operator> <operator>!</operator><name><name>sortKey</name><operator>-&gt;</operator><name>ssup_reverse</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sortKey</name><operator>-&gt;</operator><name>ssup_nulls_first</name></name> <operator>=</operator> <operator>!</operator><name><name>sortKey</name><operator>-&gt;</operator><name>ssup_nulls_first</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * Tape interface routines
 */</comment>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type>
<name>getlen</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>eofOK</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>LogicalTapeRead</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>, <argument><expr><name>tapenum</name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected end of tape"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>eofOK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected end of data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>markrunend</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LogicalTapeWrite</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>, <argument><expr><name>tapenum</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get memory for tuple from within READTUP() routine.
 *
 * We use next free slot from the slab allocator, or palloc() if the tuple
 * is too large for that.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>readtup_alloc</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>tuplen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlabSlot</name>   <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We pre-allocate enough slots in the slab arena that we should never run
	 * out.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>slabFreeHead</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>tuplen</name> <operator>&gt;</operator> <name>SLAB_SLOT_SIZE</name> <operator>||</operator> <operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>slabFreeHead</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sortcontext</name></name></expr></argument>, <argument><expr><name>tuplen</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>slabFreeHead</name></name></expr>;</expr_stmt>
		<comment type="block">/* Reuse this slot */</comment>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>slabFreeHead</name></name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>nextfree</name></name></expr>;</expr_stmt>

		<return>return <expr><name>buf</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Routines specialized for HeapTuple (actually MinimalTuple) case
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>comparetup_heap</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SortTuple</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SortTuple</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SortSupport</name></type> <name>sortKey</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>ltup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>rtup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>compare</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>datum1</name></decl>,
				<decl><type ref="prev"/><name>datum2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull1</name></decl>,
				<decl><type ref="prev"/><name>isnull2</name></decl>;</decl_stmt>


	<comment type="block">/* Compare the leading sort key */</comment>
	<expr_stmt><expr><name>compare</name> <operator>=</operator> <call><name>ApplySortComparator</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>datum1</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>isnull1</name></name></expr></argument>,
								  <argument><expr><name><name>b</name><operator>-&gt;</operator><name>datum1</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>isnull1</name></name></expr></argument>,
								  <argument><expr><name>sortKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>compare</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>compare</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Compare additional sort keys */</comment>
	<expr_stmt><expr><name><name>ltup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>MinimalTuple</name><operator>)</operator> <name><name>a</name><operator>-&gt;</operator><name>tuple</name></name><operator>)</operator><operator>-&gt;</operator><name>t_len</name> <operator>+</operator> <name>MINIMAL_TUPLE_OFFSET</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ltup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>a</name><operator>-&gt;</operator><name>tuple</name></name> <operator>-</operator> <name>MINIMAL_TUPLE_OFFSET</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rtup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>MinimalTuple</name><operator>)</operator> <name><name>b</name><operator>-&gt;</operator><name>tuple</name></name><operator>)</operator><operator>-&gt;</operator><name>t_len</name> <operator>+</operator> <name>MINIMAL_TUPLE_OFFSET</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rtup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>b</name><operator>-&gt;</operator><name>tuple</name></name> <operator>-</operator> <name>MINIMAL_TUPLE_OFFSET</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>tupDesc</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>sortKey</name><operator>-&gt;</operator><name>abbrev_converter</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>attno</name> <operator>=</operator> <name><name>sortKey</name><operator>-&gt;</operator><name>ssup_attno</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>datum1</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ltup</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>datum2</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rtup</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>compare</name> <operator>=</operator> <call><name>ApplySortAbbrevFullComparator</name><argument_list>(<argument><expr><name>datum1</name></expr></argument>, <argument><expr><name>isnull1</name></expr></argument>,
												<argument><expr><name>datum2</name></expr></argument>, <argument><expr><name>isnull2</name></expr></argument>,
												<argument><expr><name>sortKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>compare</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>compare</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>sortKey</name><operator>++</operator></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>nkey</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>nkey</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>nKeys</name></name></expr>;</condition> <incr><expr><name>nkey</name><operator>++</operator></expr><operator>,</operator> <expr><name>sortKey</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>attno</name> <operator>=</operator> <name><name>sortKey</name><operator>-&gt;</operator><name>ssup_attno</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>datum1</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ltup</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>datum2</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rtup</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>compare</name> <operator>=</operator> <call><name>ApplySortComparator</name><argument_list>(<argument><expr><name>datum1</name></expr></argument>, <argument><expr><name>isnull1</name></expr></argument>,
									  <argument><expr><name>datum2</name></expr></argument>, <argument><expr><name>isnull2</name></expr></argument>,
									  <argument><expr><name>sortKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>compare</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>compare</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>copytup_heap</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>stup</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>tup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We expect the passed "tup" to be a TupleTableSlot, and form a
	 * MinimalTuple using the exported interface for that.
	 */</comment>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><operator>(</operator><name>TupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>tup</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>original</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MinimalTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>htup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tuplecontext</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* copy the tuple into sort storage */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>ExecCopySlotMinimalTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stup</name><operator>-&gt;</operator><name>tuple</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>tuple</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>USEMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>GetMemoryChunkSpace</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* set up first-column key value */</comment>
	<expr_stmt><expr><name><name>htup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>+</operator> <name>MINIMAL_TUPLE_OFFSET</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>htup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tuple</name> <operator>-</operator> <name>MINIMAL_TUPLE_OFFSET</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>original</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>htup</name></expr></argument>,
							<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>ssup_attno</name></expr></argument>,
							<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name><name>stup</name><operator>-&gt;</operator><name>isnull1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><operator>-&gt;</operator><name>abbrev_converter</name></name> <operator>||</operator> <name><name>stup</name><operator>-&gt;</operator><name>isnull1</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Store ordinary Datum representation, or NULL value.  If there is a
		 * converter it won't expect NULL values, and cost model is not
		 * required to account for NULL, so in that case we avoid calling
		 * converter and just set datum1 to zeroed representation (to be
		 * consistent, and to support cheap inequality tests for NULL
		 * abbreviated keys).
		 */</comment>
		<expr_stmt><expr><name><name>stup</name><operator>-&gt;</operator><name>datum1</name></name> <operator>=</operator> <name>original</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>consider_abort_common</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Store abbreviated key representation */</comment>
		<expr_stmt><expr><name><name>stup</name><operator>-&gt;</operator><name>datum1</name></name> <operator>=</operator> <call><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><operator>-&gt;</operator><name>abbrev_converter</name></name><argument_list>(<argument><expr><name>original</name></expr></argument>,
														 <argument><expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Abort abbreviation */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>stup</name><operator>-&gt;</operator><name>datum1</name></name> <operator>=</operator> <name>original</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Set state to be consistent with never trying abbreviation.
		 *
		 * Alter datum1 representation in already-copied tuples, so as to
		 * ensure a consistent representation (current tuple was just
		 * handled).  It does not matter if some dumped tuples are already
		 * sorted on tape, since serialized tuples lack abbreviated keys
		 * (TSS_BUILDRUNS state prevents control reaching here in any case).
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SortTuple</name>  <modifier>*</modifier></type><name>mtup</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>memtuples</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>htup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>MinimalTuple</name><operator>)</operator> <name><name>mtup</name><operator>-&gt;</operator><name>tuple</name></name><operator>)</operator><operator>-&gt;</operator><name>t_len</name> <operator>+</operator>
				<name>MINIMAL_TUPLE_OFFSET</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>htup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>mtup</name><operator>-&gt;</operator><name>tuple</name></name> <operator>-</operator>
											 <name>MINIMAL_TUPLE_OFFSET</name><operator>)</operator></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>mtup</name><operator>-&gt;</operator><name>datum1</name></name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>htup</name></expr></argument>,
										<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>ssup_attno</name></expr></argument>,
										<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name><name>mtup</name><operator>-&gt;</operator><name>isnull1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>writetup_heap</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>, <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>stup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MinimalTuple</name></type> <name>tuple</name> <init>= <expr><operator>(</operator><name>MinimalTuple</name><operator>)</operator> <name><name>stup</name><operator>-&gt;</operator><name>tuple</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* the part of the MinimalTuple we'll write: */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tupbody</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tuple</name> <operator>+</operator> <name>MINIMAL_TUPLE_DATA_OFFSET</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tupbodylen</name> <init>= <expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>-</operator> <name>MINIMAL_TUPLE_DATA_OFFSET</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* total on-disk footprint: */</comment>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tuplen</name> <init>= <expr><name>tupbodylen</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LogicalTapeWrite</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>, <argument><expr><name>tapenum</name></expr></argument>,
					 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>tuplen</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tuplen</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LogicalTapeWrite</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>, <argument><expr><name>tapenum</name></expr></argument>,
					 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>tupbody</name></expr></argument>, <argument><expr><name>tupbodylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>randomAccess</name></name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* need trailing length word? */</comment>
		<expr_stmt><expr><call><name>LogicalTapeWrite</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>, <argument><expr><name>tapenum</name></expr></argument>,
						 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>tuplen</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tuplen</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>slabAllocatorUsed</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FREEMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>GetMemoryChunkSpace</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_free_minimal_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>readtup_heap</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>stup</name></decl></parameter>,
			 <parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tupbodylen</name> <init>= <expr><name>len</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tuplen</name> <init>= <expr><name>tupbodylen</name> <operator>+</operator> <name>MINIMAL_TUPLE_DATA_OFFSET</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MinimalTuple</name></type> <name>tuple</name> <init>= <expr><operator>(</operator><name>MinimalTuple</name><operator>)</operator> <call><name>readtup_alloc</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>tuplen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tupbody</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tuple</name> <operator>+</operator> <name>MINIMAL_TUPLE_DATA_OFFSET</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>htup</name></decl>;</decl_stmt>

	<comment type="block">/* read in the tuple proper */</comment>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator> <name>tuplen</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LogicalTapeReadExact</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>, <argument><expr><name>tapenum</name></expr></argument>,
						 <argument><expr><name>tupbody</name></expr></argument>, <argument><expr><name>tupbodylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>randomAccess</name></name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* need trailing length word? */</comment>
		<expr_stmt><expr><call><name>LogicalTapeReadExact</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>, <argument><expr><name>tapenum</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>tuplen</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tuplen</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>stup</name><operator>-&gt;</operator><name>tuple</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>tuple</name></expr>;</expr_stmt>
	<comment type="block">/* set up first-column key value */</comment>
	<expr_stmt><expr><name><name>htup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>+</operator> <name>MINIMAL_TUPLE_OFFSET</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>htup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tuple</name> <operator>-</operator> <name>MINIMAL_TUPLE_OFFSET</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stup</name><operator>-&gt;</operator><name>datum1</name></name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>htup</name></expr></argument>,
								<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>ssup_attno</name></expr></argument>,
								<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name><name>stup</name><operator>-&gt;</operator><name>isnull1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Routines specialized for the CLUSTER case (HeapTuple data, with
 * comparisons per a btree index definition)
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>comparetup_cluster</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SortTuple</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SortTuple</name> <modifier>*</modifier></type><name>b</name></decl></parameter>,
				   <parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SortSupport</name></type> <name>sortKey</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ltup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>rtup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>compare</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>datum1</name></decl>,
				<decl><type ref="prev"/><name>datum2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull1</name></decl>,
				<decl><type ref="prev"/><name>isnull2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>leading</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>indexInfo</name><operator>-&gt;</operator><name>ii_IndexAttrNumbers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Be prepared to compare additional sort keys */</comment>
	<expr_stmt><expr><name>ltup</name> <operator>=</operator> <operator>(</operator><name>HeapTuple</name><operator>)</operator> <name><name>a</name><operator>-&gt;</operator><name>tuple</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rtup</name> <operator>=</operator> <operator>(</operator><name>HeapTuple</name><operator>)</operator> <name><name>b</name><operator>-&gt;</operator><name>tuple</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>tupDesc</name></name></expr>;</expr_stmt>

	<comment type="block">/* Compare the leading sort key, if it's simple */</comment>
	<if_stmt><if>if <condition>(<expr><name>leading</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>compare</name> <operator>=</operator> <call><name>ApplySortComparator</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>datum1</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>isnull1</name></name></expr></argument>,
									  <argument><expr><name><name>b</name><operator>-&gt;</operator><name>datum1</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>isnull1</name></name></expr></argument>,
									  <argument><expr><name>sortKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>compare</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>compare</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>sortKey</name><operator>-&gt;</operator><name>abbrev_converter</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>datum1</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>ltup</name></expr></argument>, <argument><expr><name>leading</name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>datum2</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>rtup</name></expr></argument>, <argument><expr><name>leading</name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>compare</name> <operator>=</operator> <call><name>ApplySortAbbrevFullComparator</name><argument_list>(<argument><expr><name>datum1</name></expr></argument>, <argument><expr><name>isnull1</name></expr></argument>,
													<argument><expr><name>datum2</name></expr></argument>, <argument><expr><name>isnull2</name></expr></argument>,
													<argument><expr><name>sortKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>compare</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>state</name><operator>-&gt;</operator><name>nKeys</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>compare</name></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* Compare additional columns the hard way */</comment>
		<expr_stmt><expr><name>sortKey</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>nkey</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Must compare all keys the hard way */</comment>
		<expr_stmt><expr><name>nkey</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>indexInfo</name><operator>-&gt;</operator><name>ii_Expressions</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* If not expression index, just compare the proper heap attrs */</comment>

		<for>for <control>(<init>;</init> <condition><expr><name>nkey</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>nKeys</name></name></expr>;</condition> <incr><expr><name>nkey</name><operator>++</operator></expr><operator>,</operator> <expr><name>sortKey</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attno</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>indexInfo</name><operator>-&gt;</operator><name>ii_IndexAttrNumbers</name><index>[<expr><name>nkey</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>datum1</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>ltup</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>datum2</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>rtup</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>compare</name> <operator>=</operator> <call><name>ApplySortComparator</name><argument_list>(<argument><expr><name>datum1</name></expr></argument>, <argument><expr><name>isnull1</name></expr></argument>,
										  <argument><expr><name>datum2</name></expr></argument>, <argument><expr><name>isnull2</name></expr></argument>,
										  <argument><expr><name>sortKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>compare</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>compare</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * In the expression index case, compute the whole index tuple and
		 * then compare values.  It would perhaps be faster to compute only as
		 * many columns as we need to compare, but that would require
		 * duplicating all the logic in FormIndexDatum.
		 */</comment>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>l_index_values</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>l_index_isnull</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>r_index_values</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>r_index_isnull</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>ecxt_scantuple</name></decl>;</decl_stmt>

		<comment type="block">/* Reset context each time to prevent memory leakage */</comment>
		<expr_stmt><expr><call><name>ResetPerTupleExprContext</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>estate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ecxt_scantuple</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>estate</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ecxt_scantuple</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExecStoreHeapTuple</name><argument_list>(<argument><expr><name>ltup</name></expr></argument>, <argument><expr><name>ecxt_scantuple</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FormIndexDatum</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>indexInfo</name></name></expr></argument>, <argument><expr><name>ecxt_scantuple</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>estate</name></name></expr></argument>,
					   <argument><expr><name>l_index_values</name></expr></argument>, <argument><expr><name>l_index_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExecStoreHeapTuple</name><argument_list>(<argument><expr><name>rtup</name></expr></argument>, <argument><expr><name>ecxt_scantuple</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FormIndexDatum</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>indexInfo</name></name></expr></argument>, <argument><expr><name>ecxt_scantuple</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>estate</name></name></expr></argument>,
					   <argument><expr><name>r_index_values</name></expr></argument>, <argument><expr><name>r_index_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init>;</init> <condition><expr><name>nkey</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>nKeys</name></name></expr>;</condition> <incr><expr><name>nkey</name><operator>++</operator></expr><operator>,</operator> <expr><name>sortKey</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>compare</name> <operator>=</operator> <call><name>ApplySortComparator</name><argument_list>(<argument><expr><name><name>l_index_values</name><index>[<expr><name>nkey</name></expr>]</index></name></expr></argument>,
										  <argument><expr><name><name>l_index_isnull</name><index>[<expr><name>nkey</name></expr>]</index></name></expr></argument>,
										  <argument><expr><name><name>r_index_values</name><index>[<expr><name>nkey</name></expr>]</index></name></expr></argument>,
										  <argument><expr><name><name>r_index_isnull</name><index>[<expr><name>nkey</name></expr>]</index></name></expr></argument>,
										  <argument><expr><name>sortKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>compare</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>compare</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>copytup_cluster</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>stup</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>tup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><operator>(</operator><name>HeapTuple</name><operator>)</operator> <name>tup</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>original</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tuplecontext</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* copy the tuple into sort storage */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stup</name><operator>-&gt;</operator><name>tuple</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>tuple</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>USEMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>GetMemoryChunkSpace</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * set up first-column key value, and potentially abbreviate, if it's a
	 * simple column
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>indexInfo</name><operator>-&gt;</operator><name>ii_IndexAttrNumbers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>original</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
							<argument><expr><name><name>state</name><operator>-&gt;</operator><name>indexInfo</name><operator>-&gt;</operator><name>ii_IndexAttrNumbers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
							<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name><name>stup</name><operator>-&gt;</operator><name>isnull1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><operator>-&gt;</operator><name>abbrev_converter</name></name> <operator>||</operator> <name><name>stup</name><operator>-&gt;</operator><name>isnull1</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Store ordinary Datum representation, or NULL value.  If there is a
		 * converter it won't expect NULL values, and cost model is not
		 * required to account for NULL, so in that case we avoid calling
		 * converter and just set datum1 to zeroed representation (to be
		 * consistent, and to support cheap inequality tests for NULL
		 * abbreviated keys).
		 */</comment>
		<expr_stmt><expr><name><name>stup</name><operator>-&gt;</operator><name>datum1</name></name> <operator>=</operator> <name>original</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>consider_abort_common</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Store abbreviated key representation */</comment>
		<expr_stmt><expr><name><name>stup</name><operator>-&gt;</operator><name>datum1</name></name> <operator>=</operator> <call><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><operator>-&gt;</operator><name>abbrev_converter</name></name><argument_list>(<argument><expr><name>original</name></expr></argument>,
														 <argument><expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Abort abbreviation */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>stup</name><operator>-&gt;</operator><name>datum1</name></name> <operator>=</operator> <name>original</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Set state to be consistent with never trying abbreviation.
		 *
		 * Alter datum1 representation in already-copied tuples, so as to
		 * ensure a consistent representation (current tuple was just
		 * handled).  It does not matter if some dumped tuples are already
		 * sorted on tape, since serialized tuples lack abbreviated keys
		 * (TSS_BUILDRUNS state prevents control reaching here in any case).
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SortTuple</name>  <modifier>*</modifier></type><name>mtup</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>memtuples</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <operator>(</operator><name>HeapTuple</name><operator>)</operator> <name><name>mtup</name><operator>-&gt;</operator><name>tuple</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mtup</name><operator>-&gt;</operator><name>datum1</name></name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
										<argument><expr><name><name>state</name><operator>-&gt;</operator><name>indexInfo</name><operator>-&gt;</operator><name>ii_IndexAttrNumbers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
										<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name><name>mtup</name><operator>-&gt;</operator><name>isnull1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>writetup_cluster</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>, <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>stup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><operator>(</operator><name>HeapTuple</name><operator>)</operator> <name><name>stup</name><operator>-&gt;</operator><name>tuple</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tuplen</name> <init>= <expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

	<comment type="block">/* We need to store t_self, but not other fields of HeapTupleData */</comment>
	<expr_stmt><expr><call><name>LogicalTapeWrite</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>, <argument><expr><name>tapenum</name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name>tuplen</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tuplen</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LogicalTapeWrite</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>, <argument><expr><name>tapenum</name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LogicalTapeWrite</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>, <argument><expr><name>tapenum</name></expr></argument>,
					 <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>randomAccess</name></name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* need trailing length word? */</comment>
		<expr_stmt><expr><call><name>LogicalTapeWrite</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>, <argument><expr><name>tapenum</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>tuplen</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tuplen</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>slabAllocatorUsed</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FREEMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>GetMemoryChunkSpace</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>readtup_cluster</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>stup</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>tuplen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>t_len</name> <init>= <expr><name>tuplen</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><operator>(</operator><name>HeapTuple</name><operator>)</operator> <call><name>readtup_alloc</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
												  <argument><expr><name>t_len</name> <operator>+</operator> <name>HEAPTUPLESIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Reconstruct the HeapTupleData header */</comment>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tuple</name> <operator>+</operator> <name>HEAPTUPLESIZE</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator> <name>t_len</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LogicalTapeReadExact</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>, <argument><expr><name>tapenum</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* We don't currently bother to reconstruct t_tableOid */</comment>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<comment type="block">/* Read in the tuple body */</comment>
	<expr_stmt><expr><call><name>LogicalTapeReadExact</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>, <argument><expr><name>tapenum</name></expr></argument>,
						 <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>randomAccess</name></name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* need trailing length word? */</comment>
		<expr_stmt><expr><call><name>LogicalTapeReadExact</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>, <argument><expr><name>tapenum</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>tuplen</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tuplen</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>stup</name><operator>-&gt;</operator><name>tuple</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>tuple</name></expr>;</expr_stmt>
	<comment type="block">/* set up first-column key value, if it's a simple column */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>indexInfo</name><operator>-&gt;</operator><name>ii_IndexAttrNumbers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>stup</name><operator>-&gt;</operator><name>datum1</name></name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
									<argument><expr><name><name>state</name><operator>-&gt;</operator><name>indexInfo</name><operator>-&gt;</operator><name>ii_IndexAttrNumbers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
									<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>stup</name><operator>-&gt;</operator><name>isnull1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Routines specialized for IndexTuple case
 *
 * The btree and hash cases require separate comparison functions, but the
 * IndexTuple representation is the same so the copy/write/read support
 * functions can be shared.
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>comparetup_index_btree</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SortTuple</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SortTuple</name> <modifier>*</modifier></type><name>b</name></decl></parameter>,
					   <parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * This is similar to comparetup_heap(), but expects index tuples.  There
	 * is also special handling for enforcing uniqueness, and special
	 * treatment for equal keys at the end.
	 */</comment>
	<decl_stmt><decl><type><name>SortSupport</name></type> <name>sortKey</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>tuple1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>tuple2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>keysz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>equal_hasnull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>compare</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>datum1</name></decl>,
				<decl><type ref="prev"/><name>datum2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull1</name></decl>,
				<decl><type ref="prev"/><name>isnull2</name></decl>;</decl_stmt>


	<comment type="block">/* Compare the leading sort key */</comment>
	<expr_stmt><expr><name>compare</name> <operator>=</operator> <call><name>ApplySortComparator</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>datum1</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>isnull1</name></name></expr></argument>,
								  <argument><expr><name><name>b</name><operator>-&gt;</operator><name>datum1</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>isnull1</name></name></expr></argument>,
								  <argument><expr><name>sortKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>compare</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>compare</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Compare additional sort keys */</comment>
	<expr_stmt><expr><name>tuple1</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <name><name>a</name><operator>-&gt;</operator><name>tuple</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple2</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <name><name>b</name><operator>-&gt;</operator><name>tuple</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>keysz</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>nKeys</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupDes</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>indexRel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>sortKey</name><operator>-&gt;</operator><name>abbrev_converter</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>datum1</name> <operator>=</operator> <call><name>index_getattr</name><argument_list>(<argument><expr><name>tuple1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>tupDes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>datum2</name> <operator>=</operator> <call><name>index_getattr</name><argument_list>(<argument><expr><name>tuple2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>tupDes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>compare</name> <operator>=</operator> <call><name>ApplySortAbbrevFullComparator</name><argument_list>(<argument><expr><name>datum1</name></expr></argument>, <argument><expr><name>isnull1</name></expr></argument>,
												<argument><expr><name>datum2</name></expr></argument>, <argument><expr><name>isnull2</name></expr></argument>,
												<argument><expr><name>sortKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>compare</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>compare</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* they are equal, so we only need to examine one null flag */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>isnull1</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>equal_hasnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>sortKey</name><operator>++</operator></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>nkey</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>nkey</name> <operator>&lt;=</operator> <name>keysz</name></expr>;</condition> <incr><expr><name>nkey</name><operator>++</operator></expr><operator>,</operator> <expr><name>sortKey</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>datum1</name> <operator>=</operator> <call><name>index_getattr</name><argument_list>(<argument><expr><name>tuple1</name></expr></argument>, <argument><expr><name>nkey</name></expr></argument>, <argument><expr><name>tupDes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>datum2</name> <operator>=</operator> <call><name>index_getattr</name><argument_list>(<argument><expr><name>tuple2</name></expr></argument>, <argument><expr><name>nkey</name></expr></argument>, <argument><expr><name>tupDes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>compare</name> <operator>=</operator> <call><name>ApplySortComparator</name><argument_list>(<argument><expr><name>datum1</name></expr></argument>, <argument><expr><name>isnull1</name></expr></argument>,
									  <argument><expr><name>datum2</name></expr></argument>, <argument><expr><name>isnull2</name></expr></argument>,
									  <argument><expr><name>sortKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>compare</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>compare</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* done when we find unequal attributes */</comment>

		<comment type="block">/* they are equal, so we only need to examine one null flag */</comment>
		<if_stmt><if>if <condition>(<expr><name>isnull1</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>equal_hasnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If btree has asked us to enforce uniqueness, complain if two equal
	 * tuples are detected (unless there was at least one NULL field).
	 *
	 * It is sufficient to make the test here, because if two tuples are equal
	 * they *must* get compared at some stage of the sort --- otherwise the
	 * sort algorithm wouldn't have checked whether one must appear before the
	 * other.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>enforceUnique</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>equal_hasnull</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>isnull</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>key_desc</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Some rather brain-dead implementations of qsort (such as the one in
		 * QNX 4) will sometimes call the comparison routine to compare a
		 * value to itself, but we always use our own implementation, which
		 * does not.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tuple1</name> <operator>!=</operator> <name>tuple2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>index_deform_tuple</name><argument_list>(<argument><expr><name>tuple1</name></expr></argument>, <argument><expr><name>tupDes</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>key_desc</name> <operator>=</operator> <call><name>BuildIndexValueDescription</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>indexRel</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNIQUE_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create unique index \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>indexRel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><name>key_desc</name></expr> ?</condition><then> <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Key %s is duplicated."</literal></expr></argument>, <argument><expr><name>key_desc</name></expr></argument>)</argument_list></call></expr> </then><else>:
				 <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Duplicate keys exist."</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>,</operator>
				 <call><name>errtableconstraint</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heapRel</name></name></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>indexRel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Skip this for YugaByte-based table. In YugaByte, tuples do not have block number
	 * and offset.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If key values are equal, we sort on ItemPointer.  This does not affect
		 * validity of the finished index, but it may be useful to have index
		 * scans in physical order.
		 */</comment>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blk1</name> <init>= <expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tuple1</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blk2</name> <init>= <expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tuple2</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>blk1</name> <operator>!=</operator> <name>blk2</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><ternary><condition><expr><operator>(</operator><name>blk1</name> <operator>&lt;</operator> <name>blk2</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>pos1</name> <init>= <expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tuple1</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>pos2</name> <init>= <expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tuple2</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>pos1</name> <operator>!=</operator> <name>pos2</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><ternary><condition><expr><operator>(</operator><name>pos1</name> <operator>&lt;</operator> <name>pos2</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>comparetup_index_hash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SortTuple</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SortTuple</name> <modifier>*</modifier></type><name>b</name></decl></parameter>,
					  <parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bucket</name></type>		<name>bucket1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bucket</name></type>		<name>bucket2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>tuple1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>tuple2</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Fetch hash keys and mask off bits we don't want to sort by. We know
	 * that the first column of the index tuple is the hash key.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>a</name><operator>-&gt;</operator><name>isnull1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bucket1</name> <operator>=</operator> <call><name>_hash_hashkey2bucket</name><argument_list>(<argument><expr><call><name>DatumGetUInt32</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>datum1</name></name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>max_buckets</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>high_mask</name></name></expr></argument>,
								   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>low_mask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>b</name><operator>-&gt;</operator><name>isnull1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bucket2</name> <operator>=</operator> <call><name>_hash_hashkey2bucket</name><argument_list>(<argument><expr><call><name>DatumGetUInt32</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>datum1</name></name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>max_buckets</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>high_mask</name></name></expr></argument>,
								   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>low_mask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>bucket1</name> <operator>&gt;</operator> <name>bucket2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>bucket1</name> <operator>&lt;</operator> <name>bucket2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If hash values are equal, we sort on ItemPointer.  This does not affect
	 * validity of the finished index, but it may be useful to have index
	 * scans in physical order.
	 */</comment>
	<expr_stmt><expr><name>tuple1</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <name><name>a</name><operator>-&gt;</operator><name>tuple</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple2</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <name><name>b</name><operator>-&gt;</operator><name>tuple</name></name></expr>;</expr_stmt>

	<block>{<block_content>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blk1</name> <init>= <expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tuple1</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blk2</name> <init>= <expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tuple2</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>blk1</name> <operator>!=</operator> <name>blk2</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><ternary><condition><expr><operator>(</operator><name>blk1</name> <operator>&lt;</operator> <name>blk2</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>pos1</name> <init>= <expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tuple1</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>pos2</name> <init>= <expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tuple2</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>pos1</name> <operator>!=</operator> <name>pos2</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><ternary><condition><expr><operator>(</operator><name>pos1</name> <operator>&lt;</operator> <name>pos2</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>copytup_index</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>stup</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>tup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>tuple</name> <init>= <expr><operator>(</operator><name>IndexTuple</name><operator>)</operator> <name>tup</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tuplen</name> <init>= <expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>newtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>original</name></decl>;</decl_stmt>

	<comment type="block">/* copy the tuple into sort storage */</comment>
	<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tuplecontext</name></name></expr></argument>, <argument><expr><name>tuplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>tuplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>USEMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>GetMemoryChunkSpace</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stup</name><operator>-&gt;</operator><name>tuple</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>newtuple</name></expr>;</expr_stmt>
	<comment type="block">/* set up first-column key value */</comment>
	<expr_stmt><expr><name>original</name> <operator>=</operator> <call><name>index_getattr</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>,
							 <argument><expr><literal type="number">1</literal></expr></argument>,
							 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>indexRel</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>stup</name><operator>-&gt;</operator><name>isnull1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><operator>-&gt;</operator><name>abbrev_converter</name></name> <operator>||</operator> <name><name>stup</name><operator>-&gt;</operator><name>isnull1</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Store ordinary Datum representation, or NULL value.  If there is a
		 * converter it won't expect NULL values, and cost model is not
		 * required to account for NULL, so in that case we avoid calling
		 * converter and just set datum1 to zeroed representation (to be
		 * consistent, and to support cheap inequality tests for NULL
		 * abbreviated keys).
		 */</comment>
		<expr_stmt><expr><name><name>stup</name><operator>-&gt;</operator><name>datum1</name></name> <operator>=</operator> <name>original</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>consider_abort_common</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Store abbreviated key representation */</comment>
		<expr_stmt><expr><name><name>stup</name><operator>-&gt;</operator><name>datum1</name></name> <operator>=</operator> <call><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><operator>-&gt;</operator><name>abbrev_converter</name></name><argument_list>(<argument><expr><name>original</name></expr></argument>,
														 <argument><expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Abort abbreviation */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>stup</name><operator>-&gt;</operator><name>datum1</name></name> <operator>=</operator> <name>original</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Set state to be consistent with never trying abbreviation.
		 *
		 * Alter datum1 representation in already-copied tuples, so as to
		 * ensure a consistent representation (current tuple was just
		 * handled).  It does not matter if some dumped tuples are already
		 * sorted on tape, since serialized tuples lack abbreviated keys
		 * (TSS_BUILDRUNS state prevents control reaching here in any case).
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SortTuple</name>  <modifier>*</modifier></type><name>mtup</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>memtuples</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <name><name>mtup</name><operator>-&gt;</operator><name>tuple</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mtup</name><operator>-&gt;</operator><name>datum1</name></name> <operator>=</operator> <call><name>index_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
										 <argument><expr><literal type="number">1</literal></expr></argument>,
										 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>indexRel</name></name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name><name>mtup</name><operator>-&gt;</operator><name>isnull1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>writetup_index</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>, <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>stup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>tuple</name> <init>= <expr><operator>(</operator><name>IndexTuple</name><operator>)</operator> <name><name>stup</name><operator>-&gt;</operator><name>tuple</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tuplen</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuplen</name> <operator>=</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>tuplen</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LogicalTapeWrite</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>, <argument><expr><name>tapenum</name></expr></argument>,
					 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>tuplen</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tuplen</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LogicalTapeWrite</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>, <argument><expr><name>tapenum</name></expr></argument>,
					 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>tuple</name></expr></argument>, <argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>randomAccess</name></name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* need trailing length word? */</comment>
		<expr_stmt><expr><call><name>LogicalTapeWrite</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>, <argument><expr><name>tapenum</name></expr></argument>,
						 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>tuplen</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tuplen</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>slabAllocatorUsed</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FREEMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>GetMemoryChunkSpace</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>readtup_index</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>stup</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tuplen</name> <init>= <expr><name>len</name> <operator>-</operator> sizeof<operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>tuple</name> <init>= <expr><operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>readtup_alloc</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>tuplen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LogicalTapeReadExact</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>, <argument><expr><name>tapenum</name></expr></argument>,
						 <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>tuplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>randomAccess</name></name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* need trailing length word? */</comment>
		<expr_stmt><expr><call><name>LogicalTapeReadExact</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>, <argument><expr><name>tapenum</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>tuplen</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tuplen</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>stup</name><operator>-&gt;</operator><name>tuple</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>tuple</name></expr>;</expr_stmt>
	<comment type="block">/* set up first-column key value */</comment>
	<expr_stmt><expr><name><name>stup</name><operator>-&gt;</operator><name>datum1</name></name> <operator>=</operator> <call><name>index_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
								 <argument><expr><literal type="number">1</literal></expr></argument>,
								 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>indexRel</name></name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>stup</name><operator>-&gt;</operator><name>isnull1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Routines specialized for DatumTuple case
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>comparetup_datum</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SortTuple</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SortTuple</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>compare</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>compare</name> <operator>=</operator> <call><name>ApplySortComparator</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>datum1</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>isnull1</name></name></expr></argument>,
								  <argument><expr><name><name>b</name><operator>-&gt;</operator><name>datum1</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>isnull1</name></name></expr></argument>,
								  <argument><expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>compare</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>compare</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* if we have abbreviations, then "tuple" has the original value */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name><operator>-&gt;</operator><name>abbrev_converter</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>compare</name> <operator>=</operator> <call><name>ApplySortAbbrevFullComparator</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>isnull1</name></name></expr></argument>,
												<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>isnull1</name></name></expr></argument>,
												<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sortKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>compare</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>copytup_datum</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>stup</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>tup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Not currently needed */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"copytup_datum() should not be called"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>writetup_datum</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>, <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>stup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>waddr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tuplen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>writtenlen</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stup</name><operator>-&gt;</operator><name>isnull1</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>waddr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>tuplen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>tuples</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>waddr</name> <operator>=</operator> <operator>&amp;</operator><name><name>stup</name><operator>-&gt;</operator><name>datum1</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>tuplen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>waddr</name> <operator>=</operator> <name><name>stup</name><operator>-&gt;</operator><name>tuple</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>tuplen</name> <operator>=</operator> <call><name>datumGetSize</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>stup</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>datumTypeLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tuplen</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>writtenlen</name> <operator>=</operator> <name>tuplen</name> <operator>+</operator> sizeof<operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LogicalTapeWrite</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>, <argument><expr><name>tapenum</name></expr></argument>,
					 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>writtenlen</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>writtenlen</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LogicalTapeWrite</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>, <argument><expr><name>tapenum</name></expr></argument>,
					 <argument><expr><name>waddr</name></expr></argument>, <argument><expr><name>tuplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>randomAccess</name></name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* need trailing length word? */</comment>
		<expr_stmt><expr><call><name>LogicalTapeWrite</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>, <argument><expr><name>tapenum</name></expr></argument>,
						 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>writtenlen</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>writtenlen</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>slabAllocatorUsed</name></name> <operator>&amp;&amp;</operator> <name><name>stup</name><operator>-&gt;</operator><name>tuple</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FREEMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>GetMemoryChunkSpace</name><argument_list>(<argument><expr><name><name>stup</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>stup</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>readtup_datum</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>stup</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tuplen</name> <init>= <expr><name>len</name> <operator>-</operator> sizeof<operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>tuplen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* it's NULL */</comment>
		<expr_stmt><expr><name><name>stup</name><operator>-&gt;</operator><name>datum1</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stup</name><operator>-&gt;</operator><name>isnull1</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stup</name><operator>-&gt;</operator><name>tuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>tuples</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tuplen</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LogicalTapeReadExact</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>, <argument><expr><name>tapenum</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>stup</name><operator>-&gt;</operator><name>datum1</name></name></expr></argument>, <argument><expr><name>tuplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stup</name><operator>-&gt;</operator><name>isnull1</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stup</name><operator>-&gt;</operator><name>tuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>raddr</name> <init>= <expr><call><name>readtup_alloc</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>tuplen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>LogicalTapeReadExact</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>, <argument><expr><name>tapenum</name></expr></argument>,
							 <argument><expr><name>raddr</name></expr></argument>, <argument><expr><name>tuplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stup</name><operator>-&gt;</operator><name>datum1</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>raddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stup</name><operator>-&gt;</operator><name>isnull1</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stup</name><operator>-&gt;</operator><name>tuple</name></name> <operator>=</operator> <name>raddr</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>randomAccess</name></name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* need trailing length word? */</comment>
		<expr_stmt><expr><call><name>LogicalTapeReadExact</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>, <argument><expr><name>tapenum</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>tuplen</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tuplen</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Parallel sort routines
 */</comment>

<comment type="block">/*
 * tuplesort_estimate_shared - estimate required shared memory allocation
 *
 * nWorkers is an estimate of the number of workers (it's the number that
 * will be requested).
 */</comment>
<function><type><name>Size</name></type>
<name>tuplesort_estimate_shared</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nWorkers</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>tapesSize</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nWorkers</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure that BufFile shared state is MAXALIGN'd */</comment>
	<expr_stmt><expr><name>tapesSize</name> <operator>=</operator> <call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TapeShare</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>nWorkers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tapesSize</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>add_size</name><argument_list>(<argument><expr><name>tapesSize</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>Sharedsort</name></expr></argument>, <argument><expr><name>tapes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tapesSize</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * tuplesort_initialize_shared - initialize shared tuplesort state
 *
 * Must be called from leader process before workers are launched, to
 * establish state needed up-front for worker tuplesortstates.  nWorkers
 * should match the argument passed to tuplesort_estimate_shared().
 */</comment>
<function><type><name>void</name></type>
<name>tuplesort_initialize_shared</name><parameter_list>(<parameter><decl><type><name>Sharedsort</name> <modifier>*</modifier></type><name>shared</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nWorkers</name></decl></parameter>, <parameter><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>seg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nWorkers</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>currentWorker</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>workersFinished</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SharedFileSetInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>fileset</name></name></expr></argument>, <argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>nTapes</name></name> <operator>=</operator> <name>nWorkers</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nWorkers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>tapes</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>firstblocknumber</name> <operator>=</operator> <literal type="number">0L</literal></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * tuplesort_attach_shared - attach to shared tuplesort state
 *
 * Must be called by all worker processes.
 */</comment>
<function><type><name>void</name></type>
<name>tuplesort_attach_shared</name><parameter_list>(<parameter><decl><type><name>Sharedsort</name> <modifier>*</modifier></type><name>shared</name></decl></parameter>, <parameter><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>seg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Attach to SharedFileSet */</comment>
	<expr_stmt><expr><call><name>SharedFileSetAttach</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>fileset</name></name></expr></argument>, <argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * worker_get_identifier - Assign and return ordinal identifier for worker
 *
 * The order in which these are assigned is not well defined, and should not
 * matter; worker numbers across parallel sort participants need only be
 * distinct and gapless.  logtape.c requires this.
 *
 * Note that the identifiers assigned from here have no relation to
 * ParallelWorkerNumber number, to avoid making any assumption about
 * caller's requirements.  However, we do follow the ParallelWorkerNumber
 * convention of representing a non-worker with worker number -1.  This
 * includes the leader, as well as serial Tuplesort processes.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>worker_get_identifier</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Sharedsort</name> <modifier>*</modifier></type><name>shared</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>worker</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>WORKER</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>worker</name> <operator>=</operator> <name><name>shared</name><operator>-&gt;</operator><name>currentWorker</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>worker</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * worker_freeze_result_tape - freeze worker's result tape for leader
 *
 * This is called by workers just after the result tape has been determined,
 * instead of calling LogicalTapeFreeze() directly.  They do so because
 * workers require a few additional steps over similar serial
 * TSS_SORTEDONTAPE external sort cases, which also happen here.  The extra
 * steps are around freeing now unneeded resources, and representing to
 * leader that worker's input run is available for its merge.
 *
 * There should only be one final output run for each worker, which consists
 * of all tuples that were originally input into worker.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>worker_freeze_result_tape</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Sharedsort</name> <modifier>*</modifier></type><name>shared</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TapeShare</name></type>	<name>output</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>WORKER</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>result_tape</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Free most remaining memory, in case caller is sensitive to our holding
	 * on to it.  memtuples may not be a tiny merge heap at this point.
	 */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Be tidy */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>memtupsize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Parallel worker requires result tape metadata, which is to be stored in
	 * shared memory for leader
	 */</comment>
	<expr_stmt><expr><call><name>LogicalTapeFreeze</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>result_tape</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Store properties of output tape, and update finished worker count */</comment>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>tapes</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>worker</name></name></expr>]</index></name> <operator>=</operator> <name>output</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>workersFinished</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * worker_nomergeruns - dump memtuples in worker, without merging
 *
 * This called as an alternative to mergeruns() with a worker when no
 * merging is required.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>worker_nomergeruns</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>WORKER</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>result_tape</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>result_tape</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>tp_tapenum</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>destTape</name></name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>worker_freeze_result_tape</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * leader_takeover_tapes - create tapeset for leader from worker tapes
 *
 * So far, leader Tuplesortstate has performed no actual sorting.  By now, all
 * sorting has occurred in workers, all of which must have already returned
 * from tuplesort_performsort().
 *
 * When this returns, leader process is left in a state that is virtually
 * indistinguishable from it having generated runs as a serial external sort
 * might have.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>leader_takeover_tapes</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Sharedsort</name> <modifier>*</modifier></type><name>shared</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nParticipants</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>nParticipants</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>workersFinished</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LEADER</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nParticipants</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>workersFinished</name> <operator>=</operator> <name><name>shared</name><operator>-&gt;</operator><name>workersFinished</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nParticipants</name> <operator>!=</operator> <name>workersFinished</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot take over tapes before all workers finish"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Create the tapeset from worker tapes, including a leader-owned tape at
	 * the end.  Parallel workers are far more expensive than logical tapes,
	 * so the number of tapes allocated here should never be excessive.
	 *
	 * We still have a leader tape, though it's not possible to write to it
	 * due to restrictions in the shared fileset infrastructure used by
	 * logtape.c.  It will never be written to in practice because
	 * randomAccess is disallowed for parallel sorts.
	 */</comment>
	<expr_stmt><expr><call><name>inittapestate</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>nParticipants</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tapeset</name></name> <operator>=</operator> <call><name>LogicalTapeSetCreate</name><argument_list>(<argument><expr><name>nParticipants</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>shared</name><operator>-&gt;</operator><name>tapes</name></name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>fileset</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>worker</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* mergeruns() relies on currentRun for # of runs (in one-pass cases) */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>currentRun</name></name> <operator>=</operator> <name>nParticipants</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize variables of Algorithm D to be consistent with runs from
	 * workers having been generated in the leader.
	 *
	 * There will always be exactly 1 run per worker, and exactly one input
	 * tape per run, because workers always output exactly 1 run, even when
	 * there were no input tuples for workers to sort.
	 */</comment>
	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>maxTapes</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* One real run; no dummy runs for worker tapes */</comment>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tp_fib</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tp_runs</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tp_dummy</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tp_tapenum</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Leader tape gets one dummy run, and no real runs */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tp_fib</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>tapeRange</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tp_runs</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>tapeRange</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tp_dummy</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>tapeRange</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>Level</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>destTape</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>TSS_BUILDRUNS</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Convenience routine to free a tuple previously loaded into sort memory
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>free_sort_tuple</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SortTuple</name> <modifier>*</modifier></type><name>stup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>FREEMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>GetMemoryChunkSpace</name><argument_list>(<argument><expr><name><name>stup</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>stup</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
