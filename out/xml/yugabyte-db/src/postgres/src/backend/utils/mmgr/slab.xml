<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/utils/mmgr/slab.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * slab.c
 *	  SLAB allocator definitions.
 *
 * SLAB is a MemoryContext implementation designed for cases where large
 * numbers of equally-sized objects are allocated (and freed).
 *
 *
 * Portions Copyright (c) 2017-2018, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *	  src/backend/utils/mmgr/slab.c
 *
 *
 * NOTE:
 *	The constant allocation size allows significant simplification and various
 *	optimizations over more general purpose allocators. The blocks are carved
 *	into chunks of exactly the right size (plus alignment), not wasting any
 *	memory.
 *
 *	The information about free chunks is maintained both at the block level and
 *	global (context) level. This is possible as the chunk size (and thus also
 *	the number of chunks per block) is fixed.
 *
 *	On each block, free chunks are tracked in a simple linked list. Contents
 *	of free chunks is replaced with an index of the next free chunk, forming
 *	a very simple linked list. Each block also contains a counter of free
 *	chunks. Combined with the local block-level freelist, it makes it trivial
 *	to eventually free the whole block.
 *
 *	At the context level, we use 'freelist' to track blocks ordered by number
 *	of free chunks, starting with blocks having a single allocated chunk, and
 *	with completely full blocks on the tail.
 *
 *	This also allows various optimizations - for example when searching for
 *	free chunk, the allocator reuses space from the fullest blocks first, in
 *	the hope that some of the less full blocks will get completely empty (and
 *	returned back to the OS).
 *
 *	For each block, we maintain pointer to the first free chunk - this is quite
 *	cheap and allows us to skip all the preceding used chunks, eliminating
 *	a significant number of lookups in many common usage patters. In the worst
 *	case this performs as if the pointer was not maintained.
 *
 *	We cache the freelist index for the blocks with the fewest free chunks
 *	(minFreeChunks), so that we don't have to search the freelist on every
 *	SlabAlloc() call, which is quite expensive.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memdebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/ilist.h"</cpp:file></cpp:include>


<comment type="block">/*
 * SlabContext is a specialized implementation of MemoryContext.
 */</comment>
<typedef>typedef <type><struct>struct <name>SlabContext</name>
<block>{
	<decl_stmt><decl><type><name>MemoryContextData</name></type> <name>header</name></decl>;</decl_stmt>	<comment type="block">/* Standard memory-context fields */</comment>
	<comment type="block">/* Allocation parameters for this context: */</comment>
	<decl_stmt><decl><type><name>Size</name></type>		<name>chunkSize</name></decl>;</decl_stmt>		<comment type="block">/* chunk size */</comment>
	<decl_stmt><decl><type><name>Size</name></type>		<name>fullChunkSize</name></decl>;</decl_stmt>	<comment type="block">/* chunk size including header and alignment */</comment>
	<decl_stmt><decl><type><name>Size</name></type>		<name>blockSize</name></decl>;</decl_stmt>		<comment type="block">/* block size */</comment>
	<decl_stmt><decl><type><name>Size</name></type>		<name>headerSize</name></decl>;</decl_stmt>		<comment type="block">/* allocated size of context header */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>chunksPerBlock</name></decl>;</decl_stmt> <comment type="block">/* number of chunks per block */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>minFreeChunks</name></decl>;</decl_stmt>	<comment type="block">/* min number of free chunks in any block */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nblocks</name></decl>;</decl_stmt>		<comment type="block">/* number of blocks allocated */</comment>
	<comment type="block">/* blocks with free space, grouped by number of free chunks: */</comment>
	<decl_stmt><decl><type><name>dlist_head</name></type>	<name><name>freelist</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>SlabContext</name>;</typedef>

<comment type="block">/*
 * SlabBlock
 *		Structure of a single block in SLAB allocator.
 *
 * node: doubly-linked list of blocks in global freelist
 * nfree: number of free chunks in this block
 * firstFreeChunk: index of the first free chunk
 */</comment>
<typedef>typedef <type><struct>struct <name>SlabBlock</name>
<block>{
	<decl_stmt><decl><type><name>dlist_node</name></type>	<name>node</name></decl>;</decl_stmt>			<comment type="block">/* doubly-linked list */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nfree</name></decl>;</decl_stmt>			<comment type="block">/* number of free chunks */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>firstFreeChunk</name></decl>;</decl_stmt> <comment type="block">/* index of the first free chunk in the block */</comment>
}</block></struct></type> <name>SlabBlock</name>;</typedef>

<comment type="block">/*
 * SlabChunk
 *		The prefix of each piece of memory in a SlabBlock
 *
 * Note: to meet the memory context APIs, the payload area of the chunk must
 * be maxaligned, and the "slab" link must be immediately adjacent to the
 * payload area (cf. GetMemoryChunkContext).  Since we support no machines on
 * which MAXALIGN is more than twice sizeof(void *), this happens without any
 * special hacking in this struct declaration.  But there is a static
 * assertion below that the alignment is done correctly.
 */</comment>
<typedef>typedef <type><struct>struct <name>SlabChunk</name>
<block>{
	<decl_stmt><decl><type><name>SlabBlock</name>  <modifier>*</modifier></type><name>block</name></decl>;</decl_stmt>			<comment type="block">/* block owning this chunk */</comment>
	<decl_stmt><decl><type><name>SlabContext</name> <modifier>*</modifier></type><name>slab</name></decl>;</decl_stmt>			<comment type="block">/* owning context */</comment>
	<comment type="block">/* there must not be any padding to reach a MAXALIGN boundary here! */</comment>
}</block></struct></type> <name>SlabChunk</name>;</typedef>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SlabPointerGetChunk</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>)</parameter_list></cpp:macro>	\
	<cpp:value>((SlabChunk *)(((char *)(ptr)) - sizeof(SlabChunk)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SlabChunkGetPointer</name><parameter_list>(<parameter><type><name>chk</name></type></parameter>)</parameter_list></cpp:macro>	\
	<cpp:value>((void *)(((char *)(chk)) + sizeof(SlabChunk)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SlabBlockGetChunk</name><parameter_list>(<parameter><type><name>slab</name></type></parameter>, <parameter><type><name>block</name></type></parameter>, <parameter><type><name>idx</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((SlabChunk *) ((char *) (block) + sizeof(SlabBlock)	\
					+ (idx * slab-&gt;fullChunkSize)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SlabBlockStart</name><parameter_list>(<parameter><type><name>block</name></type></parameter>)</parameter_list></cpp:macro>	\
	<cpp:value>((char *) block + sizeof(SlabBlock))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SlabChunkIndex</name><parameter_list>(<parameter><type><name>slab</name></type></parameter>, <parameter><type><name>block</name></type></parameter>, <parameter><type><name>chunk</name></type></parameter>)</parameter_list></cpp:macro>	\
	<cpp:value>(((char *) chunk - SlabBlockStart(block)) / slab-&gt;fullChunkSize)</cpp:value></cpp:define>

<comment type="block">/*
 * These functions implement the MemoryContext API for Slab contexts.
 */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>SlabAlloc</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SlabFree</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pointer</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>SlabRealloc</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pointer</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SlabReset</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SlabDelete</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Size</name></type> <name>SlabGetChunkSpace</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pointer</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>SlabIsEmpty</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SlabStats</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>,
		  <parameter><decl><type><name>MemoryStatsPrintFunc</name></type> <name>printfunc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>passthru</name></decl></parameter>,
		  <parameter><decl><type><name>MemoryContextCounters</name> <modifier>*</modifier></type><name>totals</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MEMORY_CONTEXT_CHECKING</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SlabCheck</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * This is the virtual function table for Slab contexts.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>MemoryContextMethods</name></type> <name>SlabMethods</name> <init>= <expr><block>{
	<expr><name>SlabAlloc</name></expr>,
	<expr><name>SlabFree</name></expr>,
	<expr><name>SlabRealloc</name></expr>,
	<expr><name>SlabReset</name></expr>,
	<expr><name>SlabDelete</name></expr>,
	<expr><name>SlabGetChunkSpace</name></expr>,
	<expr><name>SlabIsEmpty</name></expr>,
	<expr><name>SlabStats</name></expr>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MEMORY_CONTEXT_CHECKING</name></cpp:ifdef>
	,<expr><name>SlabCheck</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* ----------
 * Debug macros
 * ----------
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_ALLOCINFO</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SlabFreeInfo</name><parameter_list>(<parameter><type><name>_cxt</name></type></parameter>, <parameter><type><name>_chunk</name></type></parameter>)</parameter_list></cpp:macro> \
			<cpp:value>fprintf(stderr, "SlabFree: %s: %p, %zu\n", \
				(_cxt)-&gt;header.name, (_chunk), (_chunk)-&gt;header.size)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SlabAllocInfo</name><parameter_list>(<parameter><type><name>_cxt</name></type></parameter>, <parameter><type><name>_chunk</name></type></parameter>)</parameter_list></cpp:macro> \
			<cpp:value>fprintf(stderr, "SlabAlloc: %s: %p, %zu\n", \
				(_cxt)-&gt;header.name, (_chunk), (_chunk)-&gt;header.size)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SlabFreeInfo</name><parameter_list>(<parameter><type><name>_cxt</name></type></parameter>, <parameter><type><name>_chunk</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SlabAllocInfo</name><parameter_list>(<parameter><type><name>_cxt</name></type></parameter>, <parameter><type><name>_chunk</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
 * SlabContextCreate
 *		Create a new Slab context.
 *
 * parent: parent context, or NULL if top-level context
 * name: name of context (must be statically allocated)
 * blockSize: allocation block size
 * chunkSize: allocation chunk size
 *
 * The chunkSize may not exceed:
 *		MAXALIGN_DOWN(SIZE_MAX) - MAXALIGN(sizeof(SlabBlock)) - SLAB_CHUNKHDRSZ
 */</comment>
<function><type><name>MemoryContext</name></type>
<name>SlabContextCreate</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>parent</name></decl></parameter>,
				  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
				  <parameter><decl><type><name>Size</name></type> <name>blockSize</name></decl></parameter>,
				  <parameter><decl><type><name>Size</name></type> <name>chunkSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>chunksPerBlock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>fullChunkSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>freelistSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>headerSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SlabContext</name> <modifier>*</modifier></type><name>slab</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Assert we padded SlabChunk properly */</comment>
	<expr_stmt><expr><call><name>StaticAssertStmt</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SlabChunk</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SlabChunk</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><literal type="string">"sizeof(SlabChunk) is not maxaligned"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>StaticAssertStmt</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>SlabChunk</name></expr></argument>, <argument><expr><name>slab</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MemoryContext</name></expr></argument>)</argument_list></sizeof> <operator>==</operator>
					 <sizeof>sizeof<argument_list>(<argument><expr><name>SlabChunk</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					 <argument><expr><literal type="string">"padding calculation in SlabChunk is wrong"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure the linked list node fits inside a freed chunk */</comment>
	<if_stmt><if>if <condition>(<expr><name>chunkSize</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>chunkSize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* chunk, including SLAB header (both addresses nicely aligned) */</comment>
	<expr_stmt><expr><name>fullChunkSize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SlabChunk</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>chunkSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure the block can store at least one chunk. */</comment>
	<if_stmt><if>if <condition>(<expr><name>blockSize</name> <operator>&lt;</operator> <name>fullChunkSize</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SlabBlock</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"block size %zu for slab is too small for %zu chunks"</literal></expr></argument>,
			 <argument><expr><name>blockSize</name></expr></argument>, <argument><expr><name>chunkSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Compute maximum number of chunks per block */</comment>
	<expr_stmt><expr><name>chunksPerBlock</name> <operator>=</operator> <operator>(</operator><name>blockSize</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SlabBlock</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>/</operator> <name>fullChunkSize</name></expr>;</expr_stmt>

	<comment type="block">/* The freelist starts with 0, ends with chunksPerBlock. */</comment>
	<expr_stmt><expr><name>freelistSize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>dlist_head</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>chunksPerBlock</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate the context header.  Unlike aset.c, we never try to combine
	 * this with the first regular block; not worth the extra complication.
	 */</comment>

	<comment type="block">/* Size of the memory context header */</comment>
	<expr_stmt><expr><name>headerSize</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>SlabContext</name></expr></argument>, <argument><expr><name>freelist</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>freelistSize</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>slab</name> <operator>=</operator> <operator>(</operator><name>SlabContext</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>headerSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>slab</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemoryContextStats</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed while creating memory context \"%s\"."</literal></expr></argument>,
						   <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>YbPgMemAddConsumption</name><argument_list>(<argument><expr><name>headerSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Avoid writing code that can fail between here and MemoryContextCreate;
	 * we'd leak the header if we ereport in this stretch.
	 */</comment>

	<comment type="block">/* Fill in SlabContext-specific header fields */</comment>
	<expr_stmt><expr><name><name>slab</name><operator>-&gt;</operator><name>chunkSize</name></name> <operator>=</operator> <name>chunkSize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slab</name><operator>-&gt;</operator><name>fullChunkSize</name></name> <operator>=</operator> <name>fullChunkSize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slab</name><operator>-&gt;</operator><name>blockSize</name></name> <operator>=</operator> <name>blockSize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slab</name><operator>-&gt;</operator><name>headerSize</name></name> <operator>=</operator> <name>headerSize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slab</name><operator>-&gt;</operator><name>chunksPerBlock</name></name> <operator>=</operator> <name>chunksPerBlock</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slab</name><operator>-&gt;</operator><name>minFreeChunks</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slab</name><operator>-&gt;</operator><name>nblocks</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* initialize the freelist slots */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name><name>slab</name><operator>-&gt;</operator><name>chunksPerBlock</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slab</name><operator>-&gt;</operator><name>freelist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* Finally, do the type-independent part of context creation */</comment>
	<expr_stmt><expr><call><name>MemoryContextCreate</name><argument_list>(<argument><expr><operator>(</operator><name>MemoryContext</name><operator>)</operator> <name>slab</name></expr></argument>,
						<argument><expr><name>T_SlabContext</name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>SlabMethods</name></expr></argument>,
						<argument><expr><name>parent</name></expr></argument>,
						<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>MemoryContext</name><operator>)</operator> <name>slab</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SlabReset
 *		Frees all memory which is allocated in the given set.
 *
 * The code simply frees all the blocks in the context - we don't keep any
 * keeper blocks or anything like that.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SlabReset</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SlabContext</name> <modifier>*</modifier></type><name>slab</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>SlabContext</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MEMORY_CONTEXT_CHECKING</name></cpp:ifdef>
	<comment type="block">/* Check for corruption and leaks before freeing */</comment>
	<expr_stmt><expr><call><name>SlabCheck</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* walk over freelists and free the blocks */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>slab</name><operator>-&gt;</operator><name>chunksPerBlock</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>dlist_mutable_iter</name></type> <name>miter</name></decl>;</decl_stmt>

		<macro><name>dlist_foreach_modify</name><argument_list>(<argument>miter</argument>, <argument>&amp;slab-&gt;freelist[i]</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SlabBlock</name>  <modifier>*</modifier></type><name>block</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>SlabBlock</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>miter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><name><name>miter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CLOBBER_FREED_MEMORY</name></cpp:ifdef>
			<expr_stmt><expr><call><name>wipe_mem</name><argument_list>(<argument><expr><name>block</name></expr></argument>, <argument><expr><name><name>slab</name><operator>-&gt;</operator><name>blockSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<decl_stmt><decl><type><name>size_t</name></type> <name>freed_sz</name> <init>= <expr><name><name>slab</name><operator>-&gt;</operator><name>blockSize</name></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>YbPgMemSubConsumption</name><argument_list>(<argument><expr><name>freed_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>slab</name><operator>-&gt;</operator><name>nblocks</name></name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>slab</name><operator>-&gt;</operator><name>minFreeChunks</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slab</name><operator>-&gt;</operator><name>nblocks</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SlabDelete
 *		Free all memory which is allocated in the given context.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SlabDelete</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Reset to release all the SlabBlocks */</comment>
	<expr_stmt><expr><call><name>SlabReset</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>size_t</name></type> <name>freed_sz</name> <init>= <expr><operator>(</operator><operator>(</operator><name>SlabContext</name> <operator>*</operator><operator>)</operator> <name>context</name><operator>)</operator><operator>-&gt;</operator><name>headerSize</name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* And free the context header */</comment>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>YbPgMemSubConsumption</name><argument_list>(<argument><expr><name>freed_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SlabAlloc
 *		Returns pointer to allocated memory of given size or NULL if
 *		request could not be completed; memory is added to the slab.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>SlabAlloc</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlabContext</name> <modifier>*</modifier></type><name>slab</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>SlabContext</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SlabBlock</name>  <modifier>*</modifier></type><name>block</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SlabChunk</name>  <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>idx</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>slab</name><operator>-&gt;</operator><name>minFreeChunks</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
		   <operator>(</operator><name><name>slab</name><operator>-&gt;</operator><name>minFreeChunks</name></name> <operator>&lt;</operator> <name><name>slab</name><operator>-&gt;</operator><name>chunksPerBlock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* make sure we only allow correct request size */</comment>
	<if_stmt><if>if <condition>(<expr><name>size</name> <operator>!=</operator> <name><name>slab</name><operator>-&gt;</operator><name>chunkSize</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected alloc chunk size %zu (expected %zu)"</literal></expr></argument>,
			 <argument><expr><name>size</name></expr></argument>, <argument><expr><name><name>slab</name><operator>-&gt;</operator><name>chunkSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If there are no free chunks in any existing block, create a new block
	 * and put it to the last freelist bucket.
	 *
	 * slab-&gt;minFreeChunks == 0 means there are no blocks with free chunks,
	 * thanks to how minFreeChunks is updated at the end of SlabAlloc().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>slab</name><operator>-&gt;</operator><name>minFreeChunks</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>block</name> <operator>=</operator> <operator>(</operator><name>SlabBlock</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name><name>slab</name><operator>-&gt;</operator><name>blockSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>block</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>YbPgMemAddConsumption</name><argument_list>(<argument><expr><name><name>slab</name><operator>-&gt;</operator><name>blockSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>nfree</name></name> <operator>=</operator> <name><name>slab</name><operator>-&gt;</operator><name>chunksPerBlock</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>firstFreeChunk</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Put all the chunks on a freelist. Walk the chunks and point each
		 * one to the next one.
		 */</comment>
		<for>for <control>(<init><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name><name>slab</name><operator>-&gt;</operator><name>chunksPerBlock</name></name></expr>;</condition> <incr><expr><name>idx</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>SlabBlockGetChunk</name><argument_list>(<argument><expr><name>slab</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name>int32</name> <operator>*</operator><operator>)</operator> <call><name>SlabChunkGetPointer</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call> <operator>=</operator> <operator>(</operator><name>idx</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * And add it to the last freelist with all chunks empty.
		 *
		 * We know there are no blocks in the freelist, otherwise we wouldn't
		 * need a new block.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slab</name><operator>-&gt;</operator><name>freelist</name><index>[<expr><name><name>slab</name><operator>-&gt;</operator><name>chunksPerBlock</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>dlist_push_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slab</name><operator>-&gt;</operator><name>freelist</name><index>[<expr><name><name>slab</name><operator>-&gt;</operator><name>chunksPerBlock</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>block</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>slab</name><operator>-&gt;</operator><name>minFreeChunks</name></name> <operator>=</operator> <name><name>slab</name><operator>-&gt;</operator><name>chunksPerBlock</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slab</name><operator>-&gt;</operator><name>nblocks</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* grab the block from the freelist (even the new block is there) */</comment>
	<expr_stmt><expr><name>block</name> <operator>=</operator> <call><name>dlist_head_element</name><argument_list>(<argument><expr><name>SlabBlock</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name><name>slab</name><operator>-&gt;</operator><name>freelist</name><index>[<expr><name><name>slab</name><operator>-&gt;</operator><name>minFreeChunks</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* make sure we actually got a valid block, with matching nfree */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>block</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slab</name><operator>-&gt;</operator><name>minFreeChunks</name></name> <operator>==</operator> <name><name>block</name><operator>-&gt;</operator><name>nfree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>nfree</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we know index of the first free chunk in the block */</comment>
	<expr_stmt><expr><name>idx</name> <operator>=</operator> <name><name>block</name><operator>-&gt;</operator><name>firstFreeChunk</name></name></expr>;</expr_stmt>

	<comment type="block">/* make sure the chunk index is valid, and that it's marked as empty */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>idx</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>idx</name> <operator>&lt;</operator> <name><name>slab</name><operator>-&gt;</operator><name>chunksPerBlock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* compute the chunk location block start (after the block header) */</comment>
	<expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>SlabBlockGetChunk</name><argument_list>(<argument><expr><name>slab</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update the block nfree count, and also the minFreeChunks as we've
	 * decreased nfree for a block with the minimum number of free chunks
	 * (because that's how we chose the block).
	 */</comment>
	<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>nfree</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slab</name><operator>-&gt;</operator><name>minFreeChunks</name></name> <operator>=</operator> <name><name>block</name><operator>-&gt;</operator><name>nfree</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Remove the chunk from the freelist head. The index of the next free
	 * chunk is stored in the chunk itself.
	 */</comment>
	<expr_stmt><expr><call><name>VALGRIND_MAKE_MEM_DEFINED</name><argument_list>(<argument><expr><call><name>SlabChunkGetPointer</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>firstFreeChunk</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int32</name> <operator>*</operator><operator>)</operator> <call><name>SlabChunkGetPointer</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>firstFreeChunk</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>firstFreeChunk</name></name> <operator>&lt;=</operator> <name><name>slab</name><operator>-&gt;</operator><name>chunksPerBlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>block</name><operator>-&gt;</operator><name>nfree</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>block</name><operator>-&gt;</operator><name>firstFreeChunk</name></name> <operator>&lt;</operator> <name><name>slab</name><operator>-&gt;</operator><name>chunksPerBlock</name></name><operator>)</operator> <operator>||</operator>
		   <operator>(</operator><name><name>block</name><operator>-&gt;</operator><name>nfree</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>block</name><operator>-&gt;</operator><name>firstFreeChunk</name></name> <operator>==</operator> <name><name>slab</name><operator>-&gt;</operator><name>chunksPerBlock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* move the whole block to the right place in the freelist */</comment>
	<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>block</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dlist_push_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slab</name><operator>-&gt;</operator><name>freelist</name><index>[<expr><name><name>block</name><operator>-&gt;</operator><name>nfree</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>block</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * And finally update minFreeChunks, i.e. the index to the block with the
	 * lowest number of free chunks. We only need to do that when the block
	 * got full (otherwise we know the current block is the right one). We'll
	 * simply walk the freelist until we find a non-empty entry.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>slab</name><operator>-&gt;</operator><name>minFreeChunks</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>idx</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>idx</name> <operator>&lt;=</operator> <name><name>slab</name><operator>-&gt;</operator><name>chunksPerBlock</name></name></expr>;</condition> <incr><expr><name>idx</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slab</name><operator>-&gt;</operator><name>freelist</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* found a non-empty freelist */</comment>
			<expr_stmt><expr><name><name>slab</name><operator>-&gt;</operator><name>minFreeChunks</name></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>slab</name><operator>-&gt;</operator><name>minFreeChunks</name></name> <operator>==</operator> <name><name>slab</name><operator>-&gt;</operator><name>chunksPerBlock</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>slab</name><operator>-&gt;</operator><name>minFreeChunks</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Prepare to initialize the chunk header. */</comment>
	<expr_stmt><expr><call><name>VALGRIND_MAKE_MEM_UNDEFINED</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SlabChunk</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>block</name></name> <operator>=</operator> <name>block</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>slab</name></name> <operator>=</operator> <name>slab</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MEMORY_CONTEXT_CHECKING</name></cpp:ifdef>
	<comment type="block">/* slab mark to catch clobber of "unused" space */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>slab</name><operator>-&gt;</operator><name>chunkSize</name></name> <operator>&lt;</operator> <operator>(</operator><name><name>slab</name><operator>-&gt;</operator><name>fullChunkSize</name></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SlabChunk</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>set_sentinel</name><argument_list>(<argument><expr><call><name>SlabChunkGetPointer</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VALGRIND_MAKE_MEM_NOACCESS</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>chunk</name><operator>)</operator> <operator>+</operator>
								   <sizeof>sizeof<argument_list>(<argument><expr><name>SlabChunk</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>slab</name><operator>-&gt;</operator><name>chunkSize</name></name></expr></argument>,
								   <argument><expr><name><name>slab</name><operator>-&gt;</operator><name>fullChunkSize</name></name> <operator>-</operator>
								   <operator>(</operator><name><name>slab</name><operator>-&gt;</operator><name>chunkSize</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SlabChunk</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RANDOMIZE_ALLOCATED_MEMORY</name></cpp:ifdef>
	<comment type="block">/* fill the allocated space with junk */</comment>
	<expr_stmt><expr><call><name>randomize_mem</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>SlabChunkGetPointer</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>SlabAllocInfo</name><argument_list>(<argument><expr><name>slab</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>SlabChunkGetPointer</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SlabFree
 *		Frees allocated memory; memory is removed from the slab.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SlabFree</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pointer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>idx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SlabContext</name> <modifier>*</modifier></type><name>slab</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>SlabContext</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SlabChunk</name>  <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>SlabPointerGetChunk</name><argument_list>(<argument><expr><name>pointer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SlabBlock</name>  <modifier>*</modifier></type><name>block</name> <init>= <expr><name><name>chunk</name><operator>-&gt;</operator><name>block</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SlabFreeInfo</name><argument_list>(<argument><expr><name>slab</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MEMORY_CONTEXT_CHECKING</name></cpp:ifdef>
	<comment type="block">/* Test for someone scribbling on unused space in chunk */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>slab</name><operator>-&gt;</operator><name>chunkSize</name></name> <operator>&lt;</operator> <operator>(</operator><name><name>slab</name><operator>-&gt;</operator><name>fullChunkSize</name></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SlabChunk</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>sentinel_ok</name><argument_list>(<argument><expr><name>pointer</name></expr></argument>, <argument><expr><name><name>slab</name><operator>-&gt;</operator><name>chunkSize</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"detected write past chunk end in %s %p"</literal></expr></argument>,
				 <argument><expr><name><name>slab</name><operator>-&gt;</operator><name>header</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* compute index of the chunk with respect to block start */</comment>
	<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>SlabChunkIndex</name><argument_list>(<argument><expr><name>slab</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* add chunk to freelist, and update block nfree count */</comment>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><name>int32</name> <operator>*</operator><operator>)</operator> <name>pointer</name> <operator>=</operator> <name><name>block</name><operator>-&gt;</operator><name>firstFreeChunk</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>firstFreeChunk</name></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>nfree</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>nfree</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>nfree</name></name> <operator>&lt;=</operator> <name><name>slab</name><operator>-&gt;</operator><name>chunksPerBlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CLOBBER_FREED_MEMORY</name></cpp:ifdef>
	<comment type="block">/* XXX don't wipe the int32 index, used for block-level freelist */</comment>
	<expr_stmt><expr><call><name>wipe_mem</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>pointer</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			 <argument><expr><name><name>slab</name><operator>-&gt;</operator><name>chunkSize</name></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* remove the block from a freelist */</comment>
	<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>block</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * See if we need to update the minFreeChunks field for the slab - we only
	 * need to do that if there the block had that number of free chunks
	 * before we freed one. In that case, we check if there still are blocks
	 * in the original freelist and we either keep the current value (if there
	 * still are blocks) or increment it by one (the new block is still the
	 * one with minimum free chunks).
	 *
	 * The one exception is when the block will get completely free - in that
	 * case we will free it, se we can't use it for minFreeChunks. It however
	 * means there are no more blocks with free chunks.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>slab</name><operator>-&gt;</operator><name>minFreeChunks</name></name> <operator>==</operator> <operator>(</operator><name><name>block</name><operator>-&gt;</operator><name>nfree</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Have we removed the last chunk from the freelist? */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slab</name><operator>-&gt;</operator><name>freelist</name><index>[<expr><name><name>slab</name><operator>-&gt;</operator><name>minFreeChunks</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* but if we made the block entirely free, we'll free it */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>block</name><operator>-&gt;</operator><name>nfree</name></name> <operator>==</operator> <name><name>slab</name><operator>-&gt;</operator><name>chunksPerBlock</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>slab</name><operator>-&gt;</operator><name>minFreeChunks</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>slab</name><operator>-&gt;</operator><name>minFreeChunks</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If the block is now completely empty, free it. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>block</name><operator>-&gt;</operator><name>nfree</name></name> <operator>==</operator> <name><name>slab</name><operator>-&gt;</operator><name>chunksPerBlock</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type> <name>freed_sz</name> <init>= <expr><name><name>slab</name><operator>-&gt;</operator><name>blockSize</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>YbPgMemSubConsumption</name><argument_list>(<argument><expr><name>freed_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slab</name><operator>-&gt;</operator><name>nblocks</name></name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dlist_push_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slab</name><operator>-&gt;</operator><name>freelist</name><index>[<expr><name><name>block</name><operator>-&gt;</operator><name>nfree</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>block</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slab</name><operator>-&gt;</operator><name>nblocks</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SlabRealloc
 *		Change the allocated size of a chunk.
 *
 * As Slab is designed for allocating equally-sized chunks of memory, it can't
 * do an actual chunk size change.  We try to be gentle and allow calls with
 * exactly the same size, as in that case we can simply return the same
 * chunk.  When the size differs, we throw an error.
 *
 * We could also allow requests with size &lt; chunkSize.  That however seems
 * rather pointless - Slab is meant for chunks of constant size, and moreover
 * realloc is usually used to enlarge the chunk.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>SlabRealloc</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pointer</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlabContext</name> <modifier>*</modifier></type><name>slab</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>SlabContext</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* can't do actual realloc with slab, but let's try to be gentle */</comment>
	<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <name><name>slab</name><operator>-&gt;</operator><name>chunkSize</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>pointer</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"slab allocator does not support realloc()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>				<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * SlabGetChunkSpace
 *		Given a currently-allocated chunk, determine the total space
 *		it occupies (including all memory-allocation overhead).
 */</comment>
<function><type><specifier>static</specifier> <name>Size</name></type>
<name>SlabGetChunkSpace</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pointer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlabContext</name> <modifier>*</modifier></type><name>slab</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>SlabContext</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>slab</name><operator>-&gt;</operator><name>fullChunkSize</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SlabIsEmpty
 *		Is an Slab empty of any allocated space?
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>SlabIsEmpty</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlabContext</name> <modifier>*</modifier></type><name>slab</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>SlabContext</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name><name>slab</name><operator>-&gt;</operator><name>nblocks</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SlabStats
 *		Compute stats about memory consumption of a Slab context.
 *
 * printfunc: if not NULL, pass a human-readable stats string to this.
 * passthru: pass this pointer through to printfunc.
 * totals: if not NULL, add stats about this context into *totals.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SlabStats</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>,
		  <parameter><decl><type><name>MemoryStatsPrintFunc</name></type> <name>printfunc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>passthru</name></decl></parameter>,
		  <parameter><decl><type><name>MemoryContextCounters</name> <modifier>*</modifier></type><name>totals</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlabContext</name> <modifier>*</modifier></type><name>slab</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>SlabContext</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>nblocks</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>freechunks</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>totalspace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>freespace</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Include context header in totalspace */</comment>
	<expr_stmt><expr><name>totalspace</name> <operator>=</operator> <name><name>slab</name><operator>-&gt;</operator><name>headerSize</name></name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>slab</name><operator>-&gt;</operator><name>chunksPerBlock</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>dlist_iter</name></type>	<name>iter</name></decl>;</decl_stmt>

		<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;slab-&gt;freelist[i]</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SlabBlock</name>  <modifier>*</modifier></type><name>block</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>SlabBlock</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>nblocks</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>totalspace</name> <operator>+=</operator> <name><name>slab</name><operator>-&gt;</operator><name>blockSize</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>freespace</name> <operator>+=</operator> <name><name>slab</name><operator>-&gt;</operator><name>fullChunkSize</name></name> <operator>*</operator> <name><name>block</name><operator>-&gt;</operator><name>nfree</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>freechunks</name> <operator>+=</operator> <name><name>block</name><operator>-&gt;</operator><name>nfree</name></name></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>printfunc</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>stats_string</name><index>[<expr><literal type="number">200</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>stats_string</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>stats_string</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><literal type="string">"%zu total in %zd blocks; %zu free (%zd chunks); %zu used"</literal></expr></argument>,
				 <argument><expr><name>totalspace</name></expr></argument>, <argument><expr><name>nblocks</name></expr></argument>, <argument><expr><name>freespace</name></expr></argument>, <argument><expr><name>freechunks</name></expr></argument>,
				 <argument><expr><name>totalspace</name> <operator>-</operator> <name>freespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printfunc</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>passthru</name></expr></argument>, <argument><expr><name>stats_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>totals</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>totals</name><operator>-&gt;</operator><name>nblocks</name></name> <operator>+=</operator> <name>nblocks</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>totals</name><operator>-&gt;</operator><name>freechunks</name></name> <operator>+=</operator> <name>freechunks</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>totals</name><operator>-&gt;</operator><name>totalspace</name></name> <operator>+=</operator> <name>totalspace</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>totals</name><operator>-&gt;</operator><name>freespace</name></name> <operator>+=</operator> <name>freespace</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MEMORY_CONTEXT_CHECKING</name></cpp:ifdef>

<comment type="block">/*
 * SlabCheck
 *		Walk through chunks and check consistency of memory.
 *
 * NOTE: report errors as WARNING, *not* ERROR or FATAL.  Otherwise you'll
 * find yourself in an infinite loop when trouble occurs, because this
 * routine will be entered again when elog cleanup tries to release memory!
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SlabCheck</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SlabContext</name> <modifier>*</modifier></type><name>slab</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>SlabContext</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>slab</name><operator>-&gt;</operator><name>header</name><operator>.</operator><name>name</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>freechunks</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slab</name><operator>-&gt;</operator><name>chunksPerBlock</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* bitmap of free chunks on a block */</comment>
	<expr_stmt><expr><name>freechunks</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>slab</name><operator>-&gt;</operator><name>chunksPerBlock</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* walk all the freelists */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>slab</name><operator>-&gt;</operator><name>chunksPerBlock</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>,
					<decl><type ref="prev"/><name>nfree</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>dlist_iter</name></type>	<name>iter</name></decl>;</decl_stmt>

		<comment type="block">/* walk all blocks on this freelist */</comment>
		<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;slab-&gt;freelist[i]</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>idx</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>SlabBlock</name>  <modifier>*</modifier></type><name>block</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>SlabBlock</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Make sure the number of free chunks (in the block header)
			 * matches position in the freelist.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>block</name><operator>-&gt;</operator><name>nfree</name></name> <operator>!=</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"problem in slab %s: number of free chunks %d in block %p does not match freelist %d"</literal></expr></argument>,
					 <argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>block</name><operator>-&gt;</operator><name>nfree</name></name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* reset the bitmap of free chunks for this block */</comment>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>freechunks</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name><name>slab</name><operator>-&gt;</operator><name>chunksPerBlock</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>idx</name> <operator>=</operator> <name><name>block</name><operator>-&gt;</operator><name>firstFreeChunk</name></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Now walk through the chunks, count the free ones and also
			 * perform some additional checks for the used ones. As the chunk
			 * freelist is stored within the chunks themselves, we have to
			 * walk through the chunks and construct our own bitmap.
			 */</comment>

			<expr_stmt><expr><name>nfree</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<while>while <condition>(<expr><name>idx</name> <operator>&lt;</operator> <name><name>slab</name><operator>-&gt;</operator><name>chunksPerBlock</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SlabChunk</name>  <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>

				<comment type="block">/* count the chunk as free, add it to the bitmap */</comment>
				<expr_stmt><expr><name>nfree</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>freechunks</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<comment type="block">/* read index of the next free chunk */</comment>
				<expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>SlabBlockGetChunk</name><argument_list>(<argument><expr><name>slab</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>VALGRIND_MAKE_MEM_DEFINED</name><argument_list>(<argument><expr><call><name>SlabChunkGetPointer</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>idx</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int32</name> <operator>*</operator><operator>)</operator> <call><name>SlabChunkGetPointer</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></while>

			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>slab</name><operator>-&gt;</operator><name>chunksPerBlock</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<comment type="block">/* non-zero bit in the bitmap means chunk the chunk is used */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>freechunks</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>SlabChunk</name>  <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>SlabBlockGetChunk</name><argument_list>(<argument><expr><name>slab</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<comment type="block">/* chunks have both block and slab pointers, so check both */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>chunk</name><operator>-&gt;</operator><name>block</name></name> <operator>!=</operator> <name>block</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"problem in slab %s: bogus block link in block %p, chunk %p"</literal></expr></argument>,
							 <argument><expr><name>name</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>chunk</name><operator>-&gt;</operator><name>slab</name></name> <operator>!=</operator> <name>slab</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"problem in slab %s: bogus slab link in block %p, chunk %p"</literal></expr></argument>,
							 <argument><expr><name>name</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/* there might be sentinel (thanks to alignment) */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>slab</name><operator>-&gt;</operator><name>chunkSize</name></name> <operator>&lt;</operator> <operator>(</operator><name><name>slab</name><operator>-&gt;</operator><name>fullChunkSize</name></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SlabChunk</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>sentinel_ok</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name><name>slab</name><operator>-&gt;</operator><name>chunkSize</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"problem in slab %s: detected write past chunk end in block %p, chunk %p"</literal></expr></argument>,
								 <argument><expr><name>name</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

			<comment type="block">/*
			 * Make sure we got the expected number of free chunks (as tracked
			 * in the block header).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>nfree</name> <operator>!=</operator> <name><name>block</name><operator>-&gt;</operator><name>nfree</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"problem in slab %s: number of free chunks %d in block %p does not match bitmap %d"</literal></expr></argument>,
					 <argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>block</name><operator>-&gt;</operator><name>nfree</name></name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>nfree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></for>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* MEMORY_CONTEXT_CHECKING */</comment>
</unit>
