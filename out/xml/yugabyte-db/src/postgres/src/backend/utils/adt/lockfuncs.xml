<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/utils/adt/lockfuncs.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * lockfuncs.c
 *		Functions for SQL access to various lock-manager capabilities.
 *
 * Copyright (c) 2002-2018, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *		src/backend/utils/adt/lockfuncs.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate_internals.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>


<comment type="block">/* This must match enum LockTagType! */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>LockTagTypeNames</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="string">"relation"</literal></expr>,
	<expr><literal type="string">"extend"</literal></expr>,
	<expr><literal type="string">"page"</literal></expr>,
	<expr><literal type="string">"tuple"</literal></expr>,
	<expr><literal type="string">"transactionid"</literal></expr>,
	<expr><literal type="string">"virtualxid"</literal></expr>,
	<expr><literal type="string">"speculative token"</literal></expr>,
	<expr><literal type="string">"object"</literal></expr>,
	<expr><literal type="string">"userlock"</literal></expr>,
	<expr><literal type="string">"advisory"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* This must match enum PredicateLockTargetType (predicate_internals.h) */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>PredicateLockTagTypeNames</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="string">"relation"</literal></expr>,
	<expr><literal type="string">"page"</literal></expr>,
	<expr><literal type="string">"tuple"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Working status for pg_lock_status */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>LockData</name>   <modifier>*</modifier></type><name>lockData</name></decl>;</decl_stmt>		<comment type="block">/* state data from lmgr */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>currIdx</name></decl>;</decl_stmt>		<comment type="block">/* current PROCLOCK index */</comment>
	<decl_stmt><decl><type><name>PredicateLockData</name> <modifier>*</modifier></type><name>predLockData</name></decl>;</decl_stmt>	<comment type="block">/* state data for pred locks */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>predLockIdx</name></decl>;</decl_stmt>	<comment type="block">/* current index for pred lock */</comment>
}</block></struct></type> <name>PG_Lock_Status</name>;</typedef>

<comment type="block">/* Number of columns in pg_locks output */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_LOCK_STATUS_COLUMNS</name></cpp:macro>		<cpp:value>15</cpp:value></cpp:define>

<comment type="block">/*
 * VXIDGetDatum - Construct a text representation of a VXID
 *
 * This is currently only used in pg_lock_status, so we put it here.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>VXIDGetDatum</name><parameter_list>(<parameter><decl><type><name>BackendId</name></type> <name>bid</name></decl></parameter>, <parameter><decl><type><name>LocalTransactionId</name></type> <name>lxid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * The representation is "&lt;bid&gt;/&lt;lxid&gt;", decimal and unsigned decimal
	 * respectively.  Note that elog.c also knows how to format a vxid.
	 */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>vxidstr</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>vxidstr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>vxidstr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d/%u"</literal></expr></argument>, <argument><expr><name>bid</name></expr></argument>, <argument><expr><name>lxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>vxidstr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * pg_lock_status - produce a view with one row per held or awaited lock mode
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_lock_status</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PG_Lock_Status</name> <modifier>*</modifier></type><name>mystatus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockData</name>   <modifier>*</modifier></type><name>lockData</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PredicateLockData</name> <modifier>*</modifier></type><name>predLockData</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

		<comment type="block">/* create a function context for cross-call persistence */</comment>
		<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * switch to memory context appropriate for multiple function calls
		 */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* build tupdesc for result tuples */</comment>
		<comment type="block">/* this had better match function's declaration in pg_proc.h */</comment>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>NUM_LOCK_STATUS_COLUMNS</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"locktype"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"database"</literal></expr></argument>,
						   <argument><expr><name>OIDOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"relation"</literal></expr></argument>,
						   <argument><expr><name>OIDOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"page"</literal></expr></argument>,
						   <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"tuple"</literal></expr></argument>,
						   <argument><expr><name>INT2OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"virtualxid"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"transactionid"</literal></expr></argument>,
						   <argument><expr><name>XIDOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><literal type="string">"classid"</literal></expr></argument>,
						   <argument><expr><name>OIDOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">9</literal></expr></argument>, <argument><expr><literal type="string">"objid"</literal></expr></argument>,
						   <argument><expr><name>OIDOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">10</literal></expr></argument>, <argument><expr><literal type="string">"objsubid"</literal></expr></argument>,
						   <argument><expr><name>INT2OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">11</literal></expr></argument>, <argument><expr><literal type="string">"virtualtransaction"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">12</literal></expr></argument>, <argument><expr><literal type="string">"pid"</literal></expr></argument>,
						   <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">13</literal></expr></argument>, <argument><expr><literal type="string">"mode"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">14</literal></expr></argument>, <argument><expr><literal type="string">"granted"</literal></expr></argument>,
						   <argument><expr><name>BOOLOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">15</literal></expr></argument>, <argument><expr><literal type="string">"fastpath"</literal></expr></argument>,
						   <argument><expr><name>BOOLOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Collect all the locking information that we will format and send
		 * out as a result set.
		 */</comment>
		<expr_stmt><expr><name>mystatus</name> <operator>=</operator> <operator>(</operator><name>PG_Lock_Status</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PG_Lock_Status</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>mystatus</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>mystatus</name><operator>-&gt;</operator><name>lockData</name></name> <operator>=</operator> <call><name>GetLockStatusData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mystatus</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mystatus</name><operator>-&gt;</operator><name>predLockData</name></name> <operator>=</operator> <call><name>GetPredicateLockStatusData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mystatus</name><operator>-&gt;</operator><name>predLockIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mystatus</name> <operator>=</operator> <operator>(</operator><name>PG_Lock_Status</name> <operator>*</operator><operator>)</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lockData</name> <operator>=</operator> <name><name>mystatus</name><operator>-&gt;</operator><name>lockData</name></name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name><name>mystatus</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>&lt;</operator> <name><name>lockData</name><operator>-&gt;</operator><name>nelements</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>granted</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>mode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>locktypename</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>tnbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>NUM_LOCK_STATUS_COLUMNS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>NUM_LOCK_STATUS_COLUMNS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LockInstanceData</name> <modifier>*</modifier></type><name>instance</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>instance</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>lockData</name><operator>-&gt;</operator><name>locks</name><index>[<expr><name><name>mystatus</name><operator>-&gt;</operator><name>currIdx</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Look to see if there are any held lock modes in this PROCLOCK. If
		 * so, report, and destructively modify lockData so we don't report
		 * again.
		 */</comment>
		<expr_stmt><expr><name>granted</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>instance</name><operator>-&gt;</operator><name>holdMask</name></name></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>mode</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>mode</name> <operator>&lt;</operator> <name>MAX_LOCKMODES</name></expr>;</condition> <incr><expr><name>mode</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>instance</name><operator>-&gt;</operator><name>holdMask</name></name> <operator>&amp;</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>granted</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>holdMask</name></name> <operator>&amp;=</operator> <call><name>LOCKBIT_OFF</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If no (more) held modes to report, see if PROC is waiting for a
		 * lock on this lock.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>granted</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>instance</name><operator>-&gt;</operator><name>waitLockMode</name></name> <operator>!=</operator> <name>NoLock</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Yes, so report it with proper mode */</comment>
				<expr_stmt><expr><name>mode</name> <operator>=</operator> <name><name>instance</name><operator>-&gt;</operator><name>waitLockMode</name></name></expr>;</expr_stmt>

				<comment type="block">/*
				 * We are now done with this PROCLOCK, so advance pointer to
				 * continue with next one on next call.
				 */</comment>
				<expr_stmt><expr><name><name>mystatus</name><operator>-&gt;</operator><name>currIdx</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Okay, we've displayed all the locks associated with this
				 * PROCLOCK, proceed to the next one.
				 */</comment>
				<expr_stmt><expr><name><name>mystatus</name><operator>-&gt;</operator><name>currIdx</name></name><operator>++</operator></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Form tuple with appropriate data.
		 */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_type</name></name> <operator>&lt;=</operator> <name>LOCKTAG_LAST_TYPE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>locktypename</name> <operator>=</operator> <name><name>LockTagTypeNames</name><index>[<expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_type</name></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tnbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tnbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"unknown %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>locktypename</name> <operator>=</operator> <name>tnbuf</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>locktypename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><operator>(</operator><name>LockTagType</name><operator>)</operator> <name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_type</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>LOCKTAG_RELATION</name></expr>:</case>
			<case>case <expr><name>LOCKTAG_RELATION_EXTEND</name></expr>:</case>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_field1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_field2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>LOCKTAG_PAGE</name></expr>:</case>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_field1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_field2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt32GetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_field3</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>LOCKTAG_TUPLE</name></expr>:</case>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_field1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_field2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt32GetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_field3</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt16GetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_field4</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>LOCKTAG_TRANSACTION</name></expr>:</case>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator>
					<call><name>TransactionIdGetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_field1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>LOCKTAG_VIRTUALTRANSACTION</name></expr>:</case>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>VXIDGetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_field1</name></name></expr></argument>,
										 <argument><expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_field2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>LOCKTAG_OBJECT</name></expr>:</case>
			<case>case <expr><name>LOCKTAG_USERLOCK</name></expr>:</case>
			<case>case <expr><name>LOCKTAG_ADVISORY</name></expr>:</case>
			<default>default:</default>			<comment type="block">/* treat unknown locktags like OBJECT */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_field1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_field2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_field3</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <call><name>Int16GetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_field4</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <call><name>VXIDGetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>backend</name></name></expr></argument>, <argument><expr><name><name>instance</name><operator>-&gt;</operator><name>lxid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>instance</name><operator>-&gt;</operator><name>pid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>GetLockmodeName</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name><operator>.</operator><name>locktag_lockmethodid</name></name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>granted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">14</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>fastpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Have returned all regular locks. Now start on the SIREAD predicate
	 * locks.
	 */</comment>
	<expr_stmt><expr><name>predLockData</name> <operator>=</operator> <name><name>mystatus</name><operator>-&gt;</operator><name>predLockData</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>mystatus</name><operator>-&gt;</operator><name>predLockIdx</name></name> <operator>&lt;</operator> <name><name>predLockData</name><operator>-&gt;</operator><name>nelements</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PredicateLockTargetType</name></type> <name>lockType</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>PREDICATELOCKTARGETTAG</name> <modifier>*</modifier></type><name>predTag</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>predLockData</name><operator>-&gt;</operator><name>locktags</name><index>[<expr><name><name>mystatus</name><operator>-&gt;</operator><name>predLockIdx</name></name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SERIALIZABLEXACT</name> <modifier>*</modifier></type><name>xact</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>predLockData</name><operator>-&gt;</operator><name>xacts</name><index>[<expr><name><name>mystatus</name><operator>-&gt;</operator><name>predLockIdx</name></name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>NUM_LOCK_STATUS_COLUMNS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>NUM_LOCK_STATUS_COLUMNS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>mystatus</name><operator>-&gt;</operator><name>predLockIdx</name></name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Form tuple with appropriate data.
		 */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* lock type */</comment>
		<expr_stmt><expr><name>lockType</name> <operator>=</operator> <call><name>GET_PREDICATELOCKTARGETTAG_TYPE</name><argument_list>(<argument><expr><operator>*</operator><name>predTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>PredicateLockTagTypeNames</name><index>[<expr><name>lockType</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* lock target */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>GET_PREDICATELOCKTARGETTAG_DB</name><argument_list>(<argument><expr><operator>*</operator><name>predTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>GET_PREDICATELOCKTARGETTAG_RELATION</name><argument_list>(<argument><expr><operator>*</operator><name>predTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>lockType</name> <operator>==</operator> <name>PREDLOCKTAG_TUPLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>GET_PREDICATELOCKTARGETTAG_OFFSET</name><argument_list>(<argument><expr><operator>*</operator><name>predTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>lockType</name> <operator>==</operator> <name>PREDLOCKTAG_TUPLE</name><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name>lockType</name> <operator>==</operator> <name>PREDLOCKTAG_PAGE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>GET_PREDICATELOCKTARGETTAG_PAGE</name><argument_list>(<argument><expr><operator>*</operator><name>predTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* these fields are targets for other types of locks */</comment>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>		<comment type="block">/* virtualxid */</comment>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>		<comment type="block">/* transactionid */</comment>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>		<comment type="block">/* classid */</comment>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>		<comment type="block">/* objid */</comment>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>		<comment type="block">/* objsubid */</comment>

		<comment type="block">/* lock holder */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <call><name>VXIDGetDatum</name><argument_list>(<argument><expr><name><name>xact</name><operator>-&gt;</operator><name>vxid</name><operator>.</operator><name>backendId</name></name></expr></argument>,
								  <argument><expr><name><name>xact</name><operator>-&gt;</operator><name>vxid</name><operator>.</operator><name>localTransactionId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>xact</name><operator>-&gt;</operator><name>pid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>xact</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * Lock mode. Currently all predicate locks are SIReadLocks, which are
		 * always held (never waiting) and have no fast path
		 */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><literal type="string">"SIReadLock"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">14</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * pg_blocking_pids - produce an array of the PIDs blocking given PID
 *
 * The reported PIDs are those that hold a lock conflicting with blocked_pid's
 * current request (hard block), or are requesting such a lock and are ahead
 * of blocked_pid in the lock's wait queue (soft block).
 *
 * In parallel-query cases, we report all PIDs blocking any member of the
 * given PID's lock group, and the reported PIDs are those of the blocking
 * PIDs' lock group leaders.  This allows callers to compare the result to
 * lists of clients' pg_backend_pid() results even during a parallel query.
 *
 * Parallel query makes it possible for there to be duplicate PIDs in the
 * result (either because multiple waiters are blocked by same PID, or
 * because multiple blockers have same group leader PID).  We do not bother
 * to eliminate such duplicates from the result.
 *
 * We need not consider predicate locks here, since those don't block anything.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_blocking_pids</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>blocked_pid</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>arrayelems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>narrayelems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockedProcsData</name> <modifier>*</modifier></type><name>lockData</name></decl>;</decl_stmt> <comment type="block">/* state data from lmgr */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<comment type="block">/* Collect a snapshot of lock manager state */</comment>
	<expr_stmt><expr><name>lockData</name> <operator>=</operator> <call><name>GetBlockerStatusData</name><argument_list>(<argument><expr><name>blocked_pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We can't need more output entries than there are reported PROCLOCKs */</comment>
	<expr_stmt><expr><name>arrayelems</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>lockData</name><operator>-&gt;</operator><name>nlocks</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>narrayelems</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* For each blocked proc in the lock group ... */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>lockData</name><operator>-&gt;</operator><name>nprocs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BlockedProcData</name> <modifier>*</modifier></type><name>bproc</name> <init>= <expr><operator>&amp;</operator><name><name>lockData</name><operator>-&gt;</operator><name>procs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LockInstanceData</name> <modifier>*</modifier></type><name>instances</name> <init>= <expr><operator>&amp;</operator><name><name>lockData</name><operator>-&gt;</operator><name>locks</name><index>[<expr><name><name>bproc</name><operator>-&gt;</operator><name>first_lock</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>preceding_waiters</name> <init>= <expr><operator>&amp;</operator><name><name>lockData</name><operator>-&gt;</operator><name>waiter_pids</name><index>[<expr><name><name>bproc</name><operator>-&gt;</operator><name>first_waiter</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LockInstanceData</name> <modifier>*</modifier></type><name>blocked_instance</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LockMethod</name></type>	<name>lockMethodTable</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>conflictMask</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Locate the blocked proc's own entry in the LockInstanceData array.
		 * There should be exactly one matching entry.
		 */</comment>
		<expr_stmt><expr><name>blocked_instance</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>bproc</name><operator>-&gt;</operator><name>num_locks</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>LockInstanceData</name> <modifier>*</modifier></type><name>instance</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>instances</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>instance</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <name><name>bproc</name><operator>-&gt;</operator><name>pid</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>blocked_instance</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>blocked_instance</name> <operator>=</operator> <name>instance</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>blocked_instance</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>lockMethodTable</name> <operator>=</operator> <call><name>GetLockTagsMethodTable</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>blocked_instance</name><operator>-&gt;</operator><name>locktag</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>conflictMask</name> <operator>=</operator> <name><name>lockMethodTable</name><operator>-&gt;</operator><name>conflictTab</name><index>[<expr><name><name>blocked_instance</name><operator>-&gt;</operator><name>waitLockMode</name></name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/* Now scan the PROCLOCK data for conflicting procs */</comment>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>bproc</name><operator>-&gt;</operator><name>num_locks</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>LockInstanceData</name> <modifier>*</modifier></type><name>instance</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>instances</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

			<comment type="block">/* A proc never blocks itself, so ignore that entry */</comment>
			<if_stmt><if>if <condition>(<expr><name>instance</name> <operator>==</operator> <name>blocked_instance</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<comment type="block">/* Members of same lock group never block each other, either */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>instance</name><operator>-&gt;</operator><name>leaderPid</name></name> <operator>==</operator> <name><name>blocked_instance</name><operator>-&gt;</operator><name>leaderPid</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>conflictMask</name> <operator>&amp;</operator> <name><name>instance</name><operator>-&gt;</operator><name>holdMask</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* hard block: blocked by lock already held by this entry */</comment>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>instance</name><operator>-&gt;</operator><name>waitLockMode</name></name> <operator>!=</operator> <name>NoLock</name> <operator>&amp;&amp;</operator>
					 <operator>(</operator><name>conflictMask</name> <operator>&amp;</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>waitLockMode</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* conflict in lock requests; who's in front in wait queue? */</comment>
				<decl_stmt><decl><type><name>bool</name></type>		<name>ahead</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>k</name></decl>;</decl_stmt>

				<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>bproc</name><operator>-&gt;</operator><name>num_waiters</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>preceding_waiters</name><index>[<expr><name>k</name></expr>]</index></name> <operator>==</operator> <name><name>instance</name><operator>-&gt;</operator><name>pid</name></name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* soft block: this entry is ahead of blocked proc */</comment>
						<expr_stmt><expr><name>ahead</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ahead</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>	<comment type="block">/* not blocked by this entry */</comment>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* not blocked by this entry */</comment>
				<continue>continue;</continue>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* blocked by this entry, so emit a record */</comment>
			<expr_stmt><expr><name><name>arrayelems</name><index>[<expr><name>narrayelems</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>leaderPid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<comment type="block">/* Assert we didn't overrun arrayelems[] */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>narrayelems</name> <operator>&lt;=</operator> <name><name>lockData</name><operator>-&gt;</operator><name>nlocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Construct array, using hardwired knowledge about int4 type */</comment>
	<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><call><name>construct_array</name><argument_list>(<argument><expr><name>arrayelems</name></expr></argument>, <argument><expr><name>narrayelems</name></expr></argument>,
										  <argument><expr><name>INT4OID</name></expr></argument>,
										  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * pg_safe_snapshot_blocking_pids - produce an array of the PIDs blocking
 * given PID from getting a safe snapshot
 *
 * XXX this does not consider parallel-query cases; not clear how big a
 * problem that is in practice
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_safe_snapshot_blocking_pids</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>blocked_pid</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>blockers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_blockers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>blocker_datums</name></decl>;</decl_stmt>

	<comment type="block">/* A buffer big enough for any possible blocker list without truncation */</comment>
	<expr_stmt><expr><name>blockers</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>MaxBackends</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Collect a snapshot of processes waited for by GetSafeSnapshot */</comment>
	<expr_stmt><expr><name>num_blockers</name> <operator>=</operator>
		<call><name>GetSafeSnapshotBlockingPids</name><argument_list>(<argument><expr><name>blocked_pid</name></expr></argument>, <argument><expr><name>blockers</name></expr></argument>, <argument><expr><name>MaxBackends</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Convert int array to Datum array */</comment>
	<if_stmt><if>if <condition>(<expr><name>num_blockers</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>blocker_datums</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_blockers</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_blockers</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>blocker_datums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>blockers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>blocker_datums</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Construct array, using hardwired knowledge about int4 type */</comment>
	<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><call><name>construct_array</name><argument_list>(<argument><expr><name>blocker_datums</name></expr></argument>, <argument><expr><name>num_blockers</name></expr></argument>,
										  <argument><expr><name>INT4OID</name></expr></argument>,
										  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * pg_isolation_test_session_is_blocked - support function for isolationtester
 *
 * Check if specified PID is blocked by any of the PIDs listed in the second
 * argument.  Currently, this looks for blocking caused by waiting for
 * heavyweight locks or safe snapshots.  We ignore blockage caused by PIDs
 * not directly under the isolationtester's control, eg autovacuum.
 *
 * This is an undocumented function intended for use by the isolation tester,
 * and may change in future releases as required for testing purposes.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_isolation_test_session_is_blocked</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>blocked_pid</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>interesting_pids_a</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>blocking_pids_a</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name>	   <modifier>*</modifier></type><name>interesting_pids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name>	   <modifier>*</modifier></type><name>blocking_pids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_interesting_pids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_blocking_pids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dummy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<comment type="block">/* Validate the passed-in array */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>interesting_pids_a</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>INT4OID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>array_contains_nulls</name><argument_list>(<argument><expr><name>interesting_pids_a</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"array must not contain nulls"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>interesting_pids</name> <operator>=</operator> <operator>(</operator><name>int32</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>interesting_pids_a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_interesting_pids</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>interesting_pids_a</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>interesting_pids_a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get the PIDs of all sessions blocking the given session's attempt to
	 * acquire heavyweight locks.
	 */</comment>
	<expr_stmt><expr><name>blocking_pids_a</name> <operator>=</operator>
		<call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>pg_blocking_pids</name></expr></argument>, <argument><expr><name>blocked_pid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>blocking_pids_a</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>INT4OID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>array_contains_nulls</name><argument_list>(<argument><expr><name>blocking_pids_a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>blocking_pids</name> <operator>=</operator> <operator>(</operator><name>int32</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>blocking_pids_a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_blocking_pids</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>blocking_pids_a</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>blocking_pids_a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check if any of these are in the list of interesting PIDs, that being
	 * the sessions that the isolation tester is running.  We don't use
	 * "arrayoverlaps" here, because it would lead to cache lookups and one of
	 * our goals is to run quickly under CLOBBER_CACHE_ALWAYS.  We expect
	 * blocking_pids to be usually empty and otherwise a very small number in
	 * isolation tester cases, so make that the outer loop of a naive search
	 * for a match.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_blocking_pids</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>num_interesting_pids</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>blocking_pids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name><name>interesting_pids</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for></block_content></block></for>

	<comment type="block">/*
	 * Check if blocked_pid is waiting for a safe snapshot.  We could in
	 * theory check the resulting array of blocker PIDs against the
	 * interesting PIDs whitelist, but since there is no danger of autovacuum
	 * blocking GetSafeSnapshot there seems to be no point in expending cycles
	 * on allocating a buffer and searching for overlap; so it's presently
	 * sufficient for the isolation tester's purposes to use a single element
	 * buffer and check if the number of safe snapshot blockers is non-zero.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>GetSafeSnapshotBlockingPids</name><argument_list>(<argument><expr><name>blocked_pid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Functions for manipulating advisory locks
 *
 * We make use of the locktag fields as follows:
 *
 *	field1: MyDatabaseId ... ensures locks are local to each database
 *	field2: first of 2 int4 keys, or high-order half of an int8 key
 *	field3: second of 2 int4 keys, or low-order half of an int8 key
 *	field4: 1 if using an int8 key, 2 if using 2 int4 keys
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_LOCKTAG_INT64</name><parameter_list>(<parameter><type><name>tag</name></type></parameter>, <parameter><type><name>key64</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>SET_LOCKTAG_ADVISORY(tag, \
						 MyDatabaseId, \
						 (uint32) ((key64) &gt;&gt; 32), \
						 (uint32) (key64), \
						 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_LOCKTAG_INT32</name><parameter_list>(<parameter><type><name>tag</name></type></parameter>, <parameter><type><name>key1</name></type></parameter>, <parameter><type><name>key2</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>SET_LOCKTAG_ADVISORY(tag, MyDatabaseId, key1, key2, 2)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>PreventAdvisoryLocksInParallelMode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TRANSACTION_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use advisory locks during a parallel operation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_advisory_lock(int8) - acquire exclusive lock on an int8 key
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_advisory_lock_int8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>		<name>key</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_LOCKTAG_INT64</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_advisory_xact_lock(int8) - acquire xact scoped
 * exclusive lock on an int8 key
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_advisory_xact_lock_int8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>		<name>key</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_LOCKTAG_INT64</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_advisory_lock_shared(int8) - acquire share lock on an int8 key
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_advisory_lock_shared_int8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>		<name>key</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_LOCKTAG_INT64</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_advisory_xact_lock_shared(int8) - acquire xact scoped
 * share lock on an int8 key
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_advisory_xact_lock_shared_int8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>		<name>key</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_LOCKTAG_INT64</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_try_advisory_lock(int8) - acquire exclusive lock on an int8 key, no wait
 *
 * Returns true if successful, false if lock not available
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_try_advisory_lock_int8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>		<name>key</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockAcquireResult</name></type> <name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_LOCKTAG_INT64</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name> <operator>!=</operator> <name>LOCKACQUIRE_NOT_AVAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_try_advisory_xact_lock(int8) - acquire xact scoped
 * exclusive lock on an int8 key, no wait
 *
 * Returns true if successful, false if lock not available
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_try_advisory_xact_lock_int8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>		<name>key</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockAcquireResult</name></type> <name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_LOCKTAG_INT64</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name> <operator>!=</operator> <name>LOCKACQUIRE_NOT_AVAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_try_advisory_lock_shared(int8) - acquire share lock on an int8 key, no wait
 *
 * Returns true if successful, false if lock not available
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_try_advisory_lock_shared_int8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>		<name>key</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockAcquireResult</name></type> <name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_LOCKTAG_INT64</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name> <operator>!=</operator> <name>LOCKACQUIRE_NOT_AVAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_try_advisory_xact_lock_shared(int8) - acquire xact scoped
 * share lock on an int8 key, no wait
 *
 * Returns true if successful, false if lock not available
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_try_advisory_xact_lock_shared_int8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>		<name>key</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockAcquireResult</name></type> <name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_LOCKTAG_INT64</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name> <operator>!=</operator> <name>LOCKACQUIRE_NOT_AVAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_advisory_unlock(int8) - release exclusive lock on an int8 key
 *
 * Returns true if successful, false if lock was not held
*/</comment>
<function><type><name>Datum</name></type>
<name>pg_advisory_unlock_int8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>		<name>key</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_LOCKTAG_INT64</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>LockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_advisory_unlock_shared(int8) - release share lock on an int8 key
 *
 * Returns true if successful, false if lock was not held
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_advisory_unlock_shared_int8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>		<name>key</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_LOCKTAG_INT64</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>LockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_advisory_lock(int4, int4) - acquire exclusive lock on 2 int4 keys
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_advisory_lock_int4</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>key1</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>key2</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_LOCKTAG_INT32</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_advisory_xact_lock(int4, int4) - acquire xact scoped
 * exclusive lock on 2 int4 keys
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_advisory_xact_lock_int4</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>key1</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>key2</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_LOCKTAG_INT32</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_advisory_lock_shared(int4, int4) - acquire share lock on 2 int4 keys
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_advisory_lock_shared_int4</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>key1</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>key2</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_LOCKTAG_INT32</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_advisory_xact_lock_shared(int4, int4) - acquire xact scoped
 * share lock on 2 int4 keys
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_advisory_xact_lock_shared_int4</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>key1</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>key2</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_LOCKTAG_INT32</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_try_advisory_lock(int4, int4) - acquire exclusive lock on 2 int4 keys, no wait
 *
 * Returns true if successful, false if lock not available
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_try_advisory_lock_int4</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>key1</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>key2</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockAcquireResult</name></type> <name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_LOCKTAG_INT32</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name> <operator>!=</operator> <name>LOCKACQUIRE_NOT_AVAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_try_advisory_xact_lock(int4, int4) - acquire xact scoped
 * exclusive lock on 2 int4 keys, no wait
 *
 * Returns true if successful, false if lock not available
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_try_advisory_xact_lock_int4</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>key1</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>key2</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockAcquireResult</name></type> <name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_LOCKTAG_INT32</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name> <operator>!=</operator> <name>LOCKACQUIRE_NOT_AVAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_try_advisory_lock_shared(int4, int4) - acquire share lock on 2 int4 keys, no wait
 *
 * Returns true if successful, false if lock not available
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_try_advisory_lock_shared_int4</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>key1</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>key2</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockAcquireResult</name></type> <name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_LOCKTAG_INT32</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name> <operator>!=</operator> <name>LOCKACQUIRE_NOT_AVAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_try_advisory_xact_lock_shared(int4, int4) - acquire xact scoped
 * share lock on 2 int4 keys, no wait
 *
 * Returns true if successful, false if lock not available
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_try_advisory_xact_lock_shared_int4</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>key1</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>key2</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockAcquireResult</name></type> <name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_LOCKTAG_INT32</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name> <operator>!=</operator> <name>LOCKACQUIRE_NOT_AVAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_advisory_unlock(int4, int4) - release exclusive lock on 2 int4 keys
 *
 * Returns true if successful, false if lock was not held
*/</comment>
<function><type><name>Datum</name></type>
<name>pg_advisory_unlock_int4</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>key1</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>key2</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_LOCKTAG_INT32</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>LockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_advisory_unlock_shared(int4, int4) - release share lock on 2 int4 keys
 *
 * Returns true if successful, false if lock was not held
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_advisory_unlock_shared_int4</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>key1</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>key2</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PreventAdvisoryLocksInParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_LOCKTAG_INT32</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>LockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_advisory_unlock_all() - release all advisory locks
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_advisory_unlock_all</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LockReleaseSession</name><argument_list>(<argument><expr><name>USER_LOCKMETHOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
