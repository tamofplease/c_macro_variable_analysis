<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/optimizer/plan/analyzejoins.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * analyzejoins.c
 *	  Routines for simplifying joins after initial query analysis
 *
 * While we do a great deal of join simplification in prep/prepjointree.c,
 * certain optimizations cannot be performed at that stage for lack of
 * detailed information about the query.  The routines here are invoked
 * after initsplan.c has done its work, and can do additional join removal
 * and simplification steps based on the information extracted.  The penalty
 * is that we have to work harder to clean up after ourselves when we modify
 * the query, since the derived data structures have to be updated too.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/optimizer/plan/analyzejoins.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/joininfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/paths.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/var.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>

<comment type="block">/* local functions */</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>join_is_removable</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>remove_rel_from_query</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>relid</name></decl></parameter>,
					  <parameter><decl><type><name>Relids</name></type> <name>joinrelids</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>remove_rel_from_joinlist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinlist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nremoved</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>rel_supports_distinctness</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>rel_is_distinct_for</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clause_list</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>distinct_col_search</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>colno</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colnos</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>opids</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_innerrel_unique_for</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					   <parameter><decl><type><name>Relids</name></type> <name>joinrelids</name></decl></parameter>,
					   <parameter><decl><type><name>Relids</name></type> <name>outerrelids</name></decl></parameter>,
					   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>innerrel</name></decl></parameter>,
					   <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictlist</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * remove_useless_joins
 *		Check for relations that don't actually need to be joined at all,
 *		and remove them from the query.
 *
 * We are passed the current joinlist and return the updated list.  Other
 * data structures that have to be updated are accessible via "root".
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>remove_useless_joins</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We are only interested in relations that are left-joined to, so we can
	 * scan the join_info_list to find them easily.
	 */</comment>
<label><name>restart</name>:</label>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;join_info_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name> <init>= <expr><operator>(</operator><name>SpecialJoinInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>innerrelid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nremoved</name></decl>;</decl_stmt>

		<comment type="block">/* Skip if not removable */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>join_is_removable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Currently, join_is_removable can only succeed when the sjinfo's
		 * righthand is a single baserel.  Remove that rel from the query and
		 * joinlist.
		 */</comment>
		<expr_stmt><expr><name>innerrelid</name> <operator>=</operator> <call><name>bms_singleton_member</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>remove_rel_from_query</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>innerrelid</name></expr></argument>,
							  <argument><expr><call><name>bms_union</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>,
										<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* We verify that exactly one reference gets removed from joinlist */</comment>
		<expr_stmt><expr><name>nremoved</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>joinlist</name> <operator>=</operator> <call><name>remove_rel_from_joinlist</name><argument_list>(<argument><expr><name>joinlist</name></expr></argument>, <argument><expr><name>innerrelid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nremoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>nremoved</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to find relation %d in joinlist"</literal></expr></argument>, <argument><expr><name>innerrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We can delete this SpecialJoinInfo from the list too, since it's no
		 * longer of interest.
		 */</comment>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>join_info_list</name></name> <operator>=</operator> <call><name>list_delete_ptr</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>join_info_list</name></name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Restart the scan.  This is necessary to ensure we find all
		 * removable joins independently of ordering of the join_info_list
		 * (note that removal of attr_needed bits may make a join appear
		 * removable that did not before).  Also, since we just deleted the
		 * current list cell, we'd have to have some kluge to continue the
		 * list scan anyway.
		 */</comment>
		<goto>goto <name>restart</name>;</goto>
	</block_content>}</block>

	<return>return <expr><name>joinlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * clause_sides_match_join
 *	  Determine whether a join clause is of the right form to use in this join.
 *
 * We already know that the clause is a binary opclause referencing only the
 * rels in the current join.  The point here is to check whether it has the
 * form "outerrel_expr op innerrel_expr" or "innerrel_expr op outerrel_expr",
 * rather than mixing outer and inner vars on either side.  If it matches,
 * we set the transient flag outer_is_left to identify which side is which.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>clause_sides_match_join</name><parameter_list>(<parameter><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>outerrelids</name></decl></parameter>,
						<parameter><decl><type><name>Relids</name></type> <name>innerrelids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>left_relids</name></name></expr></argument>, <argument><expr><name>outerrelids</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>right_relids</name></name></expr></argument>, <argument><expr><name>innerrelids</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* lefthand side is outer */</comment>
		<expr_stmt><expr><name><name>rinfo</name><operator>-&gt;</operator><name>outer_is_left</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>left_relids</name></name></expr></argument>, <argument><expr><name>innerrelids</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			 <call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>right_relids</name></name></expr></argument>, <argument><expr><name>outerrelids</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* righthand side is outer */</comment>
		<expr_stmt><expr><name><name>rinfo</name><operator>-&gt;</operator><name>outer_is_left</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>				<comment type="block">/* no good for these input relations */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * join_is_removable
 *	  Check whether we need not perform this special join at all, because
 *	  it will just duplicate its left input.
 *
 * This is true for a left join for which the join condition cannot match
 * more than one inner-side row.  (There are other possibly interesting
 * cases, but we don't have the infrastructure to prove them.)  We also
 * have to check that the inner side doesn't generate any variables needed
 * above the join.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>join_is_removable</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>innerrelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>innerrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>joinrelids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>clause_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attroff</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Must be a non-delaying left join to a single baserel, else we aren't
	 * going to be able to do anything with it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_LEFT</name> <operator>||</operator>
		<name><name>sjinfo</name><operator>-&gt;</operator><name>delay_upper_joins</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_get_singleton_member</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>innerrelid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>innerrel</name> <operator>=</operator> <call><name>find_base_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>innerrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Before we go to the effort of checking whether any innerrel variables
	 * are needed above the join, make a quick check to eliminate cases in
	 * which we will surely be unable to prove uniqueness of the innerrel.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rel_supports_distinctness</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>innerrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Compute the relid set for the join we are considering */</comment>
	<expr_stmt><expr><name>joinrelids</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>, <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We can't remove the join if any inner-rel attributes are used above the
	 * join.
	 *
	 * Note that this test only detects use of inner-rel attributes in higher
	 * join conditions and the target list.  There might be such attributes in
	 * pushed-down conditions at this join, too.  We check that case below.
	 *
	 * As a micro-optimization, it seems better to start with max_attr and
	 * count down rather than starting with min_attr and counting up, on the
	 * theory that the system attributes are somewhat less likely to be wanted
	 * and should be tested last.
	 */</comment>
	<for>for <control>(<init><expr><name>attroff</name> <operator>=</operator> <name><name>innerrel</name><operator>-&gt;</operator><name>max_attr</name></name> <operator>-</operator> <name><name>innerrel</name><operator>-&gt;</operator><name>min_attr</name></name></expr>;</init>
		 <condition><expr><name>attroff</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition>
		 <incr><expr><name>attroff</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>innerrel</name><operator>-&gt;</operator><name>attr_needed</name><index>[<expr><name>attroff</name></expr>]</index></name></expr></argument>, <argument><expr><name>joinrelids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Similarly check that the inner rel isn't needed by any PlaceHolderVars
	 * that will be used above the join.  We only need to fail if such a PHV
	 * actually references some inner-rel attributes; but the correct check
	 * for that is relatively expensive, so we first check against ph_eval_at,
	 * which must mention the inner rel if the PHV uses any inner-rel attrs as
	 * non-lateral references.  Note that if the PHV's syntactic scope is just
	 * the inner rel, we can't drop the rel even if the PHV is variable-free.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>root-&gt;placeholder_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlaceHolderInfo</name> <modifier>*</modifier></type><name>phinfo</name> <init>= <expr><operator>(</operator><name>PlaceHolderInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_lateral</name></name></expr></argument>, <argument><expr><name><name>innerrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* it references innerrel laterally */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_needed</name></name></expr></argument>, <argument><expr><name>joinrelids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* PHV is not used above the join */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_eval_at</name></name></expr></argument>, <argument><expr><name><name>innerrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* it definitely doesn't reference innerrel */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_eval_at</name></name></expr></argument>, <argument><expr><name><name>innerrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* there isn't any other place to eval PHV */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><call><name>pull_varnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>phinfo</name><operator>-&gt;</operator><name>ph_var</name><operator>-&gt;</operator><name>phexpr</name></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name><name>innerrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* it does reference innerrel */</comment>
	</block_content>}</block>

	<comment type="block">/*
	 * Search for mergejoinable clauses that constrain the inner rel against
	 * either the outer rel or a pseudoconstant.  If an operator is
	 * mergejoinable then it behaves like equality for some btree opclass, so
	 * it's what we want.  The mergejoinability test also eliminates clauses
	 * containing volatile functions, which we couldn't depend on.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>innerrel-&gt;joininfo</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>restrictinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If it's not a join clause for this outer join, we can't use it.
		 * Note that if the clause is pushed-down, then it is logically from
		 * above the outer join, even if it references no other rels (it might
		 * be from WHERE, for example).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RINFO_IS_PUSHED_DOWN</name><argument_list>(<argument><expr><name>restrictinfo</name></expr></argument>, <argument><expr><name>joinrelids</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If such a clause actually references the inner rel then join
			 * removal has to be disallowed.  We have to check this despite
			 * the previous attr_needed checks because of the possibility of
			 * pushed-down clauses referencing the rel.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>innerrelid</name></expr></argument>, <argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>clause_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<continue>continue;</continue>			<comment type="block">/* else, ignore; not useful here */</comment>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Ignore if it's not a mergejoinable clause */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>restrictinfo</name><operator>-&gt;</operator><name>can_join</name></name> <operator>||</operator>
			<name><name>restrictinfo</name><operator>-&gt;</operator><name>mergeopfamilies</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* not mergejoinable */</comment>

		<comment type="block">/*
		 * Check if clause has the form "outer op inner" or "inner op outer",
		 * and if so mark which side is inner.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clause_sides_match_join</name><argument_list>(<argument><expr><name>restrictinfo</name></expr></argument>, <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>,
									 <argument><expr><name><name>innerrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* no good for these input relations */</comment>

		<comment type="block">/* OK, add to list */</comment>
		<expr_stmt><expr><name>clause_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>clause_list</name></expr></argument>, <argument><expr><name>restrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Now that we have the relevant equality join clauses, try to prove the
	 * innerrel distinct.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>rel_is_distinct_for</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>innerrel</name></expr></argument>, <argument><expr><name>clause_list</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Some day it would be nice to check for other methods of establishing
	 * distinctness.
	 */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Remove the target relid from the planner's data structures, having
 * determined that there is no need to include it in the query.
 *
 * We are not terribly thorough here.  We must make sure that the rel is
 * no longer treated as a baserel, and that attributes of other baserels
 * are no longer marked as being needed at joins involving this rel.
 * Also, join quals involving the rel have to be removed from the joininfo
 * lists, but only if they belong to the outer join identified by joinrelids.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>remove_rel_from_query</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>joinrelids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><call><name>find_base_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>joininfos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>rti</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>nextl</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Mark the rel as "dead" to show it is no longer part of the join tree.
	 * (Removing it from the baserel array altogether seems too risky.)
	 */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>=</operator> <name>RELOPT_DEADREL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Remove references to the rel from other baserels' attr_needed arrays.
	 */</comment>
	<for>for <control>(<init><expr><name>rti</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>rti</name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name></expr>;</condition> <incr><expr><name>rti</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>otherrel</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>rti</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>attroff</name></decl>;</decl_stmt>

		<comment type="block">/* there may be empty slots corresponding to non-baserel RTEs */</comment>
		<if_stmt><if>if <condition>(<expr><name>otherrel</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>otherrel</name><operator>-&gt;</operator><name>relid</name></name> <operator>==</operator> <name>rti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* sanity check on array */</comment>

		<comment type="block">/* no point in processing target rel itself */</comment>
		<if_stmt><if>if <condition>(<expr><name>otherrel</name> <operator>==</operator> <name>rel</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<for>for <control>(<init><expr><name>attroff</name> <operator>=</operator> <name><name>otherrel</name><operator>-&gt;</operator><name>max_attr</name></name> <operator>-</operator> <name><name>otherrel</name><operator>-&gt;</operator><name>min_attr</name></name></expr>;</init>
			 <condition><expr><name>attroff</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition>
			 <incr><expr><name>attroff</name><operator>--</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>otherrel</name><operator>-&gt;</operator><name>attr_needed</name><index>[<expr><name>attroff</name></expr>]</index></name> <operator>=</operator>
				<call><name>bms_del_member</name><argument_list>(<argument><expr><name><name>otherrel</name><operator>-&gt;</operator><name>attr_needed</name><index>[<expr><name>attroff</name></expr>]</index></name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Likewise remove references from SpecialJoinInfo data structures.
	 *
	 * This is relevant in case the outer join we're deleting is nested inside
	 * other outer joins: the upper joins' relid sets have to be adjusted. The
	 * RHS of the target outer join will be made empty here, but that's OK
	 * since caller will delete that SpecialJoinInfo entirely.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>root-&gt;join_info_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name> <init>= <expr><operator>(</operator><name>SpecialJoinInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_lefthand</name></name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_lefthand</name></name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Likewise remove references from PlaceHolderVar data structures,
	 * removing any no-longer-needed placeholders entirely.
	 *
	 * Removal is a bit tricker than it might seem: we can remove PHVs that
	 * are used at the target rel and/or in the join qual, but not those that
	 * are used at join partner rels or above the join.  It's not that easy to
	 * distinguish PHVs used at partner rels from those used in the join qual,
	 * since they will both have ph_needed sets that are subsets of
	 * joinrelids.  However, a PHV used at a partner rel could not have the
	 * target rel in ph_eval_at, so we check that while deciding whether to
	 * remove or just update the PHV.  There is no corresponding test in
	 * join_is_removable because it doesn't need to distinguish those cases.
	 */</comment>
	<for>for <control>(<init><expr><name>l</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>placeholder_list</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>l</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>l</name> <operator>=</operator> <name>nextl</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlaceHolderInfo</name> <modifier>*</modifier></type><name>phinfo</name> <init>= <expr><operator>(</operator><name>PlaceHolderInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>nextl</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_lateral</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_needed</name></name></expr></argument>, <argument><expr><name>joinrelids</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>bms_is_member</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_eval_at</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>placeholder_list</name></name> <operator>=</operator> <call><name>list_delete_ptr</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>placeholder_list</name></name></expr></argument>,
													 <argument><expr><name>phinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_eval_at</name></name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_eval_at</name></name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_eval_at</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_needed</name></name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_needed</name></name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Remove any joinquals referencing the rel from the joininfo lists.
	 *
	 * In some cases, a joinqual has to be put back after deleting its
	 * reference to the target rel.  This can occur for pseudoconstant and
	 * outerjoin-delayed quals, which can get marked as requiring the rel in
	 * order to force them to be evaluated at or above the join.  We can't
	 * just discard them, though.  Only quals that logically belonged to the
	 * outer join being discarded should be removed from the query.
	 *
	 * We must make a copy of the rel's old joininfo list before starting the
	 * loop, because otherwise remove_join_clause_from_rels would destroy the
	 * list while we're scanning it.
	 */</comment>
	<expr_stmt><expr><name>joininfos</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>joininfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>joininfos</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>remove_join_clause_from_rels</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>required_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>RINFO_IS_PUSHED_DOWN</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>, <argument><expr><name>joinrelids</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Recheck that qual doesn't actually reference the target rel */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause_relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * The required_relids probably aren't shared with anything else,
			 * but let's copy them just to be sure.
			 */</comment>
			<expr_stmt><expr><name><name>rinfo</name><operator>-&gt;</operator><name>required_relids</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>required_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rinfo</name><operator>-&gt;</operator><name>required_relids</name></name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>required_relids</name></name></expr></argument>,
													<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>distribute_restrictinfo_to_rels</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * There may be references to the rel in root-&gt;fkey_list, but if so,
	 * match_foreign_keys_to_quals() will get rid of them.
	 */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Remove any occurrences of the target relid from a joinlist structure.
 *
 * It's easiest to build a whole new list structure, so we handle it that
 * way.  Efficiency is not a big deal here.
 *
 * *nremoved is incremented by the number of occurrences removed (there
 * should be exactly one, but the caller checks that).
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>remove_rel_from_joinlist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinlist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nremoved</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>jl</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>jl</argument>, <argument>joinlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>jlnode</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>jl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jlnode</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>varno</name> <init>= <expr><operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>jlnode</name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>varno</name> <operator>==</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>(</operator><operator>*</operator><name>nremoved</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>jlnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jlnode</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Recurse to handle subproblem */</comment>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sublist</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>sublist</name> <operator>=</operator> <call><name>remove_rel_from_joinlist</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>jlnode</name></expr></argument>,
											   <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>nremoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Avoid including empty sub-lists in the result */</comment>
			<if_stmt><if>if <condition>(<expr><name>sublist</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>sublist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized joinlist node type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>jlnode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * reduce_unique_semijoins
 *		Check for semijoins that can be simplified to plain inner joins
 *		because the inner relation is provably unique for the join clauses.
 *
 * Ideally this would happen during reduce_outer_joins, but we don't have
 * enough information at that point.
 *
 * To perform the strength reduction when applicable, we need only delete
 * the semijoin's SpecialJoinInfo from root-&gt;join_info_list.  (We don't
 * bother fixing the join type attributed to it in the query jointree,
 * since that won't be consulted again.)
 */</comment>
<function><type><name>void</name></type>
<name>reduce_unique_semijoins</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Scan the join_info_list to find semijoins.  We can't use foreach
	 * because we may delete the current cell.
	 */</comment>
	<for>for <control>(<init><expr><name>lc</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>join_info_list</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>lc</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>lc</name> <operator>=</operator> <name>next</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name> <init>= <expr><operator>(</operator><name>SpecialJoinInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>innerrelid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>innerrel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>joinrelids</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>restrictlist</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Must be a non-delaying semijoin to a single baserel, else we aren't
		 * going to be able to do anything with it.  (It's probably not
		 * possible for delay_upper_joins to be set on a semijoin, but we
		 * might as well check.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_SEMI</name> <operator>||</operator>
			<name><name>sjinfo</name><operator>-&gt;</operator><name>delay_upper_joins</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_get_singleton_member</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>innerrelid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>innerrel</name> <operator>=</operator> <call><name>find_base_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>innerrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Before we trouble to run generate_join_implied_equalities, make a
		 * quick check to eliminate cases in which we will surely be unable to
		 * prove uniqueness of the innerrel.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rel_supports_distinctness</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>innerrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Compute the relid set for the join we are considering */</comment>
		<expr_stmt><expr><name>joinrelids</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>, <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Since we're only considering a single-rel RHS, any join clauses it
		 * has must be clauses linking it to the semijoin's min_lefthand.  We
		 * can also consider EC-derived join clauses.
		 */</comment>
		<expr_stmt><expr><name>restrictlist</name> <operator>=</operator>
			<call><name>list_concat</name><argument_list>(<argument><expr><call><name>generate_join_implied_equalities</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														 <argument><expr><name>joinrelids</name></expr></argument>,
														 <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>,
														 <argument><expr><name>innerrel</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name><name>innerrel</name><operator>-&gt;</operator><name>joininfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Test whether the innerrel is unique for those clauses. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>innerrel_is_unique</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								<argument><expr><name>joinrelids</name></expr></argument>, <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>, <argument><expr><name>innerrel</name></expr></argument>,
								<argument><expr><name>JOIN_SEMI</name></expr></argument>, <argument><expr><name>restrictlist</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* OK, remove the SpecialJoinInfo from the list. */</comment>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>join_info_list</name></name> <operator>=</operator> <call><name>list_delete_ptr</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>join_info_list</name></name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * rel_supports_distinctness
 *		Could the relation possibly be proven distinct on some set of columns?
 *
 * This is effectively a pre-checking function for rel_is_distinct_for().
 * It must return true if rel_is_distinct_for() could possibly return true
 * with this rel, but it should not expend a lot of cycles.  The idea is
 * that callers can avoid doing possibly-expensive processing to compute
 * rel_is_distinct_for()'s argument lists if the call could not possibly
 * succeed.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>rel_supports_distinctness</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* We only know about baserels ... */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>!=</operator> <name>RELOPT_BASEREL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For a plain relation, we only know how to prove uniqueness by
		 * reference to unique indexes.  Make sure there's at least one
		 * suitable unique index.  It must be immediately enforced, and if
		 * it's a partial index, it must match the query.  (Keep these
		 * conditions in sync with relation_has_unique_index_for!)
		 */</comment>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rel-&gt;indexlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>ind</name> <init>= <expr><operator>(</operator><name>IndexOptInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>ind</name><operator>-&gt;</operator><name>unique</name></name> <operator>&amp;&amp;</operator> <name><name>ind</name><operator>-&gt;</operator><name>immediate</name></name> <operator>&amp;&amp;</operator>
				<operator>(</operator><name><name>ind</name><operator>-&gt;</operator><name>indpred</name></name> <operator>==</operator> <name>NIL</name> <operator>||</operator> <name><name>ind</name><operator>-&gt;</operator><name>predOK</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>subquery</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr>]</index></name><operator>-&gt;</operator><name>subquery</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Check if the subquery has any qualities that support distinctness */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>query_supports_distinctness</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* We have no proof rules for any other rtekinds. */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * rel_is_distinct_for
 *		Does the relation return only distinct rows according to clause_list?
 *
 * clause_list is a list of join restriction clauses involving this rel and
 * some other one.  Return true if no two rows emitted by this rel could
 * possibly join to the same row of the other rel.
 *
 * The caller must have already determined that each condition is a
 * mergejoinable equality with an expression in this relation on one side, and
 * an expression not involving this relation on the other.  The transient
 * outer_is_left flag is used to identify which side references this relation:
 * left side if outer_is_left is false, right side if it is true.
 *
 * Note that the passed-in clause_list may be destructively modified!  This
 * is OK for current uses, because the clause_list is built by the caller for
 * the sole purpose of passing to this function.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>rel_is_distinct_for</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clause_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We could skip a couple of tests here if we assume all callers checked
	 * rel_supports_distinctness first, but it doesn't seem worth taking any
	 * risk for.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>!=</operator> <name>RELOPT_BASEREL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Examine the indexes to see if we have a matching unique index.
		 * relation_has_unique_index_for automatically adds any usable
		 * restriction clauses for the rel, so we needn't do that here.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>relation_has_unique_index_for</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>clause_list</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Index</name></type>		<name>relid</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>subquery</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name>relid</name></expr>]</index></name><operator>-&gt;</operator><name>subquery</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>colnos</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>opids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Build the argument lists for query_is_distinct_for: a list of
		 * output column numbers that the query needs to be distinct over, and
		 * a list of equality operators that the output columns need to be
		 * distinct according to.
		 *
		 * (XXX we are not considering restriction clauses attached to the
		 * subquery; is that worth doing?)
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>clause_list</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>op</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Get the equality operator we need uniqueness according to.
			 * (This might be a cross-type operator and thus not exactly the
			 * same operator the subquery would consider; that's all right
			 * since query_is_distinct_for can resolve such cases.)  The
			 * caller's mergejoinability test should have selected only
			 * OpExprs.
			 */</comment>
			<expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>opno</name></expr>;</expr_stmt>

			<comment type="block">/* caller identified the inner side for us */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>outer_is_left</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>get_rightop</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>get_leftop</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/*
			 * We may ignore any RelabelType node above the operand.  (There
			 * won't be more than one, since eval_const_expressions() has been
			 * applied already.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>var</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>var</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * If inner side isn't a Var referencing a subquery output column,
			 * this clause doesn't help us.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>var</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>!=</operator> <name>relid</name> <operator>||</operator> <name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>colnos</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>colnos</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>opids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>opids</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><call><name>query_is_distinct_for</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>, <argument><expr><name>colnos</name></expr></argument>, <argument><expr><name>opids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * query_supports_distinctness - could the query possibly be proven distinct
 *		on some set of output columns?
 *
 * This is effectively a pre-checking function for query_is_distinct_for().
 * It must return true if query_is_distinct_for() could possibly return true
 * with this query, but it should not expend a lot of cycles.  The idea is
 * that callers can avoid doing possibly-expensive processing to compute
 * query_is_distinct_for()'s argument lists if the call could not possibly
 * succeed.
 */</comment>
<function><type><name>bool</name></type>
<name>query_supports_distinctness</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* SRFs break distinctness except with DISTINCT, see below */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>&amp;&amp;</operator> <name><name>query</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* check for features we can prove distinctness with */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>!=</operator> <name>NIL</name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>!=</operator> <name>NIL</name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>!=</operator> <name>NIL</name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>setOperations</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * query_is_distinct_for - does query never return duplicates of the
 *		specified columns?
 *
 * query is a not-yet-planned subquery (in current usage, it's always from
 * a subquery RTE, which the planner avoids scribbling on).
 *
 * colnos is an integer list of output column numbers (resno's).  We are
 * interested in whether rows consisting of just these columns are certain
 * to be distinct.  "Distinctness" is defined according to whether the
 * corresponding upper-level equality operators listed in opids would think
 * the values are distinct.  (Note: the opids entries could be cross-type
 * operators, and thus not exactly the equality operators that the subquery
 * would use itself.  We use equality_ops_are_compatible() to check
 * compatibility.  That looks at btree or hash opfamily membership, and so
 * should give trustworthy answers for all operators that we might need
 * to deal with here.)
 */</comment>
<function><type><name>bool</name></type>
<name>query_is_distinct_for</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colnos</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>opids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>colnos</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>opids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * DISTINCT (including DISTINCT ON) guarantees uniqueness if all the
	 * columns in the DISTINCT clause appear in colnos and operator semantics
	 * match.  This is true even if there are SRFs in the DISTINCT columns or
	 * elsewhere in the tlist.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>distinctClause</name></name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>query-&gt;distinctClause</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sgc</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>sgc</name></expr></argument>,
													   <argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>opid</name> <operator>=</operator> <call><name>distinct_col_search</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>, <argument><expr><name>colnos</name></expr></argument>, <argument><expr><name>opids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>opid</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<operator>!</operator><call><name>equality_ops_are_compatible</name><argument_list>(<argument><expr><name>opid</name></expr></argument>, <argument><expr><name><name>sgc</name><operator>-&gt;</operator><name>eqop</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* exit early if no match */</comment>
		</block_content>}</block>
		<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>			<comment type="block">/* had matches for all? */</comment>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise, a set-returning function in the query's targetlist can
	 * result in returning duplicate rows, despite any grouping that might
	 * occur before tlist evaluation.  (If all tlist SRFs are within GROUP BY
	 * columns, it would be safe because they'd be expanded before grouping.
	 * But it doesn't currently seem worth the effort to check for that.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Similarly, GROUP BY without GROUPING SETS guarantees uniqueness if all
	 * the grouped columns appear in colnos and operator semantics match.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>query</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>query-&gt;groupClause</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sgc</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>sgc</name></expr></argument>,
													   <argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>opid</name> <operator>=</operator> <call><name>distinct_col_search</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>, <argument><expr><name>colnos</name></expr></argument>, <argument><expr><name>opids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>opid</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<operator>!</operator><call><name>equality_ops_are_compatible</name><argument_list>(<argument><expr><name>opid</name></expr></argument>, <argument><expr><name><name>sgc</name><operator>-&gt;</operator><name>eqop</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* exit early if no match */</comment>
		</block_content>}</block>
		<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>			<comment type="block">/* had matches for all? */</comment>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we have grouping sets with expressions, we probably don't have
		 * uniqueness and analysis would be hard. Punt.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>groupClause</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If we have no groupClause (therefore no grouping expressions), we
		 * might have one or many empty grouping sets. If there's just one,
		 * then we're returning only one row and are certainly unique. But
		 * otherwise, we know we're certainly not unique.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>groupingSets</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>(</operator><name>GroupingSet</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>groupingSets</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>kind</name> <operator>==</operator> <name>GROUPING_SET_EMPTY</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If we have no GROUP BY, but do have aggregates or HAVING, then the
		 * result is at most one row so it's surely unique, for any operators.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>||</operator> <name><name>query</name><operator>-&gt;</operator><name>havingQual</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * UNION, INTERSECT, EXCEPT guarantee uniqueness of the whole output row,
	 * except with ALL.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>setOperations</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>topop</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>SetOperationStmt</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>setOperations</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>topop</name><operator>-&gt;</operator><name>op</name></name> <operator>!=</operator> <name>SETOP_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>topop</name><operator>-&gt;</operator><name>all</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lg</name></decl>;</decl_stmt>

			<comment type="block">/* We're good if all the nonjunk output columns are in colnos */</comment>
			<expr_stmt><expr><name>lg</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>topop</name><operator>-&gt;</operator><name>groupClauses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>query-&gt;targetList</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sgc</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>	<comment type="block">/* ignore resjunk columns */</comment>

				<comment type="block">/* non-resjunk columns should have grouping clauses */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lg</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>sgc</name> <operator>=</operator> <operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>lg</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>opid</name> <operator>=</operator> <call><name>distinct_col_search</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>, <argument><expr><name>colnos</name></expr></argument>, <argument><expr><name>opids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>opid</name></expr></argument>)</argument_list></call> <operator>||</operator>
					<operator>!</operator><call><name>equality_ops_are_compatible</name><argument_list>(<argument><expr><name>opid</name></expr></argument>, <argument><expr><name><name>sgc</name><operator>-&gt;</operator><name>eqop</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>		<comment type="block">/* exit early if no match */</comment>
			</block_content>}</block>
			<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* had matches for all? */</comment>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * XXX Are there any other cases in which we can easily see the result
	 * must be distinct?
	 *
	 * If you do add more smarts to this function, be sure to update
	 * query_supports_distinctness() to match.
	 */</comment>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * distinct_col_search - subroutine for query_is_distinct_for
 *
 * If colno is in colnos, return the corresponding element of opids,
 * else return InvalidOid.  (Ordinarily colnos would not contain duplicates,
 * but if it does, we arbitrarily select the first match.)
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>distinct_col_search</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>colno</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colnos</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>opids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

	<macro><name>forboth</name><argument_list>(<argument>lc1</argument>, <argument>colnos</argument>, <argument>lc2</argument>, <argument>opids</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>colno</name> <operator>==</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>InvalidOid</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * innerrel_is_unique
 *	  Check if the innerrel provably contains at most one tuple matching any
 *	  tuple from the outerrel, based on join clauses in the 'restrictlist'.
 *
 * We need an actual RelOptInfo for the innerrel, but it's sufficient to
 * identify the outerrel by its Relids.  This asymmetry supports use of this
 * function before joinrels have been built.  (The caller is expected to
 * also supply the joinrelids, just to save recalculating that.)
 *
 * The proof must be made based only on clauses that will be "joinquals"
 * rather than "otherquals" at execution.  For an inner join there's no
 * difference; but if the join is outer, we must ignore pushed-down quals,
 * as those will become "otherquals".  Note that this means the answer might
 * vary depending on whether IS_OUTER_JOIN(jointype); since we cache the
 * answer without regard to that, callers must take care not to call this
 * with jointypes that would be classified differently by IS_OUTER_JOIN().
 *
 * The actual proof is undertaken by is_innerrel_unique_for(); this function
 * is a frontend that is mainly concerned with caching the answers.
 * In particular, the force_cache argument allows overriding the internal
 * heuristic about whether to cache negative answers; it should be "true"
 * if making an inquiry that is not part of the normal bottom-up join search
 * sequence.
 */</comment>
<function><type><name>bool</name></type>
<name>innerrel_is_unique</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
				   <parameter><decl><type><name>Relids</name></type> <name>joinrelids</name></decl></parameter>,
				   <parameter><decl><type><name>Relids</name></type> <name>outerrelids</name></decl></parameter>,
				   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>innerrel</name></decl></parameter>,
				   <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictlist</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>force_cache</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Certainly can't prove uniqueness when there are no joinclauses */</comment>
	<if_stmt><if>if <condition>(<expr><name>restrictlist</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Make a quick check to eliminate cases in which we will surely be unable
	 * to prove uniqueness of the innerrel.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rel_supports_distinctness</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>innerrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Query the cache to see if we've managed to prove that innerrel is
	 * unique for any subset of this outerrel.  We don't need an exact match,
	 * as extra outerrels can't make the innerrel any less unique (or more
	 * formally, the restrictlist for a join to a superset outerrel must be a
	 * superset of the conditions we successfully used before).
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>innerrel-&gt;unique_for_rels</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>unique_for_rels</name> <init>= <expr><operator>(</operator><name>Relids</name><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name>unique_for_rels</name></expr></argument>, <argument><expr><name>outerrelids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* Success! */</comment>
	</block_content>}</block>

	<comment type="block">/*
	 * Conversely, we may have already determined that this outerrel, or some
	 * superset thereof, cannot prove this innerrel to be unique.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>innerrel-&gt;non_unique_for_rels</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>unique_for_rels</name> <init>= <expr><operator>(</operator><name>Relids</name><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name>outerrelids</name></expr></argument>, <argument><expr><name>unique_for_rels</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* No cached information, so try to make the proof. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>is_innerrel_unique_for</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrelids</name></expr></argument>, <argument><expr><name>outerrelids</name></expr></argument>, <argument><expr><name>innerrel</name></expr></argument>,
							   <argument><expr><name>jointype</name></expr></argument>, <argument><expr><name>restrictlist</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Cache the positive result for future probes, being sure to keep it
		 * in the planner_cxt even if we are working in GEQO.
		 *
		 * Note: one might consider trying to isolate the minimal subset of
		 * the outerrels that proved the innerrel unique.  But it's not worth
		 * the trouble, because the planner builds up joinrels incrementally
		 * and so we'll see the minimally sufficient outerrels before any
		 * supersets of them anyway.
		 */</comment>
		<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>planner_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>innerrel</name><operator>-&gt;</operator><name>unique_for_rels</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>innerrel</name><operator>-&gt;</operator><name>unique_for_rels</name></name></expr></argument>,
											<argument><expr><call><name>bms_copy</name><argument_list>(<argument><expr><name>outerrelids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>true</name></expr>;</return>			<comment type="block">/* Success! */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * None of the join conditions for outerrel proved innerrel unique, so
		 * we can safely reject this outerrel or any subset of it in future
		 * checks.
		 *
		 * However, in normal planning mode, caching this knowledge is totally
		 * pointless; it won't be queried again, because we build up joinrels
		 * from smaller to larger.  It is useful in GEQO mode, where the
		 * knowledge can be carried across successive planning attempts; and
		 * it's likely to be useful when using join-search plugins, too. Hence
		 * cache when join_search_private is non-NULL.  (Yeah, that's a hack,
		 * but it seems reasonable.)
		 *
		 * Also, allow callers to override that heuristic and force caching;
		 * that's useful for reduce_unique_semijoins, which calls here before
		 * the normal join search starts.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>force_cache</name> <operator>||</operator> <name><name>root</name><operator>-&gt;</operator><name>join_search_private</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>planner_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>innerrel</name><operator>-&gt;</operator><name>non_unique_for_rels</name></name> <operator>=</operator>
				<call><name>lappend</name><argument_list>(<argument><expr><name><name>innerrel</name><operator>-&gt;</operator><name>non_unique_for_rels</name></name></expr></argument>,
						<argument><expr><call><name>bms_copy</name><argument_list>(<argument><expr><name>outerrelids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * is_innerrel_unique_for
 *	  Check if the innerrel provably contains at most one tuple matching any
 *	  tuple from the outerrel, based on join clauses in the 'restrictlist'.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_innerrel_unique_for</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					   <parameter><decl><type><name>Relids</name></type> <name>joinrelids</name></decl></parameter>,
					   <parameter><decl><type><name>Relids</name></type> <name>outerrelids</name></decl></parameter>,
					   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>innerrel</name></decl></parameter>,
					   <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>clause_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Search for mergejoinable clauses that constrain the inner rel against
	 * the outer rel.  If an operator is mergejoinable then it behaves like
	 * equality for some btree opclass, so it's what we want.  The
	 * mergejoinability test also eliminates clauses containing volatile
	 * functions, which we couldn't depend on.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>restrictlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>restrictinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * As noted above, if it's a pushed-down clause and we're at an outer
		 * join, we can't use it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IS_OUTER_JOIN</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>RINFO_IS_PUSHED_DOWN</name><argument_list>(<argument><expr><name>restrictinfo</name></expr></argument>, <argument><expr><name>joinrelids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Ignore if it's not a mergejoinable clause */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>restrictinfo</name><operator>-&gt;</operator><name>can_join</name></name> <operator>||</operator>
			<name><name>restrictinfo</name><operator>-&gt;</operator><name>mergeopfamilies</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* not mergejoinable */</comment>

		<comment type="block">/*
		 * Check if clause has the form "outer op inner" or "inner op outer",
		 * and if so mark which side is inner.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clause_sides_match_join</name><argument_list>(<argument><expr><name>restrictinfo</name></expr></argument>, <argument><expr><name>outerrelids</name></expr></argument>,
									 <argument><expr><name><name>innerrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* no good for these input relations */</comment>

		<comment type="block">/* OK, add to list */</comment>
		<expr_stmt><expr><name>clause_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>clause_list</name></expr></argument>, <argument><expr><name>restrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Let rel_is_distinct_for() do the hard work */</comment>
	<return>return <expr><call><name>rel_is_distinct_for</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>innerrel</name></expr></argument>, <argument><expr><name>clause_list</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
