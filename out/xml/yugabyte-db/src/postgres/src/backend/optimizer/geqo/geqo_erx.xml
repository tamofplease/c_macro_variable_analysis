<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/optimizer/geqo/geqo_erx.c"><comment type="block">/*------------------------------------------------------------------------
*
* geqo_erx.c
*	 edge recombination crossover [ER]
*
* src/backend/optimizer/geqo/geqo_erx.c
*
*-------------------------------------------------------------------------
*/</comment>

<comment type="block">/* contributed by:
   =*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=
   *  Martin Utesch				 * Institute of Automatic Control	   *
   =							 = University of Mining and Technology =
   *  utesch@aut.tu-freiberg.de  * Freiberg, Germany				   *
   =*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=
 */</comment>

<comment type="block">/* the edge recombination algorithm is adopted from Genitor : */</comment>
<comment type="block" format="doxygen">/*************************************************************/</comment>
<comment type="block">/*															 */</comment>
<comment type="block">/*	Copyright (c) 1990										 */</comment>
<comment type="block">/*	Darrell L. Whitley										 */</comment>
<comment type="block">/*	Computer Science Department								 */</comment>
<comment type="block">/*	Colorado State University								 */</comment>
<comment type="block">/*															 */</comment>
<comment type="block">/*	Permission is hereby granted to copy all or any part of  */</comment>
<comment type="block">/*	this program for free distribution.   The author's name  */</comment>
<comment type="block">/*	and this copyright notice must be included in any copy.  */</comment>
<comment type="block">/*															 */</comment>
<comment type="block" format="doxygen">/*************************************************************/</comment>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/geqo_recombination.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/geqo_random.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ERX</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>gimme_edge</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Gene</name></type> <name>gene1</name></decl></parameter>, <parameter><decl><type><name>Gene</name></type> <name>gene2</name></decl></parameter>, <parameter><decl><type><name>Edge</name> <modifier>*</modifier></type><name>edge_table</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>remove_gene</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Gene</name></type> <name>gene</name></decl></parameter>, <parameter><decl><type><name>Edge</name></type> <name>edge</name></decl></parameter>, <parameter><decl><type><name>Edge</name> <modifier>*</modifier></type><name>edge_table</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Gene</name></type> <name>gimme_gene</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Edge</name></type> <name>edge</name></decl></parameter>, <parameter><decl><type><name>Edge</name> <modifier>*</modifier></type><name>edge_table</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Gene</name></type> <name>edge_failure</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Gene</name> <modifier>*</modifier></type><name>gene</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>Edge</name> <modifier>*</modifier></type><name>edge_table</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num_gene</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* alloc_edge_table
 *
 *	 allocate memory for edge table
 *
 */</comment>

<function><type><name>Edge</name> <modifier>*</modifier></type>
<name>alloc_edge_table</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num_gene</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Edge</name>	   <modifier>*</modifier></type><name>edge_table</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * palloc one extra location so that nodes numbered 1..n can be indexed
	 * directly; 0 will not be used
	 */</comment>

	<expr_stmt><expr><name>edge_table</name> <operator>=</operator> <operator>(</operator><name>Edge</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>num_gene</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Edge</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>edge_table</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* free_edge_table
 *
 *	  deallocate memory of edge table
 *
 */</comment>
<function><type><name>void</name></type>
<name>free_edge_table</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Edge</name> <modifier>*</modifier></type><name>edge_table</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>edge_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* gimme_edge_table
 *
 *	 fills a data structure which represents the set of explicit
 *	 edges between points in the (2) input genes
 *
 *	 assumes circular tours and bidirectional edges
 *
 *	 gimme_edge() will set "shared" edges to negative values
 *
 *	 returns average number edges/city in range 2.0 - 4.0
 *	 where 2.0=homogeneous; 4.0=diverse
 *
 */</comment>
<function><type><name>float</name></type>
<name>gimme_edge_table</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Gene</name> <modifier>*</modifier></type><name>tour1</name></decl></parameter>, <parameter><decl><type><name>Gene</name> <modifier>*</modifier></type><name>tour2</name></decl></parameter>,
				 <parameter><decl><type><name>int</name></type> <name>num_gene</name></decl></parameter>, <parameter><decl><type><name>Edge</name> <modifier>*</modifier></type><name>edge_table</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>index1</name></decl>,
				<decl><type ref="prev"/><name>index2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>edge_total</name></decl>;</decl_stmt>		<comment type="block">/* total number of unique edges in two genes */</comment>

	<comment type="block">/* at first clear the edge table's old data */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>num_gene</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>edge_table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>total_edges</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>edge_table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>unused_edges</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* fill edge table with new data */</comment>

	<expr_stmt><expr><name>edge_total</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>index1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index1</name> <operator>&lt;</operator> <name>num_gene</name></expr>;</condition> <incr><expr><name>index1</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * presume the tour is circular, i.e. 1-&gt;2, 2-&gt;3, 3-&gt;1 this operation
		 * maps n back to 1
		 */</comment>

		<expr_stmt><expr><name>index2</name> <operator>=</operator> <operator>(</operator><name>index1</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>num_gene</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * edges are bidirectional, i.e. 1-&gt;2 is same as 2-&gt;1 call gimme_edge
		 * twice per edge
		 */</comment>

		<expr_stmt><expr><name>edge_total</name> <operator>+=</operator> <call><name>gimme_edge</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>tour1</name><index>[<expr><name>index1</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>tour1</name><index>[<expr><name>index2</name></expr>]</index></name></expr></argument>, <argument><expr><name>edge_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>gimme_edge</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>tour1</name><index>[<expr><name>index2</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>tour1</name><index>[<expr><name>index1</name></expr>]</index></name></expr></argument>, <argument><expr><name>edge_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>edge_total</name> <operator>+=</operator> <call><name>gimme_edge</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>tour2</name><index>[<expr><name>index1</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>tour2</name><index>[<expr><name>index2</name></expr>]</index></name></expr></argument>, <argument><expr><name>edge_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>gimme_edge</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>tour2</name><index>[<expr><name>index2</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>tour2</name><index>[<expr><name>index1</name></expr>]</index></name></expr></argument>, <argument><expr><name>edge_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* return average number of edges per index */</comment>
	<return>return <expr><operator>(</operator><operator>(</operator><name>float</name><operator>)</operator> <operator>(</operator><name>edge_total</name> <operator>*</operator> <literal type="number">2</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><name>float</name><operator>)</operator> <name>num_gene</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* gimme_edge
 *
 *	  registers edge from city1 to city2 in input edge table
 *
 *	  no assumptions about directionality are made;
 *	  therefore it is up to the calling routine to
 *	  call gimme_edge twice to make a bi-directional edge
 *	  between city1 and city2;
 *	  uni-directional edges are possible as well (just call gimme_edge
 *	  once with the direction from city1 to city2)
 *
 *	  returns 1 if edge was not already registered and was just added;
 *			  0 if edge was already registered and edge_table is unchanged
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>gimme_edge</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Gene</name></type> <name>gene1</name></decl></parameter>, <parameter><decl><type><name>Gene</name></type> <name>gene2</name></decl></parameter>, <parameter><decl><type><name>Edge</name> <modifier>*</modifier></type><name>edge_table</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>edges</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>city1</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <name>gene1</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>city2</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <name>gene2</name></expr></init></decl>;</decl_stmt>


	<comment type="block">/* check whether edge city1-&gt;city2 already exists */</comment>
	<expr_stmt><expr><name>edges</name> <operator>=</operator> <name><name>edge_table</name><index>[<expr><name>city1</name></expr>]</index></name><operator>.</operator><name>total_edges</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>edges</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Gene</name><operator>)</operator> <call><name>Abs</name><argument_list>(<argument><expr><name><name>edge_table</name><index>[<expr><name>city1</name></expr>]</index></name><operator>.</operator><name><name>edge_list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>city2</name></expr>)</condition>
		<block>{<block_content>

			<comment type="block">/* mark shared edges as negative */</comment>
			<expr_stmt><expr><name><name>edge_table</name><index>[<expr><name>city1</name></expr>]</index></name><operator>.</operator><name><name>edge_list</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal> <operator>-</operator> <name>city2</name></expr>;</expr_stmt>

			<return>return <expr><literal type="number">0</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* add city1-&gt;city2; */</comment>
	<expr_stmt><expr><name><name>edge_table</name><index>[<expr><name>city1</name></expr>]</index></name><operator>.</operator><name><name>edge_list</name><index>[<expr><name>edges</name></expr>]</index></name> <operator>=</operator> <name>city2</name></expr>;</expr_stmt>

	<comment type="block">/* increment the number of edges from city1 */</comment>
	<expr_stmt><expr><name><name>edge_table</name><index>[<expr><name>city1</name></expr>]</index></name><operator>.</operator><name>total_edges</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>edge_table</name><index>[<expr><name>city1</name></expr>]</index></name><operator>.</operator><name>unused_edges</name><operator>++</operator></expr>;</expr_stmt>

	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* gimme_tour
 *
 *	  creates a new tour using edges from the edge table.
 *	  priority is given to "shared" edges (i.e. edges which
 *	  all parent genes possess and are marked as negative
 *	  in the edge table.)
 *
 */</comment>
<function><type><name>int</name></type>
<name>gimme_tour</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Edge</name> <modifier>*</modifier></type><name>edge_table</name></decl></parameter>, <parameter><decl><type><name>Gene</name> <modifier>*</modifier></type><name>new_gene</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num_gene</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>edge_failures</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* choose int between 1 and num_gene */</comment>
	<expr_stmt><expr><name><name>new_gene</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Gene</name><operator>)</operator> <call><name>geqo_randint</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>num_gene</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_gene</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * as each point is entered into the tour, remove it from the edge
		 * table
		 */</comment>

		<expr_stmt><expr><call><name>remove_gene</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>new_gene</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>edge_table</name><index>[<expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>new_gene</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>]</index></name></expr></argument>, <argument><expr><name>edge_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* find destination for the newly entered point */</comment>

		<if_stmt><if>if <condition>(<expr><name><name>edge_table</name><index>[<expr><name><name>new_gene</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>]</index></name><operator>.</operator><name>unused_edges</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>new_gene</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>gimme_gene</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>edge_table</name><index>[<expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>new_gene</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>]</index></name></expr></argument>, <argument><expr><name>edge_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

		<else>else
		<block>{<block_content>						<comment type="block">/* cope with fault */</comment>
			<expr_stmt><expr><name>edge_failures</name><operator>++</operator></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>new_gene</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>edge_failure</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>new_gene</name></expr></argument>, <argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>edge_table</name></expr></argument>, <argument><expr><name>num_gene</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* mark this node as incorporated */</comment>
		<expr_stmt><expr><name><name>edge_table</name><index>[<expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>new_gene</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>]</index></name><operator>.</operator><name>unused_edges</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	</block_content>}</block></for>							<comment type="block">/* for (i=1; i&lt;num_gene; i++) */</comment>

	<return>return <expr><name>edge_failures</name></expr>;</return>

</block_content>}</block></function>

<comment type="block">/* remove_gene
 *
 *	 removes input gene from edge_table.
 *	 input edge is used
 *	 to identify deletion locations within edge table.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>remove_gene</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Gene</name></type> <name>gene</name></decl></parameter>, <parameter><decl><type><name>Edge</name></type> <name>edge</name></decl></parameter>, <parameter><decl><type><name>Edge</name> <modifier>*</modifier></type><name>edge_table</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>possess_edge</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>genes_remaining</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * do for every gene known to have an edge to input gene (i.e. in
	 * edge_list for input edge)
	 */</comment>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>edge</name><operator>.</operator><name>unused_edges</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>possess_edge</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>Abs</name><argument_list>(<argument><expr><name><name>edge</name><operator>.</operator><name>edge_list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>genes_remaining</name> <operator>=</operator> <name><name>edge_table</name><index>[<expr><name>possess_edge</name></expr>]</index></name><operator>.</operator><name>unused_edges</name></expr>;</expr_stmt>

		<comment type="block">/* find the input gene in all edge_lists and delete it */</comment>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>genes_remaining</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>

			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Gene</name><operator>)</operator> <call><name>Abs</name><argument_list>(<argument><expr><name><name>edge_table</name><index>[<expr><name>possess_edge</name></expr>]</index></name><operator>.</operator><name><name>edge_list</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>gene</name></expr>)</condition>
			<block>{<block_content>

				<expr_stmt><expr><name><name>edge_table</name><index>[<expr><name>possess_edge</name></expr>]</index></name><operator>.</operator><name>unused_edges</name><operator>--</operator></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>edge_table</name><index>[<expr><name>possess_edge</name></expr>]</index></name><operator>.</operator><name><name>edge_list</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator>
					<name><name>edge_table</name><index>[<expr><name>possess_edge</name></expr>]</index></name><operator>.</operator><name><name>edge_list</name><index>[<expr><name>genes_remaining</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* gimme_gene
 *
 *	  priority is given to "shared" edges
 *	  (i.e. edges which both genes possess)
 *
 */</comment>
<function><type><specifier>static</specifier> <name>Gene</name></type>
<name>gimme_gene</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Edge</name></type> <name>edge</name></decl></parameter>, <parameter><decl><type><name>Edge</name> <modifier>*</modifier></type><name>edge_table</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Gene</name></type>		<name>friend</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>minimum_edges</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>minimum_count</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rand_decision</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * no point has edges to more than 4 other points thus, this contrived
	 * minimum will be replaced
	 */</comment>

	<expr_stmt><expr><name>minimum_edges</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>

	<comment type="block">/* consider candidate destination points in edge list */</comment>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>edge</name><operator>.</operator><name>unused_edges</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>friend</name> <operator>=</operator> <operator>(</operator><name>Gene</name><operator>)</operator> <name><name>edge</name><operator>.</operator><name>edge_list</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * give priority to shared edges that are negative; so return 'em
		 */</comment>

		<comment type="block">/*
		 * negative values are caught here so we need not worry about
		 * converting to absolute values
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>friend</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>(</operator><name>Gene</name><operator>)</operator> <call><name>Abs</name><argument_list>(<argument><expr><name>friend</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


		<comment type="block">/*
		 * give priority to candidates with fewest remaining unused edges;
		 * find out what the minimum number of unused edges is
		 * (minimum_edges); if there is more than one candidate with the
		 * minimum number of unused edges keep count of this number
		 * (minimum_count);
		 */</comment>

		<comment type="block">/*
		 * The test for minimum_count can probably be removed at some point
		 * but comments should probably indicate exactly why it is guaranteed
		 * that the test will always succeed the first time around.  If it can
		 * fail then the code is in error
		 */</comment>


		<if_stmt><if>if <condition>(<expr><name><name>edge_table</name><index>[<expr><operator>(</operator><name>int</name><operator>)</operator> <name>friend</name></expr>]</index></name><operator>.</operator><name>unused_edges</name> <operator>&lt;</operator> <name>minimum_edges</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>minimum_edges</name> <operator>=</operator> <name><name>edge_table</name><index>[<expr><operator>(</operator><name>int</name><operator>)</operator> <name>friend</name></expr>]</index></name><operator>.</operator><name>unused_edges</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>minimum_count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>minimum_count</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"minimum_count not set"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>edge_table</name><index>[<expr><operator>(</operator><name>int</name><operator>)</operator> <name>friend</name></expr>]</index></name><operator>.</operator><name>unused_edges</name> <operator>==</operator> <name>minimum_edges</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>minimum_count</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	</block_content>}</block></for>							<comment type="block">/* for (i=0; i&lt;edge.unused_edges; i++) */</comment>


	<comment type="block">/* random decision of the possible candidates to use */</comment>
	<expr_stmt><expr><name>rand_decision</name> <operator>=</operator> <call><name>geqo_randint</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>minimum_count</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>edge</name><operator>.</operator><name>unused_edges</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>friend</name> <operator>=</operator> <operator>(</operator><name>Gene</name><operator>)</operator> <name><name>edge</name><operator>.</operator><name>edge_list</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/* return the chosen candidate point */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>edge_table</name><index>[<expr><operator>(</operator><name>int</name><operator>)</operator> <name>friend</name></expr>]</index></name><operator>.</operator><name>unused_edges</name> <operator>==</operator> <name>minimum_edges</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>minimum_count</name><operator>--</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>minimum_count</name> <operator>==</operator> <name>rand_decision</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>friend</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* ... should never be reached */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"neither shared nor minimum number nor random edge found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>					<comment type="block">/* to keep the compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/* edge_failure
 *
 *	  routine for handling edge failure
 *
 */</comment>
<function><type><specifier>static</specifier> <name>Gene</name></type>
<name>edge_failure</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Gene</name> <modifier>*</modifier></type><name>gene</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>Edge</name> <modifier>*</modifier></type><name>edge_table</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num_gene</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Gene</name></type>		<name>fail_gene</name> <init>= <expr><name><name>gene</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>remaining_edges</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>four_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rand_decision</name></decl>;</decl_stmt>


	<comment type="block">/*
	 * how many edges remain? how many gene with four total (initial) edges
	 * remain?
	 */</comment>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>num_gene</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>edge_table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>unused_edges</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>i</name> <operator>!=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>fail_gene</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>remaining_edges</name><operator>++</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>edge_table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>total_edges</name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>four_count</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * random decision of the gene with remaining edges and whose total_edges
	 * == 4
	 */</comment>

	<if_stmt><if>if <condition>(<expr><name>four_count</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>

		<expr_stmt><expr><name>rand_decision</name> <operator>=</operator> <call><name>geqo_randint</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>four_count</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>num_gene</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>

			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Gene</name><operator>)</operator> <name>i</name> <operator>!=</operator> <name>fail_gene</name> <operator>&amp;&amp;</operator>
				<name><name>edge_table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>unused_edges</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
				<name><name>edge_table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>total_edges</name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition>
			<block>{<block_content>

				<expr_stmt><expr><name>four_count</name><operator>--</operator></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>rand_decision</name> <operator>==</operator> <name>four_count</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><operator>(</operator><name>Gene</name><operator>)</operator> <name>i</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"no edge found via random decision and total_edges == 4"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>remaining_edges</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* random decision of the gene with remaining edges */</comment>
		<expr_stmt><expr><name>rand_decision</name> <operator>=</operator> <call><name>geqo_randint</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>remaining_edges</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>num_gene</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>

			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Gene</name><operator>)</operator> <name>i</name> <operator>!=</operator> <name>fail_gene</name> <operator>&amp;&amp;</operator>
				<name><name>edge_table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>unused_edges</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>

				<expr_stmt><expr><name>remaining_edges</name><operator>--</operator></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>rand_decision</name> <operator>==</operator> <name>remaining_edges</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"no edge found via random decision with remaining edges"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>

	<comment type="block">/*
	 * edge table seems to be empty; this happens sometimes on the last point
	 * due to the fact that the first point is removed from the table even
	 * though only one of its edges has been determined
	 */</comment>

	<else>else
	<block>{<block_content>							<comment type="block">/* occurs only at the last point in the tour;
								 * simply look for the point which is not yet
								 * used */</comment>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>num_gene</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><name><name>edge_table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>unused_edges</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>(</operator><name>Gene</name><operator>)</operator> <name>i</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"no edge found via looking for the last unused point"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>


	<comment type="block">/* ... should never be reached */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no edge found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>					<comment type="block">/* to keep the compiler quiet */</comment>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* defined(ERX) */</comment>
</unit>
