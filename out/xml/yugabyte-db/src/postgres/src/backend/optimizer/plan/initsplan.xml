<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/optimizer/plan/initsplan.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * initsplan.c
 *	  Target list, qualification, joininfo initialization routines
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/optimizer/plan/initsplan.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/joininfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/paths.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/placeholder.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/prep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/restrictinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/var.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/analyze.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>


<comment type="block">/* These parameters are set by GUC */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>from_collapse_limit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>join_collapse_limit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>yb_bnl_batch_size</name></decl>;</decl_stmt>


<comment type="block">/* Elements of the postponed_qual_list used during deconstruct_recurse */</comment>
<typedef>typedef <type><struct>struct <name>PostponedQual</name>
<block>{
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>qual</name></decl>;</decl_stmt>			<comment type="block">/* a qual clause waiting to be processed */</comment>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>relids</name></decl>;</decl_stmt>			<comment type="block">/* the set of baserels it references */</comment>
}</block></struct></type> <name>PostponedQual</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>extract_lateral_references</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>brel</name></decl></parameter>,
						   <parameter><decl><type><name>Index</name></type> <name>rtindex</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>deconstruct_recurse</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>below_outer_join</name></decl></parameter>,
					<parameter><decl><type><name>Relids</name> <modifier>*</modifier></type><name>qualscope</name></decl></parameter>, <parameter><decl><type><name>Relids</name> <modifier>*</modifier></type><name>inner_join_rels</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>postponed_qual_list</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>process_security_barrier_quals</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>qualscope</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>below_outer_join</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>make_outerjoininfo</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
				   <parameter><decl><type><name>Relids</name></type> <name>left_rels</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>right_rels</name></decl></parameter>,
				   <parameter><decl><type><name>Relids</name></type> <name>inner_join_rels</name></decl></parameter>,
				   <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>compute_semijoin_info</name><parameter_list>(<parameter><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>distribute_qual_to_rels</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>is_deduced</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>below_outer_join</name></decl></parameter>,
						<parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
						<parameter><decl><type><name>Index</name></type> <name>security_level</name></decl></parameter>,
						<parameter><decl><type><name>Relids</name></type> <name>qualscope</name></decl></parameter>,
						<parameter><decl><type><name>Relids</name></type> <name>ojscope</name></decl></parameter>,
						<parameter><decl><type><name>Relids</name></type> <name>outerjoin_nonnullable</name></decl></parameter>,
						<parameter><decl><type><name>Relids</name></type> <name>deduced_nullable_relids</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>postponed_qual_list</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_outerjoin_delay</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Relids</name> <modifier>*</modifier></type><name>relids_p</name></decl></parameter>,
					  <parameter><decl><type><name>Relids</name> <modifier>*</modifier></type><name>nullable_relids_p</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pushed_down</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_equivalence_delay</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						<parameter><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>restrictinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_redundant_nullability_qual</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_mergejoinable</name><parameter_list>(<parameter><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>restrictinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_hashjoinable</name><parameter_list>(<parameter><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>restrictinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_batchable</name><parameter_list>(<parameter><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>restrictinfo</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block" format="doxygen">/*****************************************************************************
 *
 *	 JOIN TREES
 *
 *****************************************************************************/</comment>

<comment type="block">/*
 * add_base_rels_to_query
 *
 *	  Scan the query's jointree and create baserel RelOptInfos for all
 *	  the base relations (ie, table, subquery, and function RTEs)
 *	  appearing in the jointree.
 *
 * The initial invocation must pass root-&gt;parse-&gt;jointree as the value of
 * jtnode.  Internally, the function recurses through the jointree.
 *
 * At the end of this process, there should be one baserel RelOptInfo for
 * every non-join RTE that is used in the query.  Therefore, this routine
 * is the only place that should call build_simple_rel with reloptkind
 * RELOPT_BASEREL.  (Note: build_simple_rel recurses internally to build
 * "other rel" RelOptInfos for the members of any appendrels we find here.)
 */</comment>
<function><type><name>void</name></type>
<name>add_base_rels_to_query</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>jtnode</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>varno</name> <init>= <expr><operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>jtnode</name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>build_simple_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>varno</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FromExpr</name>   <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator><name>FromExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>f-&gt;fromlist</argument>)</argument_list></macro>
			<expr_stmt><expr><call><name>add_base_rels_to_query</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>j</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>add_base_rels_to_query</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>add_base_rels_to_query</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 *
 *	 TARGET LISTS
 *
 *****************************************************************************/</comment>

<comment type="block">/*
 * build_base_rel_tlists
 *	  Add targetlist entries for each var needed in the query's final tlist
 *	  (and HAVING clause, if any) to the appropriate base relations.
 *
 * We mark such vars as needed by "relation 0" to ensure that they will
 * propagate up through all join plan steps.
 */</comment>
<function><type><name>void</name></type>
<name>build_base_rel_tlists</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>final_tlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist_vars</name> <init>= <expr><call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>final_tlist</name></expr></argument>,
											 <argument><expr><name>PVC_RECURSE_AGGREGATES</name> <operator>|</operator>
											 <name>PVC_RECURSE_WINDOWFUNCS</name> <operator>|</operator>
											 <name>PVC_INCLUDE_PLACEHOLDERS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>tlist_vars</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>add_vars_to_targetlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>tlist_vars</name></expr></argument>, <argument><expr><call><name>bms_make_singleton</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>tlist_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If there's a HAVING clause, we'll need the Vars it uses, too.  Note
	 * that HAVING can contain Aggrefs but not WindowFuncs.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>having_vars</name> <init>= <expr><call><name>pull_var_clause</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>,
												  <argument><expr><name>PVC_RECURSE_AGGREGATES</name> <operator>|</operator>
												  <name>PVC_INCLUDE_PLACEHOLDERS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>having_vars</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>add_vars_to_targetlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>having_vars</name></expr></argument>,
								   <argument><expr><call><name>bms_make_singleton</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>having_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * add_vars_to_targetlist
 *	  For each variable appearing in the list, add it to the owning
 *	  relation's targetlist if not already present, and mark the variable
 *	  as being needed for the indicated join (or for final output if
 *	  where_needed includes "relation 0").
 *
 *	  The list may also contain PlaceHolderVars.  These don't necessarily
 *	  have a single owning relation; we keep their attr_needed info in
 *	  root-&gt;placeholder_list instead.  If create_new_ph is true, it's OK
 *	  to create new PlaceHolderInfos; otherwise, the PlaceHolderInfos must
 *	  already exist, and we should only update their ph_needed.  (This should
 *	  be true before deconstruct_jointree begins, and false after that.)
 */</comment>
<function><type><name>void</name></type>
<name>add_vars_to_targetlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>vars</name></decl></parameter>,
					   <parameter><decl><type><name>Relids</name></type> <name>where_needed</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>create_new_ph</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>where_needed</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>temp</argument>, <argument>vars</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><call><name>find_base_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>attno</name> <init>= <expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name>where_needed</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attno</name> <operator>&gt;=</operator> <name><name>rel</name><operator>-&gt;</operator><name>min_attr</name></name> <operator>&amp;&amp;</operator> <name>attno</name> <operator>&lt;=</operator> <name><name>rel</name><operator>-&gt;</operator><name>max_attr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>attno</name> <operator>-=</operator> <name><name>rel</name><operator>-&gt;</operator><name>min_attr</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>attr_needed</name><index>[<expr><name>attno</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Variable not yet requested, so add to rel's targetlist */</comment>
				<comment type="block">/* XXX is copyObject necessary here? */</comment>
				<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>,
												<argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* reltarget cost and width will be computed later */</comment>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>attr_needed</name><index>[<expr><name>attno</name></expr>]</index></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>attr_needed</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>,
													  <argument><expr><name>where_needed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>phv</name> <init>= <expr><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PlaceHolderInfo</name> <modifier>*</modifier></type><name>phinfo</name> <init>= <expr><call><name>find_placeholder_info</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>phv</name></expr></argument>,
															<argument><expr><name>create_new_ph</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_needed</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_needed</name></name></expr></argument>,
												<argument><expr><name>where_needed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 *
 *	  LATERAL REFERENCES
 *
 *****************************************************************************/</comment>

<comment type="block">/*
 * find_lateral_references
 *	  For each LATERAL subquery, extract all its references to Vars and
 *	  PlaceHolderVars of the current query level, and make sure those values
 *	  will be available for evaluation of the subquery.
 *
 * While later planning steps ensure that the Var/PHV source rels are on the
 * outside of nestloops relative to the LATERAL subquery, we also need to
 * ensure that the Vars/PHVs propagate up to the nestloop join level; this
 * means setting suitable where_needed values for them.
 *
 * Note that this only deals with lateral references in unflattened LATERAL
 * subqueries.  When we flatten a LATERAL subquery, its lateral references
 * become plain Vars in the parent query, but they may have to be wrapped in
 * PlaceHolderVars if they need to be forced NULL by outer joins that don't
 * also null the LATERAL subquery.  That's all handled elsewhere.
 *
 * This has to run before deconstruct_jointree, since it might result in
 * creation of PlaceHolderInfos.
 */</comment>
<function><type><name>void</name></type>
<name>find_lateral_references</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Index</name></type>		<name>rti</name></decl>;</decl_stmt>

	<comment type="block">/* We need do nothing if the query contains no LATERAL RTEs */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>root</name><operator>-&gt;</operator><name>hasLateralRTEs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Examine all baserels (the rel array has been set up by now).
	 */</comment>
	<for>for <control>(<init><expr><name>rti</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>rti</name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name></expr>;</condition> <incr><expr><name>rti</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>brel</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>rti</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* there may be empty slots corresponding to non-baserel RTEs */</comment>
		<if_stmt><if>if <condition>(<expr><name>brel</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>brel</name><operator>-&gt;</operator><name>relid</name></name> <operator>==</operator> <name>rti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* sanity check on array */</comment>

		<comment type="block">/*
		 * This bit is less obvious than it might look.  We ignore appendrel
		 * otherrels and consider only their parent baserels.  In a case where
		 * a LATERAL-containing UNION ALL subquery was pulled up, it is the
		 * otherrel that is actually going to be in the plan.  However, we
		 * want to mark all its lateral references as needed by the parent,
		 * because it is the parent's relid that will be used for join
		 * planning purposes.  And the parent's RTE will contain all the
		 * lateral references we need to know, since the pulled-up member is
		 * nothing but a copy of parts of the original RTE's subquery.  We
		 * could visit the parent's children instead and transform their
		 * references back to the parent's relid, but it would be much more
		 * complicated for no real gain.  (Important here is that the child
		 * members have not yet received any processing beyond being pulled
		 * up.)  Similarly, in appendrels created by inheritance expansion,
		 * it's sufficient to look at the parent relation.
		 */</comment>

		<comment type="block">/* ignore RTEs that are "other rels" */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>brel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>!=</operator> <name>RELOPT_BASEREL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>extract_lateral_references</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>brel</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>extract_lateral_references</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>brel</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rtindex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name>rtindex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>vars</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newvars</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>where_needed</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* No cross-references are possible if it's not LATERAL */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rte</name><operator>-&gt;</operator><name>lateral</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Fetch the appropriate variables */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>vars</name> <operator>=</operator> <call><name>pull_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>tablesample</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>vars</name> <operator>=</operator> <call><name>pull_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_FUNCTION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>vars</name> <operator>=</operator> <call><name>pull_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_TABLEFUNC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>vars</name> <operator>=</operator> <call><name>pull_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>tablefunc</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_VALUES</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>vars</name> <operator>=</operator> <call><name>pull_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>					<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>vars</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* nothing to do */</comment>

	<comment type="block">/* Copy each Var (or PlaceHolderVar) and adjust it to match our level */</comment>
	<expr_stmt><expr><name>newvars</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>vars</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Adjustment is easy since it's just one node */</comment>
			<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>phv</name> <init>= <expr><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>levelsup</name> <init>= <expr><name><name>phv</name><operator>-&gt;</operator><name>phlevelsup</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Have to work harder to adjust the contained expression too */</comment>
			<if_stmt><if>if <condition>(<expr><name>levelsup</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>IncrementVarSublevelsUp</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>-</operator><name>levelsup</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * If we pulled the PHV out of a subquery RTE, its expression
			 * needs to be preprocessed.  subquery_planner() already did this
			 * for level-zero PHVs in function and values RTEs, though.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>levelsup</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>phv</name><operator>-&gt;</operator><name>phexpr</name></name> <operator>=</operator> <call><name>preprocess_phv_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>phv</name><operator>-&gt;</operator><name>phexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>newvars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newvars</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We mark the Vars as being "needed" at the LATERAL RTE.  This is a bit
	 * of a cheat: a more formal approach would be to mark each one as needed
	 * at the join of the LATERAL RTE with its source RTE.  But it will work,
	 * and it's much less tedious than computing a separate where_needed for
	 * each Var.
	 */</comment>
	<expr_stmt><expr><name>where_needed</name> <operator>=</operator> <call><name>bms_make_singleton</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Push Vars into their source relations' targetlists, and PHVs into
	 * root-&gt;placeholder_list.
	 */</comment>
	<expr_stmt><expr><call><name>add_vars_to_targetlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>newvars</name></expr></argument>, <argument><expr><name>where_needed</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Remember the lateral references for create_lateral_join_info */</comment>
	<expr_stmt><expr><name><name>brel</name><operator>-&gt;</operator><name>lateral_vars</name></name> <operator>=</operator> <name>newvars</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * create_lateral_join_info
 *	  Fill in the per-base-relation direct_lateral_relids, lateral_relids
 *	  and lateral_referencers sets.
 *
 * This has to run after deconstruct_jointree, because we need to know the
 * final ph_eval_at values for PlaceHolderVars.
 */</comment>
<function><type><name>void</name></type>
<name>create_lateral_join_info</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found_laterals</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name>		<name>prev_parents</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>rti</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* We need do nothing if the query contains no LATERAL RTEs */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>root</name><operator>-&gt;</operator><name>hasLateralRTEs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Examine all baserels (the rel array has been set up by now).
	 */</comment>
	<for>for <control>(<init><expr><name>rti</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>rti</name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name></expr>;</condition> <incr><expr><name>rti</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>brel</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>rti</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>lateral_relids</name></decl>;</decl_stmt>

		<comment type="block">/* there may be empty slots corresponding to non-baserel RTEs */</comment>
		<if_stmt><if>if <condition>(<expr><name>brel</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>brel</name><operator>-&gt;</operator><name>relid</name></name> <operator>==</operator> <name>rti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* sanity check on array */</comment>

		<comment type="block">/* ignore RTEs that are "other rels" */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>brel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>!=</operator> <name>RELOPT_BASEREL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>lateral_relids</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/* consider each laterally-referenced Var or PHV */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>brel-&gt;lateral_vars</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>found_laterals</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>lateral_relids</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>lateral_relids</name></expr></argument>,
												<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>phv</name> <init>= <expr><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PlaceHolderInfo</name> <modifier>*</modifier></type><name>phinfo</name> <init>= <expr><call><name>find_placeholder_info</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>phv</name></expr></argument>,
																<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>found_laterals</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>lateral_relids</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>lateral_relids</name></expr></argument>,
												 <argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_eval_at</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>

		<comment type="block">/* We now have all the simple lateral refs from this rel */</comment>
		<expr_stmt><expr><name><name>brel</name><operator>-&gt;</operator><name>direct_lateral_relids</name></name> <operator>=</operator> <name>lateral_relids</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>brel</name><operator>-&gt;</operator><name>lateral_relids</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>lateral_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Now check for lateral references within PlaceHolderVars, and mark their
	 * eval_at rels as having lateral references to the source rels.
	 *
	 * For a PHV that is due to be evaluated at a baserel, mark its source(s)
	 * as direct lateral dependencies of the baserel (adding onto the ones
	 * recorded above).  If it's due to be evaluated at a join, mark its
	 * source(s) as indirect lateral dependencies of each baserel in the join,
	 * ie put them into lateral_relids but not direct_lateral_relids.  This is
	 * appropriate because we can't put any such baserel on the outside of a
	 * join to one of the PHV's lateral dependencies, but on the other hand we
	 * also can't yet join it directly to the dependency.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;placeholder_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlaceHolderInfo</name> <modifier>*</modifier></type><name>phinfo</name> <init>= <expr><operator>(</operator><name>PlaceHolderInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>eval_at</name> <init>= <expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_eval_at</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>varno</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_lateral</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* PHV is uninteresting if no lateral refs */</comment>

		<expr_stmt><expr><name>found_laterals</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>bms_get_singleton_member</name><argument_list>(<argument><expr><name>eval_at</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>varno</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Evaluation site is a baserel */</comment>
			<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>brel</name> <init>= <expr><call><name>find_base_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>varno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>brel</name><operator>-&gt;</operator><name>direct_lateral_relids</name></name> <operator>=</operator>
				<call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>brel</name><operator>-&gt;</operator><name>direct_lateral_relids</name></name></expr></argument>,
								<argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_lateral</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>brel</name><operator>-&gt;</operator><name>lateral_relids</name></name> <operator>=</operator>
				<call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>brel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>,
								<argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_lateral</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Evaluation site is a join */</comment>
			<expr_stmt><expr><name>varno</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<while>while <condition>(<expr><operator>(</operator><name>varno</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>eval_at</name></expr></argument>, <argument><expr><name>varno</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>brel</name> <init>= <expr><call><name>find_base_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>varno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>brel</name><operator>-&gt;</operator><name>lateral_relids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>brel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>,
													   <argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_lateral</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If we found no actual lateral references, we're done; but reset the
	 * hasLateralRTEs flag to avoid useless work later.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found_laterals</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>hasLateralRTEs</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Calculate the transitive closure of the lateral_relids sets, so that
	 * they describe both direct and indirect lateral references.  If relation
	 * X references Y laterally, and Y references Z laterally, then we will
	 * have to scan X on the inside of a nestloop with Z, so for all intents
	 * and purposes X is laterally dependent on Z too.
	 *
	 * This code is essentially Warshall's algorithm for transitive closure.
	 * The outer loop considers each baserel, and propagates its lateral
	 * dependencies to those baserels that have a lateral dependency on it.
	 */</comment>
	<for>for <control>(<init><expr><name>rti</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>rti</name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name></expr>;</condition> <incr><expr><name>rti</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>brel</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>rti</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>outer_lateral_relids</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Index</name></type>		<name>rti2</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>brel</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>brel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>!=</operator> <name>RELOPT_BASEREL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* need not consider baserel further if it has no lateral refs */</comment>
		<expr_stmt><expr><name>outer_lateral_relids</name> <operator>=</operator> <name><name>brel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>outer_lateral_relids</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* else scan all baserels */</comment>
		<for>for <control>(<init><expr><name>rti2</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>rti2</name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name></expr>;</condition> <incr><expr><name>rti2</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>brel2</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>rti2</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>brel2</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>brel2</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>!=</operator> <name>RELOPT_BASEREL</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* if brel2 has lateral ref to brel, propagate brel's refs */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>rti</name></expr></argument>, <argument><expr><name><name>brel2</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>brel2</name><operator>-&gt;</operator><name>lateral_relids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>brel2</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>,
														<argument><expr><name>outer_lateral_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Now that we've identified all lateral references, mark each baserel
	 * with the set of relids of rels that reference it laterally (possibly
	 * indirectly) --- that is, the inverse mapping of lateral_relids.
	 */</comment>
	<for>for <control>(<init><expr><name>rti</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>rti</name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name></expr>;</condition> <incr><expr><name>rti</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>brel</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>rti</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>lateral_relids</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>rti2</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>brel</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>brel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>!=</operator> <name>RELOPT_BASEREL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Nothing to do at rels with no lateral refs */</comment>
		<expr_stmt><expr><name>lateral_relids</name> <operator>=</operator> <name><name>brel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>lateral_relids</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We should not have broken the invariant that lateral_relids is
		 * exactly NULL if empty.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>lateral_relids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Also, no rel should have a lateral dependency on itself */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>rti</name></expr></argument>, <argument><expr><name>lateral_relids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Mark this rel's referencees */</comment>
		<expr_stmt><expr><name>rti2</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>rti2</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>lateral_relids</name></expr></argument>, <argument><expr><name>rti2</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>brel2</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>rti2</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>brel2</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>brel2</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_BASEREL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>brel2</name><operator>-&gt;</operator><name>lateral_referencers</name></name> <operator>=</operator>
				<call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>brel2</name><operator>-&gt;</operator><name>lateral_referencers</name></name></expr></argument>, <argument><expr><name>rti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Lastly, propagate lateral_relids and lateral_referencers from appendrel
	 * parent rels to their child rels.  We intentionally give each child rel
	 * the same minimum parameterization, even though it's quite possible that
	 * some don't reference all the lateral rels.  This is because any append
	 * path for the parent will have to have the same parameterization for
	 * every child anyway, and there's no value in forcing extra
	 * reparameterize_path() calls.  Similarly, a lateral reference to the
	 * parent prevents use of otherwise-movable join rels for each child.
	 *
	 * It's possible for child rels to have their own children, in which case
	 * the topmost parent's lateral info must be propagated all the way down.
	 * This code handles that case correctly so long as append_rel_list has
	 * entries for child relationships before grandchild relationships, which
	 * is an okay assumption right now, but we'll need to be careful to
	 * preserve it.  The assertions below check for incorrect ordering.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;append_rel_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><operator>(</operator><name>AppendRelInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>parentrel</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>childrel</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If we're processing a subquery of a query with inherited target rel
		 * (cf. inheritance_planner), append_rel_list may contain entries for
		 * tables that are not part of the current subquery and hence have no
		 * RelOptInfo.  Ignore them.  We can ignore dead rels, too.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>parentrel</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IS_SIMPLE_REL</name><argument_list>(<argument><expr><name>parentrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Verify that children are processed before grandchildren */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
		<expr_stmt><expr><name>prev_parents</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>prev_parents</name></expr></argument>, <argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr></argument>, <argument><expr><name>prev_parents</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/* OK, propagate info down */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>childrel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_OTHER_MEMBER_REL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>childrel</name><operator>-&gt;</operator><name>direct_lateral_relids</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>childrel</name><operator>-&gt;</operator><name>direct_lateral_relids</name></name> <operator>=</operator> <name><name>parentrel</name><operator>-&gt;</operator><name>direct_lateral_relids</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>childrel</name><operator>-&gt;</operator><name>lateral_relids</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>childrel</name><operator>-&gt;</operator><name>lateral_relids</name></name> <operator>=</operator> <name><name>parentrel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>childrel</name><operator>-&gt;</operator><name>lateral_referencers</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>childrel</name><operator>-&gt;</operator><name>lateral_referencers</name></name> <operator>=</operator> <name><name>parentrel</name><operator>-&gt;</operator><name>lateral_referencers</name></name></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 *
 *	  JOIN TREE PROCESSING
 *
 *****************************************************************************/</comment>

<comment type="block">/*
 * deconstruct_jointree
 *	  Recursively scan the query's join tree for WHERE and JOIN/ON qual
 *	  clauses, and add these to the appropriate restrictinfo and joininfo
 *	  lists belonging to base RelOptInfos.  Also, add SpecialJoinInfo nodes
 *	  to root-&gt;join_info_list for any outer joins appearing in the query tree.
 *	  Return a "joinlist" data structure showing the join order decisions
 *	  that need to be made by make_one_rel().
 *
 * The "joinlist" result is a list of items that are either RangeTblRef
 * jointree nodes or sub-joinlists.  All the items at the same level of
 * joinlist must be joined in an order to be determined by make_one_rel()
 * (note that legal orders may be constrained by SpecialJoinInfo nodes).
 * A sub-joinlist represents a subproblem to be planned separately. Currently
 * sub-joinlists arise only from FULL OUTER JOIN or when collapsing of
 * subproblems is stopped by join_collapse_limit or from_collapse_limit.
 *
 * NOTE: when dealing with inner joins, it is appropriate to let a qual clause
 * be evaluated at the lowest level where all the variables it mentions are
 * available.  However, we cannot push a qual down into the nullable side(s)
 * of an outer join since the qual might eliminate matching rows and cause a
 * NULL row to be incorrectly emitted by the join.  Therefore, we artificially
 * OR the minimum-relids of such an outer join into the required_relids of
 * clauses appearing above it.  This forces those clauses to be delayed until
 * application of the outer join (or maybe even higher in the join tree).
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>deconstruct_jointree</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>qualscope</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>inner_join_rels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>postponed_qual_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Start recursion at top of jointree */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>jointree</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		   <call><name>IsA</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* this is filled as we scan the jointree */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>nullable_baserels</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>deconstruct_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>qualscope</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_join_rels</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>postponed_qual_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Shouldn't be any leftover quals */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>postponed_qual_list</name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * deconstruct_recurse
 *	  One recursion level of deconstruct_jointree processing.
 *
 * Inputs:
 *	jtnode is the jointree node to examine
 *	below_outer_join is true if this node is within the nullable side of a
 *		higher-level outer join
 * Outputs:
 *	*qualscope gets the set of base Relids syntactically included in this
 *		jointree node (do not modify or free this, as it may also be pointed
 *		to by RestrictInfo and SpecialJoinInfo nodes)
 *	*inner_join_rels gets the set of base Relids syntactically included in
 *		inner joins appearing at or below this jointree node (do not modify
 *		or free this, either)
 *	*postponed_qual_list is a list of PostponedQual structs, which we can
 *		add quals to if they turn out to belong to a higher join level
 *	Return value is the appropriate joinlist for this jointree node
 *
 * In addition, entries will be added to root-&gt;join_info_list for outer joins.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>deconstruct_recurse</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>below_outer_join</name></decl></parameter>,
					<parameter><decl><type><name>Relids</name> <modifier>*</modifier></type><name>qualscope</name></decl></parameter>, <parameter><decl><type><name>Relids</name> <modifier>*</modifier></type><name>inner_join_rels</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>postponed_qual_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>joinlist</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>jtnode</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>qualscope</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>inner_join_rels</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>varno</name> <init>= <expr><operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>jtnode</name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* qualscope is just the one RTE */</comment>
		<expr_stmt><expr><operator>*</operator><name>qualscope</name> <operator>=</operator> <call><name>bms_make_singleton</name><argument_list>(<argument><expr><name>varno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Deal with any securityQuals attached to the RTE */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>qual_security_level</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>process_security_barrier_quals</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										   <argument><expr><name>varno</name></expr></argument>,
										   <argument><expr><operator>*</operator><name>qualscope</name></expr></argument>,
										   <argument><expr><name>below_outer_join</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* A single baserel does not create an inner join */</comment>
		<expr_stmt><expr><operator>*</operator><name>inner_join_rels</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>joinlist</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FromExpr</name>   <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator><name>FromExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>child_postponed_quals</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>remaining</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * First, recurse to handle child joins.  We collapse subproblems into
		 * a single joinlist whenever the resulting joinlist wouldn't exceed
		 * from_collapse_limit members.  Also, always collapse one-element
		 * subproblems, since that won't lengthen the joinlist anyway.
		 */</comment>
		<expr_stmt><expr><operator>*</operator><name>qualscope</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>inner_join_rels</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>joinlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>remaining</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>fromlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>f-&gt;fromlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Relids</name></type>		<name>sub_qualscope</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sub_joinlist</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>sub_members</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>sub_joinlist</name> <operator>=</operator> <call><name>deconstruct_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><name>below_outer_join</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>sub_qualscope</name></expr></argument>,
											   <argument><expr><name>inner_join_rels</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>child_postponed_quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>qualscope</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><operator>*</operator><name>qualscope</name></expr></argument>, <argument><expr><name>sub_qualscope</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sub_members</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>sub_joinlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>remaining</name><operator>--</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>sub_members</name> <operator>&lt;=</operator> <literal type="number">1</literal> <operator>||</operator>
				<call><name>list_length</name><argument_list>(<argument><expr><name>joinlist</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>sub_members</name> <operator>+</operator> <name>remaining</name> <operator>&lt;=</operator> <name>from_collapse_limit</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>joinlist</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>joinlist</name></expr></argument>, <argument><expr><name>sub_joinlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>joinlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>joinlist</name></expr></argument>, <argument><expr><name>sub_joinlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * A FROM with more than one list element is an inner join subsuming
		 * all below it, so we should report inner_join_rels = qualscope. If
		 * there was exactly one element, we should (and already did) report
		 * whatever its inner_join_rels were.  If there were no elements (is
		 * that possible?) the initialization before the loop fixed it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>fromlist</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>inner_join_rels</name> <operator>=</operator> <operator>*</operator><name>qualscope</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Try to process any quals postponed by children.  If they need
		 * further postponement, add them to my output postponed_qual_list.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>child_postponed_quals</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PostponedQual</name> <modifier>*</modifier></type><name>pq</name> <init>= <expr><operator>(</operator><name>PostponedQual</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>pq</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><operator>*</operator><name>qualscope</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>distribute_qual_to_rels</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>pq</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>, <argument><expr><name>below_outer_join</name></expr></argument>, <argument><expr><name>JOIN_INNER</name></expr></argument>,
										<argument><expr><name><name>root</name><operator>-&gt;</operator><name>qual_security_level</name></name></expr></argument>,
										<argument><expr><operator>*</operator><name>qualscope</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>postponed_qual_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>postponed_qual_list</name></expr></argument>, <argument><expr><name>pq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Now process the top-level quals.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>(List *) f-&gt;quals</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>qual</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>distribute_qual_to_rels</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>,
									<argument><expr><name>false</name></expr></argument>, <argument><expr><name>below_outer_join</name></expr></argument>, <argument><expr><name>JOIN_INNER</name></expr></argument>,
									<argument><expr><name><name>root</name><operator>-&gt;</operator><name>qual_security_level</name></name></expr></argument>,
									<argument><expr><operator>*</operator><name>qualscope</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									<argument><expr><name>postponed_qual_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>j</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>child_postponed_quals</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>leftids</name></decl>,
					<decl><type ref="prev"/><name>rightids</name></decl>,
					<decl><type ref="prev"/><name>left_inners</name></decl>,
					<decl><type ref="prev"/><name>right_inners</name></decl>,
					<decl><type ref="prev"/><name>nonnullable_rels</name></decl>,
					<decl><type ref="prev"/><name>nullable_rels</name></decl>,
					<decl><type ref="prev"/><name>ojscope</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>leftjoinlist</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>rightjoinlist</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>my_quals</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Order of operations here is subtle and critical.  First we recurse
		 * to handle sub-JOINs.  Their join quals will be placed without
		 * regard for whether this level is an outer join, which is correct.
		 * Then we place our own join quals, which are restricted by lower
		 * outer joins in any case, and are forced to this level if this is an
		 * outer join and they mention the outer side.  Finally, if this is an
		 * outer join, we create a join_info_list entry for the join.  This
		 * will prevent quals above us in the join tree that use those rels
		 * from being pushed down below this level.  (It's okay for upper
		 * quals to be pushed down to the outer side, however.)
		 */</comment>
		<switch>switch <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>jointype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>JOIN_INNER</name></expr>:</case>
				<expr_stmt><expr><name>leftjoinlist</name> <operator>=</operator> <call><name>deconstruct_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>,
												   <argument><expr><name>below_outer_join</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>leftids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>left_inners</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>child_postponed_quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rightjoinlist</name> <operator>=</operator> <call><name>deconstruct_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>,
													<argument><expr><name>below_outer_join</name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>rightids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>right_inners</name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>child_postponed_quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>qualscope</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name>leftids</name></expr></argument>, <argument><expr><name>rightids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>inner_join_rels</name> <operator>=</operator> <operator>*</operator><name>qualscope</name></expr>;</expr_stmt>
				<comment type="block">/* Inner join adds no restrictions for quals */</comment>
				<expr_stmt><expr><name>nonnullable_rels</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<comment type="block">/* and it doesn't force anything to null, either */</comment>
				<expr_stmt><expr><name>nullable_rels</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>JOIN_LEFT</name></expr>:</case>
			<case>case <expr><name>JOIN_ANTI</name></expr>:</case>
				<expr_stmt><expr><name>leftjoinlist</name> <operator>=</operator> <call><name>deconstruct_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>,
												   <argument><expr><name>below_outer_join</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>leftids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>left_inners</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>child_postponed_quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rightjoinlist</name> <operator>=</operator> <call><name>deconstruct_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>,
													<argument><expr><name>true</name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>rightids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>right_inners</name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>child_postponed_quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>qualscope</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name>leftids</name></expr></argument>, <argument><expr><name>rightids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>inner_join_rels</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name>left_inners</name></expr></argument>, <argument><expr><name>right_inners</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>nonnullable_rels</name> <operator>=</operator> <name>leftids</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>nullable_rels</name> <operator>=</operator> <name>rightids</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>JOIN_SEMI</name></expr>:</case>
				<expr_stmt><expr><name>leftjoinlist</name> <operator>=</operator> <call><name>deconstruct_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>,
												   <argument><expr><name>below_outer_join</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>leftids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>left_inners</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>child_postponed_quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rightjoinlist</name> <operator>=</operator> <call><name>deconstruct_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>,
													<argument><expr><name>below_outer_join</name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>rightids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>right_inners</name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>child_postponed_quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>qualscope</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name>leftids</name></expr></argument>, <argument><expr><name>rightids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>inner_join_rels</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name>left_inners</name></expr></argument>, <argument><expr><name>right_inners</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Semi join adds no restrictions for quals */</comment>
				<expr_stmt><expr><name>nonnullable_rels</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Theoretically, a semijoin would null the RHS; but since the
				 * RHS can't be accessed above the join, this is immaterial
				 * and we needn't account for it.
				 */</comment>
				<expr_stmt><expr><name>nullable_rels</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>JOIN_FULL</name></expr>:</case>
				<expr_stmt><expr><name>leftjoinlist</name> <operator>=</operator> <call><name>deconstruct_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>,
												   <argument><expr><name>true</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>leftids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>left_inners</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>child_postponed_quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rightjoinlist</name> <operator>=</operator> <call><name>deconstruct_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>,
													<argument><expr><name>true</name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>rightids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>right_inners</name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>child_postponed_quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>qualscope</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name>leftids</name></expr></argument>, <argument><expr><name>rightids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>inner_join_rels</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name>left_inners</name></expr></argument>, <argument><expr><name>right_inners</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* each side is both outer and inner */</comment>
				<expr_stmt><expr><name>nonnullable_rels</name> <operator>=</operator> <operator>*</operator><name>qualscope</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>nullable_rels</name> <operator>=</operator> <operator>*</operator><name>qualscope</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<comment type="block">/* JOIN_RIGHT was eliminated during reduce_outer_joins() */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized join type: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>j</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>nonnullable_rels</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
				<expr_stmt><expr><name>nullable_rels</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>leftjoinlist</name> <operator>=</operator> <name>rightjoinlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<comment type="block">/* Report all rels that will be nulled anywhere in the jointree */</comment>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>nullable_baserels</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>nullable_baserels</name></name></expr></argument>,
												  <argument><expr><name>nullable_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Try to process any quals postponed by children.  If they need
		 * further postponement, add them to my output postponed_qual_list.
		 * Quals that can be processed now must be included in my_quals, so
		 * that they'll be handled properly in make_outerjoininfo.
		 */</comment>
		<expr_stmt><expr><name>my_quals</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>child_postponed_quals</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PostponedQual</name> <modifier>*</modifier></type><name>pq</name> <init>= <expr><operator>(</operator><name>PostponedQual</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>pq</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><operator>*</operator><name>qualscope</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>my_quals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>my_quals</name></expr></argument>, <argument><expr><name><name>pq</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * We should not be postponing any quals past an outer join.
				 * If this Assert fires, pull_up_subqueries() messed up.
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_INNER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>postponed_qual_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>postponed_qual_list</name></expr></argument>, <argument><expr><name>pq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>
		<comment type="block">/* list_concat is nondestructive of its second argument */</comment>
		<expr_stmt><expr><name>my_quals</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>my_quals</name></expr></argument>, <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>j</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * For an OJ, form the SpecialJoinInfo now, because we need the OJ's
		 * semantic scope (ojscope) to pass to distribute_qual_to_rels.  But
		 * we mustn't add it to join_info_list just yet, because we don't want
		 * distribute_qual_to_rels to think it is an outer join below us.
		 *
		 * Semijoins are a bit of a hybrid: we build a SpecialJoinInfo, but we
		 * want ojscope = NULL for distribute_qual_to_rels.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_INNER</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>sjinfo</name> <operator>=</operator> <call><name>make_outerjoininfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										<argument><expr><name>leftids</name></expr></argument>, <argument><expr><name>rightids</name></expr></argument>,
										<argument><expr><operator>*</operator><name>inner_join_rels</name></expr></argument>,
										<argument><expr><name><name>j</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>,
										<argument><expr><name>my_quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_SEMI</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ojscope</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>ojscope</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>,
									<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>sjinfo</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ojscope</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Process the JOIN's qual clauses */</comment>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>my_quals</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>qual</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>distribute_qual_to_rels</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>,
									<argument><expr><name>false</name></expr></argument>, <argument><expr><name>below_outer_join</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>,
									<argument><expr><name><name>root</name><operator>-&gt;</operator><name>qual_security_level</name></name></expr></argument>,
									<argument><expr><operator>*</operator><name>qualscope</name></expr></argument>,
									<argument><expr><name>ojscope</name></expr></argument>, <argument><expr><name>nonnullable_rels</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									<argument><expr><name>postponed_qual_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* Now we can add the SpecialJoinInfo to join_info_list */</comment>
		<if_stmt><if>if <condition>(<expr><name>sjinfo</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>join_info_list</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>join_info_list</name></name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Each time we do that, recheck placeholder eval levels */</comment>
			<expr_stmt><expr><call><name>update_placeholder_eval_levels</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Finally, compute the output joinlist.  We fold subproblems together
		 * except at a FULL JOIN or where join_collapse_limit would be
		 * exceeded.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_FULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* force the join order exactly at this node */</comment>
			<expr_stmt><expr><name>joinlist</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>leftjoinlist</name></expr></argument>, <argument><expr><name>rightjoinlist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>leftjoinlist</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>rightjoinlist</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator>
				 <name>join_collapse_limit</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* OK to combine subproblems */</comment>
			<expr_stmt><expr><name>joinlist</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>leftjoinlist</name></expr></argument>, <argument><expr><name>rightjoinlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* can't combine, but needn't force join order above here */</comment>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>leftpart</name></decl>,
					   <decl><type ref="prev"><modifier>*</modifier></type><name>rightpart</name></decl>;</decl_stmt>

			<comment type="block">/* avoid creating useless 1-element sublists */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>leftjoinlist</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>leftpart</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>leftjoinlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>leftpart</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>leftjoinlist</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>rightjoinlist</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>rightpart</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>rightjoinlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>rightpart</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rightjoinlist</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>joinlist</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>leftpart</name></expr></argument>, <argument><expr><name>rightpart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>joinlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>			<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>joinlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * process_security_barrier_quals
 *	  Transfer security-barrier quals into relation's baserestrictinfo list.
 *
 * The rewriter put any relevant security-barrier conditions into the RTE's
 * securityQuals field, but it's now time to copy them into the rel's
 * baserestrictinfo.
 *
 * In inheritance cases, we only consider quals attached to the parent rel
 * here; they will be valid for all children too, so it's okay to consider
 * them for purposes like equivalence class creation.  Quals attached to
 * individual child rels will be dealt with during path creation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_security_barrier_quals</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>qualscope</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>below_outer_join</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name>rti</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>security_level</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Each element of the securityQuals list has been preprocessed into an
	 * implicitly-ANDed list of clauses.  All the clauses in a given sublist
	 * should get the same security level, but successive sublists get higher
	 * levels.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rte-&gt;securityQuals</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>qualset</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>qualset</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>qual</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * We cheat to the extent of passing ojscope = qualscope rather
			 * than its more logical value of NULL.  The only effect this has
			 * is to force a Var-free qual to be evaluated at the rel rather
			 * than being pushed up to top of tree, which we don't want.
			 */</comment>
			<expr_stmt><expr><call><name>distribute_qual_to_rels</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>,
									<argument><expr><name>false</name></expr></argument>,
									<argument><expr><name>below_outer_join</name></expr></argument>,
									<argument><expr><name>JOIN_INNER</name></expr></argument>,
									<argument><expr><name>security_level</name></expr></argument>,
									<argument><expr><name>qualscope</name></expr></argument>,
									<argument><expr><name>qualscope</name></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><name>security_level</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Assert that qual_security_level is higher than anything we just used */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>security_level</name> <operator>&lt;=</operator> <name><name>root</name><operator>-&gt;</operator><name>qual_security_level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * make_outerjoininfo
 *	  Build a SpecialJoinInfo for the current outer join
 *
 * Inputs:
 *	left_rels: the base Relids syntactically on outer side of join
 *	right_rels: the base Relids syntactically on inner side of join
 *	inner_join_rels: base Relids participating in inner joins below this one
 *	jointype: what it says (must always be LEFT, FULL, SEMI, or ANTI)
 *	clause: the outer join's join condition (in implicit-AND format)
 *
 * The node should eventually be appended to root-&gt;join_info_list, but we
 * do not do that here.
 *
 * Note: we assume that this function is invoked bottom-up, so that
 * root-&gt;join_info_list already contains entries for all outer joins that are
 * syntactically below this one.
 */</comment>
<function><type><specifier>static</specifier> <name>SpecialJoinInfo</name> <modifier>*</modifier></type>
<name>make_outerjoininfo</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
				   <parameter><decl><type><name>Relids</name></type> <name>left_rels</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>right_rels</name></decl></parameter>,
				   <parameter><decl><type><name>Relids</name></type> <name>inner_join_rels</name></decl></parameter>,
				   <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SpecialJoinInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>clause_relids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>strict_relids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>min_lefthand</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>min_righthand</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We should not see RIGHT JOIN here because left/right were switched
	 * earlier
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>jointype</name> <operator>!=</operator> <name>JOIN_INNER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>jointype</name> <operator>!=</operator> <name>JOIN_RIGHT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Presently the executor cannot support FOR [KEY] UPDATE/SHARE marking of
	 * rels appearing on the nullable side of an outer join. (It's somewhat
	 * unclear what that would mean, anyway: what should we mark when a result
	 * row is generated from no element of the nullable relation?)	So,
	 * complain if any nullable rel is FOR [KEY] UPDATE/SHARE.
	 *
	 * You might be wondering why this test isn't made far upstream in the
	 * parser.  It's because the parser hasn't got enough info --- consider
	 * FOR UPDATE applied to a view.  Only after rewriting and flattening do
	 * we know whether the view contains an outer join.
	 *
	 * We use the original RowMarkClause list here; the PlanRowMark list would
	 * list everything.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>root-&gt;parse-&gt;rowMarks</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RowMarkClause</name> <modifier>*</modifier></type><name>rc</name> <init>= <expr><operator>(</operator><name>RowMarkClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>rti</name></name></expr></argument>, <argument><expr><name>right_rels</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<operator>(</operator><name>jointype</name> <operator>==</operator> <name>JOIN_FULL</name> <operator>&amp;&amp;</operator> <call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>rti</name></name></expr></argument>, <argument><expr><name>left_rels</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
			<comment type="block">/*------
			 translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s cannot be applied to the nullable side of an outer join"</literal></expr></argument>,
							<argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>strength</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_lefthand</name></name> <operator>=</operator> <name>left_rels</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name> <operator>=</operator> <name>right_rels</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name> <operator>=</operator> <name>jointype</name></expr>;</expr_stmt>
	<comment type="block">/* this always starts out false */</comment>
	<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>delay_upper_joins</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>compute_semijoin_info</name><argument_list>(<argument><expr><name>sjinfo</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If it's a full join, no need to be very smart */</comment>
	<if_stmt><if>if <condition>(<expr><name>jointype</name> <operator>==</operator> <name>JOIN_FULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>left_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>right_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>lhs_strict</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* don't care about this */</comment>
		<return>return <expr><name>sjinfo</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Retrieve all relids mentioned within the join clause.
	 */</comment>
	<expr_stmt><expr><name>clause_relids</name> <operator>=</operator> <call><name>pull_varnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For which relids is the clause strict, ie, it cannot succeed if the
	 * rel's columns are all NULL?
	 */</comment>
	<expr_stmt><expr><name>strict_relids</name> <operator>=</operator> <call><name>find_nonnullable_rels</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Remember whether the clause is strict for any LHS relations */</comment>
	<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>lhs_strict</name></name> <operator>=</operator> <call><name>bms_overlap</name><argument_list>(<argument><expr><name>strict_relids</name></expr></argument>, <argument><expr><name>left_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Required LHS always includes the LHS rels mentioned in the clause. We
	 * may have to add more rels based on lower outer joins; see below.
	 */</comment>
	<expr_stmt><expr><name>min_lefthand</name> <operator>=</operator> <call><name>bms_intersect</name><argument_list>(<argument><expr><name>clause_relids</name></expr></argument>, <argument><expr><name>left_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Similarly for required RHS.  But here, we must also include any lower
	 * inner joins, to ensure we don't try to commute with any of them.
	 */</comment>
	<expr_stmt><expr><name>min_righthand</name> <operator>=</operator> <call><name>bms_int_members</name><argument_list>(<argument><expr><call><name>bms_union</name><argument_list>(<argument><expr><name>clause_relids</name></expr></argument>, <argument><expr><name>inner_join_rels</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name>right_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now check previous outer joins for ordering restrictions.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>root-&gt;join_info_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>otherinfo</name> <init>= <expr><operator>(</operator><name>SpecialJoinInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * A full join is an optimization barrier: we can't associate into or
		 * out of it.  Hence, if it overlaps either LHS or RHS of the current
		 * rel, expand that side's min relset to cover the whole full join.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>otherinfo</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_FULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name>left_rels</name></expr></argument>, <argument><expr><name><name>otherinfo</name><operator>-&gt;</operator><name>syn_lefthand</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>bms_overlap</name><argument_list>(<argument><expr><name>left_rels</name></expr></argument>, <argument><expr><name><name>otherinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>min_lefthand</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>min_lefthand</name></expr></argument>,
											   <argument><expr><name><name>otherinfo</name><operator>-&gt;</operator><name>syn_lefthand</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>min_lefthand</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>min_lefthand</name></expr></argument>,
											   <argument><expr><name><name>otherinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name>right_rels</name></expr></argument>, <argument><expr><name><name>otherinfo</name><operator>-&gt;</operator><name>syn_lefthand</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>bms_overlap</name><argument_list>(<argument><expr><name>right_rels</name></expr></argument>, <argument><expr><name><name>otherinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>min_righthand</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>min_righthand</name></expr></argument>,
												<argument><expr><name><name>otherinfo</name><operator>-&gt;</operator><name>syn_lefthand</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>min_righthand</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>min_righthand</name></expr></argument>,
												<argument><expr><name><name>otherinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Needn't do anything else with the full join */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * For a lower OJ in our LHS, if our join condition uses the lower
		 * join's RHS and is not strict for that rel, we must preserve the
		 * ordering of the two OJs, so add lower OJ's full syntactic relset to
		 * min_lefthand.  (We must use its full syntactic relset, not just its
		 * min_lefthand + min_righthand.  This is because there might be other
		 * OJs below this one that this one can commute with, but we cannot
		 * commute with them if we don't with this one.)  Also, if the current
		 * join is a semijoin or antijoin, we must preserve ordering
		 * regardless of strictness.
		 *
		 * Note: I believe we have to insist on being strict for at least one
		 * rel in the lower OJ's min_righthand, not its whole syn_righthand.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name>left_rels</name></expr></argument>, <argument><expr><name><name>otherinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name>clause_relids</name></expr></argument>, <argument><expr><name><name>otherinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>(</operator><name>jointype</name> <operator>==</operator> <name>JOIN_SEMI</name> <operator>||</operator> <name>jointype</name> <operator>==</operator> <name>JOIN_ANTI</name> <operator>||</operator>
				 <operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name>strict_relids</name></expr></argument>, <argument><expr><name><name>otherinfo</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>min_lefthand</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>min_lefthand</name></expr></argument>,
											   <argument><expr><name><name>otherinfo</name><operator>-&gt;</operator><name>syn_lefthand</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>min_lefthand</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>min_lefthand</name></expr></argument>,
											   <argument><expr><name><name>otherinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * For a lower OJ in our RHS, if our join condition does not use the
		 * lower join's RHS and the lower OJ's join condition is strict, we
		 * can interchange the ordering of the two OJs; otherwise we must add
		 * the lower OJ's full syntactic relset to min_righthand.
		 *
		 * Also, if our join condition does not use the lower join's LHS
		 * either, force the ordering to be preserved.  Otherwise we can end
		 * up with SpecialJoinInfos with identical min_righthands, which can
		 * confuse join_is_legal (see discussion in backend/optimizer/README).
		 *
		 * Also, we must preserve ordering anyway if either the current join
		 * or the lower OJ is either a semijoin or an antijoin.
		 *
		 * Here, we have to consider that "our join condition" includes any
		 * clauses that syntactically appeared above the lower OJ and below
		 * ours; those are equivalent to degenerate clauses in our OJ and must
		 * be treated as such.  Such clauses obviously can't reference our
		 * LHS, and they must be non-strict for the lower OJ's RHS (else
		 * reduce_outer_joins would have reduced the lower OJ to a plain
		 * join).  Hence the other ways in which we handle clauses within our
		 * join condition are not affected by them.  The net effect is
		 * therefore sufficiently represented by the delay_upper_joins flag
		 * saved for us by check_outerjoin_delay.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name>right_rels</name></expr></argument>, <argument><expr><name><name>otherinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name>clause_relids</name></expr></argument>, <argument><expr><name><name>otherinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
				<operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name>clause_relids</name></expr></argument>, <argument><expr><name><name>otherinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
				<name>jointype</name> <operator>==</operator> <name>JOIN_SEMI</name> <operator>||</operator>
				<name>jointype</name> <operator>==</operator> <name>JOIN_ANTI</name> <operator>||</operator>
				<name><name>otherinfo</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_SEMI</name> <operator>||</operator>
				<name><name>otherinfo</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_ANTI</name> <operator>||</operator>
				<operator>!</operator><name><name>otherinfo</name><operator>-&gt;</operator><name>lhs_strict</name></name> <operator>||</operator> <name><name>otherinfo</name><operator>-&gt;</operator><name>delay_upper_joins</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>min_righthand</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>min_righthand</name></expr></argument>,
												<argument><expr><name><name>otherinfo</name><operator>-&gt;</operator><name>syn_lefthand</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>min_righthand</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>min_righthand</name></expr></argument>,
												<argument><expr><name><name>otherinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Examine PlaceHolderVars.  If a PHV is supposed to be evaluated within
	 * this join's nullable side, then ensure that min_righthand contains the
	 * full eval_at set of the PHV.  This ensures that the PHV actually can be
	 * evaluated within the RHS.  Note that this works only because we should
	 * already have determined the final eval_at level for any PHV
	 * syntactically within this join.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>root-&gt;placeholder_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlaceHolderInfo</name> <modifier>*</modifier></type><name>phinfo</name> <init>= <expr><operator>(</operator><name>PlaceHolderInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>ph_syn_level</name> <init>= <expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_var</name><operator>-&gt;</operator><name>phrels</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Ignore placeholder if it didn't syntactically come from RHS */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name>ph_syn_level</name></expr></argument>, <argument><expr><name>right_rels</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Else, prevent join from being formed before we eval the PHV */</comment>
		<expr_stmt><expr><name>min_righthand</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>min_righthand</name></expr></argument>, <argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_eval_at</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If we found nothing to put in min_lefthand, punt and make it the full
	 * LHS, to avoid having an empty min_lefthand which will confuse later
	 * processing. (We don't try to be smart about such cases, just correct.)
	 * Likewise for min_righthand.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>min_lefthand</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>min_lefthand</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>left_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>min_righthand</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>min_righthand</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>right_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Now they'd better be nonempty */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>min_lefthand</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>min_righthand</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Shouldn't overlap either */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name>min_lefthand</name></expr></argument>, <argument><expr><name>min_righthand</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name> <operator>=</operator> <name>min_lefthand</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name> <operator>=</operator> <name>min_righthand</name></expr>;</expr_stmt>

	<return>return <expr><name>sjinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * compute_semijoin_info
 *	  Fill semijoin-related fields of a new SpecialJoinInfo
 *
 * Note: this relies on only the jointype and syn_righthand fields of the
 * SpecialJoinInfo; the rest may not be set yet.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compute_semijoin_info</name><parameter_list>(<parameter><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>semi_operators</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>semi_rhs_exprs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>all_btree</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>all_hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Initialize semijoin-related fields in case we can't unique-ify */</comment>
	<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_can_btree</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_can_hash</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_operators</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_rhs_exprs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/* Nothing more to do if it's not a semijoin */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_SEMI</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Look to see whether the semijoin's join quals consist of AND'ed
	 * equality operators, with (only) RHS variables on only one side of each
	 * one.  If so, we can figure out how to enforce uniqueness for the RHS.
	 *
	 * Note that the input clause list is the list of quals that are
	 * *syntactically* associated with the semijoin, which in practice means
	 * the synthesized comparison list for an IN or the WHERE of an EXISTS.
	 * Particularly in the latter case, it might contain clauses that aren't
	 * *semantically* associated with the join, but refer to just one side or
	 * the other.  We can ignore such clauses here, as they will just drop
	 * down to be processed within one side or the other.  (It is okay to
	 * consider only the syntactically-associated clauses here because for a
	 * semijoin, no higher-level quals could refer to the RHS, and so there
	 * can be no other quals that are semantically associated with this join.
	 * We do things this way because it is useful to have the set of potential
	 * unique-ification expressions before we can extract the list of quals
	 * that are actually semantically associated with the particular join.)
	 *
	 * Note that the semi_operators list consists of the joinqual operators
	 * themselves (but commuted if needed to put the RHS value on the right).
	 * These could be cross-type operators, in which case the operator
	 * actually needed for uniqueness is a related single-type operator. We
	 * assume here that that operator will be available from the btree or hash
	 * opclass when the time comes ... if not, create_unique_plan() will fail.
	 */</comment>
	<expr_stmt><expr><name>semi_operators</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>semi_rhs_exprs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>all_btree</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>all_hash</name> <operator>=</operator> <name>enable_hashagg</name></expr>;</expr_stmt>	<comment type="block">/* don't consider hash if not enabled */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>clause</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>opno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>left_expr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>right_expr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>left_varnos</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>right_varnos</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>all_varnos</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>opinputtype</name></decl>;</decl_stmt>

		<comment type="block">/* Is it a binary opclause? */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>list_length</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* No, but does it reference both sides? */</comment>
			<expr_stmt><expr><name>all_varnos</name> <operator>=</operator> <call><name>pull_varnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name>all_varnos</name></expr></argument>, <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>bms_is_subset</name><argument_list>(<argument><expr><name>all_varnos</name></expr></argument>, <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Clause refers to only one rel, so ignore it --- unless it
				 * contains volatile functions, in which case we'd better
				 * punt.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>op</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return;</return></block_content></block></if></if_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Non-operator clause referencing both sides, must punt */</comment>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Extract data from binary opclause */</comment>
		<expr_stmt><expr><name>opno</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>opno</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>left_expr</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>right_expr</name> <operator>=</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>left_varnos</name> <operator>=</operator> <call><name>pull_varnos</name><argument_list>(<argument><expr><name>left_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>right_varnos</name> <operator>=</operator> <call><name>pull_varnos</name><argument_list>(<argument><expr><name>right_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>all_varnos</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name>left_varnos</name></expr></argument>, <argument><expr><name>right_varnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>opinputtype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>left_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Does it reference both sides? */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name>all_varnos</name></expr></argument>, <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>bms_is_subset</name><argument_list>(<argument><expr><name>all_varnos</name></expr></argument>, <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Clause refers to only one rel, so ignore it --- unless it
			 * contains volatile functions, in which case we'd better punt.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>op</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* check rel membership of arguments */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>right_varnos</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>bms_is_subset</name><argument_list>(<argument><expr><name>right_varnos</name></expr></argument>, <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name>left_varnos</name></expr></argument>, <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* typical case, right_expr is RHS variable */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>left_varnos</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				 <call><name>bms_is_subset</name><argument_list>(<argument><expr><name>left_varnos</name></expr></argument>, <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				 <operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name>right_varnos</name></expr></argument>, <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* flipped case, left_expr is RHS variable */</comment>
			<expr_stmt><expr><name>opno</name> <operator>=</operator> <call><name>get_commutator</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>right_expr</name> <operator>=</operator> <name>left_expr</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* mixed membership of args, punt */</comment>
			<return>return;</return>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* all operators must be btree equality or hash equality */</comment>
		<if_stmt><if>if <condition>(<expr><name>all_btree</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* oprcanmerge is considered a hint... */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>op_mergejoinable</name><argument_list>(<argument><expr><name>opno</name></expr></argument>, <argument><expr><name>opinputtype</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>get_mergejoin_opfamilies</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>all_btree</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>all_hash</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* ... but oprcanhash had better be correct */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>op_hashjoinable</name><argument_list>(<argument><expr><name>opno</name></expr></argument>, <argument><expr><name>opinputtype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>all_hash</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>all_btree</name> <operator>||</operator> <name>all_hash</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/* so far so good, keep building lists */</comment>
		<expr_stmt><expr><name>semi_operators</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>semi_operators</name></expr></argument>, <argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>semi_rhs_exprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>semi_rhs_exprs</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>right_expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Punt if we didn't find at least one column to unique-ify */</comment>
	<if_stmt><if>if <condition>(<expr><name>semi_rhs_exprs</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The expressions we'd need to unique-ify mustn't be volatile.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>semi_rhs_exprs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we get here, we can unique-ify the semijoin's RHS using at least one
	 * of sorting and hashing.  Save the information about how to do that.
	 */</comment>
	<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_can_btree</name></name> <operator>=</operator> <name>all_btree</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_can_hash</name></name> <operator>=</operator> <name>all_hash</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_operators</name></name> <operator>=</operator> <name>semi_operators</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_rhs_exprs</name></name> <operator>=</operator> <name>semi_rhs_exprs</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 *
 *	  QUALIFICATIONS
 *
 *****************************************************************************/</comment>

<comment type="block">/*
 * distribute_qual_to_rels
 *	  Add clause information to either the baserestrictinfo or joininfo list
 *	  (depending on whether the clause is a join) of each base relation
 *	  mentioned in the clause.  A RestrictInfo node is created and added to
 *	  the appropriate list for each rel.  Alternatively, if the clause uses a
 *	  mergejoinable operator and is not delayed by outer-join rules, enter
 *	  the left- and right-side expressions into the query's list of
 *	  EquivalenceClasses.  Alternatively, if the clause needs to be treated
 *	  as belonging to a higher join level, just add it to postponed_qual_list.
 *
 * 'clause': the qual clause to be distributed
 * 'is_deduced': true if the qual came from implied-equality deduction
 * 'below_outer_join': true if the qual is from a JOIN/ON that is below the
 *		nullable side of a higher-level outer join
 * 'jointype': type of join the qual is from (JOIN_INNER for a WHERE clause)
 * 'security_level': security_level to assign to the qual
 * 'qualscope': set of baserels the qual's syntactic scope covers
 * 'ojscope': NULL if not an outer-join qual, else the minimum set of baserels
 *		needed to form this join
 * 'outerjoin_nonnullable': NULL if not an outer-join qual, else the set of
 *		baserels appearing on the outer (nonnullable) side of the join
 *		(for FULL JOIN this includes both sides of the join, and must in fact
 *		equal qualscope)
 * 'deduced_nullable_relids': if is_deduced is true, the nullable relids to
 *		impute to the clause; otherwise NULL
 * 'postponed_qual_list': list of PostponedQual structs, which we can add
 *		this qual to if it turns out to belong to a higher join level.
 *		Can be NULL if caller knows postponement is impossible.
 *
 * 'qualscope' identifies what level of JOIN the qual came from syntactically.
 * 'ojscope' is needed if we decide to force the qual up to the outer-join
 * level, which will be ojscope not necessarily qualscope.
 *
 * In normal use (when is_deduced is false), at the time this is called,
 * root-&gt;join_info_list must contain entries for all and only those special
 * joins that are syntactically below this qual.  But when is_deduced is true,
 * we are adding new deduced clauses after completion of deconstruct_jointree,
 * so it cannot be assumed that root-&gt;join_info_list has anything to do with
 * qual placement.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>distribute_qual_to_rels</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>is_deduced</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>below_outer_join</name></decl></parameter>,
						<parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
						<parameter><decl><type><name>Index</name></type> <name>security_level</name></decl></parameter>,
						<parameter><decl><type><name>Relids</name></type> <name>qualscope</name></decl></parameter>,
						<parameter><decl><type><name>Relids</name></type> <name>ojscope</name></decl></parameter>,
						<parameter><decl><type><name>Relids</name></type> <name>outerjoin_nonnullable</name></decl></parameter>,
						<parameter><decl><type><name>Relids</name></type> <name>deduced_nullable_relids</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>postponed_qual_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>relids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_pushed_down</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>outerjoin_delayed</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>pseudoconstant</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>maybe_equivalence</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>maybe_outer_join</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>nullable_relids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>restrictinfo</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Retrieve all relids mentioned within the clause.
	 */</comment>
	<expr_stmt><expr><name>relids</name> <operator>=</operator> <call><name>pull_varnos</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In ordinary SQL, a WHERE or JOIN/ON clause can't reference any rels
	 * that aren't within its syntactic scope; however, if we pulled up a
	 * LATERAL subquery then we might find such references in quals that have
	 * been pulled up.  We need to treat such quals as belonging to the join
	 * level that includes every rel they reference.  Although we could make
	 * pull_up_subqueries() place such quals correctly to begin with, it's
	 * easier to handle it here.  When we find a clause that contains Vars
	 * outside its syntactic scope, we add it to the postponed-quals list, and
	 * process it once we've recursed back up to the appropriate join level.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>qualscope</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PostponedQual</name> <modifier>*</modifier></type><name>pq</name> <init>= <expr><operator>(</operator><name>PostponedQual</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PostponedQual</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>hasLateralRTEs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* shouldn't happen otherwise */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>jointype</name> <operator>==</operator> <name>JOIN_INNER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* mustn't postpone past outer join */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_deduced</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* shouldn't be deduced, either */</comment>
		<expr_stmt><expr><name><name>pq</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>clause</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pq</name><operator>-&gt;</operator><name>relids</name></name> <operator>=</operator> <name>relids</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>postponed_qual_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>postponed_qual_list</name></expr></argument>, <argument><expr><name>pq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If it's an outer-join clause, also check that relids is a subset of
	 * ojscope.  (This should not fail if the syntactic scope check passed.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ojscope</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>ojscope</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"JOIN qualification cannot refer to other relations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the clause is variable-free, our normal heuristic for pushing it
	 * down to just the mentioned rels doesn't work, because there are none.
	 *
	 * If the clause is an outer-join clause, we must force it to the OJ's
	 * semantic level to preserve semantics.
	 *
	 * Otherwise, when the clause contains volatile functions, we force it to
	 * be evaluated at its original syntactic level.  This preserves the
	 * expected semantics.
	 *
	 * When the clause contains no volatile functions either, it is actually a
	 * pseudoconstant clause that will not change value during any one
	 * execution of the plan, and hence can be used as a one-time qual in a
	 * gating Result plan node.  We put such a clause into the regular
	 * RestrictInfo lists for the moment, but eventually createplan.c will
	 * pull it out and make a gating Result node immediately above whatever
	 * plan node the pseudoconstant clause is assigned to.  It's usually best
	 * to put a gating node as high in the plan tree as possible. If we are
	 * not below an outer join, we can actually push the pseudoconstant qual
	 * all the way to the top of the tree.  If we are below an outer join, we
	 * leave the qual at its original syntactic level (we could push it up to
	 * just below the outer join, but that seems more complex than it's
	 * worth).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>ojscope</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* clause is attached to outer join, eval it there */</comment>
			<expr_stmt><expr><name>relids</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>ojscope</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* mustn't use as gating qual, so don't mark pseudoconstant */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* eval at original syntactic level */</comment>
			<expr_stmt><expr><name>relids</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>qualscope</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* mark as gating qual */</comment>
				<expr_stmt><expr><name>pseudoconstant</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<comment type="block">/* tell createplan.c to check for gating quals */</comment>
				<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>hasPseudoConstantQuals</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<comment type="block">/* if not below outer join, push it to top of tree */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>below_outer_join</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>relids</name> <operator>=</operator>
						<call><name>get_relids_in_jointree</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>qualscope</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*----------
	 * Check to see if clause application must be delayed by outer-join
	 * considerations.
	 *
	 * A word about is_pushed_down: we mark the qual as "pushed down" if
	 * it is (potentially) applicable at a level different from its original
	 * syntactic level.  This flag is used to distinguish OUTER JOIN ON quals
	 * from other quals pushed down to the same joinrel.  The rules are:
	 *		WHERE quals and INNER JOIN quals: is_pushed_down = true.
	 *		Non-degenerate OUTER JOIN quals: is_pushed_down = false.
	 *		Degenerate OUTER JOIN quals: is_pushed_down = true.
	 * A "degenerate" OUTER JOIN qual is one that doesn't mention the
	 * non-nullable side, and hence can be pushed down into the nullable side
	 * without changing the join result.  It is correct to treat it as a
	 * regular filter condition at the level where it is evaluated.
	 *
	 * Note: it is not immediately obvious that a simple boolean is enough
	 * for this: if for some reason we were to attach a degenerate qual to
	 * its original join level, it would need to be treated as an outer join
	 * qual there.  However, this cannot happen, because all the rels the
	 * clause mentions must be in the outer join's min_righthand, therefore
	 * the join it needs must be formed before the outer join; and we always
	 * attach quals to the lowest level where they can be evaluated.  But
	 * if we were ever to re-introduce a mechanism for delaying evaluation
	 * of "expensive" quals, this area would need work.
	 *
	 * Note: generally, use of is_pushed_down has to go through the macro
	 * RINFO_IS_PUSHED_DOWN, because that flag alone is not always sufficient
	 * to tell whether a clause must be treated as pushed-down in context.
	 * This seems like another reason why it should perhaps be rethought.
	 *----------
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_deduced</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the qual came from implied-equality deduction, it should not be
		 * outerjoin-delayed, else deducer blew it.  But we can't check this
		 * because the join_info_list may now contain OJs above where the qual
		 * belongs.  For the same reason, we must rely on caller to supply the
		 * correct nullable_relids set.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>ojscope</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>is_pushed_down</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>outerjoin_delayed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nullable_relids</name> <operator>=</operator> <name>deduced_nullable_relids</name></expr>;</expr_stmt>
		<comment type="block">/* Don't feed it back for more deductions */</comment>
		<expr_stmt><expr><name>maybe_equivalence</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>maybe_outer_join</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>outerjoin_nonnullable</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The qual is attached to an outer join and mentions (some of the)
		 * rels on the nonnullable side, so it's not degenerate.
		 *
		 * We can't use such a clause to deduce equivalence (the left and
		 * right sides might be unequal above the join because one of them has
		 * gone to NULL) ... but we might be able to use it for more limited
		 * deductions, if it is mergejoinable.  So consider adding it to the
		 * lists of set-aside outer-join clauses.
		 */</comment>
		<expr_stmt><expr><name>is_pushed_down</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>maybe_equivalence</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>maybe_outer_join</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/* Check to see if must be delayed by lower outer join */</comment>
		<expr_stmt><expr><name>outerjoin_delayed</name> <operator>=</operator> <call><name>check_outerjoin_delay</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>relids</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>nullable_relids</name></expr></argument>,
												  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now force the qual to be evaluated exactly at the level of joining
		 * corresponding to the outer join.  We cannot let it get pushed down
		 * into the nonnullable side, since then we'd produce no output rows,
		 * rather than the intended single null-extended row, for any
		 * nonnullable-side rows failing the qual.
		 *
		 * (Do this step after calling check_outerjoin_delay, because that
		 * trashes relids.)
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ojscope</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>relids</name> <operator>=</operator> <name>ojscope</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>pseudoconstant</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Normal qual clause or degenerate outer-join clause.  Either way, we
		 * can mark it as pushed-down.
		 */</comment>
		<expr_stmt><expr><name>is_pushed_down</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/* Check to see if must be delayed by lower outer join */</comment>
		<expr_stmt><expr><name>outerjoin_delayed</name> <operator>=</operator> <call><name>check_outerjoin_delay</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>relids</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>nullable_relids</name></expr></argument>,
												  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>outerjoin_delayed</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Should still be a subset of current scope ... */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>hasLateralRTEs</name></name> <operator>||</operator> <call><name>bms_is_subset</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>qualscope</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ojscope</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>bms_is_subset</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>ojscope</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Because application of the qual will be delayed by outer join,
			 * we mustn't assume its vars are equal everywhere.
			 */</comment>
			<expr_stmt><expr><name>maybe_equivalence</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * It's possible that this is an IS NULL clause that's redundant
			 * with a lower antijoin; if so we can just discard it.  We need
			 * not test in any of the other cases, because this will only be
			 * possible for pushed-down, delayed clauses.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>check_redundant_nullability_qual</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Qual is not delayed by any lower outer-join restriction, so we
			 * can consider feeding it to the equivalence machinery. However,
			 * if it's itself within an outer-join clause, treat it as though
			 * it appeared below that outer join (note that we can only get
			 * here when the clause references only nullable-side rels).
			 */</comment>
			<expr_stmt><expr><name>maybe_equivalence</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>outerjoin_nonnullable</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>below_outer_join</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Since it doesn't mention the LHS, it's certainly not useful as a
		 * set-aside OJ clause, even if it's in an OJ.
		 */</comment>
		<expr_stmt><expr><name>maybe_outer_join</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Build the RestrictInfo node itself.
	 */</comment>
	<expr_stmt><expr><name>restrictinfo</name> <operator>=</operator> <call><name>make_restrictinfo</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>,
									 <argument><expr><name>is_pushed_down</name></expr></argument>,
									 <argument><expr><name>outerjoin_delayed</name></expr></argument>,
									 <argument><expr><name>pseudoconstant</name></expr></argument>,
									 <argument><expr><name>security_level</name></expr></argument>,
									 <argument><expr><name>relids</name></expr></argument>,
									 <argument><expr><name>outerjoin_nonnullable</name></expr></argument>,
									 <argument><expr><name>nullable_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it's a join clause (either naturally, or because delayed by
	 * outer-join rules), add vars used in the clause to targetlists of their
	 * relations, so that they will be emitted by the plan nodes that scan
	 * those relations (else they won't be available at the join node!).
	 *
	 * Note: if the clause gets absorbed into an EquivalenceClass then this
	 * may be unnecessary, but for now we have to do it to cover the case
	 * where the EC becomes ec_broken and we end up reinserting the original
	 * clauses into the plan.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bms_membership</name><argument_list>(<argument><expr><name>relids</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BMS_MULTIPLE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>vars</name> <init>= <expr><call><name>pull_var_clause</name><argument_list>(<argument><expr><name>clause</name></expr></argument>,
										   <argument><expr><name>PVC_RECURSE_AGGREGATES</name> <operator>|</operator>
										   <name>PVC_RECURSE_WINDOWFUNCS</name> <operator>|</operator>
										   <name>PVC_INCLUDE_PLACEHOLDERS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>add_vars_to_targetlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>vars</name></expr></argument>, <argument><expr><name>relids</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We check "mergejoinability" of every clause, not only join clauses,
	 * because we want to know about equivalences between vars of the same
	 * relation, or between vars and consts.
	 */</comment>
	<expr_stmt><expr><call><name>check_mergejoinable</name><argument_list>(<argument><expr><name>restrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_batchable</name><argument_list>(<argument><expr><name>restrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it is a true equivalence clause, send it to the EquivalenceClass
	 * machinery.  We do *not* attach it directly to any restriction or join
	 * lists.  The EC code will propagate it to the appropriate places later.
	 *
	 * If the clause has a mergejoinable operator and is not
	 * outerjoin-delayed, yet isn't an equivalence because it is an outer-join
	 * clause, the EC code may yet be able to do something with it.  We add it
	 * to appropriate lists for further consideration later.  Specifically:
	 *
	 * If it is a left or right outer-join qualification that relates the two
	 * sides of the outer join (no funny business like leftvar1 = leftvar2 +
	 * rightvar), we add it to root-&gt;left_join_clauses or
	 * root-&gt;right_join_clauses according to which side the nonnullable
	 * variable appears on.
	 *
	 * If it is a full outer-join qualification, we add it to
	 * root-&gt;full_join_clauses.  (Ideally we'd discard cases that aren't
	 * leftvar = rightvar, as we do for left/right joins, but this routine
	 * doesn't have the info needed to do that; and the current usage of the
	 * full_join_clauses list doesn't require that, so it's not currently
	 * worth complicating this routine's API to make it possible.)
	 *
	 * If none of the above hold, pass it off to
	 * distribute_restrictinfo_to_rels().
	 *
	 * In all cases, it's important to initialize the left_ec and right_ec
	 * fields of a mergejoinable clause, so that all possibly mergejoinable
	 * expressions have representations in EquivalenceClasses.  If
	 * process_equivalence is successful, it will take care of that;
	 * otherwise, we have to call initialize_mergeclause_eclasses to do it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>mergeopfamilies</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>maybe_equivalence</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>check_equivalence_delay</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>restrictinfo</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>process_equivalence</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>restrictinfo</name></expr></argument>, <argument><expr><name>below_outer_join</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>
			<comment type="block">/* EC rejected it, so set left_ec/right_ec the hard way ... */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>mergeopfamilies</name></name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* EC might have changed this */</comment>
				<expr_stmt><expr><call><name>initialize_mergeclause_eclasses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>restrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* ... and fall through to distribute_restrictinfo_to_rels */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>maybe_outer_join</name> <operator>&amp;&amp;</operator> <name><name>restrictinfo</name><operator>-&gt;</operator><name>can_join</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* we need to set up left_ec/right_ec the hard way */</comment>
			<expr_stmt><expr><call><name>initialize_mergeclause_eclasses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>restrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* now see if it should go to any outer-join lists */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>left_relids</name></name></expr></argument>,
							  <argument><expr><name>outerjoin_nonnullable</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>right_relids</name></name></expr></argument>,
							 <argument><expr><name>outerjoin_nonnullable</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* we have outervar = innervar */</comment>
				<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>left_join_clauses</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>left_join_clauses</name></name></expr></argument>,
												  <argument><expr><name>restrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>right_relids</name></name></expr></argument>,
							  <argument><expr><name>outerjoin_nonnullable</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>left_relids</name></name></expr></argument>,
							 <argument><expr><name>outerjoin_nonnullable</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* we have innervar = outervar */</comment>
				<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>right_join_clauses</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>right_join_clauses</name></name></expr></argument>,
												   <argument><expr><name>restrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>jointype</name> <operator>==</operator> <name>JOIN_FULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* FULL JOIN (above tests cannot match in this case) */</comment>
				<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>full_join_clauses</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>full_join_clauses</name></name></expr></argument>,
												  <argument><expr><name>restrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* nope, so fall through to distribute_restrictinfo_to_rels */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* we still need to set up left_ec/right_ec */</comment>
			<expr_stmt><expr><call><name>initialize_mergeclause_eclasses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>restrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* No EC special case applies, so push it into the clause lists */</comment>
	<expr_stmt><expr><call><name>distribute_restrictinfo_to_rels</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>restrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * check_outerjoin_delay
 *		Detect whether a qual referencing the given relids must be delayed
 *		in application due to the presence of a lower outer join, and/or
 *		may force extra delay of higher-level outer joins.
 *
 * If the qual must be delayed, add relids to *relids_p to reflect the lowest
 * safe level for evaluating the qual, and return true.  Any extra delay for
 * higher-level joins is reflected by setting delay_upper_joins to true in
 * SpecialJoinInfo structs.  We also compute nullable_relids, the set of
 * referenced relids that are nullable by lower outer joins (note that this
 * can be nonempty even for a non-delayed qual).
 *
 * For an is_pushed_down qual, we can evaluate the qual as soon as (1) we have
 * all the rels it mentions, and (2) we are at or above any outer joins that
 * can null any of these rels and are below the syntactic location of the
 * given qual.  We must enforce (2) because pushing down such a clause below
 * the OJ might cause the OJ to emit null-extended rows that should not have
 * been formed, or that should have been rejected by the clause.  (This is
 * only an issue for non-strict quals, since if we can prove a qual mentioning
 * only nullable rels is strict, we'd have reduced the outer join to an inner
 * join in reduce_outer_joins().)
 *
 * To enforce (2), scan the join_info_list and merge the required-relid sets of
 * any such OJs into the clause's own reference list.  At the time we are
 * called, the join_info_list contains only outer joins below this qual.  We
 * have to repeat the scan until no new relids get added; this ensures that
 * the qual is suitably delayed regardless of the order in which OJs get
 * executed.  As an example, if we have one OJ with LHS=A, RHS=B, and one with
 * LHS=B, RHS=C, it is implied that these can be done in either order; if the
 * B/C join is done first then the join to A can null C, so a qual actually
 * mentioning only C cannot be applied below the join to A.
 *
 * For a non-pushed-down qual, this isn't going to determine where we place the
 * qual, but we need to determine outerjoin_delayed and nullable_relids anyway
 * for use later in the planning process.
 *
 * Lastly, a pushed-down qual that references the nullable side of any current
 * join_info_list member and has to be evaluated above that OJ (because its
 * required relids overlap the LHS too) causes that OJ's delay_upper_joins
 * flag to be set true.  This will prevent any higher-level OJs from
 * being interchanged with that OJ, which would result in not having any
 * correct place to evaluate the qual.  (The case we care about here is a
 * sub-select WHERE clause within the RHS of some outer join.  The WHERE
 * clause must effectively be treated as a degenerate clause of that outer
 * join's condition.  Rather than trying to match such clauses with joins
 * directly, we set delay_upper_joins here, and when the upper outer join
 * is processed by make_outerjoininfo, it will refrain from allowing the
 * two OJs to commute.)
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_outerjoin_delay</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					  <parameter><decl><type><name>Relids</name> <modifier>*</modifier></type><name>relids_p</name></decl></parameter>, <comment type="block">/* in/out parameter */</comment>
					  <parameter><decl><type><name>Relids</name> <modifier>*</modifier></type><name>nullable_relids_p</name></decl></parameter>,	<comment type="block">/* output parameter */</comment>
					  <parameter><decl><type><name>bool</name></type> <name>is_pushed_down</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>relids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>nullable_relids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>outerjoin_delayed</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found_some</name></decl>;</decl_stmt>

	<comment type="block">/* fast path if no special joins */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>join_info_list</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>nullable_relids_p</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* must copy relids because we need the original value at the end */</comment>
	<expr_stmt><expr><name>relids</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><operator>*</operator><name>relids_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nullable_relids</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>outerjoin_delayed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>found_some</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>root-&gt;join_info_list</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name> <init>= <expr><operator>(</operator><name>SpecialJoinInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* do we reference any nullable rels of this OJ? */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
				<operator>(</operator><name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_FULL</name> <operator>&amp;&amp;</operator>
				 <call><name>bms_overlap</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* yes; have we included all its rels in relids? */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call> <operator>||</operator>
					<operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* no, so add them in */</comment>
					<expr_stmt><expr><name>relids</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>relids</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>outerjoin_delayed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<comment type="block">/* we'll need another iteration */</comment>
					<expr_stmt><expr><name>found_some</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* track all the nullable rels of relevant OJs */</comment>
				<expr_stmt><expr><name>nullable_relids</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>nullable_relids</name></expr></argument>,
												  <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_FULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>nullable_relids</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>nullable_relids</name></expr></argument>,
													  <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/* set delay_upper_joins if needed */</comment>
				<if_stmt><if>if <condition>(<expr><name>is_pushed_down</name> <operator>&amp;&amp;</operator> <name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_FULL</name> <operator>&amp;&amp;</operator>
					<call><name>bms_overlap</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>delay_upper_joins</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block> while <condition>(<expr><name>found_some</name></expr>)</condition>;</do>

	<comment type="block">/* identify just the actually-referenced nullable rels */</comment>
	<expr_stmt><expr><name>nullable_relids</name> <operator>=</operator> <call><name>bms_int_members</name><argument_list>(<argument><expr><name>nullable_relids</name></expr></argument>, <argument><expr><operator>*</operator><name>relids_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* replace *relids_p, and return nullable_relids */</comment>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><operator>*</operator><name>relids_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>relids_p</name> <operator>=</operator> <name>relids</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>nullable_relids_p</name> <operator>=</operator> <name>nullable_relids</name></expr>;</expr_stmt>
	<return>return <expr><name>outerjoin_delayed</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * check_equivalence_delay
 *		Detect whether a potential equivalence clause is rendered unsafe
 *		by outer-join-delay considerations.  Return true if it's safe.
 *
 * The initial tests in distribute_qual_to_rels will consider a mergejoinable
 * clause to be a potential equivalence clause if it is not outerjoin_delayed.
 * But since the point of equivalence processing is that we will recombine the
 * two sides of the clause with others, we have to check that each side
 * satisfies the not-outerjoin_delayed condition on its own; otherwise it might
 * not be safe to evaluate everywhere we could place a derived equivalence
 * condition.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_equivalence_delay</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						<parameter><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>restrictinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>relids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>nullable_relids</name></decl>;</decl_stmt>

	<comment type="block">/* fast path if no special joins */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>join_info_list</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* must copy restrictinfo's relids to avoid changing it */</comment>
	<expr_stmt><expr><name>relids</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>left_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* check left side does not need delay */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>check_outerjoin_delay</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nullable_relids</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* and similarly for the right side */</comment>
	<expr_stmt><expr><name>relids</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>right_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>check_outerjoin_delay</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nullable_relids</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * check_redundant_nullability_qual
 *	  Check to see if the qual is an IS NULL qual that is redundant with
 *	  a lower JOIN_ANTI join.
 *
 * We want to suppress redundant IS NULL quals, not so much to save cycles
 * as to avoid generating bogus selectivity estimates for them.  So if
 * redundancy is detected here, distribute_qual_to_rels() just throws away
 * the qual.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_redundant_nullability_qual</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>forced_null_var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>forced_null_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Check for IS NULL, and identify the Var forced to NULL */</comment>
	<expr_stmt><expr><name>forced_null_var</name> <operator>=</operator> <call><name>find_forced_null_var</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>forced_null_var</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>forced_null_rel</name> <operator>=</operator> <name><name>forced_null_var</name><operator>-&gt;</operator><name>varno</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the Var comes from the nullable side of a lower antijoin, the IS
	 * NULL condition is necessarily true.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;join_info_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name> <init>= <expr><operator>(</operator><name>SpecialJoinInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_ANTI</name> <operator>&amp;&amp;</operator>
			<call><name>bms_is_member</name><argument_list>(<argument><expr><name>forced_null_rel</name></expr></argument>, <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * distribute_restrictinfo_to_rels
 *	  Push a completed RestrictInfo into the proper restriction or join
 *	  clause list(s).
 *
 * This is the last step of distribute_qual_to_rels() for ordinary qual
 * clauses.  Clauses that are interesting for equivalence-class processing
 * are diverted to the EC machinery, but may ultimately get fed back here.
 */</comment>
<function><type><name>void</name></type>
<name>distribute_restrictinfo_to_rels</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
								<parameter><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>restrictinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>relids</name> <init>= <expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>required_relids</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><call><name>bms_membership</name><argument_list>(<argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>BMS_SINGLETON</name></expr>:</case>

			<comment type="block">/*
			 * There is only one relation participating in the clause, so it
			 * is a restriction clause for that relation.
			 */</comment>
			<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>find_base_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><call><name>bms_singleton_member</name><argument_list>(<argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Add clause to rel's restriction list */</comment>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name></expr></argument>,
											<argument><expr><name>restrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Update security level info */</comment>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrict_min_security</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrict_min_security</name></name></expr></argument>,
												 <argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>security_level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>BMS_MULTIPLE</name></expr>:</case>

			<comment type="block">/*
			 * The clause is a join clause, since there is more than one rel
			 * in its relid set.
			 */</comment>

			<comment type="block">/*
			 * Check for hashjoinable operators.  (We don't bother setting the
			 * hashjoin info except in true join clauses.)
			 */</comment>
			<expr_stmt><expr><call><name>check_hashjoinable</name><argument_list>(<argument><expr><name>restrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Add clause to the join lists of all the relevant relations.
			 */</comment>
			<expr_stmt><expr><call><name>add_join_clause_to_rels</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>restrictinfo</name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>

			<comment type="block">/*
			 * clause references no rels, and therefore we have no place to
			 * attach it.  Shouldn't get here if callers are working properly.
			 */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot cope with variable-free clause"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * process_implied_equality
 *	  Create a restrictinfo item that says "item1 op item2", and push it
 *	  into the appropriate lists.  (In practice opno is always a btree
 *	  equality operator.)
 *
 * "qualscope" is the nominal syntactic level to impute to the restrictinfo.
 * This must contain at least all the rels used in the expressions, but it
 * is used only to set the qual application level when both exprs are
 * variable-free.  Otherwise the qual is applied at the lowest join level
 * that provides all its variables.
 *
 * "nullable_relids" is the set of relids used in the expressions that are
 * potentially nullable below the expressions.  (This has to be supplied by
 * caller because this function is used after deconstruct_jointree, so we
 * don't have knowledge of where the clause items came from.)
 *
 * "security_level" is the security level to assign to the new restrictinfo.
 *
 * "both_const" indicates whether both items are known pseudo-constant;
 * in this case it is worth applying eval_const_expressions() in case we
 * can produce constant TRUE or constant FALSE.  (Otherwise it's not,
 * because the expressions went through eval_const_expressions already.)
 *
 * Note: this function will copy item1 and item2, but it is caller's
 * responsibility to make sure that the Relids parameters are fresh copies
 * not shared with other uses.
 *
 * This is currently used only when an EquivalenceClass is found to
 * contain pseudoconstants.  See path/pathkeys.c for more details.
 */</comment>
<function><type><name>void</name></type>
<name>process_implied_equality</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>,
						 <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>item1</name></decl></parameter>,
						 <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>item2</name></decl></parameter>,
						 <parameter><decl><type><name>Relids</name></type> <name>qualscope</name></decl></parameter>,
						 <parameter><decl><type><name>Relids</name></type> <name>nullable_relids</name></decl></parameter>,
						 <parameter><decl><type><name>Index</name></type> <name>security_level</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>below_outer_join</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>both_const</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>clause</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Build the new clause.  Copy to ensure it shares no substructure with
	 * original (this is necessary in case there are subselects in there...)
	 */</comment>
	<expr_stmt><expr><name>clause</name> <operator>=</operator> <call><name>make_opclause</name><argument_list>(<argument><expr><name>opno</name></expr></argument>,
						   <argument><expr><name>BOOLOID</name></expr></argument>, <comment type="block">/* opresulttype */</comment>
						   <argument><expr><name>false</name></expr></argument>,	<comment type="block">/* opretset */</comment>
						   <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>item1</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>item2</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name>InvalidOid</name></expr></argument>,
						   <argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If both constant, try to reduce to a boolean constant. */</comment>
	<if_stmt><if>if <condition>(<expr><name>both_const</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>clause</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If we produced const TRUE, just drop the clause */</comment>
		<if_stmt><if>if <condition>(<expr><name>clause</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>cclause</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cclause</name><operator>-&gt;</operator><name>consttype</name></name> <operator>==</operator> <name>BOOLOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cclause</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>&amp;&amp;</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>cclause</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Push the new clause into all the appropriate restrictinfo lists.
	 */</comment>
	<expr_stmt><expr><call><name>distribute_qual_to_rels</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>,
							<argument><expr><name>true</name></expr></argument>, <argument><expr><name>below_outer_join</name></expr></argument>, <argument><expr><name>JOIN_INNER</name></expr></argument>,
							<argument><expr><name>security_level</name></expr></argument>,
							<argument><expr><name>qualscope</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>nullable_relids</name></expr></argument>,
							<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * build_implied_join_equality --- build a RestrictInfo for a derived equality
 *
 * This overlaps the functionality of process_implied_equality(), but we
 * must return the RestrictInfo, not push it into the joininfo tree.
 *
 * Note: this function will copy item1 and item2, but it is caller's
 * responsibility to make sure that the Relids parameters are fresh copies
 * not shared with other uses.
 *
 * Note: we do not do initialize_mergeclause_eclasses() here.  It is
 * caller's responsibility that left_ec/right_ec be set as necessary.
 */</comment>
<function><type><name>RestrictInfo</name> <modifier>*</modifier></type>
<name>build_implied_join_equality</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>,
							<parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>,
							<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>item1</name></decl></parameter>,
							<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>item2</name></decl></parameter>,
							<parameter><decl><type><name>Relids</name></type> <name>qualscope</name></decl></parameter>,
							<parameter><decl><type><name>Relids</name></type> <name>nullable_relids</name></decl></parameter>,
							<parameter><decl><type><name>Index</name></type> <name>security_level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>restrictinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>clause</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Build the new clause.  Copy to ensure it shares no substructure with
	 * original (this is necessary in case there are subselects in there...)
	 */</comment>
	<expr_stmt><expr><name>clause</name> <operator>=</operator> <call><name>make_opclause</name><argument_list>(<argument><expr><name>opno</name></expr></argument>,
						   <argument><expr><name>BOOLOID</name></expr></argument>, <comment type="block">/* opresulttype */</comment>
						   <argument><expr><name>false</name></expr></argument>,	<comment type="block">/* opretset */</comment>
						   <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>item1</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>item2</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name>InvalidOid</name></expr></argument>,
						   <argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build the RestrictInfo node itself.
	 */</comment>
	<expr_stmt><expr><name>restrictinfo</name> <operator>=</operator> <call><name>make_restrictinfo</name><argument_list>(<argument><expr><name>clause</name></expr></argument>,
									 <argument><expr><name>true</name></expr></argument>,	<comment type="block">/* is_pushed_down */</comment>
									 <argument><expr><name>false</name></expr></argument>, <comment type="block">/* outerjoin_delayed */</comment>
									 <argument><expr><name>false</name></expr></argument>, <comment type="block">/* pseudoconstant */</comment>
									 <argument><expr><name>security_level</name></expr></argument>,	<comment type="block">/* security_level */</comment>
									 <argument><expr><name>qualscope</name></expr></argument>, <comment type="block">/* required_relids */</comment>
									 <argument><expr><name>NULL</name></expr></argument>,	<comment type="block">/* outer_relids */</comment>
									 <argument><expr><name>nullable_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* nullable_relids */</comment>

	<comment type="block">/* Set mergejoinability/hashjoinability flags */</comment>
	<expr_stmt><expr><call><name>check_mergejoinable</name><argument_list>(<argument><expr><name>restrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_hashjoinable</name><argument_list>(<argument><expr><name>restrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_batchable</name><argument_list>(<argument><expr><name>restrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>restrictinfo</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * match_foreign_keys_to_quals
 *		Match foreign-key constraints to equivalence classes and join quals
 *
 * The idea here is to see which query join conditions match equality
 * constraints of a foreign-key relationship.  For such join conditions,
 * we can use the FK semantics to make selectivity estimates that are more
 * reliable than estimating from statistics, especially for multiple-column
 * FKs, where the normal assumption of independent conditions tends to fail.
 *
 * In this function we annotate the ForeignKeyOptInfos in root-&gt;fkey_list
 * with info about which eclasses and join qual clauses they match, and
 * discard any ForeignKeyOptInfos that are irrelevant for the query.
 */</comment>
<function><type><name>void</name></type>
<name>match_foreign_keys_to_quals</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;fkey_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ForeignKeyOptInfo</name> <modifier>*</modifier></type><name>fkinfo</name> <init>= <expr><operator>(</operator><name>ForeignKeyOptInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>con_rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>ref_rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>colno</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Either relid might identify a rel that is in the query's rtable but
		 * isn't referenced by the jointree so won't have a RelOptInfo.  Hence
		 * don't use find_base_rel() here.  We can ignore such FKs.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>fkinfo</name><operator>-&gt;</operator><name>con_relid</name></name> <operator>&gt;=</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name> <operator>||</operator>
			<name><name>fkinfo</name><operator>-&gt;</operator><name>ref_relid</name></name> <operator>&gt;=</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* just paranoia */</comment>
		<expr_stmt><expr><name>con_rel</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name><name>fkinfo</name><operator>-&gt;</operator><name>con_relid</name></name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>con_rel</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>ref_rel</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name><name>fkinfo</name><operator>-&gt;</operator><name>ref_relid</name></name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ref_rel</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Ignore FK unless both rels are baserels.  This gets rid of FKs that
		 * link to inheritance child rels (otherrels) and those that link to
		 * rels removed by join removal (dead rels).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>con_rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>!=</operator> <name>RELOPT_BASEREL</name> <operator>||</operator>
			<name><name>ref_rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>!=</operator> <name>RELOPT_BASEREL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Scan the columns and try to match them to eclasses and quals.
		 *
		 * Note: for simple inner joins, any match should be in an eclass.
		 * "Loose" quals that syntactically match an FK equality must have
		 * been rejected for EC status because they are outer-join quals or
		 * similar.  We can still consider them to match the FK if they are
		 * not outerjoin_delayed.
		 */</comment>
		<for>for <control>(<init><expr><name>colno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>colno</name> <operator>&lt;</operator> <name><name>fkinfo</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>colno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>con_attno</name></decl>,
						<decl><type ref="prev"/><name>ref_attno</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>fpeqop</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>fkinfo</name><operator>-&gt;</operator><name>eclass</name><index>[<expr><name>colno</name></expr>]</index></name> <operator>=</operator> <call><name>match_eclasses_to_foreign_key_col</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
																	  <argument><expr><name>fkinfo</name></expr></argument>,
																	  <argument><expr><name>colno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Don't bother looking for loose quals if we got an EC match */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>fkinfo</name><operator>-&gt;</operator><name>eclass</name><index>[<expr><name>colno</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>fkinfo</name><operator>-&gt;</operator><name>nmatched_ec</name></name><operator>++</operator></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Scan joininfo list for relevant clauses.  Either rel's joininfo
			 * list would do equally well; we use con_rel's.
			 */</comment>
			<expr_stmt><expr><name>con_attno</name> <operator>=</operator> <name><name>fkinfo</name><operator>-&gt;</operator><name>conkey</name><index>[<expr><name>colno</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ref_attno</name> <operator>=</operator> <name><name>fkinfo</name><operator>-&gt;</operator><name>confkey</name><index>[<expr><name>colno</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>fpeqop</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>	<comment type="block">/* we'll look this up only if needed */</comment>

			<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>con_rel-&gt;joininfo</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>clause</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>leftvar</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>rightvar</name></decl>;</decl_stmt>

				<comment type="block">/* Ignore outerjoin-delayed clauses */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>outerjoin_delayed</name></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<comment type="block">/* Only binary OpExprs are useful for consideration */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call> <operator>||</operator>
					<call><name>list_length</name><argument_list>(<argument><expr><name><name>clause</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>leftvar</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>get_leftop</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rightvar</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>get_rightop</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Operands must be Vars, possibly with RelabelType */</comment>
				<while>while <condition>(<expr><name>leftvar</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>leftvar</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>leftvar</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>leftvar</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></while>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>leftvar</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>leftvar</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<while>while <condition>(<expr><name>rightvar</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>rightvar</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>rightvar</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>rightvar</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></while>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>rightvar</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>rightvar</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<comment type="block">/* Now try to match the vars to the current foreign key cols */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>fkinfo</name><operator>-&gt;</operator><name>ref_relid</name></name> <operator>==</operator> <name><name>leftvar</name><operator>-&gt;</operator><name>varno</name></name> <operator>&amp;&amp;</operator>
					<name>ref_attno</name> <operator>==</operator> <name><name>leftvar</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&amp;&amp;</operator>
					<name><name>fkinfo</name><operator>-&gt;</operator><name>con_relid</name></name> <operator>==</operator> <name><name>rightvar</name><operator>-&gt;</operator><name>varno</name></name> <operator>&amp;&amp;</operator>
					<name>con_attno</name> <operator>==</operator> <name><name>rightvar</name><operator>-&gt;</operator><name>varattno</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Vars match, but is it the right operator? */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>clause</name><operator>-&gt;</operator><name>opno</name></name> <operator>==</operator> <name><name>fkinfo</name><operator>-&gt;</operator><name>conpfeqop</name><index>[<expr><name>colno</name></expr>]</index></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>fkinfo</name><operator>-&gt;</operator><name>rinfos</name><index>[<expr><name>colno</name></expr>]</index></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>fkinfo</name><operator>-&gt;</operator><name>rinfos</name><index>[<expr><name>colno</name></expr>]</index></name></expr></argument>,
														<argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>fkinfo</name><operator>-&gt;</operator><name>nmatched_ri</name></name><operator>++</operator></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>fkinfo</name><operator>-&gt;</operator><name>ref_relid</name></name> <operator>==</operator> <name><name>rightvar</name><operator>-&gt;</operator><name>varno</name></name> <operator>&amp;&amp;</operator>
						 <name>ref_attno</name> <operator>==</operator> <name><name>rightvar</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&amp;&amp;</operator>
						 <name><name>fkinfo</name><operator>-&gt;</operator><name>con_relid</name></name> <operator>==</operator> <name><name>leftvar</name><operator>-&gt;</operator><name>varno</name></name> <operator>&amp;&amp;</operator>
						 <name>con_attno</name> <operator>==</operator> <name><name>leftvar</name><operator>-&gt;</operator><name>varattno</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Reverse match, must check commutator operator.  Look it
					 * up if we didn't already.  (In the worst case we might
					 * do multiple lookups here, but that would require an FK
					 * equality operator without commutator, which is
					 * unlikely.)
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>fpeqop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>fpeqop</name> <operator>=</operator> <call><name>get_commutator</name><argument_list>(<argument><expr><name><name>fkinfo</name><operator>-&gt;</operator><name>conpfeqop</name><index>[<expr><name>colno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>clause</name><operator>-&gt;</operator><name>opno</name></name> <operator>==</operator> <name>fpeqop</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>fkinfo</name><operator>-&gt;</operator><name>rinfos</name><index>[<expr><name>colno</name></expr>]</index></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>fkinfo</name><operator>-&gt;</operator><name>rinfos</name><index>[<expr><name>colno</name></expr>]</index></name></expr></argument>,
														<argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>fkinfo</name><operator>-&gt;</operator><name>nmatched_ri</name></name><operator>++</operator></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<comment type="block">/* If we found any matching loose quals, count col as matched */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>fkinfo</name><operator>-&gt;</operator><name>rinfos</name><index>[<expr><name>colno</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>fkinfo</name><operator>-&gt;</operator><name>nmatched_rcols</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Currently, we drop multicolumn FKs that aren't fully matched to the
		 * query.  Later we might figure out how to derive some sort of
		 * estimate from them, in which case this test should be weakened to
		 * "if ((fkinfo-&gt;nmatched_ec + fkinfo-&gt;nmatched_rcols) &gt; 0)".
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>fkinfo</name><operator>-&gt;</operator><name>nmatched_ec</name></name> <operator>+</operator> <name><name>fkinfo</name><operator>-&gt;</operator><name>nmatched_rcols</name></name><operator>)</operator> <operator>==</operator> <name><name>fkinfo</name><operator>-&gt;</operator><name>nkeys</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newlist</name></expr></argument>, <argument><expr><name>fkinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<comment type="block">/* Replace fkey_list, thereby discarding any useless entries */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>fkey_list</name></name> <operator>=</operator> <name>newlist</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 *
 *	 CHECKS FOR MERGEJOINABLE AND HASHJOINABLE CLAUSES
 *
 *****************************************************************************/</comment>

<comment type="block">/*
 * check_mergejoinable
 *	  If the restrictinfo's clause is mergejoinable, set the mergejoin
 *	  info fields in the restrictinfo.
 *
 *	  Currently, we support mergejoin for binary opclauses where
 *	  the operator is a mergejoinable operator.  The arguments can be
 *	  anything --- as long as there are no volatile functions in them.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_mergejoinable</name><parameter_list>(<parameter><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>restrictinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>clause</name> <init>= <expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>leftarg</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>pseudoconstant</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_opclause</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>opno</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>opno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>leftarg</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>op_mergejoinable</name><argument_list>(<argument><expr><name>opno</name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>leftarg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>mergeopfamilies</name></name> <operator>=</operator> <call><name>get_mergejoin_opfamilies</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Note: op_mergejoinable is just a hint; if we fail to find the operator
	 * in any btree opfamilies, mergeopfamilies remains NIL and so the clause
	 * is not treated as mergejoinable.
	 */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * check_hashjoinable
 *	  If the restrictinfo's clause is hashjoinable, set the hashjoin
 *	  info fields in the restrictinfo.
 *
 *	  Currently, we support hashjoin for binary opclauses where
 *	  the operator is a hashjoinable operator.  The arguments can be
 *	  anything --- as long as there are no volatile functions in them.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_hashjoinable</name><parameter_list>(<parameter><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>restrictinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>clause</name> <init>= <expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>leftarg</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>pseudoconstant</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_opclause</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>opno</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>opno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>leftarg</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>op_hashjoinable</name><argument_list>(<argument><expr><name>opno</name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>leftarg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>hashjoinoperator</name></name> <operator>=</operator> <name>opno</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * check_batchable
 *	  If the restrictinfo's clause can potentially be a batched join clause
 *	  then yb_batched_rinfo is filled in with candidate batched versions of
 *	  this clause.
 *		
 *	  Note that this does nothing if yb_bnl_batch_size indicates no batching.
 *	  Right now we only support batching mergejoinable conditions of the form
 *	  var_1 op var_2. These yield batched expressions,
 *	  var_1 op YbBatchedExpr(var_2) and var_2 op YbBatchedExpr(var_1).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_batchable</name><parameter_list>(<parameter><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>restrictinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>clause</name> <init>= <expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>leftarg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>rightarg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>opexpr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>yb_bnl_batch_size</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>restrictinfo</name><operator>-&gt;</operator><name>mergeopfamilies</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>leftarg</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rightarg</name> <operator>=</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>outer</name> <init>= <expr><name>leftarg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>inner</name> <init>= <expr><name>rightarg</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>inner</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>outer</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>num_batched_rinfos</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>inner</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>outer</name> <operator>=</operator> <name>rightarg</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>inner</name> <operator>=</operator> <name>leftarg</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>num_batched_rinfos</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>left_relids</name></name></expr></argument>, <argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>right_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>outerType</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>outer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>outerTypMod</name> <init>= <expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>outer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>innerType</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>inner</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>innerTypMod</name> <init>= <expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>inner</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>opno</name> <init>= <expr><name><name>opexpr</name><operator>-&gt;</operator><name>opno</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>outerType</name> <operator>!=</operator> <name>innerType</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We need to coerce one of the operands to a common type. */</comment>
		<decl_stmt><decl><type><name>Oid</name></type> <name>finalargtype</name> <init>= <expr><name>innerType</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>finalargtypmod</name> <init>= <expr><name>innerTypMod</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>coerced</name> <init>= <expr><call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>outer</name></expr></argument>, <argument><expr><name>outerType</name></expr></argument>,
											  <argument><expr><name>finalargtype</name></expr></argument>, <argument><expr><name>finalargtypmod</name></expr></argument>,
											  <argument><expr><name>COERCION_IMPLICIT</name></expr></argument>,
											  <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>coerced</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>finalargtype</name> <operator>=</operator> <name>outerType</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>finalargtypmod</name> <operator>=</operator> <name>outerTypMod</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>coerced</name> <operator>=</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>inner</name></expr></argument>, <argument><expr><name>innerType</name></expr></argument>,
											<argument><expr><name>finalargtype</name></expr></argument>, <argument><expr><name>finalargtypmod</name></expr></argument>,
											<argument><expr><name>COERCION_IMPLICIT</name></expr></argument>,
											<argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* If we can't cast either operand, we can't batch. */</comment>
			<if_stmt><if>if <condition>(<expr><name>coerced</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>inner</name> <operator>=</operator> <name>outer</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		
		<comment type="block">/* Casted operand needs to always be on the outer side for now. */</comment>
		<comment type="block">/* 
		 * If we can't swap outer and inner and outer isn't the correct one,
		 * we can't batch. Bail.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>num_batched_rinfos</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>outer</name> <operator>!=</operator> <name>coerced</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>outer</name> <operator>=</operator> <name>coerced</name></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>opname</name> <init>= <expr><call><name>get_opname</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>names</name> <init>= <expr><call><name>lappend</name><argument_list>(<argument><expr><name>NIL</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>opname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		
		<comment type="block">/* Find an equivalent operator whose operands are of the same type. */</comment>
		<decl_stmt><decl><type><name>Oid</name></type> <name>newopno</name> <init>= 
			<expr><call><name>OpernameGetOprid</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><name>finalargtype</name></expr></argument>, <argument><expr><name>finalargtype</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>newopno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
		
		<expr_stmt><expr><name>opno</name> <operator>=</operator> <name>newopno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>opname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Only one isomoporh of this expression is batchable. */</comment>
		<expr_stmt><expr><name>num_batched_rinfos</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_batched_rinfos</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>YbBatchedExpr</name> <modifier>*</modifier></type><name>bexpr</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>YbBatchedExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>bexpr</name><operator>-&gt;</operator><name>orig_expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name><operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>batched_op</name> <init>= <expr><call><name>make_opclause</name><argument_list>(<argument><expr><name>opno</name></expr></argument>,
										 <argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>opresulttype</name></name></expr></argument>,
										 <argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>opretset</name></name></expr></argument>,
										 <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>inner</name></expr></argument>,
										 <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>bexpr</name></expr></argument>,
										 <argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>opcollid</name></name></expr></argument>,
										 <argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>batched</name> <init>=
			<expr><call><name>make_restrictinfo</name><argument_list>(<argument><expr><name>batched_op</name></expr></argument>,
							  <argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>is_pushed_down</name></name></expr></argument>,
							  <argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>outerjoin_delayed</name></name></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>,
							  <argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>security_level</name></name></expr></argument>,
							  <argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>required_relids</name></name></expr></argument>,
							  <argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>outer_relids</name></name></expr></argument>,
							  <argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>nullable_relids</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>yb_batched_rinfo</name></name> <operator>=</operator>
			<call><name>lappend</name><argument_list>(<argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>yb_batched_rinfo</name></name></expr></argument>, <argument><expr><name>batched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>outer</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>outer</name> <operator>=</operator> <name>inner</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>inner</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>
</unit>
