<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/optimizer/path/allpaths.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * allpaths.c
 *	  Routines to find possible search paths for processing a query
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/optimizer/path/allpaths.c
 *
 * The following only applies to changes made to this file as part of
 * YugaByte development.
 *
 * Portions Copyright (c) YugaByte, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you
 * may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied.  See the License for the specific language governing
 * permissions and limitations under the License.
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/rel.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tsmapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_database.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/fdwapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>OPTIMIZER_DEBUG</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/print.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/geqo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/paths.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/plancat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/prep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/restrictinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/var.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_clause.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning/partprune.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>

<comment type="block">/*  YB includes. */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/ybc_fdw.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/ybcExpr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_yb_utils.h"</cpp:file></cpp:include>

<comment type="block">/* results of subquery_is_pushdown_safe */</comment>
<typedef>typedef <type><struct>struct <name>pushdown_safety_info</name>
<block>{
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>unsafeColumns</name></decl>;</decl_stmt>	<comment type="block">/* which output columns are unsafe to use */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>unsafeVolatile</name></decl>;</decl_stmt> <comment type="block">/* don't push down volatile quals */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>unsafeLeaky</name></decl>;</decl_stmt>	<comment type="block">/* don't push down leaky quals */</comment>
}</block></struct></type> <name>pushdown_safety_info</name>;</typedef>

<comment type="block">/* These parameters are set by GUC */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>enable_geqo</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* just in case GUC doesn't set it */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>geqo_threshold</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>min_parallel_table_scan_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>min_parallel_index_scan_size</name></decl>;</decl_stmt>

<comment type="block">/* Hook for plugins to get control in set_rel_pathlist() */</comment>
<decl_stmt><decl><type><name>set_rel_pathlist_hook_type</name></type> <name>set_rel_pathlist_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Hook for plugins to replace standard_join_search() */</comment>
<decl_stmt><decl><type><name>join_search_hook_type</name></type> <name>join_search_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_base_rel_consider_startup</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_base_rel_sizes</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_base_rel_pathlists</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_rel_size</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
			 <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_rel_pathlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
				 <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_plain_rel_size</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
				   <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>create_plain_partial_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_rel_consider_parallel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						  <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_plain_rel_pathlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
					   <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_tablesample_rel_size</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						 <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_tablesample_rel_pathlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
							 <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_foreign_size</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
				 <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_foreign_pathlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
					 <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_append_rel_size</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
					<parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_append_rel_pathlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						<parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>generate_mergeappend_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>live_childrels</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>all_child_pathkeys</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitioned_rels</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Path</name> <modifier>*</modifier></type><name>get_cheapest_parameterized_child_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
									  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
									  <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>accumulate_append_subpath</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>subpaths</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>special_subpaths</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_subquery_pathlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
					  <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_function_pathlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
					  <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_values_pathlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
					<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_tablefunc_pathlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
					   <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_cte_pathlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
				 <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_namedtuplestore_pathlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
							 <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_worktable_pathlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
					   <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type><name>make_rel_from_joinlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinlist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>subquery_is_pushdown_safe</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>topquery</name></decl></parameter>,
						  <parameter><decl><type><name>pushdown_safety_info</name> <modifier>*</modifier></type><name>safetyInfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>recurse_pushdown_safe</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>setOp</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>topquery</name></decl></parameter>,
					  <parameter><decl><type><name>pushdown_safety_info</name> <modifier>*</modifier></type><name>safetyInfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_output_expressions</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name></decl></parameter>,
						 <parameter><decl><type><name>pushdown_safety_info</name> <modifier>*</modifier></type><name>safetyInfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>compare_tlist_datatypes</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colTypes</name></decl></parameter>,
						<parameter><decl><type><name>pushdown_safety_info</name> <modifier>*</modifier></type><name>safetyInfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>targetIsInAllPartitionLists</name><parameter_list>(<parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>qual_is_pushdown_safe</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>,
					  <parameter><decl><type><name>pushdown_safety_info</name> <modifier>*</modifier></type><name>safetyInfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>subquery_push_qual</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name></decl></parameter>,
				   <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>recurse_push_qual</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>setOp</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>topquery</name></decl></parameter>,
				  <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>remove_unused_subquery_outputs</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * make_one_rel
 *	  Finds all possible access paths for executing a query, returning a
 *	  single rel that represents the join of all base rels in the query.
 */</comment>
<function><type><name>RelOptInfo</name> <modifier>*</modifier></type>
<name>make_one_rel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>rti</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Construct the all_baserels Relids set.
	 */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>all_baserels</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>rti</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>rti</name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name></expr>;</condition> <incr><expr><name>rti</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>brel</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>rti</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* there may be empty slots corresponding to non-baserel RTEs */</comment>
		<if_stmt><if>if <condition>(<expr><name>brel</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>brel</name><operator>-&gt;</operator><name>relid</name></name> <operator>==</operator> <name>rti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* sanity check on array */</comment>

		<comment type="block">/* ignore RTEs that are "other rels" */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>brel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>!=</operator> <name>RELOPT_BASEREL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>all_baserels</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>all_baserels</name></name></expr></argument>, <argument><expr><name><name>brel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>rti</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>rti</name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name></expr>;</condition> <incr><expr><name>rti</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>relation</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>rti</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>relation</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>relation</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name>rti</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>IsYBRelationById</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
					<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
					<comment type="block">/*
					 * Set the YugaByte FDW routine because we will use the foreign
					 * scan API below.
					 */</comment>
					<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>is_yb_relation</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>=</operator> <operator>(</operator><name>FdwRoutine</name> <operator>*</operator><operator>)</operator> <call><name>ybc_fdw_handler</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>relation-&gt;baserestrictinfo</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>ri</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<expr_stmt><expr><name><name>ri</name><operator>-&gt;</operator><name>yb_pushable</name></name> <operator>=</operator> <call><name>YbCanPushdownExpr</name><argument_list>(<argument><expr><name><name>ri</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Mark base rels as to whether we care about fast-start plans */</comment>
	<expr_stmt><expr><call><name>set_base_rel_consider_startup</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute size estimates and consider_parallel flags for each base rel,
	 * then generate access paths.
	 */</comment>
	<expr_stmt><expr><call><name>set_base_rel_sizes</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_base_rel_pathlists</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Generate access paths for the entire join tree.
	 */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>make_rel_from_joinlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The result should join all and only the query's base rels.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_equal</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>all_baserels</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * set_base_rel_consider_startup
 *	  Set the consider_[param_]startup flags for each base-relation entry.
 *
 * For the moment, we only deal with consider_param_startup here; because the
 * logic for consider_startup is pretty trivial and is the same for every base
 * relation, we just let build_simple_rel() initialize that flag correctly to
 * start with.  If that logic ever gets more complicated it would probably
 * be better to move it here.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_base_rel_consider_startup</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Since parameterized paths can only be used on the inside of a nestloop
	 * join plan, there is usually little value in considering fast-start
	 * plans for them.  However, for relations that are on the RHS of a SEMI
	 * or ANTI join, a fast-start plan can be useful because we're only going
	 * to care about fetching one tuple anyway.
	 *
	 * To minimize growth of planning time, we currently restrict this to
	 * cases where the RHS is a single base relation, not a join; there is no
	 * provision for consider_param_startup to get set at all on joinrels.
	 * Also we don't worry about appendrels.  costsize.c's costing rules for
	 * nestloop semi/antijoins don't consider such cases either.
	 */</comment>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;join_info_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name> <init>= <expr><operator>(</operator><name>SpecialJoinInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>varno</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_SEMI</name> <operator>||</operator> <name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_ANTI</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<call><name>bms_get_singleton_member</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>varno</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><call><name>find_base_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>varno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>consider_param_startup</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * set_base_rel_sizes
 *	  Set the size estimates (rows and widths) for each base-relation entry.
 *	  Also determine whether to consider parallel paths for base relations.
 *
 * We do this in a separate pass over the base rels so that rowcount
 * estimates are available for parameterized path generation, and also so
 * that each rel's consider_parallel flag is set correctly before we begin to
 * generate paths.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_base_rel_sizes</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Index</name></type>		<name>rti</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>rti</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>rti</name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name></expr>;</condition> <incr><expr><name>rti</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>rti</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

		<comment type="block">/* there may be empty slots corresponding to non-baserel RTEs */</comment>
		<if_stmt><if>if <condition>(<expr><name>rel</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>==</operator> <name>rti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* sanity check on array */</comment>

		<comment type="block">/* ignore RTEs that are "other rels" */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>!=</operator> <name>RELOPT_BASEREL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>rte</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name>rti</name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If parallelism is allowable for this query in general, see whether
		 * it's allowable for this rel in particular.  We have to do this
		 * before set_rel_size(), because (a) if this rel is an inheritance
		 * parent, set_append_rel_size() will use and perhaps change the rel's
		 * consider_parallel flag, and (b) for some RTE types, set_rel_size()
		 * goes ahead and makes paths immediately.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>parallelModeOK</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>set_rel_consider_parallel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>set_rel_size</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * set_base_rel_pathlists
 *	  Finds all paths available for scanning each base-relation entry.
 *	  Sequential scan and any available indices are considered.
 *	  Each useful path is attached to its relation's 'pathlist' field.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_base_rel_pathlists</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Index</name></type>		<name>rti</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>rti</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>rti</name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name></expr>;</condition> <incr><expr><name>rti</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>rti</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* there may be empty slots corresponding to non-baserel RTEs */</comment>
		<if_stmt><if>if <condition>(<expr><name>rel</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>==</operator> <name>rti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* sanity check on array */</comment>

		<comment type="block">/* ignore RTEs that are "other rels" */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>!=</operator> <name>RELOPT_BASEREL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>set_rel_pathlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name>rti</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * set_rel_size
 *	  Set size estimates for a base relation
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_rel_size</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
			 <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_BASEREL</name> <operator>&amp;&amp;</operator>
		<call><name>relation_excluded_by_constraints</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We proved we don't need to scan the rel via constraint exclusion,
		 * so set up a single dummy path for it.  Here we only check this for
		 * regular baserels; if it's an otherrel, CE was already checked in
		 * set_append_rel_size().
		 *
		 * In this case, we go ahead and set up the relation's path right away
		 * instead of leaving it for set_rel_pathlist to do.  This is because
		 * we don't have a convention for marking a rel as dummy except by
		 * assigning a dummy path to it.
		 */</comment>
		<expr_stmt><expr><call><name>set_dummy_rel_pathlist</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* It's an "append relation", process accordingly */</comment>
		<expr_stmt><expr><call><name>set_append_rel_size</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>RTE_RELATION</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Foreign table */</comment>
					<expr_stmt><expr><call><name>set_foreign_size</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * A partitioned table without any partitions is marked as
					 * a dummy rel.
					 */</comment>
					<expr_stmt><expr><call><name>set_dummy_rel_pathlist</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>tablesample</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>IsYBRelationById</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* TODO we don't support tablesample queries yet. */</comment>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"'TABLESAMPLE' clause is not yet "</literal>
										<literal type="string">"supported by YugaByte"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/* Sampled relation */</comment>
					<expr_stmt><expr><call><name>set_tablesample_rel_size</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Plain relation */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>IsYBRelationById</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>set_foreign_size</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* Use regular scan for initdb tables. */</comment>
						<expr_stmt><expr><call><name>set_plain_rel_size</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>

				<comment type="block">/*
				 * Subqueries don't support making a choice between
				 * parameterized and unparameterized paths, so just go ahead
				 * and build their paths immediately.
				 */</comment>
				<expr_stmt><expr><call><name>set_subquery_pathlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_FUNCTION</name></expr>:</case>
				<expr_stmt><expr><call><name>set_function_size_estimates</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_TABLEFUNC</name></expr>:</case>
				<expr_stmt><expr><call><name>set_tablefunc_size_estimates</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_VALUES</name></expr>:</case>
				<expr_stmt><expr><call><name>set_values_size_estimates</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_CTE</name></expr>:</case>

				<comment type="block">/*
				 * CTEs don't support making a choice between parameterized
				 * and unparameterized paths, so just go ahead and build their
				 * paths immediately.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>self_reference</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>set_worktable_pathlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>set_cte_pathlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_NAMEDTUPLESTORE</name></expr>:</case>
				<expr_stmt><expr><call><name>set_namedtuplestore_pathlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected rtekind: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * We insist that all non-dummy rels have a nonzero rowcount estimate.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rows</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>IS_DUMMY_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set_rel_pathlist
 *	  Build access paths for a base relation
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_rel_pathlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
				 <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IS_DUMMY_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We already proved the relation empty, so nothing more to do */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* It's an "append relation", process accordingly */</comment>
		<expr_stmt><expr><call><name>set_append_rel_pathlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>RTE_RELATION</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Foreign table */</comment>
					<expr_stmt><expr><call><name>set_foreign_pathlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>tablesample</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>IsYBRelationById</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* TODO we don't support tablesample queries yet. */</comment>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"'TABLESAMPLE' clause is not yet "</literal>
									   <literal type="string">"supported by YugaByte"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/* Sampled relation */</comment>
					<expr_stmt><expr><call><name>set_tablesample_rel_pathlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Plain relation */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>IsYBRelationById</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * Using a foreign scan which will use the YB FDW by
						 * default.
						 */</comment>
						<expr_stmt><expr><call><name>set_foreign_pathlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* Use regular scan for initdb tables. */</comment>
						<expr_stmt><expr><call><name>set_plain_rel_pathlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>
				<comment type="block">/* Subquery --- fully handled during set_rel_size */</comment>
				<break>break;</break>
			<case>case <expr><name>RTE_FUNCTION</name></expr>:</case>
				<comment type="block">/* RangeFunction */</comment>
				<expr_stmt><expr><call><name>set_function_pathlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_TABLEFUNC</name></expr>:</case>
				<comment type="block">/* Table Function */</comment>
				<expr_stmt><expr><call><name>set_tablefunc_pathlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_VALUES</name></expr>:</case>
				<comment type="block">/* Values list */</comment>
				<expr_stmt><expr><call><name>set_values_pathlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_CTE</name></expr>:</case>
				<comment type="block">/* CTE reference --- fully handled during set_rel_size */</comment>
				<break>break;</break>
			<case>case <expr><name>RTE_NAMEDTUPLESTORE</name></expr>:</case>
				<comment type="block">/* tuplestore reference --- fully handled during set_rel_size */</comment>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected rtekind: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Allow a plugin to editorialize on the set of Paths for this base
	 * relation.  It could add new paths (such as CustomPaths) by calling
	 * add_path(), or add_partial_path() if parallel aware.  It could also
	 * delete or modify paths added by the core code.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>set_rel_pathlist_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>set_rel_pathlist_hook</name>) <argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If this is a baserel, we should normally consider gathering any partial
	 * paths we may have created for it.  We have to do this after calling the
	 * set_rel_pathlist_hook, else it cannot add partial paths to be included
	 * here.
	 *
	 * However, if this is an inheritance child, skip it.  Otherwise, we could
	 * end up with a very large number of gather nodes, each trying to grab
	 * its own pool of workers.  Instead, we'll consider gathering partial
	 * paths for the parent appendrel.
	 *
	 * Also, if this is the topmost scan/join rel (that is, the only baserel),
	 * we postpone gathering until the final scan/join targetlist is available
	 * (see grouping_planner).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_BASEREL</name> <operator>&amp;&amp;</operator>
		<call><name>bms_membership</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>all_baserels</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>BMS_SINGLETON</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>generate_gather_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Now find the cheapest of the paths for this rel */</comment>
	<expr_stmt><expr><call><name>set_cheapest</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>OPTIMIZER_DEBUG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>debug_print_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * set_plain_rel_size
 *	  Set size estimates for a plain relation (no subquery, no inheritance)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_plain_rel_size</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Test any partial indexes of rel for applicability.  We must do this
	 * first since partial unique indexes can affect size estimates.
	 */</comment>
	<expr_stmt><expr><call><name>check_index_predicates</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark rel with estimated output rows, width, etc */</comment>
	<expr_stmt><expr><call><name>set_baserel_size_estimates</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * If this relation could possibly be scanned from within a worker, then set
 * its consider_parallel flag.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_rel_consider_parallel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						  <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * The flag has previously been initialized to false, so we can just
	 * return if it becomes clear that we can't safely set it.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Don't call this if parallelism is disallowed for the entire query. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>parallelModeOK</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* This should only be called for baserels and appendrel children. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_SIMPLE_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Assorted checks based on rtekind. */</comment>
	<switch>switch <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RTE_RELATION</name></expr>:</case>

			<comment type="block">/*
			 * Currently, parallel workers can't access the leader's temporary
			 * tables.  We could possibly relax this if the wrote all of its
			 * local buffers at the start of the query and made no changes
			 * thereafter (maybe we could allow hint bit changes), and if we
			 * taught the workers to read them.  Writing a large number of
			 * temporary buffers could be expensive, though, and we don't have
			 * the rest of the necessary infrastructure right now anyway.  So
			 * for now, bail out if we see a temporary table.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>get_rel_persistence</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Table sampling can be pushed down to workers if the sample
			 * function and its arguments are safe.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>tablesample</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type>		<name>proparallel</name> <init>= <expr><call><name>func_parallel</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>tablesample</name><operator>-&gt;</operator><name>tsmhandler</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>proparallel</name> <operator>!=</operator> <name>PROPARALLEL_SAFE</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>tablesample</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Ask FDWs whether they can support performing a ForeignScan
			 * within a worker.  Most often, the answer will be no.  For
			 * example, if the nature of the FDW is such that it opens a TCP
			 * connection with a remote server, each parallel worker would end
			 * up with a separate connection, and these connections might not
			 * be appropriately coordinated between workers and the leader.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>fdwroutine</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>fdwroutine</name><operator>-&gt;</operator><name>IsForeignScanParallelSafe</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>rel</name><operator>-&gt;</operator><name>fdwroutine</name><operator>-&gt;</operator><name>IsForeignScanParallelSafe</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* If YB scan, disable parallelization for now. */</comment>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * There are additional considerations for appendrels, which we'll
			 * deal with in set_append_rel_size and set_append_rel_pathlist.
			 * For now, just set consider_parallel based on the rel's own
			 * quals and targetlist.
			 */</comment>
			<break>break;</break>

		<case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>

			<comment type="block">/*
			 * There's no intrinsic problem with scanning a subquery-in-FROM
			 * (as distinct from a SubPlan or InitPlan) in a parallel worker.
			 * If the subquery doesn't happen to have any parallel-safe paths,
			 * then flagging it as consider_parallel won't change anything,
			 * but that's true for plain tables, too.  We must set
			 * consider_parallel based on the rel's own quals and targetlist,
			 * so that if a subquery path is parallel-safe but the quals and
			 * projection we're sticking onto it are not, we correctly mark
			 * the SubqueryScanPath as not parallel-safe.  (Note that
			 * set_subquery_pathlist() might push some of these quals down
			 * into the subquery itself, but that doesn't change anything.)
			 *
			 * We can't push sub-select containing LIMIT/OFFSET to workers as
			 * there is no guarantee that the row order will be fully
			 * deterministic, and applying LIMIT/OFFSET will lead to
			 * inconsistent results at the top-level.  (In some cases, where
			 * the result is ordered, we could relax this restriction.  But it
			 * doesn't currently seem worth expending extra effort to do so.)
			 */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>subquery</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>limit_needed</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>RTE_JOIN</name></expr>:</case>
			<comment type="block">/* Shouldn't happen; we're only considering baserels here. */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>

		<case>case <expr><name>RTE_FUNCTION</name></expr>:</case>
			<comment type="block">/* Check for parallel-restricted functions. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>RTE_TABLEFUNC</name></expr>:</case>
			<comment type="block">/* not parallel safe */</comment>
			<return>return;</return>

		<case>case <expr><name>RTE_VALUES</name></expr>:</case>
			<comment type="block">/* Check for parallel-restricted functions. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>RTE_CTE</name></expr>:</case>

			<comment type="block">/*
			 * CTE tuplestores aren't shared among parallel workers, so we
			 * force all CTE scans to happen in the leader.  Also, populating
			 * the CTE would require executing a subplan that's not available
			 * in the worker, might be parallel-restricted, and must get
			 * executed only once.
			 */</comment>
			<return>return;</return>

		<case>case <expr><name>RTE_NAMEDTUPLESTORE</name></expr>:</case>

			<comment type="block">/*
			 * tuplestore cannot be shared, at least without more
			 * infrastructure to support that.
			 */</comment>
			<return>return;</return>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * If there's anything in baserestrictinfo that's parallel-restricted, we
	 * give up on parallelizing access to this relation.  We could consider
	 * instead postponing application of the restricted quals until we're
	 * above all the parallelism in the plan tree, but it's not clear that
	 * that would be a win in very many cases, and it might be tricky to make
	 * outer join clauses work correctly.  It would likely break equivalence
	 * classes, too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Likewise, if the relation's outputs are not parallel-safe, give up.
	 * (Usually, they're just Vars, but sometimes they're not.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* We have a winner. */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set_plain_rel_pathlist
 *	  Build access paths for a plain relation (no subquery, no inheritance)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_plain_rel_pathlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>required_outer</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We don't support pushing join clauses into the quals of a seqscan, but
	 * it could still have required parameterization due to LATERAL refs in
	 * its tlist.
	 */</comment>
	<expr_stmt><expr><name>required_outer</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr>;</expr_stmt>

	<comment type="block">/* Consider sequential scan */</comment>
	<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>create_seqscan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If appropriate, consider parallel sequential scan */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator> <name>required_outer</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>create_plain_partial_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Consider index scans */</comment>
	<expr_stmt><expr><call><name>create_index_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Consider TID scans */</comment>
	<expr_stmt><expr><call><name>create_tidscan_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * create_plain_partial_paths
 *	  Build partial access paths for parallel scan of a plain relation
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>create_plain_partial_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>parallel_workers</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>parallel_workers</name> <operator>=</operator> <call><name>compute_parallel_worker</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>pages</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
											   <argument><expr><name>max_parallel_workers_per_gather</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If any limit was set to zero, the user doesn't want a parallel scan. */</comment>
	<if_stmt><if>if <condition>(<expr><name>parallel_workers</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Add an unordered partial path based on a parallel sequential scan. */</comment>
	<expr_stmt><expr><call><name>add_partial_path</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>create_seqscan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>parallel_workers</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set_tablesample_rel_size
 *	  Set size estimates for a sampled relation
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_tablesample_rel_size</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TableSampleClause</name> <modifier>*</modifier></type><name>tsc</name> <init>= <expr><name><name>rte</name><operator>-&gt;</operator><name>tablesample</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TsmRoutine</name> <modifier>*</modifier></type><name>tsm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>pages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>tuples</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Test any partial indexes of rel for applicability.  We must do this
	 * first since partial unique indexes can affect size estimates.
	 */</comment>
	<expr_stmt><expr><call><name>check_index_predicates</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Call the sampling method's estimation function to estimate the number
	 * of pages it will read and the number of tuples it will return.  (Note:
	 * we assume the function returns sane values.)
	 */</comment>
	<expr_stmt><expr><name>tsm</name> <operator>=</operator> <call><name>GetTsmRoutine</name><argument_list>(<argument><expr><name><name>tsc</name><operator>-&gt;</operator><name>tsmhandler</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name><name>tsm</name><operator>-&gt;</operator><name>SampleScanGetSampleSize</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>tsc</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>pages</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For the moment, because we will only consider a SampleScan path for the
	 * rel, it's okay to just overwrite the pages and tuples estimates for the
	 * whole relation.  If we ever consider multiple path types for sampled
	 * rels, we'll need more complication.
	 */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>pages</name></name> <operator>=</operator> <name>pages</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator> <name>tuples</name></expr>;</expr_stmt>

	<comment type="block">/* Mark rel with estimated output rows, width, etc */</comment>
	<expr_stmt><expr><call><name>set_baserel_size_estimates</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set_tablesample_rel_pathlist
 *	  Build access paths for a sampled relation
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_tablesample_rel_pathlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>required_outer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We don't support pushing join clauses into the quals of a samplescan,
	 * but it could still have required parameterization due to LATERAL refs
	 * in its tlist or TABLESAMPLE arguments.
	 */</comment>
	<expr_stmt><expr><name>required_outer</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr>;</expr_stmt>

	<comment type="block">/* Consider sampled scan */</comment>
	<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_samplescan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the sampling method does not support repeatable scans, we must avoid
	 * plans that would scan the rel multiple times.  Ideally, we'd simply
	 * avoid putting the rel on the inside of a nestloop join; but adding such
	 * a consideration to the planner seems like a great deal of complication
	 * to support an uncommon usage of second-rate sampling methods.  Instead,
	 * if there is a risk that the query might perform an unsafe join, just
	 * wrap the SampleScan in a Materialize node.  We can check for joins by
	 * counting the membership of all_baserels (note that this correctly
	 * counts inheritance trees as single rels).  If we're inside a subquery,
	 * we can't easily check whether a join might occur in the outer query, so
	 * just assume one is possible.
	 *
	 * GetTsmRoutine is relatively expensive compared to the other tests here,
	 * so check repeatable_across_scans last, even though that's a bit odd.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>root</name><operator>-&gt;</operator><name>query_level</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator>
		 <call><name>bms_membership</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>all_baserels</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>BMS_SINGLETON</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>!</operator><operator>(</operator><call><name>GetTsmRoutine</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>tablesample</name><operator>-&gt;</operator><name>tsmhandler</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>repeatable_across_scans</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_material_path</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* For the moment, at least, there are no other paths to consider */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * set_foreign_size
 *		Set size estimates for a foreign table RTE
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_foreign_size</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Mark rel with estimated output rows, width, etc */</comment>
	<expr_stmt><expr><call><name>set_foreign_size_estimates</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Let FDW adjust the size estimates, if it can */</comment>
	<expr_stmt><expr><call><name><name>rel</name><operator>-&gt;</operator><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignRelSize</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* ... but do not let it set the rows estimate to zero */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set_foreign_pathlist
 *		Build access paths for a foreign table RTE
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_foreign_pathlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Call the FDW's GetForeignPaths function to generate path(s) */</comment>
	<expr_stmt><expr><call><name><name>rel</name><operator>-&gt;</operator><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignPaths</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set_append_rel_size
 *	  Set size estimates for a simple "append relation"
 *
 * The passed-in rel and RTE represent the entire append relation.  The
 * relation's contents are computed by appending together the output of the
 * individual member relations.  Note that in the non-partitioned inheritance
 * case, the first member relation is actually the same table as is mentioned
 * in the parent RTE ... but it has a different RTE and RelOptInfo.  This is
 * a good thing because their outputs are not the same size.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_append_rel_size</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
					<parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>parentRTindex</name> <init>= <expr><name>rti</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_live_children</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>parent_rows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>parent_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name>	   <modifier>*</modifier></type><name>parent_attrsizes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nattrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>live_children</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>did_pruning</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Guard against stack overflow due to overly deep inheritance tree. */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_SIMPLE_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize partitioned_child_rels to contain this RT index.
	 *
	 * Note that during the set_append_rel_pathlist() phase, we will bubble up
	 * the indexes of partitioned relations that appear down in the tree, so
	 * that when we've created Paths for all the children, the root
	 * partitioned table's list will contain all such indexes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>partitioned_child_rels</name></name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><name>rti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the partitioned relation has any baserestrictinfo quals then we
	 * attempt to use these quals to prune away partitions that cannot
	 * possibly contain any tuples matching these quals.  In this case we'll
	 * store the relids of all partitions which could possibly contain a
	 * matching tuple, and skip anything else in the loop below.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>enable_partition_pruning</name> <operator>&amp;&amp;</operator>
		<name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>live_children</name> <operator>=</operator> <call><name>prune_append_rel_partitions</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>did_pruning</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If this is a partitioned baserel, set the consider_partitionwise_join
	 * flag; currently, we only consider partitionwise joins with the baserel
	 * if its targetlist doesn't contain a whole-row Var.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>enable_partitionwise_join</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_BASEREL</name> <operator>&amp;&amp;</operator>
		<name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>attr_needed</name><index>[<expr><name>InvalidAttrNumber</name> <operator>-</operator> <name><name>rel</name><operator>-&gt;</operator><name>min_attr</name></name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>consider_partitionwise_join</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Initialize to compute size estimates for whole append relation.
	 *
	 * We handle width estimates by weighting the widths of different child
	 * rels proportionally to their number of rows.  This is sensible because
	 * the use of width estimates is mainly to compute the total relation
	 * "footprint" if we have to sort or hash it.  To do this, we sum the
	 * total equivalent size (in "double" arithmetic) and then divide by the
	 * total rowcount estimate.  This is done separately for the total rel
	 * width and each attribute.
	 *
	 * Note: if you consider changing this logic, beware that child rels could
	 * have zero rows and/or width, if they were excluded by constraints.
	 */</comment>
	<expr_stmt><expr><name>has_live_children</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>parent_rows</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>parent_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>nattrs</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>max_attr</name></name> <operator>-</operator> <name><name>rel</name><operator>-&gt;</operator><name>min_attr</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>parent_attrsizes</name> <operator>=</operator> <operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nattrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>root-&gt;append_rel_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><operator>(</operator><name>AppendRelInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>childRTindex</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>childRTE</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>childrel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>childquals</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Index</name></type>		<name>cq_min_security</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>have_const_false_cq</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>parentvars</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>childvars</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<comment type="block">/* append_rel_list contains all append rels; ignore others */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name> <operator>!=</operator> <name>parentRTindex</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>childRTindex</name> <operator>=</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>childRTE</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name>childRTindex</name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * The child rel's RelOptInfo was already created during
		 * add_base_rels_to_query.
		 */</comment>
		<expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>find_base_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>childRTindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>childrel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_OTHER_MEMBER_REL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We have to copy the parent's targetlist and quals to the child,
		 * with appropriate substitution of variables.  However, only the
		 * baserestrictinfo quals are needed before we can check for
		 * constraint exclusion; so do that first and then check to see if we
		 * can disregard this child.
		 *
		 * The child rel's targetlist might contain non-Var expressions, which
		 * means that substitution into the quals could produce opportunities
		 * for const-simplification, and perhaps even pseudoconstant quals.
		 * Therefore, transform each RestrictInfo separately to see if it
		 * reduces to a constant or pseudoconstant.  (We must process them
		 * separately to keep track of the security level of each qual.)
		 */</comment>
		<expr_stmt><expr><name>childquals</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cq_min_security</name> <operator>=</operator> <name>UINT_MAX</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>have_const_false_cq</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rel-&gt;baserestrictinfo</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>childqual</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>, <argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>childqual</name> <operator>=</operator> <call><name>adjust_appendrel_attrs</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>,
											   <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>appinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>childqual</name> <operator>=</operator> <call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>childqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* check for flat-out constant */</comment>
			<if_stmt><if>if <condition>(<expr><name>childqual</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>childqual</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>childqual</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name> <operator>||</operator>
					<operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>childqual</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Restriction reduces to constant FALSE or NULL */</comment>
					<expr_stmt><expr><name>have_const_false_cq</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* Restriction reduces to constant TRUE, so drop it */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* might have gotten an AND clause, if so flatten it */</comment>
			<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>make_ands_implicit((Expr *) childqual)</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>onecq</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>pseudoconstant</name></decl>;</decl_stmt>

				<comment type="block">/* check for pseudoconstant (no Vars or volatile functions) */</comment>
				<expr_stmt><expr><name>pseudoconstant</name> <operator>=</operator>
					<operator>!</operator><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><name>onecq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><name>onecq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>pseudoconstant</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* tell createplan.c to check for gating quals */</comment>
					<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>hasPseudoConstantQuals</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* reconstitute RestrictInfo with appropriate properties */</comment>
				<expr_stmt><expr><name>childquals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>childquals</name></expr></argument>,
									 <argument><expr><call><name>make_restrictinfo</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>onecq</name></expr></argument>,
													   <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>is_pushed_down</name></name></expr></argument>,
													   <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>outerjoin_delayed</name></name></expr></argument>,
													   <argument><expr><name>pseudoconstant</name></expr></argument>,
													   <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>security_level</name></name></expr></argument>,
													   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* track minimum security level among child quals */</comment>
				<expr_stmt><expr><name>cq_min_security</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>cq_min_security</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>security_level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block>

		<comment type="block">/*
		 * In addition to the quals inherited from the parent, we might have
		 * securityQuals associated with this particular child node.
		 * (Currently this can only happen in appendrels originating from
		 * UNION ALL; inheritance child tables don't have their own
		 * securityQuals, see expand_inherited_rtentry().)	Pull any such
		 * securityQuals up into the baserestrictinfo for the child.  This is
		 * similar to process_security_barrier_quals() for the parent rel,
		 * except that we can't make any general deductions from such quals,
		 * since they don't hold for the whole appendrel.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>childRTE</name><operator>-&gt;</operator><name>securityQuals</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Index</name></type>		<name>security_level</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>childRTE-&gt;securityQuals</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>qualset</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

				<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>qualset</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>qual</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<comment type="block">/* not likely that we'd see constants here, so no check */</comment>
					<expr_stmt><expr><name>childquals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>childquals</name></expr></argument>,
										 <argument><expr><call><name>make_restrictinfo</name><argument_list>(<argument><expr><name>qual</name></expr></argument>,
														   <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
														   <argument><expr><name>security_level</name></expr></argument>,
														   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>cq_min_security</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>cq_min_security</name></expr></argument>, <argument><expr><name>security_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<expr_stmt><expr><name>security_level</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>security_level</name> <operator>&lt;=</operator> <name><name>root</name><operator>-&gt;</operator><name>qual_security_level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * OK, we've got all the baserestrictinfo quals for this child.
		 */</comment>
		<expr_stmt><expr><name><name>childrel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name> <operator>=</operator> <name>childquals</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>childrel</name><operator>-&gt;</operator><name>baserestrict_min_security</name></name> <operator>=</operator> <name>cq_min_security</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>have_const_false_cq</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Some restriction clause reduced to constant FALSE or NULL after
			 * substitution, so this child need not be scanned.
			 */</comment>
			<expr_stmt><expr><call><name>set_dummy_rel_pathlist</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>did_pruning</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr></argument>, <argument><expr><name>live_children</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* This partition was pruned; skip it. */</comment>
			<expr_stmt><expr><call><name>set_dummy_rel_pathlist</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>relation_excluded_by_constraints</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>childRTE</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * This child need not be scanned, so we can omit it from the
			 * appendrel.
			 */</comment>
			<expr_stmt><expr><call><name>set_dummy_rel_pathlist</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * CE failed, so finish copying/modifying targetlist and join quals.
		 *
		 * NB: the resulting childrel-&gt;reltarget-&gt;exprs may contain arbitrary
		 * expressions, which otherwise would not occur in a rel's targetlist.
		 * Code that might be looking at an appendrel child must cope with
		 * such.  (Normally, a rel's targetlist would only include Vars and
		 * PlaceHolderVars.)  XXX we do not bother to update the cost or width
		 * fields of childrel-&gt;reltarget; not clear if that would be useful.
		 */</comment>
		<expr_stmt><expr><name><name>childrel</name><operator>-&gt;</operator><name>joininfo</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>adjust_appendrel_attrs</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rel</name><operator>-&gt;</operator><name>joininfo</name></name></expr></argument>,
								   <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>appinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>childrel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>adjust_appendrel_attrs</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>,
								   <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>appinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We have to make child entries in the EquivalenceClass data
		 * structures as well.  This is needed either if the parent
		 * participates in some eclass joins (because we will want to consider
		 * inner-indexscan joins on the individual children) or if the parent
		 * has useful pathkeys (because we should try to build MergeAppend
		 * paths that produce those sort orderings).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>has_eclass_joins</name></name> <operator>||</operator> <call><name>has_useful_pathkeys</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>add_child_rel_equivalences</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>appinfo</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>childrel</name><operator>-&gt;</operator><name>has_eclass_joins</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>has_eclass_joins</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Note: we could compute appropriate attr_needed data for the child's
		 * variables, by transforming the parent's attr_needed through the
		 * translated_vars mapping.  However, currently there's no need
		 * because attr_needed is only examined for base relations not
		 * otherrels.  So we just leave the child's attr_needed empty.
		 */</comment>

		<comment type="block">/*
		 * If we consider partitionwise joins with the parent rel, do the same
		 * for partitioned child rels.
		 *
		 * Note: here we abuse the consider_partitionwise_join flag by setting
		 * it *even* for child rels that are not partitioned.  In that case,
		 * we set it to tell try_partitionwise_join() that it doesn't need to
		 * generate their targetlists and EC entries as they have already been
		 * generated here, as opposed to the dummy child rels for which the
		 * flag is left set to false so that it will generate them.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>consider_partitionwise_join</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>childrel</name><operator>-&gt;</operator><name>consider_partitionwise_join</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If parallelism is allowable for this query in general, see whether
		 * it's allowable for this childrel in particular.  But if we've
		 * already decided the appendrel is not parallel-safe as a whole,
		 * there's no point in considering parallelism for this child.  For
		 * consistency, do this before calling set_rel_size() for the child.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>parallelModeOK</name></name> <operator>&amp;&amp;</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>set_rel_consider_parallel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>childRTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Compute the child's size.
		 */</comment>
		<expr_stmt><expr><call><name>set_rel_size</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>childRTindex</name></expr></argument>, <argument><expr><name>childRTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * It is possible that constraint exclusion detected a contradiction
		 * within a child subquery, even though we didn't prove one above. If
		 * so, we can skip this child.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IS_DUMMY_REL</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* We have at least one live child. */</comment>
		<expr_stmt><expr><name>has_live_children</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>childRTE</name><operator>-&gt;</operator><name>inh</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>yb_num_referenced_relations</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If any live child is not parallel-safe, treat the whole appendrel
		 * as not parallel-safe.  In future we might be able to generate plans
		 * in which some children are farmed out to workers while others are
		 * not; but we don't have that today, so it's a waste to consider
		 * partial paths anywhere in the appendrel unless it's all safe.
		 * (Child rels visited before this one will be unmarked in
		 * set_append_rel_pathlist().)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>childrel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Accumulate size information from each live child.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>childrel</name><operator>-&gt;</operator><name>rows</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>parent_rows</name> <operator>+=</operator> <name><name>childrel</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>parent_size</name> <operator>+=</operator> <name><name>childrel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>width</name></name> <operator>*</operator> <name><name>childrel</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Accumulate per-column estimates too.  We need not do anything for
		 * PlaceHolderVars in the parent list.  If child expression isn't a
		 * Var, or we didn't record a width estimate for it, we have to fall
		 * back on a datatype-based estimate.
		 *
		 * By construction, child's targetlist is 1-to-1 with parent's.
		 */</comment>
		<macro><name>forboth</name><argument_list>(<argument>parentvars</argument>, <argument>rel-&gt;reltarget-&gt;exprs</argument>,
				<argument>childvars</argument>, <argument>childrel-&gt;reltarget-&gt;exprs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>parentvar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>parentvars</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>childvar</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>childvars</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parentvar</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>pndx</name> <init>= <expr><name><name>parentvar</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <name><name>rel</name><operator>-&gt;</operator><name>min_attr</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int32</name></type>		<name>child_width</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>childvar</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>childvar</name><operator>)</operator><operator>-&gt;</operator><name>varno</name> <operator>==</operator> <name><name>childrel</name><operator>-&gt;</operator><name>relid</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>cndx</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>childvar</name><operator>)</operator><operator>-&gt;</operator><name>varattno</name> <operator>-</operator> <name><name>childrel</name><operator>-&gt;</operator><name>min_attr</name></name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name>child_width</name> <operator>=</operator> <name><name>childrel</name><operator>-&gt;</operator><name>attr_widths</name><index>[<expr><name>cndx</name></expr>]</index></name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>child_width</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>child_width</name> <operator>=</operator> <call><name>get_typavgwidth</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>childvar</name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>childvar</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>child_width</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>parent_attrsizes</name><index>[<expr><name>pndx</name></expr>]</index></name> <operator>+=</operator> <name>child_width</name> <operator>*</operator> <name><name>childrel</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>has_live_children</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Save the finished size estimates.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>parent_rows</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name>parent_rows</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <call><name>rint</name><argument_list>(<argument><expr><name>parent_size</name> <operator>/</operator> <name>parent_rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nattrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>attr_widths</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>rint</name><argument_list>(<argument><expr><name><name>parent_attrsizes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>/</operator> <name>parent_rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

		<comment type="block">/*
		 * Set "raw tuples" count equal to "rows" for the appendrel; needed
		 * because some places assume rel-&gt;tuples is valid for any baserel.
		 */</comment>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator> <name>parent_rows</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * All children were excluded by constraints, so mark the whole
		 * appendrel dummy.  We must do this in this phase so that the rel's
		 * dummy-ness is visible when we generate paths for other rels.
		 */</comment>
		<expr_stmt><expr><call><name>set_dummy_rel_pathlist</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>parent_attrsizes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set_append_rel_pathlist
 *	  Build access paths for an "append relation"
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_append_rel_pathlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						<parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>parentRTindex</name> <init>= <expr><name>rti</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>live_childrels</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Generate access paths for each member relation, and remember the
	 * non-dummy children.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>root-&gt;append_rel_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><operator>(</operator><name>AppendRelInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>childRTindex</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>childRTE</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>childrel</name></decl>;</decl_stmt>

		<comment type="block">/* append_rel_list contains all append rels; ignore others */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name> <operator>!=</operator> <name>parentRTindex</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Re-locate the child RTE and RelOptInfo */</comment>
		<expr_stmt><expr><name>childRTindex</name> <operator>=</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>childRTE</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name>childRTindex</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>childrel</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>childRTindex</name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If set_append_rel_size() decided the parent appendrel was
		 * parallel-unsafe at some point after visiting this child rel, we
		 * need to propagate the unsafety marking down to the child, so that
		 * we don't generate useless partial paths for it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>childrel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Compute the child's access paths.
		 */</comment>
		<expr_stmt><expr><call><name>set_rel_pathlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>childRTindex</name></expr></argument>, <argument><expr><name>childRTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If child is dummy, ignore it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IS_DUMMY_REL</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Bubble up childrel's partitioned children. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>part_scheme</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>partitioned_child_rels</name></name> <operator>=</operator>
				<call><name>list_concat</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>partitioned_child_rels</name></name></expr></argument>,
							<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>childrel</name><operator>-&gt;</operator><name>partitioned_child_rels</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Child is live, so add it to the live_childrels list for use below.
		 */</comment>
		<expr_stmt><expr><name>live_childrels</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>live_childrels</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Add paths to the append relation. */</comment>
	<expr_stmt><expr><call><name>add_paths_to_append_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>live_childrels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * add_paths_to_append_rel
 *		Generate paths for the given append relation given the set of non-dummy
 *		child rels.
 *
 * The function collects all parameterizations and orderings supported by the
 * non-dummy children. For every such parameterization or ordering, it creates
 * an append path collecting one path from each non-dummy child with given
 * parameterization or ordering. Similarly it collects partial paths from
 * non-dummy children to create partial append paths.
 */</comment>
<function><type><name>void</name></type>
<name>add_paths_to_append_rel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>live_childrels</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subpaths</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>subpaths_valid</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partial_subpaths</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pa_partial_subpaths</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pa_nonpartial_subpaths</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>partial_subpaths_valid</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>pa_subpaths_valid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>all_child_pathkeys</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>all_child_outers</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partitioned_rels</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>partial_rows</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* If appropriate, consider parallel append */</comment>
	<expr_stmt><expr><name>pa_subpaths_valid</name> <operator>=</operator> <name>enable_parallel_append</name> <operator>&amp;&amp;</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * AppendPath generated for partitioned tables must record the RT indexes
	 * of partitioned tables that are direct or indirect children of this
	 * Append rel.
	 *
	 * AppendPath may be for a sub-query RTE (UNION ALL), in which case, 'rel'
	 * itself does not represent a partitioned relation, but the child sub-
	 * queries may contain references to partitioned relations.  The loop
	 * below will look for such children and collect them in a list to be
	 * passed to the path creation function.  (This assumes that we don't need
	 * to look through multiple levels of subquery RTEs; if we ever do, we
	 * could consider stuffing the list we generate here into sub-query RTE's
	 * RelOptInfo, just like we do for partitioned rels, which would be used
	 * when populating our parent rel with paths.  For the present, that
	 * appears to be unnecessary.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>part_scheme</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IS_SIMPLE_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>partitioned_rels</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>partitioned_child_rels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IS_JOIN_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>relid</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partrels</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * For a partitioned joinrel, concatenate the component rels'
			 * partitioned_child_rels lists.
			 */</comment>
			<while>while <condition>(<expr><operator>(</operator><name>relid</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>component</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>relid</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>relid</name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>component</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>relid</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>component</name><operator>-&gt;</operator><name>part_scheme</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>component</name><operator>-&gt;</operator><name>partitioned_child_rels</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>partrels</name> <operator>=</operator>
					<call><name>list_concat</name><argument_list>(<argument><expr><name>partrels</name></expr></argument>,
								<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>component</name><operator>-&gt;</operator><name>partitioned_child_rels</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></while>

			<expr_stmt><expr><name>partitioned_rels</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>partrels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>partitioned_rels</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * For every non-dummy child, remember the cheapest path.  Also, identify
	 * all pathkeys (orderings) and parameterizations (required_outer sets)
	 * available for the non-dummy member relations.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>live_childrels</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>childrel</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>cheapest_partial_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * For UNION ALLs with non-empty partitioned_child_rels, accumulate
		 * the Lists of child relations.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name> <operator>&amp;&amp;</operator> <name><name>childrel</name><operator>-&gt;</operator><name>partitioned_child_rels</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>partitioned_rels</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>partitioned_rels</name></expr></argument>,
									   <argument><expr><name><name>childrel</name><operator>-&gt;</operator><name>partitioned_child_rels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If child has an unparameterized cheapest-total path, add that to
		 * the unparameterized Append path we are constructing for the parent.
		 * If not, there's no workable unparameterized path.
		 *
		 * With partitionwise aggregates, the child rel's pathlist may be
		 * empty, so don't assume that a path exists here.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>childrel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
			<name><name>childrel</name><operator>-&gt;</operator><name>cheapest_total_path</name><operator>-&gt;</operator><name>param_info</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>accumulate_append_subpath</name><argument_list>(<argument><expr><name><name>childrel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>subpaths</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>subpaths_valid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Same idea, but for a partial plan. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>childrel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>cheapest_partial_path</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>childrel</name><operator>-&gt;</operator><name>partial_pathlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>accumulate_append_subpath</name><argument_list>(<argument><expr><name>cheapest_partial_path</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>partial_subpaths</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>partial_subpaths_valid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * Same idea, but for a parallel append mixing partial and non-partial
		 * paths.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>pa_subpaths_valid</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>nppath</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>nppath</name> <operator>=</operator>
				<call><name>get_cheapest_parallel_safe_total_inner</name><argument_list>(<argument><expr><name><name>childrel</name><operator>-&gt;</operator><name>pathlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>cheapest_partial_path</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>nppath</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Neither a partial nor a parallel-safe path?  Forget it. */</comment>
				<expr_stmt><expr><name>pa_subpaths_valid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>nppath</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
					 <operator>(</operator><name>cheapest_partial_path</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
					  <name><name>cheapest_partial_path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>&lt;</operator> <name><name>nppath</name><operator>-&gt;</operator><name>total_cost</name></name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Partial path is cheaper or the only option. */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cheapest_partial_path</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>accumulate_append_subpath</name><argument_list>(<argument><expr><name>cheapest_partial_path</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>pa_partial_subpaths</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>pa_nonpartial_subpaths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Either we've got only a non-partial path, or we think that
				 * a single backend can execute the best non-partial path
				 * faster than all the parallel backends working together can
				 * execute the best partial path.
				 *
				 * It might make sense to be more aggressive here.  Even if
				 * the best non-partial path is more expensive than the best
				 * partial path, it could still be better to choose the
				 * non-partial path if there are several such paths that can
				 * be given to different workers.  For now, we don't try to
				 * figure that out.
				 */</comment>
				<expr_stmt><expr><call><name>accumulate_append_subpath</name><argument_list>(<argument><expr><name>nppath</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>pa_nonpartial_subpaths</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Collect lists of all the available path orderings and
		 * parameterizations for all the children.  We use these as a
		 * heuristic to indicate which sort orderings and parameterizations we
		 * should build Append and MergeAppend paths for.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lcp</argument>, <argument>childrel-&gt;pathlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>childpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lcp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>childkeys</name> <init>= <expr><name><name>childpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relids</name></type>		<name>childouter</name> <init>= <expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>childpath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Unsorted paths don't contribute to pathkey list */</comment>
			<if_stmt><if>if <condition>(<expr><name>childkeys</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lpk</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* Have we already seen this ordering? */</comment>
				<macro><name>foreach</name><argument_list>(<argument>lpk</argument>, <argument>all_child_pathkeys</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>existing_pathkeys</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lpk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>compare_pathkeys</name><argument_list>(<argument><expr><name>existing_pathkeys</name></expr></argument>,
										 <argument><expr><name>childkeys</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PATHKEYS_EQUAL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* No, so add it to all_child_pathkeys */</comment>
					<expr_stmt><expr><name>all_child_pathkeys</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>all_child_pathkeys</name></expr></argument>,
												 <argument><expr><name>childkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Unparameterized paths don't contribute to param-set list */</comment>
			<if_stmt><if>if <condition>(<expr><name>childouter</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lco</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* Have we already seen this param set? */</comment>
				<macro><name>foreach</name><argument_list>(<argument>lco</argument>, <argument>all_child_outers</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Relids</name></type>		<name>existing_outers</name> <init>= <expr><operator>(</operator><name>Relids</name><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lco</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>bms_equal</name><argument_list>(<argument><expr><name>existing_outers</name></expr></argument>, <argument><expr><name>childouter</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* No, so add it to all_child_outers */</comment>
					<expr_stmt><expr><name>all_child_outers</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>all_child_outers</name></expr></argument>,
											   <argument><expr><name>childouter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<comment type="block">/*
	 * If we found unparameterized paths for all children, build an unordered,
	 * unparameterized Append path for the rel.  (Note: this is correct even
	 * if we have zero or one live subpath due to constraint exclusion.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>subpaths_valid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_append_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>subpaths</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
												  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>,
												  <argument><expr><name>partitioned_rels</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Consider an append of unordered, unparameterized partial paths.  Make
	 * it parallel-aware if possible.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>partial_subpaths_valid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AppendPath</name> <modifier>*</modifier></type><name>appendpath</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>parallel_workers</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Find the highest number of workers requested for any subpath. */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>partial_subpaths</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>parallel_workers</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>parallel_workers</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>parallel_workers</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the use of parallel append is permitted, always request at least
		 * log2(# of children) workers.  We assume it can be useful to have
		 * extra workers in this case because they will be spread out across
		 * the children.  The precise formula is just a guess, but we don't
		 * want to end up with a radically different answer for a table with N
		 * partitions vs. an unpartitioned table with the same data, so the
		 * use of some kind of log-scaling here seems to make some sense.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>enable_parallel_append</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>parallel_workers</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>parallel_workers</name></expr></argument>,
								   <argument><expr><call><name>fls</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>live_childrels</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>parallel_workers</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>parallel_workers</name></expr></argument>,
								   <argument><expr><name>max_parallel_workers_per_gather</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>parallel_workers</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Generate a partial append path. */</comment>
		<expr_stmt><expr><name>appendpath</name> <operator>=</operator> <call><name>create_append_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>partial_subpaths</name></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>parallel_workers</name></expr></argument>,
										<argument><expr><name>enable_parallel_append</name></expr></argument>,
										<argument><expr><name>partitioned_rels</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Make sure any subsequent partial paths use the same row count
		 * estimate.
		 */</comment>
		<expr_stmt><expr><name>partial_rows</name> <operator>=</operator> <name><name>appendpath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr>;</expr_stmt>

		<comment type="block">/* Add the path. */</comment>
		<expr_stmt><expr><call><name>add_partial_path</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>appendpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Consider a parallel-aware append using a mix of partial and non-partial
	 * paths.  (This only makes sense if there's at least one child which has
	 * a non-partial path that is substantially cheaper than any partial path;
	 * otherwise, we should use the append path added in the previous step.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>pa_subpaths_valid</name> <operator>&amp;&amp;</operator> <name>pa_nonpartial_subpaths</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AppendPath</name> <modifier>*</modifier></type><name>appendpath</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>parallel_workers</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Find the highest number of workers requested for any partial
		 * subpath.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>pa_partial_subpaths</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>parallel_workers</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>parallel_workers</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Same formula here as above.  It's even more important in this
		 * instance because the non-partial paths won't contribute anything to
		 * the planned number of parallel workers.
		 */</comment>
		<expr_stmt><expr><name>parallel_workers</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>parallel_workers</name></expr></argument>,
							   <argument><expr><call><name>fls</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>live_childrels</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>parallel_workers</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>parallel_workers</name></expr></argument>,
							   <argument><expr><name>max_parallel_workers_per_gather</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>parallel_workers</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>appendpath</name> <operator>=</operator> <call><name>create_append_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>pa_nonpartial_subpaths</name></expr></argument>,
										<argument><expr><name>pa_partial_subpaths</name></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>parallel_workers</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
										<argument><expr><name>partitioned_rels</name></expr></argument>, <argument><expr><name>partial_rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>add_partial_path</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>appendpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Also build unparameterized MergeAppend paths based on the collected
	 * list of child pathkeys.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>subpaths_valid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>generate_mergeappend_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>live_childrels</name></expr></argument>,
								   <argument><expr><name>all_child_pathkeys</name></expr></argument>,
								   <argument><expr><name>partitioned_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Build Append paths for each parameterization seen among the child rels.
	 * (This may look pretty expensive, but in most cases of practical
	 * interest, the child rels will expose mostly the same parameterizations,
	 * so that not that many cases actually get considered here.)
	 *
	 * The Append node itself cannot enforce quals, so all qual checking must
	 * be done in the child paths.  This means that to have a parameterized
	 * Append path, we must have the exact same parameterization for each
	 * child path; otherwise some children might be failing to check the
	 * moved-down quals.  To make them match up, we can try to increase the
	 * parameterization of lesser-parameterized paths.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>all_child_outers</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>required_outer</name> <init>= <expr><operator>(</operator><name>Relids</name><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcr</name></decl>;</decl_stmt>

		<comment type="block">/* Select the child paths for an Append with this parameterization */</comment>
		<expr_stmt><expr><name>subpaths</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>subpaths_valid</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lcr</argument>, <argument>live_childrels</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>childrel</name> <init>= <expr><operator>(</operator><name>RelOptInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lcr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>childrel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* failed to make a suitable path for this child */</comment>
				<expr_stmt><expr><name>subpaths_valid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>subpath</name> <operator>=</operator> <call><name>get_cheapest_parameterized_child_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															<argument><expr><name>childrel</name></expr></argument>,
															<argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>subpath</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* failed to make a suitable path for this child */</comment>
				<expr_stmt><expr><name>subpaths_valid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>accumulate_append_subpath</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>subpaths</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>subpaths_valid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
					 <call><name>create_append_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>subpaths</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
										<argument><expr><name>required_outer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										<argument><expr><name>partitioned_rels</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * generate_mergeappend_paths
 *		Generate MergeAppend paths for an append relation
 *
 * Generate a path for each ordering (pathkey list) appearing in
 * all_child_pathkeys.
 *
 * We consider both cheapest-startup and cheapest-total cases, ie, for each
 * interesting ordering, collect all the cheapest startup subpaths and all the
 * cheapest total paths, and build a MergeAppend path for each case.
 *
 * We don't currently generate any parameterized MergeAppend paths.  While
 * it would not take much more code here to do so, it's very unclear that it
 * is worth the planning cycles to investigate such paths: there's little
 * use for an ordered path on the inside of a nestloop.  In fact, it's likely
 * that the current coding of add_path would reject such paths out of hand,
 * because add_path gives no credit for sort ordering of parameterized paths,
 * and a parameterized MergeAppend is going to be more expensive than the
 * corresponding parameterized Append path.  If we ever try harder to support
 * parameterized mergejoin plans, it might be worth adding support for
 * parameterized MergeAppends to feed such joins.  (See notes in
 * optimizer/README for why that might not ever happen, though.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>generate_mergeappend_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>live_childrels</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>all_child_pathkeys</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitioned_rels</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcp</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lcp</argument>, <argument>all_child_pathkeys</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pathkeys</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lcp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>startup_subpaths</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>total_subpaths</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>startup_neq_total</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcr</name></decl>;</decl_stmt>

		<comment type="block">/* Select the child paths for this ordering... */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lcr</argument>, <argument>live_childrels</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>childrel</name> <init>= <expr><operator>(</operator><name>RelOptInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lcr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>cheapest_startup</name></decl>,
					   <decl><type ref="prev"><modifier>*</modifier></type><name>cheapest_total</name></decl>;</decl_stmt>

			<comment type="block">/* Locate the right paths, if they are available. */</comment>
			<expr_stmt><expr><name>cheapest_startup</name> <operator>=</operator>
				<call><name>get_cheapest_path_for_pathkeys</name><argument_list>(<argument><expr><name><name>childrel</name><operator>-&gt;</operator><name>pathlist</name></name></expr></argument>,
											   <argument><expr><name>pathkeys</name></expr></argument>,
											   <argument><expr><name>NULL</name></expr></argument>,
											   <argument><expr><name>STARTUP_COST</name></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cheapest_total</name> <operator>=</operator>
				<call><name>get_cheapest_path_for_pathkeys</name><argument_list>(<argument><expr><name><name>childrel</name><operator>-&gt;</operator><name>pathlist</name></name></expr></argument>,
											   <argument><expr><name>pathkeys</name></expr></argument>,
											   <argument><expr><name>NULL</name></expr></argument>,
											   <argument><expr><name>TOTAL_COST</name></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If we can't find any paths with the right order just use the
			 * cheapest-total path; we'll have to sort it later.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>cheapest_startup</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>cheapest_total</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>cheapest_startup</name> <operator>=</operator> <name>cheapest_total</name> <operator>=</operator>
					<name><name>childrel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr>;</expr_stmt>
				<comment type="block">/* Assert we do have an unparameterized path for this child */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cheapest_total</name><operator>-&gt;</operator><name>param_info</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Notice whether we actually have different paths for the
			 * "cheapest" and "total" cases; frequently there will be no point
			 * in two create_merge_append_path() calls.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>cheapest_startup</name> <operator>!=</operator> <name>cheapest_total</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>startup_neq_total</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>accumulate_append_subpath</name><argument_list>(<argument><expr><name>cheapest_startup</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>startup_subpaths</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>accumulate_append_subpath</name><argument_list>(<argument><expr><name>cheapest_total</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>total_subpaths</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* ... and build the MergeAppend paths */</comment>
		<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_merge_append_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														<argument><expr><name>rel</name></expr></argument>,
														<argument><expr><name>startup_subpaths</name></expr></argument>,
														<argument><expr><name>pathkeys</name></expr></argument>,
														<argument><expr><name>NULL</name></expr></argument>,
														<argument><expr><name>partitioned_rels</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>startup_neq_total</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_merge_append_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															<argument><expr><name>rel</name></expr></argument>,
															<argument><expr><name>total_subpaths</name></expr></argument>,
															<argument><expr><name>pathkeys</name></expr></argument>,
															<argument><expr><name>NULL</name></expr></argument>,
															<argument><expr><name>partitioned_rels</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * get_cheapest_parameterized_child_path
 *		Get cheapest path for this relation that has exactly the requested
 *		parameterization.
 *
 * Returns NULL if unable to create such a path.
 */</comment>
<function><type><specifier>static</specifier> <name>Path</name> <modifier>*</modifier></type>
<name>get_cheapest_parameterized_child_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
									  <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>cheapest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Look up the cheapest existing path with no more than the needed
	 * parameterization.  If it has exactly the needed parameterization, we're
	 * done.
	 */</comment>
	<expr_stmt><expr><name>cheapest</name> <operator>=</operator> <call><name>get_cheapest_path_for_pathkeys</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>pathlist</name></name></expr></argument>,
											  <argument><expr><name>NIL</name></expr></argument>,
											  <argument><expr><name>required_outer</name></expr></argument>,
											  <argument><expr><name>TOTAL_COST</name></expr></argument>,
											  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cheapest</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>bms_equal</name><argument_list>(<argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>cheapest</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>cheapest</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise, we can "reparameterize" an existing path to match the given
	 * parameterization, which effectively means pushing down additional
	 * joinquals to be checked within the path's scan.  However, some existing
	 * paths might check the available joinquals already while others don't;
	 * therefore, it's not clear which existing path will be cheapest after
	 * reparameterization.  We have to go through them all and find out.
	 */</comment>
	<expr_stmt><expr><name>cheapest</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rel-&gt;pathlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Can't use it if it needs more than requested parameterization */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Reparameterization can only increase the path's cost, so if it's
		 * already more expensive than the current cheapest, forget it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>cheapest</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<call><name>compare_path_costs</name><argument_list>(<argument><expr><name>cheapest</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>TOTAL_COST</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Reparameterize if needed, then recheck cost */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_equal</name><argument_list>(<argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>reparameterize_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>, <argument><expr><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* failed to reparameterize this one */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_equal</name><argument_list>(<argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>cheapest</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				<call><name>compare_path_costs</name><argument_list>(<argument><expr><name>cheapest</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>TOTAL_COST</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* We have a new best path */</comment>
		<expr_stmt><expr><name>cheapest</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Return the best path, or NULL if we found no suitable candidate */</comment>
	<return>return <expr><name>cheapest</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * accumulate_append_subpath
 *		Add a subpath to the list being built for an Append or MergeAppend.
 *
 * It's possible that the child is itself an Append or MergeAppend path, in
 * which case we can "cut out the middleman" and just add its child paths to
 * our own list.  (We don't try to do this earlier because we need to apply
 * both levels of transformation to the quals.)
 *
 * Note that if we omit a child MergeAppend in this way, we are effectively
 * omitting a sort step, which seems fine: if the parent is to be an Append,
 * its result would be unsorted anyway, while if the parent is to be a
 * MergeAppend, there's no point in a separate sort on a child.
 * its result would be unsorted anyway.
 *
 * Normally, either path is a partial path and subpaths is a list of partial
 * paths, or else path is a non-partial plan and subpaths is a list of those.
 * However, if path is a parallel-aware Append, then we add its partial path
 * children to subpaths and the rest to special_subpaths.  If the latter is
 * NULL, we don't flatten the path at all (unless it contains only partial
 * paths).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>accumulate_append_subpath</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>subpaths</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>special_subpaths</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>AppendPath</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AppendPath</name> <modifier>*</modifier></type><name>apath</name> <init>= <expr><operator>(</operator><name>AppendPath</name> <operator>*</operator><operator>)</operator> <name>path</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>apath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>||</operator> <name><name>apath</name><operator>-&gt;</operator><name>first_partial_path</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* list_copy is important here to avoid sharing list substructure */</comment>
			<expr_stmt><expr><operator>*</operator><name>subpaths</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><operator>*</operator><name>subpaths</name></expr></argument>, <argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>apath</name><operator>-&gt;</operator><name>subpaths</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>special_subpaths</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_special_subpaths</name></decl>;</decl_stmt>

			<comment type="block">/* Split Parallel Append into partial and non-partial subpaths */</comment>
			<expr_stmt><expr><operator>*</operator><name>subpaths</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><operator>*</operator><name>subpaths</name></expr></argument>,
									<argument><expr><call><name>list_copy_tail</name><argument_list>(<argument><expr><name><name>apath</name><operator>-&gt;</operator><name>subpaths</name></name></expr></argument>,
												   <argument><expr><name><name>apath</name><operator>-&gt;</operator><name>first_partial_path</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>new_special_subpaths</name> <operator>=</operator>
				<call><name>list_truncate</name><argument_list>(<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>apath</name><operator>-&gt;</operator><name>subpaths</name></name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name><name>apath</name><operator>-&gt;</operator><name>first_partial_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>special_subpaths</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><operator>*</operator><name>special_subpaths</name></expr></argument>,
											<argument><expr><name>new_special_subpaths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MergeAppendPath</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MergeAppendPath</name> <modifier>*</modifier></type><name>mpath</name> <init>= <expr><operator>(</operator><name>MergeAppendPath</name> <operator>*</operator><operator>)</operator> <name>path</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* list_copy is important here to avoid sharing list substructure */</comment>
		<expr_stmt><expr><operator>*</operator><name>subpaths</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><operator>*</operator><name>subpaths</name></expr></argument>, <argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>mpath</name><operator>-&gt;</operator><name>subpaths</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>subpaths</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>subpaths</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set_dummy_rel_pathlist
 *	  Build a dummy path for a relation that's been excluded by constraints
 *
 * Rather than inventing a special "dummy" path type, we represent this as an
 * AppendPath with no members (see also IS_DUMMY_PATH/IS_DUMMY_REL macros).
 *
 * This is exported because inheritance_planner() has need for it.
 */</comment>
<function><type><name>void</name></type>
<name>set_dummy_rel_pathlist</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Set dummy size estimates --- we leave attr_widths[] as zeroes */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Discard any pre-existing paths; no further need for them */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_append_path</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
											  <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We set the cheapest path immediately, to ensure that IS_DUMMY_REL()
	 * will recognize the relation as dummy if anyone asks.  This is redundant
	 * when we're called from set_rel_size(), but not when called from
	 * elsewhere, and doing it twice is harmless anyway.
	 */</comment>
	<expr_stmt><expr><call><name>set_cheapest</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* quick-and-dirty test to see if any joining is needed */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>has_multiple_baserels</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_base_rels</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>rti</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>rti</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>rti</name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name></expr>;</condition> <incr><expr><name>rti</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>brel</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>rti</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>brel</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* ignore RTEs that are "other rels" */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>brel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_BASEREL</name></expr>)</condition><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><operator>++</operator><name>num_base_rels</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * set_subquery_pathlist
 *		Generate SubqueryScan access paths for a subquery RTE
 *
 * We don't currently support generating parameterized paths for subqueries
 * by pushing join clauses down into them; it seems too expensive to re-plan
 * the subquery multiple times to consider different alternatives.
 * (XXX that could stand to be reconsidered, now that we use Paths.)
 * So the paths made here will be parameterized if the subquery contains
 * LATERAL references, otherwise not.  As long as that's true, there's no need
 * for a separate set_subquery_size phase: just make the paths right away.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_subquery_pathlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
					  <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>subquery</name> <init>= <expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>required_outer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pushdown_safety_info</name></type> <name>safetyInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>tuple_fraction</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>sub_final_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Must copy the Query so that planning doesn't mess up the RTE contents
	 * (really really need to fix the planner to not scribble on its input,
	 * someday ... but see remove_unused_subquery_outputs to start with).
	 */</comment>
	<expr_stmt><expr><name>subquery</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it's a LATERAL subquery, it might contain some Vars of the current
	 * query level, requiring it to be treated as parameterized, even though
	 * we don't support pushing down join quals into subqueries.
	 */</comment>
	<expr_stmt><expr><name>required_outer</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Zero out result area for subquery_is_pushdown_safe, so that it can set
	 * flags as needed while recursing.  In particular, we need a workspace
	 * for keeping track of unsafe-to-reference columns.  unsafeColumns[i]
	 * will be set true if we find that output column i of the subquery is
	 * unsafe to use in a pushed-down qual.
	 */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>safetyInfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>safetyInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>safetyInfo</name><operator>.</operator><name>unsafeColumns</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the subquery has the "security_barrier" flag, it means the subquery
	 * originated from a view that must enforce row level security.  Then we
	 * must not push down quals that contain leaky functions.  (Ideally this
	 * would be checked inside subquery_is_pushdown_safe, but since we don't
	 * currently pass the RTE to that function, we must do it here.)
	 */</comment>
	<expr_stmt><expr><name><name>safetyInfo</name><operator>.</operator><name>unsafeLeaky</name></name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>security_barrier</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there are any restriction clauses that have been attached to the
	 * subquery relation, consider pushing them down to become WHERE or HAVING
	 * quals of the subquery itself.  This transformation is useful because it
	 * may allow us to generate a better plan for the subquery than evaluating
	 * all the subquery output rows and then filtering them.
	 *
	 * There are several cases where we cannot push down clauses. Restrictions
	 * involving the subquery are checked by subquery_is_pushdown_safe().
	 * Restrictions on individual clauses are checked by
	 * qual_is_pushdown_safe().  Also, we don't want to push down
	 * pseudoconstant clauses; better to have the gating node above the
	 * subquery.
	 *
	 * Non-pushed-down clauses will get evaluated as qpquals of the
	 * SubqueryScan node.
	 *
	 * XXX Are there any cases where we want to make a policy decision not to
	 * push down a pushable qual, because it'd result in a worse plan?
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
		<call><name>subquery_is_pushdown_safe</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>, <argument><expr><name>subquery</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>safetyInfo</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* OK to consider pushing down individual quals */</comment>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>upperrestrictlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>rel-&gt;baserestrictinfo</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>clause</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rinfo</name><operator>-&gt;</operator><name>pseudoconstant</name></name> <operator>&amp;&amp;</operator>
				<call><name>qual_is_pushdown_safe</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>safetyInfo</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Push it down */</comment>
				<expr_stmt><expr><call><name>subquery_push_qual</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Keep it in the upper query */</comment>
				<expr_stmt><expr><name>upperrestrictlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>upperrestrictlist</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name> <operator>=</operator> <name>upperrestrictlist</name></expr>;</expr_stmt>
		<comment type="block">/* We don't bother recomputing baserestrict_min_security */</comment>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>safetyInfo</name><operator>.</operator><name>unsafeColumns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The upper query might not use all the subquery's output columns; if
	 * not, we can simplify.
	 */</comment>
	<expr_stmt><expr><call><name>remove_unused_subquery_outputs</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We can safely pass the outer tuple_fraction down to the subquery if the
	 * outer level has no joining, aggregation, or sorting to do. Otherwise
	 * we'd better tell the subquery to plan for full retrieval. (XXX This
	 * could probably be made more intelligent ...)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>||</operator>
		<name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>||</operator>
		<name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>||</operator>
		<name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>||</operator>
		<name><name>parse</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>||</operator>
		<name><name>parse</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>||</operator>
		<call><name>has_multiple_baserels</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tuple_fraction</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* default case */</comment>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>tuple_fraction</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>tuple_fraction</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* plan_params should not be in use in current query level */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Generate a subroot and Paths for the subquery */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>subroot</name></name> <operator>=</operator> <call><name>subquery_planner</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name></name></expr></argument>, <argument><expr><name>subquery</name></expr></argument>,
									<argument><expr><name>root</name></expr></argument>,
									<argument><expr><name>false</name></expr></argument>, <argument><expr><name>tuple_fraction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Isolate the params needed by this specific subplan */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>subplan_params</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * It's possible that constraint exclusion proved the subquery empty. If
	 * so, it's desirable to produce an unadorned dummy path so that we will
	 * recognize appropriate optimizations at this query level.
	 */</comment>
	<expr_stmt><expr><name>sub_final_rel</name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>subroot</name></name></expr></argument>, <argument><expr><name>UPPERREL_FINAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_DUMMY_REL</name><argument_list>(<argument><expr><name>sub_final_rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>set_dummy_rel_pathlist</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Mark rel with estimated output rows, width, etc.  Note that we have to
	 * do this before generating outer-query paths, else cost_subqueryscan is
	 * not happy.
	 */</comment>
	<expr_stmt><expr><call><name>set_subquery_size_estimates</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For each Path that subquery_planner produced, make a SubqueryScanPath
	 * in the outer query.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>sub_final_rel-&gt;pathlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pathkeys</name></decl>;</decl_stmt>

		<comment type="block">/* Convert subpath's pathkeys to outer representation */</comment>
		<expr_stmt><expr><name>pathkeys</name> <operator>=</operator> <call><name>convert_subquery_pathkeys</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											 <argument><expr><name>rel</name></expr></argument>,
											 <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>,
											 <argument><expr><call><name>make_tlist_from_pathtarget</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Generate outer path using this subpath */</comment>
		<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
				 <call><name>create_subqueryscan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>,
										  <argument><expr><name>pathkeys</name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* If outer rel allows parallelism, do same for partial paths. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator> <call><name>bms_is_empty</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* If consider_parallel is false, there should be no partial paths. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sub_final_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>||</operator>
			   <name><name>sub_final_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Same for partial paths. */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>sub_final_rel-&gt;partial_pathlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pathkeys</name></decl>;</decl_stmt>

			<comment type="block">/* Convert subpath's pathkeys to outer representation */</comment>
			<expr_stmt><expr><name>pathkeys</name> <operator>=</operator> <call><name>convert_subquery_pathkeys</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												 <argument><expr><name>rel</name></expr></argument>,
												 <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>,
												 <argument><expr><call><name>make_tlist_from_pathtarget</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Generate outer path using this subpath */</comment>
			<expr_stmt><expr><call><name>add_partial_path</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
							 <call><name>create_subqueryscan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>,
													  <argument><expr><name>pathkeys</name></expr></argument>,
													  <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set_function_pathlist
 *		Build the (single) access path for a function RTE
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_function_pathlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>required_outer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pathkeys</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We don't support pushing join clauses into the quals of a function
	 * scan, but it could still have required parameterization due to LATERAL
	 * refs in the function expression.
	 */</comment>
	<expr_stmt><expr><name>required_outer</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * The result is considered unordered unless ORDINALITY was used, in which
	 * case it is ordered by the ordinal column (the last one).  See if we
	 * care, by checking for uses of that Var in equivalence classes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>funcordinality</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>ordattno</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>max_attr</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Is there a Var for it in rel's targetlist?  If not, the query did
		 * not reference the ordinality column, or at least not in any way
		 * that would be interesting for sorting.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rel-&gt;reltarget-&gt;exprs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* checking varno/varlevelsup is just paranoia */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<name><name>node</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name>ordattno</name> <operator>&amp;&amp;</operator>
				<name><name>node</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>&amp;&amp;</operator>
				<name><name>node</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>var</name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Try to build pathkeys for this Var with int8 sorting.  We tell
		 * build_expression_pathkey not to build any new equivalence class; if
		 * the Var isn't already mentioned in some EC, it means that nothing
		 * cares about the ordering.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>var</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>pathkeys</name> <operator>=</operator> <call><name>build_expression_pathkey</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
												<argument><expr><name>NULL</name></expr></argument>,	<comment type="block">/* below outer joins */</comment>
												<argument><expr><name>Int8LessOperator</name></expr></argument>,
												<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
												<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Generate appropriate path */</comment>
	<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>create_functionscan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
										   <argument><expr><name>pathkeys</name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set_values_pathlist
 *		Build the (single) access path for a VALUES RTE
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_values_pathlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>required_outer</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We don't support pushing join clauses into the quals of a values scan,
	 * but it could still have required parameterization due to LATERAL refs
	 * in the values expressions.
	 */</comment>
	<expr_stmt><expr><name>required_outer</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr>;</expr_stmt>

	<comment type="block">/* Generate appropriate path */</comment>
	<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>create_valuesscan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set_tablefunc_pathlist
 *		Build the (single) access path for a table func RTE
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_tablefunc_pathlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>required_outer</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We don't support pushing join clauses into the quals of a tablefunc
	 * scan, but it could still have required parameterization due to LATERAL
	 * refs in the function expression.
	 */</comment>
	<expr_stmt><expr><name>required_outer</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr>;</expr_stmt>

	<comment type="block">/* Generate appropriate path */</comment>
	<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>create_tablefuncscan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
											<argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set_cte_pathlist
 *		Build the (single) access path for a non-self-reference CTE RTE
 *
 * There's no need for a separate set_cte_size phase, since we don't
 * support join-qual-parameterized paths for CTEs.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_cte_pathlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>cteplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>cteroot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>levelsup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>plan_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>required_outer</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Find the referenced CTE, and locate the plan previously made for it.
	 */</comment>
	<expr_stmt><expr><name>levelsup</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>ctelevelsup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cteroot</name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>levelsup</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>cteroot</name> <operator>=</operator> <name><name>cteroot</name><operator>-&gt;</operator><name>parent_root</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cteroot</name></expr>)</condition><block type="pseudo"><block_content>			<comment type="block">/* shouldn't happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bad levelsup for CTE \"%s\""</literal></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Note: cte_plan_ids can be shorter than cteList, if we are still working
	 * on planning the CTEs (ie, this is a side-reference from another CTE).
	 * So we mustn't use forboth here.
	 */</comment>
	<expr_stmt><expr><name>ndx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>cteroot-&gt;parse-&gt;cteList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name> <init>= <expr><operator>(</operator><name>CommonTableExpr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>ndx</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><name>lc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>				<comment type="block">/* shouldn't happen */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find CTE \"%s\""</literal></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>ndx</name> <operator>&gt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>cteroot</name><operator>-&gt;</operator><name>cte_plan_ids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find plan for CTE \"%s\""</literal></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>plan_id</name> <operator>=</operator> <call><name>list_nth_int</name><argument_list>(<argument><expr><name><name>cteroot</name><operator>-&gt;</operator><name>cte_plan_ids</name></name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>plan_id</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cteplan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>, <argument><expr><name>plan_id</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark rel with estimated output rows, width, etc */</comment>
	<expr_stmt><expr><call><name>set_cte_size_estimates</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cteplan</name><operator>-&gt;</operator><name>plan_rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We don't support pushing join clauses into the quals of a CTE scan, but
	 * it could still have required parameterization due to LATERAL refs in
	 * its tlist.
	 */</comment>
	<expr_stmt><expr><name>required_outer</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr>;</expr_stmt>

	<comment type="block">/* Generate appropriate path */</comment>
	<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>create_ctescan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set_namedtuplestore_pathlist
 *		Build the (single) access path for a named tuplestore RTE
 *
 * There's no need for a separate set_namedtuplestore_size phase, since we
 * don't support join-qual-parameterized paths for tuplestores.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_namedtuplestore_pathlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
							 <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>required_outer</name></decl>;</decl_stmt>

	<comment type="block">/* Mark rel with estimated output rows, width, etc */</comment>
	<expr_stmt><expr><call><name>set_namedtuplestore_size_estimates</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We don't support pushing join clauses into the quals of a tuplestore
	 * scan, but it could still have required parameterization due to LATERAL
	 * refs in its tlist.
	 */</comment>
	<expr_stmt><expr><name>required_outer</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr>;</expr_stmt>

	<comment type="block">/* Generate appropriate path */</comment>
	<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>create_namedtuplestorescan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Select cheapest path (pretty easy in this case...) */</comment>
	<expr_stmt><expr><call><name>set_cheapest</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set_worktable_pathlist
 *		Build the (single) access path for a self-reference CTE RTE
 *
 * There's no need for a separate set_worktable_size phase, since we don't
 * support join-qual-parameterized paths for CTEs.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_worktable_pathlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>ctepath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>cteroot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>levelsup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>required_outer</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We need to find the non-recursive term's path, which is in the plan
	 * level that's processing the recursive UNION, which is one level *below*
	 * where the CTE comes from.
	 */</comment>
	<expr_stmt><expr><name>levelsup</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>ctelevelsup</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>levelsup</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>			<comment type="block">/* shouldn't happen */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bad levelsup for CTE \"%s\""</literal></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>levelsup</name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>cteroot</name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>levelsup</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>cteroot</name> <operator>=</operator> <name><name>cteroot</name><operator>-&gt;</operator><name>parent_root</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cteroot</name></expr>)</condition><block type="pseudo"><block_content>			<comment type="block">/* shouldn't happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bad levelsup for CTE \"%s\""</literal></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><name>ctepath</name> <operator>=</operator> <name><name>cteroot</name><operator>-&gt;</operator><name>non_recursive_path</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ctepath</name></expr>)</condition><block type="pseudo"><block_content>				<comment type="block">/* shouldn't happen */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find path for CTE \"%s\""</literal></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Mark rel with estimated output rows, width, etc */</comment>
	<expr_stmt><expr><call><name>set_cte_size_estimates</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>ctepath</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We don't support pushing join clauses into the quals of a worktable
	 * scan, but it could still have required parameterization due to LATERAL
	 * refs in its tlist.  (I'm not sure this is actually possible given the
	 * restrictions on recursive references, but it's easy enough to support.)
	 */</comment>
	<expr_stmt><expr><name>required_outer</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr>;</expr_stmt>

	<comment type="block">/* Generate appropriate path */</comment>
	<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>create_worktablescan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * generate_gather_paths
 *		Generate parallel access paths for a relation by pushing a Gather or
 *		Gather Merge on top of a partial path.
 *
 * This must not be called until after we're done creating all partial paths
 * for the specified relation.  (Otherwise, add_partial_path might delete a
 * path that some GatherPath or GatherMergePath has a reference to.)
 *
 * If we're generating paths for a scan or join relation, override_rows will
 * be false, and we'll just use the relation's size estimate.  When we're
 * being called for a partially-grouped path, though, we need to override
 * the rowcount estimate.  (It's not clear that the particular value we're
 * using here is actually best, but the underlying rel has no estimate so
 * we must do something.)
 */</comment>
<function><type><name>void</name></type>
<name>generate_gather_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>override_rows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>cheapest_partial_path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>simple_gather_path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>rows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name>	   <modifier>*</modifier></type><name>rowsp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* If there are no partial paths, there's nothing to do here. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Should we override the rel's rowcount estimate? */</comment>
	<if_stmt><if>if <condition>(<expr><name>override_rows</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>rowsp</name> <operator>=</operator> <operator>&amp;</operator><name>rows</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The output of Gather is always unsorted, so there's only one partial
	 * path of interest: the cheapest one.  That will be the one at the front
	 * of partial_pathlist because of the way add_partial_path works.
	 */</comment>
	<expr_stmt><expr><name>cheapest_partial_path</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rows</name> <operator>=</operator>
		<name><name>cheapest_partial_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>*</operator> <name><name>cheapest_partial_path</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>simple_gather_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
		<call><name>create_gather_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cheapest_partial_path</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr></argument>,
						   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>rowsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>simple_gather_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For each useful ordering, we can consider an order-preserving Gather
	 * Merge.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rel-&gt;partial_pathlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GatherMergePath</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>rows</name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name> <operator>*</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_gather_merge_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr></argument>,
										<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>rowsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * make_rel_from_joinlist
 *	  Build access paths using a "joinlist" to guide the join path search.
 *
 * See comments for deconstruct_jointree() for definition of the joinlist
 * data structure.
 */</comment>
<function><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type>
<name>make_rel_from_joinlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>levels_needed</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>initial_rels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>jl</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Count the number of child joinlist nodes.  This is the depth of the
	 * dynamic-programming algorithm we must employ to consider all ways of
	 * joining the child nodes.
	 */</comment>
	<expr_stmt><expr><name>levels_needed</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>joinlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>levels_needed</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* nothing to do? */</comment>

	<comment type="block">/*
	 * Construct a list of rels corresponding to the child joinlist nodes.
	 * This may contain both base rels and rels constructed according to
	 * sub-joinlists.
	 */</comment>
	<expr_stmt><expr><name>initial_rels</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>jl</argument>, <argument>joinlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>jlnode</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>jl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>thisrel</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jlnode</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>varno</name> <init>= <expr><operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>jlnode</name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>thisrel</name> <operator>=</operator> <call><name>find_base_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>varno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jlnode</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Recurse to handle subproblem */</comment>
			<expr_stmt><expr><name>thisrel</name> <operator>=</operator> <call><name>make_rel_from_joinlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>jlnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized joinlist node type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>jlnode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>thisrel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* keep compiler quiet */</comment>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>initial_rels</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>initial_rels</name></expr></argument>, <argument><expr><name>thisrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>levels_needed</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Single joinlist node, so we're done.
		 */</comment>
		<return>return <expr><operator>(</operator><name>RelOptInfo</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>initial_rels</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Consider the different orders in which we could join the rels,
		 * using a plugin, GEQO, or the regular join search code.
		 *
		 * We put the initial_rels list into a PlannerInfo field because
		 * has_legal_joinclause() needs to look at it (ugly :-().
		 */</comment>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>initial_rels</name></name> <operator>=</operator> <name>initial_rels</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>join_search_hook</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call>(<modifier>*</modifier><name>join_search_hook</name>) <argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>levels_needed</name></expr></argument>, <argument><expr><name>initial_rels</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>enable_geqo</name> <operator>&amp;&amp;</operator> <name>levels_needed</name> <operator>&gt;=</operator> <name>geqo_threshold</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>geqo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>levels_needed</name></expr></argument>, <argument><expr><name>initial_rels</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><call><name>standard_join_search</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>levels_needed</name></expr></argument>, <argument><expr><name>initial_rels</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * standard_join_search
 *	  Find possible joinpaths for a query by successively finding ways
 *	  to join component relations into join relations.
 *
 * 'levels_needed' is the number of iterations needed, ie, the number of
 *		independent jointree items in the query.  This is &gt; 1.
 *
 * 'initial_rels' is a list of RelOptInfo nodes for each independent
 *		jointree item.  These are the components to be joined together.
 *		Note that levels_needed == list_length(initial_rels).
 *
 * Returns the final level of join relations, i.e., the relation that is
 * the result of joining all the original relations together.
 * At least one implementation path must be provided for this relation and
 * all required sub-relations.
 *
 * To support loadable plugins that modify planner behavior by changing the
 * join searching algorithm, we provide a hook variable that lets a plugin
 * replace or supplement this function.  Any such hook must return the same
 * final join relation as the standard code would, but it might have a
 * different set of implementation paths attached, and only the sub-joinrels
 * needed for these paths need have been instantiated.
 *
 * Note to plugin authors: the functions invoked during standard_join_search()
 * modify root-&gt;join_rel_list and root-&gt;join_rel_hash.  If you want to do more
 * than one join-order search, you'll probably need to save and restore the
 * original states of those data structures.  See geqo_eval() for an example.
 */</comment>
<function><type><name>RelOptInfo</name> <modifier>*</modifier></type>
<name>standard_join_search</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>levels_needed</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>initial_rels</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>lev</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * This function cannot be invoked recursively within any one planning
	 * problem, so join_rel_level[] can't be in use already.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>join_rel_level</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We employ a simple "dynamic programming" algorithm: we first find all
	 * ways to build joins of two jointree items, then all ways to build joins
	 * of three items (from two-item joins and single items), then four-item
	 * joins, and so on until we have considered all ways to join all the
	 * items into one rel.
	 *
	 * root-&gt;join_rel_level[j] is a list of all the j-item rels.  Initially we
	 * set root-&gt;join_rel_level[1] to represent all the single-jointree-item
	 * relations.
	 */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>join_rel_level</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><name>levels_needed</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>join_rel_level</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>initial_rels</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>lev</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>lev</name> <operator>&lt;=</operator> <name>levels_needed</name></expr>;</condition> <incr><expr><name>lev</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Determine all possible pairs of relations to be joined at this
		 * level, and build paths for making each one from every available
		 * pair of lower-level relations.
		 */</comment>
		<expr_stmt><expr><call><name>join_search_one_level</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>lev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Run generate_partitionwise_join_paths() and generate_gather_paths()
		 * for each just-processed joinrel.  We could not do this earlier
		 * because both regular and partial paths can get added to a
		 * particular joinrel at multiple times within join_search_one_level.
		 *
		 * After that, we're done creating paths for the joinrel, so run
		 * set_cheapest().
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;join_rel_level[lev]</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>rel</name> <operator>=</operator> <operator>(</operator><name>RelOptInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Create paths for partitionwise joins. */</comment>
			<expr_stmt><expr><call><name>generate_partitionwise_join_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Except for the topmost scan/join rel, consider gathering
			 * partial paths.  We'll do the same for the topmost scan/join rel
			 * once we know the final targetlist (see grouping_planner).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>lev</name> <operator>&lt;</operator> <name>levels_needed</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>generate_gather_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Find and save the cheapest paths for this rel */</comment>
			<expr_stmt><expr><call><name>set_cheapest</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>OPTIMIZER_DEBUG</name></cpp:ifdef>
			<expr_stmt><expr><call><name>debug_print_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block>
	</block_content>}</block></for>

	<comment type="block">/*
	 * We should have a single rel at the final level.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>join_rel_level</name><index>[<expr><name>levels_needed</name></expr>]</index></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to build any %d-way joins"</literal></expr></argument>, <argument><expr><name>levels_needed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>join_rel_level</name><index>[<expr><name>levels_needed</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <operator>(</operator><name>RelOptInfo</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>join_rel_level</name><index>[<expr><name>levels_needed</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>join_rel_level</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>rel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************************************************
 *			PUSHING QUALS DOWN INTO SUBQUERIES
 *****************************************************************************/</comment>

<comment type="block">/*
 * subquery_is_pushdown_safe - is a subquery safe for pushing down quals?
 *
 * subquery is the particular component query being checked.  topquery
 * is the top component of a set-operations tree (the same Query if no
 * set-op is involved).
 *
 * Conditions checked here:
 *
 * 1. If the subquery has a LIMIT clause, we must not push down any quals,
 * since that could change the set of rows returned.
 *
 * 2. If the subquery contains EXCEPT or EXCEPT ALL set ops we cannot push
 * quals into it, because that could change the results.
 *
 * 3. If the subquery uses DISTINCT, we cannot push volatile quals into it.
 * This is because upper-level quals should semantically be evaluated only
 * once per distinct row, not once per original row, and if the qual is
 * volatile then extra evaluations could change the results.  (This issue
 * does not apply to other forms of aggregation such as GROUP BY, because
 * when those are present we push into HAVING not WHERE, so that the quals
 * are still applied after aggregation.)
 *
 * 4. If the subquery contains window functions, we cannot push volatile quals
 * into it.  The issue here is a bit different from DISTINCT: a volatile qual
 * might succeed for some rows of a window partition and fail for others,
 * thereby changing the partition contents and thus the window functions'
 * results for rows that remain.
 *
 * 5. If the subquery contains any set-returning functions in its targetlist,
 * we cannot push volatile quals into it.  That would push them below the SRFs
 * and thereby change the number of times they are evaluated.  Also, a
 * volatile qual could succeed for some SRF output rows and fail for others,
 * a behavior that cannot occur if it's evaluated before SRF expansion.
 *
 * In addition, we make several checks on the subquery's output columns to see
 * if it is safe to reference them in pushed-down quals.  If output column k
 * is found to be unsafe to reference, we set safetyInfo-&gt;unsafeColumns[k]
 * to true, but we don't reject the subquery overall since column k might not
 * be referenced by some/all quals.  The unsafeColumns[] array will be
 * consulted later by qual_is_pushdown_safe().  It's better to do it this way
 * than to make the checks directly in qual_is_pushdown_safe(), because when
 * the subquery involves set operations we have to check the output
 * expressions in each arm of the set op.
 *
 * Note: pushing quals into a DISTINCT subquery is theoretically dubious:
 * we're effectively assuming that the quals cannot distinguish values that
 * the DISTINCT's equality operator sees as equal, yet there are many
 * counterexamples to that assumption.  However use of such a qual with a
 * DISTINCT subquery would be unsafe anyway, since there's no guarantee which
 * "equal" value will be chosen as the output value by the DISTINCT operation.
 * So we don't worry too much about that.  Another objection is that if the
 * qual is expensive to evaluate, running it for each original row might cost
 * more than we save by eliminating rows before the DISTINCT step.  But it
 * would be very hard to estimate that at this stage, and in practice pushdown
 * seldom seems to make things worse, so we ignore that problem too.
 *
 * Note: likewise, pushing quals into a subquery with window functions is a
 * bit dubious: the quals might remove some rows of a window partition while
 * leaving others, causing changes in the window functions' results for the
 * surviving rows.  We insist that such a qual reference only partitioning
 * columns, but again that only protects us if the qual does not distinguish
 * values that the partitioning equality operator sees as equal.  The risks
 * here are perhaps larger than for DISTINCT, since no de-duplication of rows
 * occurs and thus there is no theoretical problem with such a qual.  But
 * we'll do this anyway because the potential performance benefits are very
 * large, and we've seen no field complaints about the longstanding comparable
 * behavior with DISTINCT.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>subquery_is_pushdown_safe</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>topquery</name></decl></parameter>,
						  <parameter><decl><type><name>pushdown_safety_info</name> <modifier>*</modifier></type><name>safetyInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>topop</name></decl>;</decl_stmt>

	<comment type="block">/* Check point 1 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subquery</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name><name>subquery</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Check points 3, 4, and 5 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subquery</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>||</operator>
		<name><name>subquery</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name> <operator>||</operator>
		<name><name>subquery</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>safetyInfo</name><operator>-&gt;</operator><name>unsafeVolatile</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we're at a leaf query, check for unsafe expressions in its target
	 * list, and mark any unsafe ones in unsafeColumns[].  (Non-leaf nodes in
	 * setop trees have only simple Vars in their tlists, so no need to check
	 * them.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subquery</name><operator>-&gt;</operator><name>setOperations</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>check_output_expressions</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>, <argument><expr><name>safetyInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Are we at top level, or looking at a setop component? */</comment>
	<if_stmt><if>if <condition>(<expr><name>subquery</name> <operator>==</operator> <name>topquery</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Top level, so check any component queries */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>subquery</name><operator>-&gt;</operator><name>setOperations</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>recurse_pushdown_safe</name><argument_list>(<argument><expr><name><name>subquery</name><operator>-&gt;</operator><name>setOperations</name></name></expr></argument>, <argument><expr><name>topquery</name></expr></argument>,
									   <argument><expr><name>safetyInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Setop component must not have more components (too weird) */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>subquery</name><operator>-&gt;</operator><name>setOperations</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* Check whether setop component output types match top level */</comment>
		<expr_stmt><expr><name>topop</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>SetOperationStmt</name></expr></argument>, <argument><expr><name><name>topquery</name><operator>-&gt;</operator><name>setOperations</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>topop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>compare_tlist_datatypes</name><argument_list>(<argument><expr><name><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
								<argument><expr><name><name>topop</name><operator>-&gt;</operator><name>colTypes</name></name></expr></argument>,
								<argument><expr><name>safetyInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper routine to recurse through setOperations tree
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>recurse_pushdown_safe</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>setOp</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>topquery</name></decl></parameter>,
					  <parameter><decl><type><name>pushdown_safety_info</name> <modifier>*</modifier></type><name>safetyInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>setOp</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name> <init>= <expr><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>setOp</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name><name>topquery</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>subquery</name> <init>= <expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>subquery</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>subquery_is_pushdown_safe</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>, <argument><expr><name>topquery</name></expr></argument>, <argument><expr><name>safetyInfo</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>setOp</name></expr></argument>, <argument><expr><name>SetOperationStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>(</operator><name>SetOperationStmt</name> <operator>*</operator><operator>)</operator> <name>setOp</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* EXCEPT is no good (point 2 for subquery_is_pushdown_safe) */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>SETOP_EXCEPT</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* Else recurse */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>recurse_pushdown_safe</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>topquery</name></expr></argument>, <argument><expr><name>safetyInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>recurse_pushdown_safe</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>topquery</name></expr></argument>, <argument><expr><name>safetyInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>setOp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * check_output_expressions - check subquery's output expressions for safety
 *
 * There are several cases in which it's unsafe to push down an upper-level
 * qual if it references a particular output column of a subquery.  We check
 * each output column of the subquery and set unsafeColumns[k] to true if
 * that column is unsafe for a pushed-down qual to reference.  The conditions
 * checked here are:
 *
 * 1. We must not push down any quals that refer to subselect outputs that
 * return sets, else we'd introduce functions-returning-sets into the
 * subquery's WHERE/HAVING quals.
 *
 * 2. We must not push down any quals that refer to subselect outputs that
 * contain volatile functions, for fear of introducing strange results due
 * to multiple evaluation of a volatile function.
 *
 * 3. If the subquery uses DISTINCT ON, we must not push down any quals that
 * refer to non-DISTINCT output columns, because that could change the set
 * of rows returned.  (This condition is vacuous for DISTINCT, because then
 * there are no non-DISTINCT output columns, so we needn't check.  Note that
 * subquery_is_pushdown_safe already reported that we can't use volatile
 * quals if there's DISTINCT or DISTINCT ON.)
 *
 * 4. If the subquery has any window functions, we must not push down quals
 * that reference any output columns that are not listed in all the subquery's
 * window PARTITION BY clauses.  We can push down quals that use only
 * partitioning columns because they should succeed or fail identically for
 * every row of any one window partition, and totally excluding some
 * partitions will not change a window function's results for remaining
 * partitions.  (Again, this also requires nonvolatile quals, but
 * subquery_is_pushdown_safe handles that.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_output_expressions</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name></decl></parameter>, <parameter><decl><type><name>pushdown_safety_info</name> <modifier>*</modifier></type><name>safetyInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>subquery-&gt;targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* ignore resjunk columns */</comment>

		<comment type="block">/* We need not check further if output col is already known unsafe */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>safetyInfo</name><operator>-&gt;</operator><name>unsafeColumns</name><index>[<expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Functions returning sets are unsafe (point 1) */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>subquery</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>&amp;&amp;</operator>
			<call><name>expression_returns_set</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>safetyInfo</name><operator>-&gt;</operator><name>unsafeColumns</name><index>[<expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Volatile functions are unsafe (point 2) */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>safetyInfo</name><operator>-&gt;</operator><name>unsafeColumns</name><index>[<expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* If subquery uses DISTINCT ON, check point 3 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>subquery</name><operator>-&gt;</operator><name>hasDistinctOn</name></name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>targetIsInSortList</name><argument_list>(<argument><expr><name>tle</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name><name>subquery</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* non-DISTINCT column, so mark it unsafe */</comment>
			<expr_stmt><expr><name><name>safetyInfo</name><operator>-&gt;</operator><name>unsafeColumns</name><index>[<expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* If subquery uses window functions, check point 4 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>subquery</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>targetIsInAllPartitionLists</name><argument_list>(<argument><expr><name>tle</name></expr></argument>, <argument><expr><name>subquery</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* not present in all PARTITION BY clauses, so mark it unsafe */</comment>
			<expr_stmt><expr><name><name>safetyInfo</name><operator>-&gt;</operator><name>unsafeColumns</name><index>[<expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * For subqueries using UNION/UNION ALL/INTERSECT/INTERSECT ALL, we can
 * push quals into each component query, but the quals can only reference
 * subquery columns that suffer no type coercions in the set operation.
 * Otherwise there are possible semantic gotchas.  So, we check the
 * component queries to see if any of them have output types different from
 * the top-level setop outputs.  unsafeColumns[k] is set true if column k
 * has different type in any component.
 *
 * We don't have to care about typmods here: the only allowed difference
 * between set-op input and output typmods is input is a specific typmod
 * and output is -1, and that does not require a coercion.
 *
 * tlist is a subquery tlist.
 * colTypes is an OID list of the top-level setop's output column types.
 * safetyInfo-&gt;unsafeColumns[] is the result array.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compare_tlist_datatypes</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colTypes</name></decl></parameter>,
						<parameter><decl><type><name>pushdown_safety_info</name> <modifier>*</modifier></type><name>safetyInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>colType</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name>colTypes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* ignore resjunk columns */</comment>
		<if_stmt><if>if <condition>(<expr><name>colType</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"wrong number of tlist entries"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>colType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>safetyInfo</name><operator>-&gt;</operator><name>unsafeColumns</name><index>[<expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>colType</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>colType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><name>colType</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"wrong number of tlist entries"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * targetIsInAllPartitionLists
 *		True if the TargetEntry is listed in the PARTITION BY clause
 *		of every window defined in the query.
 *
 * It would be safe to ignore windows not actually used by any window
 * function, but it's not easy to get that info at this stage; and it's
 * unlikely to be useful to spend any extra cycles getting it, since
 * unreferenced window definitions are probably infrequent in practice.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>targetIsInAllPartitionLists</name><parameter_list>(<parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>query-&gt;windowClause</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name> <init>= <expr><operator>(</operator><name>WindowClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>targetIsInSortList</name><argument_list>(<argument><expr><name>tle</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name><name>wc</name><operator>-&gt;</operator><name>partitionClause</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * qual_is_pushdown_safe - is a particular qual safe to push down?
 *
 * qual is a restriction clause applying to the given subquery (whose RTE
 * has index rti in the parent query).
 *
 * Conditions checked here:
 *
 * 1. The qual must not contain any SubPlans (mainly because I'm not sure
 * it will work correctly: SubLinks will already have been transformed into
 * SubPlans in the qual, but not in the subquery).  Note that SubLinks that
 * transform to initplans are safe, and will be accepted here because what
 * we'll see in the qual is just a Param referencing the initplan output.
 *
 * 2. If unsafeVolatile is set, the qual must not contain any volatile
 * functions.
 *
 * 3. If unsafeLeaky is set, the qual must not contain any leaky functions
 * that are passed Var nodes, and therefore might reveal values from the
 * subquery as side effects.
 *
 * 4. The qual must not refer to the whole-row output of the subquery
 * (since there is no easy way to name that within the subquery itself).
 *
 * 5. The qual must not refer to any subquery output columns that were
 * found to be unsafe to reference by subquery_is_pushdown_safe().
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>qual_is_pushdown_safe</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>,
					  <parameter><decl><type><name>pushdown_safety_info</name> <modifier>*</modifier></type><name>safetyInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>safe</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>vars</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>vl</name></decl>;</decl_stmt>

	<comment type="block">/* Refuse subselects (point 1) */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>contain_subplans</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Refuse volatile quals if we found they'd be unsafe (point 2) */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>safetyInfo</name><operator>-&gt;</operator><name>unsafeVolatile</name></name> <operator>&amp;&amp;</operator>
		<call><name>contain_volatile_functions</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Refuse leaky quals if told to (point 3) */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>safetyInfo</name><operator>-&gt;</operator><name>unsafeLeaky</name></name> <operator>&amp;&amp;</operator>
		<call><name>contain_leaked_vars</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * It would be unsafe to push down window function calls, but at least for
	 * the moment we could never see any in a qual anyhow.  (The same applies
	 * to aggregates, which we check for in pull_var_clause below.)
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>contain_window_function</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Examine all Vars used in clause; since it's a restriction clause, all
	 * such Vars must refer to subselect output columns.
	 */</comment>
	<expr_stmt><expr><name>vars</name> <operator>=</operator> <call><name>pull_var_clause</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><name>PVC_INCLUDE_PLACEHOLDERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>vl</argument>, <argument>vars</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>vl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * XXX Punt if we find any PlaceHolderVars in the restriction clause.
		 * It's not clear whether a PHV could safely be pushed down, and even
		 * less clear whether such a situation could arise in any cases of
		 * practical interest anyway.  So for the moment, just refuse to push
		 * down.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>safe</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>rti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Check point 4 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>safe</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Check point 5 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>safetyInfo</name><operator>-&gt;</operator><name>unsafeColumns</name><index>[<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>safe</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>safe</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * subquery_push_qual - push down a qual that we have determined is safe
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>subquery_push_qual</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>subquery</name><operator>-&gt;</operator><name>setOperations</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Recurse to push it separately to each component query */</comment>
		<expr_stmt><expr><call><name>recurse_push_qual</name><argument_list>(<argument><expr><name><name>subquery</name><operator>-&gt;</operator><name>setOperations</name></name></expr></argument>, <argument><expr><name>subquery</name></expr></argument>,
						  <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We need to replace Vars in the qual (which must refer to outputs of
		 * the subquery) with copies of the subquery's targetlist expressions.
		 * Note that at this point, any uplevel Vars in the qual should have
		 * been replaced with Params, so they need no work.
		 *
		 * This step also ensures that when we are pushing into a setop tree,
		 * each component query gets its own copy of the qual.
		 */</comment>
		<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>ReplaceVarsFromTargetList</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rte</name></expr></argument>,
										 <argument><expr><name><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
										 <argument><expr><name>REPLACEVARS_REPORT_ERROR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name><name>subquery</name><operator>-&gt;</operator><name>hasSubLinks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now attach the qual to the proper place: normally WHERE, but if the
		 * subquery uses grouping or aggregation, put it in HAVING (since the
		 * qual really refers to the group-result rows).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>subquery</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>||</operator> <name><name>subquery</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>||</operator> <name><name>subquery</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>||</operator> <name><name>subquery</name><operator>-&gt;</operator><name>havingQual</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>subquery</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>=</operator> <call><name>make_and_qual</name><argument_list>(<argument><expr><name><name>subquery</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>subquery</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator>
				<call><name>make_and_qual</name><argument_list>(<argument><expr><name><name>subquery</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * We need not change the subquery's hasAggs or hasSubLinks flags,
		 * since we can't be pushing down any aggregates that weren't there
		 * before, and we don't push down subselects at all.
		 */</comment>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Helper routine to recurse through setOperations tree
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>recurse_push_qual</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>setOp</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>topquery</name></decl></parameter>,
				  <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>setOp</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name> <init>= <expr><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>setOp</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>subrte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name><name>topquery</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>subquery</name> <init>= <expr><name><name>subrte</name><operator>-&gt;</operator><name>subquery</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>subquery</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>subquery_push_qual</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>setOp</name></expr></argument>, <argument><expr><name>SetOperationStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>(</operator><name>SetOperationStmt</name> <operator>*</operator><operator>)</operator> <name>setOp</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>recurse_push_qual</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>topquery</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>recurse_push_qual</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>topquery</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>setOp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************************************************
 *			SIMPLIFYING SUBQUERY TARGETLISTS
 *****************************************************************************/</comment>

<comment type="block">/*
 * remove_unused_subquery_outputs
 *		Remove subquery targetlist items we don't need
 *
 * It's possible, even likely, that the upper query does not read all the
 * output columns of the subquery.  We can remove any such outputs that are
 * not needed by the subquery itself (e.g., as sort/group columns) and do not
 * affect semantics otherwise (e.g., volatile functions can't be removed).
 * This is useful not only because we might be able to remove expensive-to-
 * compute expressions, but because deletion of output columns might allow
 * optimizations such as join removal to occur within the subquery.
 *
 * To avoid affecting column numbering in the targetlist, we don't physically
 * remove unused tlist entries, but rather replace their expressions with NULL
 * constants.  This is implemented by modifying subquery-&gt;targetList.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>remove_unused_subquery_outputs</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>attrs_used</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Do nothing if subquery has UNION/INTERSECT/EXCEPT: in principle we
	 * could update all the child SELECTs' tlists, but it seems not worth the
	 * trouble presently.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subquery</name><operator>-&gt;</operator><name>setOperations</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If subquery has regular DISTINCT (not DISTINCT ON), we're wasting our
	 * time: all its output columns must be used in the distinctClause.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subquery</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>subquery</name><operator>-&gt;</operator><name>hasDistinctOn</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Collect a bitmap of all the output column numbers used by the upper
	 * query.
	 *
	 * Add all the attributes needed for joins or final output.  Note: we must
	 * look at rel's targetlist, not the attr_needed data, because attr_needed
	 * isn't computed for inheritance child rels, cf set_append_rel_size().
	 * (XXX might be worth changing that sometime.)
	 */</comment>
	<expr_stmt><expr><call><name>pull_varattnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attrs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add all the attributes used by un-pushed-down restriction clauses. */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rel-&gt;baserestrictinfo</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pull_varattnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attrs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If there's a whole-row reference to the subquery, we can't remove
	 * anything.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>, <argument><expr><name>attrs_used</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Run through the tlist and zap entries we don't need.  It's okay to
	 * modify the tlist items in-place because set_subquery_pathlist made a
	 * copy of the subquery.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>subquery-&gt;targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>texpr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If it has a sortgroupref number, it's used in some sort/group
		 * clause so we'd better not remove it.  Also, don't remove any
		 * resjunk columns, since their reason for being has nothing to do
		 * with anybody reading the subquery's output.  (It's likely that
		 * resjunk columns in a sub-SELECT would always have ressortgroupref
		 * set, but even if they don't, it seems imprudent to remove them.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>||</operator> <name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If it's used by the upper query, we can't remove it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>,
						  <argument><expr><name>attrs_used</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If it contains a set-returning function, we can't remove it since
		 * that could change the number of rows returned by the subquery.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>subquery</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>&amp;&amp;</operator>
			<call><name>expression_returns_set</name><argument_list>(<argument><expr><name>texpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If it contains volatile functions, we daren't remove it for fear
		 * that the user is expecting their side-effects to happen.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><name>texpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * OK, we don't need it.  Replace the expression with a NULL constant.
		 * Preserve the exposed type of the expression, in case something
		 * looks at the rowtype of the subquery's result.
		 */</comment>
		<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeNullConst</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>texpr</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>texpr</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><name>texpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * create_partial_bitmap_paths
 *	  Build partial bitmap heap path for the relation
 */</comment>
<function><type><name>void</name></type>
<name>create_partial_bitmap_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
							<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>bitmapqual</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>parallel_workers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>pages_fetched</name></decl>;</decl_stmt>

	<comment type="block">/* Compute heap pages for bitmap heap scan */</comment>
	<expr_stmt><expr><name>pages_fetched</name> <operator>=</operator> <call><name>compute_bitmap_pages</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>bitmapqual</name></expr></argument>, <argument><expr><literal type="number">1.0</literal></expr></argument>,
										 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>parallel_workers</name> <operator>=</operator> <call><name>compute_parallel_worker</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>pages_fetched</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
											   <argument><expr><name>max_parallel_workers_per_gather</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>parallel_workers</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>add_partial_path</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_bitmap_heap_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
														   <argument><expr><name>bitmapqual</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>, <argument><expr><literal type="number">1.0</literal></expr></argument>, <argument><expr><name>parallel_workers</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Compute the number of parallel workers that should be used to scan a
 * relation.  We compute the parallel workers based on the size of the heap to
 * be scanned and the size of the index to be scanned, then choose a minimum
 * of those.
 *
 * "heap_pages" is the number of pages from the table that we expect to scan, or
 * -1 if we don't expect to scan any.
 *
 * "index_pages" is the number of pages from the index that we expect to scan, or
 * -1 if we don't expect to scan any.
 *
 * "max_workers" is caller's limit on the number of workers.  This typically
 * comes from a GUC.
 */</comment>
<function><type><name>int</name></type>
<name>compute_parallel_worker</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>heap_pages</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>index_pages</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>max_workers</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>parallel_workers</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the user has set the parallel_workers reloption, use that; otherwise
	 * select a default number of workers.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rel_parallel_workers</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>parallel_workers</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rel_parallel_workers</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If the number of pages being scanned is insufficient to justify a
		 * parallel scan, just return zero ... unless it's an inheritance
		 * child. In that case, we want to generate a parallel path here
		 * anyway.  It might not be worthwhile just for this relation, but
		 * when combined with all of its inheritance siblings it may well pay
		 * off.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_BASEREL</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>(</operator><name>heap_pages</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>heap_pages</name> <operator>&lt;</operator> <name>min_parallel_table_scan_size</name><operator>)</operator> <operator>||</operator>
			 <operator>(</operator><name>index_pages</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>index_pages</name> <operator>&lt;</operator> <name>min_parallel_index_scan_size</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>heap_pages</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>heap_parallel_threshold</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>heap_parallel_workers</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Select the number of workers based on the log of the size of
			 * the relation.  This probably needs to be a good deal more
			 * sophisticated, but we need something here for now.  Note that
			 * the upper limit of the min_parallel_table_scan_size GUC is
			 * chosen to prevent overflow here.
			 */</comment>
			<expr_stmt><expr><name>heap_parallel_threshold</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>min_parallel_table_scan_size</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<while>while <condition>(<expr><name>heap_pages</name> <operator>&gt;=</operator> <operator>(</operator><name>BlockNumber</name><operator>)</operator> <operator>(</operator><name>heap_parallel_threshold</name> <operator>*</operator> <literal type="number">3</literal><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>heap_parallel_workers</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>heap_parallel_threshold</name> <operator>*=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>heap_parallel_threshold</name> <operator>&gt;</operator> <name>INT_MAX</name> <operator>/</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>		<comment type="block">/* avoid overflow */</comment>
			</block_content>}</block></while>

			<expr_stmt><expr><name>parallel_workers</name> <operator>=</operator> <name>heap_parallel_workers</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>index_pages</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>index_parallel_workers</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>index_parallel_threshold</name></decl>;</decl_stmt>

			<comment type="block">/* same calculation as for heap_pages above */</comment>
			<expr_stmt><expr><name>index_parallel_threshold</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>min_parallel_index_scan_size</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<while>while <condition>(<expr><name>index_pages</name> <operator>&gt;=</operator> <operator>(</operator><name>BlockNumber</name><operator>)</operator> <operator>(</operator><name>index_parallel_threshold</name> <operator>*</operator> <literal type="number">3</literal><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>index_parallel_workers</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>index_parallel_threshold</name> <operator>*=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>index_parallel_threshold</name> <operator>&gt;</operator> <name>INT_MAX</name> <operator>/</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>		<comment type="block">/* avoid overflow */</comment>
			</block_content>}</block></while>

			<if_stmt><if>if <condition>(<expr><name>parallel_workers</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>parallel_workers</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>parallel_workers</name></expr></argument>, <argument><expr><name>index_parallel_workers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>parallel_workers</name> <operator>=</operator> <name>index_parallel_workers</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* In no case use more than caller supplied maximum number of workers */</comment>
	<expr_stmt><expr><name>parallel_workers</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>parallel_workers</name></expr></argument>, <argument><expr><name>max_workers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>parallel_workers</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * generate_partitionwise_join_paths
 * 		Create paths representing partitionwise join for given partitioned
 * 		join relation.
 *
 * This must not be called until after we are done adding paths for all
 * child-joins. Otherwise, add_path might delete a path to which some path
 * generated here has a reference.
 */</comment>
<function><type><name>void</name></type>
<name>generate_partitionwise_join_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>live_children</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt_parts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_parts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>part_rels</name></decl>;</decl_stmt>

	<comment type="block">/* Handle only join relations here. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_JOIN_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* We've nothing to do if the relation is not partitioned. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_PARTITIONED_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* The relation should have consider_partitionwise_join set. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>consider_partitionwise_join</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Guard against stack overflow due to overly deep partition hierarchy. */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>num_parts</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>nparts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>part_rels</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>part_rels</name></name></expr>;</expr_stmt>

	<comment type="block">/* Collect non-dummy child-joins. */</comment>
	<for>for <control>(<init><expr><name>cnt_parts</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cnt_parts</name> <operator>&lt;</operator> <name>num_parts</name></expr>;</condition> <incr><expr><name>cnt_parts</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>child_rel</name> <init>= <expr><name><name>part_rels</name><index>[<expr><name>cnt_parts</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>child_rel</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Add partitionwise join paths for partitioned child-joins. */</comment>
		<expr_stmt><expr><call><name>generate_partitionwise_join_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Dummy children will not be scanned, so ignore those. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IS_DUMMY_REL</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>set_cheapest</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>OPTIMIZER_DEBUG</name></cpp:ifdef>
		<expr_stmt><expr><call><name>debug_print_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr_stmt><expr><name>live_children</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>live_children</name></expr></argument>, <argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* If all child-joins are dummy, parent join is also dummy. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>live_children</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>mark_dummy_rel</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Build additional paths for this rel from child-join paths. */</comment>
	<expr_stmt><expr><call><name>add_paths_to_append_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>live_children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>live_children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 *			DEBUG SUPPORT
 *****************************************************************************/</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>OPTIMIZER_DEBUG</name></cpp:ifdef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_relids</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>x</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>x</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>x</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name> <operator>&amp;&amp;</operator>
			<name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name>x</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name>x</name></expr>]</index></name><operator>-&gt;</operator><name><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_restrictclauses</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>clauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>print_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>c</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>lnext</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>indent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>join</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Path</name></expr>:</case>
			<switch>switch <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>pathtype</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>T_SeqScan</name></expr>:</case>
					<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"SeqScan"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>T_SampleScan</name></expr>:</case>
					<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"SampleScan"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>T_SubqueryScan</name></expr>:</case>
					<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"SubqueryScan"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>T_FunctionScan</name></expr>:</case>
					<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"FunctionScan"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>T_TableFuncScan</name></expr>:</case>
					<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"TableFuncScan"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>T_ValuesScan</name></expr>:</case>
					<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"ValuesScan"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>T_CteScan</name></expr>:</case>
					<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"CteScan"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>T_WorkTableScan</name></expr>:</case>
					<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"WorkTableScan"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"???Path"</literal></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
			<break>break;</break>
		<case>case <expr><name>T_IndexPath</name></expr>:</case>
			<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"IdxScan"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_BitmapHeapPath</name></expr>:</case>
			<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"BitmapHeapScan"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_BitmapAndPath</name></expr>:</case>
			<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"BitmapAndPath"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_BitmapOrPath</name></expr>:</case>
			<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"BitmapOrPath"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_TidPath</name></expr>:</case>
			<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"TidScan"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SubqueryScanPath</name></expr>:</case>
			<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"SubqueryScanScan"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ForeignPath</name></expr>:</case>
			<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"ForeignScan"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CustomPath</name></expr>:</case>
			<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"CustomScan"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_NestPath</name></expr>:</case>
			<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"NestLoop"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>join</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_MergePath</name></expr>:</case>
			<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"MergeJoin"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>join</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_HashPath</name></expr>:</case>
			<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"HashJoin"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>join</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AppendPath</name></expr>:</case>
			<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"Append"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_MergeAppendPath</name></expr>:</case>
			<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"MergeAppend"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ResultPath</name></expr>:</case>
			<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"Result"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_MaterialPath</name></expr>:</case>
			<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"Material"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>subpath</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>MaterialPath</name> <operator>*</operator><operator>)</operator> <name>path</name><operator>)</operator><operator>-&gt;</operator><name>subpath</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_UniquePath</name></expr>:</case>
			<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"Unique"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>subpath</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>UniquePath</name> <operator>*</operator><operator>)</operator> <name>path</name><operator>)</operator><operator>-&gt;</operator><name>subpath</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_GatherPath</name></expr>:</case>
			<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"Gather"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>subpath</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>GatherPath</name> <operator>*</operator><operator>)</operator> <name>path</name><operator>)</operator><operator>-&gt;</operator><name>subpath</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_GatherMergePath</name></expr>:</case>
			<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"GatherMerge"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>subpath</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>GatherMergePath</name> <operator>*</operator><operator>)</operator> <name>path</name><operator>)</operator><operator>-&gt;</operator><name>subpath</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ProjectionPath</name></expr>:</case>
			<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"Projection"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>subpath</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>ProjectionPath</name> <operator>*</operator><operator>)</operator> <name>path</name><operator>)</operator><operator>-&gt;</operator><name>subpath</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ProjectSetPath</name></expr>:</case>
			<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"ProjectSet"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>subpath</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>ProjectSetPath</name> <operator>*</operator><operator>)</operator> <name>path</name><operator>)</operator><operator>-&gt;</operator><name>subpath</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SortPath</name></expr>:</case>
			<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"Sort"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>subpath</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SortPath</name> <operator>*</operator><operator>)</operator> <name>path</name><operator>)</operator><operator>-&gt;</operator><name>subpath</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_GroupPath</name></expr>:</case>
			<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"Group"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>subpath</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>GroupPath</name> <operator>*</operator><operator>)</operator> <name>path</name><operator>)</operator><operator>-&gt;</operator><name>subpath</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_UpperUniquePath</name></expr>:</case>
			<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"UpperUnique"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>subpath</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>UpperUniquePath</name> <operator>*</operator><operator>)</operator> <name>path</name><operator>)</operator><operator>-&gt;</operator><name>subpath</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AggPath</name></expr>:</case>
			<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"Agg"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>subpath</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>AggPath</name> <operator>*</operator><operator>)</operator> <name>path</name><operator>)</operator><operator>-&gt;</operator><name>subpath</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_GroupingSetsPath</name></expr>:</case>
			<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"GroupingSets"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>subpath</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>GroupingSetsPath</name> <operator>*</operator><operator>)</operator> <name>path</name><operator>)</operator><operator>-&gt;</operator><name>subpath</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_MinMaxAggPath</name></expr>:</case>
			<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"MinMaxAgg"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_WindowAggPath</name></expr>:</case>
			<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"WindowAgg"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>subpath</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>WindowAggPath</name> <operator>*</operator><operator>)</operator> <name>path</name><operator>)</operator><operator>-&gt;</operator><name>subpath</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SetOpPath</name></expr>:</case>
			<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"SetOp"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>subpath</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SetOpPath</name> <operator>*</operator><operator>)</operator> <name>path</name><operator>)</operator><operator>-&gt;</operator><name>subpath</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RecursiveUnionPath</name></expr>:</case>
			<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"RecursiveUnion"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_LockRowsPath</name></expr>:</case>
			<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"LockRows"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>subpath</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>LockRowsPath</name> <operator>*</operator><operator>)</operator> <name>path</name><operator>)</operator><operator>-&gt;</operator><name>subpath</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ModifyTablePath</name></expr>:</case>
			<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"ModifyTable"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_LimitPath</name></expr>:</case>
			<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"Limit"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>subpath</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>LimitPath</name> <operator>*</operator><operator>)</operator> <name>path</name><operator>)</operator><operator>-&gt;</operator><name>subpath</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="string">"???Path"</literal></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>indent</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>ptype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>parent</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>print_relids</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>param_info</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" required_outer ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>print_relids</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>param_info</name><operator>-&gt;</operator><name>ppi_req_outer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" rows=%.0f cost=%.2f..%.2f\n"</literal></expr></argument>,
		   <argument><expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>startup_cost</name></name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>indent</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  pathkeys: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>print_pathkeys</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>join</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinPath</name>   <modifier>*</modifier></type><name>jp</name> <init>= <expr><operator>(</operator><name>JoinPath</name> <operator>*</operator><operator>)</operator> <name>path</name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>indent</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  clauses: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>print_restrictclauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>jp</name><operator>-&gt;</operator><name>joinrestrictinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MergePath</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MergePath</name>  <modifier>*</modifier></type><name>mp</name> <init>= <expr><operator>(</operator><name>MergePath</name> <operator>*</operator><operator>)</operator> <name>path</name></expr></init></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>indent</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  sortouter=%d sortinner=%d materializeinner=%d\n"</literal></expr></argument>,
				   <argument><expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>mp</name><operator>-&gt;</operator><name>outersortkeys</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>,
				   <argument><expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>mp</name><operator>-&gt;</operator><name>innersortkeys</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>,
				   <argument><expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>mp</name><operator>-&gt;</operator><name>materialize_inner</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>print_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>jp</name><operator>-&gt;</operator><name>outerjoinpath</name></name></expr></argument>, <argument><expr><name>indent</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>print_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>jp</name><operator>-&gt;</operator><name>innerjoinpath</name></name></expr></argument>, <argument><expr><name>indent</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>subpath</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>print_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>indent</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>debug_print_rel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"RELOPTINFO ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>print_relids</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"): rows=%.0f width=%d\n"</literal></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\tbaserestrictinfo: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>print_restrictclauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>joininfo</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\tjoininfo: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>print_restrictclauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>joininfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\tpath list:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>rel-&gt;pathlist</argument>)</argument_list></macro>
		<expr_stmt><expr><call><name>print_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>cheapest_parameterized_paths</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n\tcheapest parameterized paths:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>rel-&gt;cheapest_parameterized_paths</argument>)</argument_list></macro>
			<expr_stmt><expr><call><name>print_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>cheapest_startup_path</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n\tcheapest startup path:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>print_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>cheapest_startup_path</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n\tcheapest total path:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>print_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* OPTIMIZER_DEBUG */</comment>
</unit>
